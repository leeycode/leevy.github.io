<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>vue项目性能优化方案</title>
      <link href="2020/10/30/vue-xiang-mu-xing-neng-you-hua-fang-an/"/>
      <url>2020/10/30/vue-xiang-mu-xing-neng-you-hua-fang-an/</url>
      
        <content type="html"><![CDATA[<p><img src="https://7.dusays.com/2020/11/02/3ce96e73d8ee0.jpg" alt="vue.jpg"></p><h1 id="按需使用第三方库"><a href="#按需使用第三方库" class="headerlink" title="按需使用第三方库"></a>按需使用第三方库</h1><p>项目引入过多的第三方库会增大项目体积，带来性能问题<br>。以 Bootstrap 为例，如果你只是用一下它的响应式机制，还不如自己手写相关的 CSS，也不会太复杂，完全没有必要引入整个库。moment.js，Lodash.js这些库为了普适性，提供了尽可能多的功能，但你的项目可能只用了极少部分。我们不鼓励重复造轮子，但是要按需引入。现在很多库都提供了 ES 模块化的方式，也可以做到这一点。</p><p>采用按需引入的方式引入第三方组件，减少在入口文件全局引入。</p><h1 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a>路由懒加载</h1><p>路由懒加载也可以提高入口页面的加载速度，因为很多路由页面在多数情况下并没有被访问，在打包的时候放到单独的文件里可以减少入口页的体积。路由懒加载是通过 webpack 的动态 import来实现的。</p><pre><code>// in router.jsimport Home from '@/views/Home.vue'; // 静态 importconst About = () =&gt; import('@/views/About.vue'); // 动态 importconst router = new VueRouter({  routes: [    { path: '/', component: Home },    { path: '/about', component: About }  ]})</code></pre><p>另外，这些懒加载的路由还可以分组，让相关性模块的多个路由页面打包到同一个 chunk，算是一种折中方案：既实现了按需加载，又不会过于碎片化。适用于子路由页面。</p><pre><code>// in router.jsimport Home from '@/views/Home.vue'; // traditonal importsimport User from '@/views/User.vue';const About = () =&gt;  import('@/views/About.vue'); // dynamic importconst router = new VueRouter({  routes: [    { path: '/', component: Home },    { path: '/about', component: About },    { path: '/user/:id', component: User,       children: [        {          path: '/settings',          component: () =&gt; import(/* webpackChunkName: "user" */ '@/views/UserSettings')        },        {          path: '/articles',          component: () =&gt; import(/* webpackChunkName: "user" */ '@/views/UserArticles')        }      ]    }   ]})</code></pre><p>这是通过 webpack 的注释语法/* webpackChunkName: “user” */实现的，webpackChunkName相同的路由会打进同一个 chunk文件。</p><h1 id="只做展示用数据禁用响应式"><a href="#只做展示用数据禁用响应式" class="headerlink" title="只做展示用数据禁用响应式"></a>只做展示用数据禁用响应式</h1><p>默认情况下，定义在 Vue 组件data 里的数据都是响应式的，这种机制方便了数据绑定，当数据变化时界面得到自动更新。但有时候我们只是将数据显示到界面上，之后也不会改变它。这种情况下我们根本用不上响应式机制，而实现响应式是有性能代价的，特别是对于大对象和大列表。</p><p>建议将data还有Vuex 里面只用于展示的数据通过Object.freeze()禁用对象的响应式特性。</p><h1 id="资源释放"><a href="#资源释放" class="headerlink" title="资源释放"></a>资源释放</h1><ol><li> 如果在mounted/created 钩子中使用了$on，需要在beforeDestroy 中做对应解绑($off)处理</li><li> 如果在mounted/created 钩子中绑定了DOM/BOM 对象中的事件，需要在beforeDestroy 中做对应解绑处理</li><li> 如果在mounted/created 钩子中使用了第三方库初始化，需要在beforeDestroy 中做对应销毁处理</li><li> 如果使用setTimeout setInterval需要在beforeDestroy中做对应销毁处理，（最好不用）可以使用nextTick代替</li><li> 模块形成的闭包内部变量使用完后没有置成null</li><li> 全局变量没有回收</li><li> 绑在EventBus的事件没有解绑，注册的总线事件（Bus）要在组件销毁时(beforeDestroy/destroyed)卸载</li></ol><h1 id="v-if-和-v-show-区分使用场景"><a href="#v-if-和-v-show-区分使用场景" class="headerlink" title="v-if 和 v-show 区分使用场景"></a>v-if 和 v-show 区分使用场景</h1><p>v-if&nbsp;是&nbsp;真正&nbsp;的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</p><p>v-show&nbsp;就简单得多， 不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 的 display 属性进行切换。</p><p>所以，v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景；v-show 则适用于需要非常频繁切换条件的场景。</p><h1 id="computed-和-watch-区分使用场景"><a href="#computed-和-watch-区分使用场景" class="headerlink" title="computed 和 watch &nbsp;区分使用场景"></a>computed 和 watch &nbsp;区分使用场景</h1><p>（1）computed：&nbsp;是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed &nbsp;的值；</p><p>（2） watch：&nbsp;更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；</p><p>运用场景：</p><p>当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；</p><p>当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</p><h1 id="v-for-遍历必须为-item-添加-key，且避免同时使用-v-if"><a href="#v-for-遍历必须为-item-添加-key，且避免同时使用-v-if" class="headerlink" title="v-for 遍历必须为 item 添加 key，且避免同时使用 v-if"></a>v-for 遍历必须为 item 添加 key，且避免同时使用 v-if</h1><p>（1）v-for 遍历必须为 item 添加 key</p><p>在列表数据进行遍历渲染时，需要为每一项 item 设置唯一 key 值，方便 Vue.js 内部机制精准找到该条列表数据。当 state 更新时，新的状态值和旧的状态值对比，较快地定位到 diff 。</p><p>（2）v-for 遍历避免同时使用 v-if</p><p>v-for 比 v-if 优先级高，如果每一次都需要遍历整个数组，将会影响速度，尤其是当之需要渲染很小一部分的时候，必要情况下应该替换成 computed 属性。</p><pre><code>&lt;ul&gt;  &lt;li    v-for="user in activeUsers"    :key="user.id"&gt;    {{ user.name }}  &lt;/li&gt;&lt;/ul&gt;computed: {  activeUsers: function () {    return this.users.filter(function (user) {   return user.isActive    })  }}</code></pre><h1 id="减少-ES6-转为-ES5-的冗余代码"><a href="#减少-ES6-转为-ES5-的冗余代码" class="headerlink" title="减少 ES6 转为 ES5 的冗余代码"></a>减少 ES6 转为 ES5 的冗余代码</h1><p>Babel 插件会在将 ES6 代码转换成 ES5 代码时会注入一些辅助函数，例如下面的 ES6 代码：</p><pre><code>class HelloWebpack extends Component{...}</code></pre><p>这段代码再被转换成能正常运行的 ES5 代码时需要以下两个辅助函数：</p><pre><code>babel-runtime/helpers/createClass  // 用于实现 class 语法babel-runtime/helpers/inherits  // 用于实现 extends 语法</code></pre><p>在默认情况下， Babel 会在每个输出文件中内嵌这些依赖的辅助函数代码，如果多个源代码文件都依赖这些辅助函数，那么这些辅助函数的代码将会出现很多次，造成代码冗余。为了不让这些辅助函数的代码重复出现，可以在依赖它们时通过&nbsp;require(‘babel-runtime/helpers/createClass’)&nbsp;的方式导入，这样就能做到只让它们出现一次。babel-plugin-transform-runtime&nbsp;插件就是用来实现这个作用的，将相关辅助函数进行替换成导入语句，从而减小 babel 编译出来的代码的文件大小。</p><p>首先，安装 babel-plugin-transform-runtime ：</p><pre><code>npm install babel-plugin-transform-runtime --save-dev</code></pre><p>然后，修改 .babelrc  配置文件为：</p><pre><code>"plugins": [    "transform-runtime"]</code></pre><h1 id="开启gzip压缩"><a href="#开启gzip压缩" class="headerlink" title="开启gzip压缩"></a>开启gzip压缩</h1><p>首先，修改productionGzip 为true,<br>安装 compression-webpack-plugin ：</p><pre><code> //  npm install --save-dev compression-webpack-plugin  //(此处有坑) 如果打包报错，应该是版本问题 ，先卸载之前安装的此插件 ，然后安装低版本   npm install --save-dev compression-webpack-plugin@1.1.11</code></pre><p>修改nginx的配置</p><pre><code>http {  //在 http中配置如下代码，   gzip on;   gzip_disable "msie6";    gzip_vary on;    gzip_proxied any;   gzip_comp_level 8; #压缩级别   gzip_buffers 16 8k;   #gzip_http_version 1.1;   gzip_min_length 100; #不压缩临界值   gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png; }</code></pre><h1 id="图片懒加载"><a href="#图片懒加载" class="headerlink" title="图片懒加载"></a>图片懒加载</h1><p>如果应用里需要展示大量图片，通常的做法是懒加载图片。懒加载的基本原理是提前准备好图片 URL，当图片真正进入可视范围时才去加载。可以手动实现懒加载机制，不过更方便的是直接用现成的插件，比如 [vue-lazyload]<br>安装：</p><pre><code>npm i vue-lazyload -S</code></pre><p>引入：</p><pre><code>import VueLazyload from 'vue-lazyload'Vue.use(VueLazyload)</code></pre><p>使用：</p><pre><code> &lt;ul&gt;    &lt;li v-for="img in list"&gt;      &lt;img v-lazy="img.src"&gt;    &lt;/li&gt;  &lt;/ul&gt;</code></pre><h1 id="cdn加速"><a href="#cdn加速" class="headerlink" title="cdn加速"></a>cdn加速</h1><p>采用cdn加速去从别的服务器上加载第三方库而非自己的服务器，这样就会快很多.并且能节省自己服务器的带宽。</p><p>首先，在index.html中 将你所需的第三方库的链接加载进来：</p><pre><code>&lt;script src="https://cdn.bootcdn.net/ajax/libs/vue/3.0.0-beta.18/vue.cjs.js"&gt;&lt;/script&gt;</code></pre><p>在webpack.base.conf 中添加 externals 来告诉webpack我们这些第三方库不需要打包</p><pre><code>externals:{    // key表示第三方插件名称，value是暴露出的全局变量    'vue':'Vue'}</code></pre><p>在 主文件main.js 或者其他 js 修改引用这些配置的第三方插件</p><pre><code>// import Vue from 'vue';const Vue = require('vue');</code></pre><h1 id="Webpack-对图片进行压缩"><a href="#Webpack-对图片进行压缩" class="headerlink" title="Webpack 对图片进行压缩"></a>Webpack 对图片进行压缩</h1><p>安装 image-webpack-loader ：</p><pre><code>npm install image-webpack-loader --save-dev</code></pre><p>然后，在 webpack.base.conf.js  中进行配置：</p><pre><code>{  test: /\.(png|jpe?g|gif|svg)(\?.*)?$/,  use:[     {      loader: 'url-loader',      options: {        limit: 10000 ,        name: '[path][name].[ext]?[hash:6]!./dir/file.png'      }    },    /*对图片进行压缩*/    {      loader: 'image-webpack-loader',      query: {        progressive: true,        optimizationLevel: 7,        interlaced: false,        pngquant: {          quality: '65-90',          speed: 4        }      }    }  ]}</code></pre><h1 id="pax-ui框架相关"><a href="#pax-ui框架相关" class="headerlink" title="pax-ui框架相关"></a>pax-ui框架相关</h1><p>（1） 表单组件<br>pax组件的Form表单组件会对绑定数据监听，表单组件很多的情况下页面会卡顿，在pax-form上设置局部更新，会提升一部分性能。</p><pre><code>&lt;pax-form :form="form" :selfUpdate="true"&gt;&lt;/pax-form&gt;</code></pre><p>(2) select组件<br>select大数据量情况下，会造成页面元素较多，在ie上消耗更多的内存。建议采用虚拟滚动的方式：</p><pre><code>import { RecycleScroller} from 'vue-virtual-scroller';// 在Select预留卡槽中使用详情见文档：IE浏览器select大数据问题造成输入不流畅分析处理</code></pre><p>（3）tree组件<br>pax-tree在ie上问题严重,如果兼容ie，建议用@pa/vue-org-tree,使用方法参考ztree.js</p><pre><code>npm install @pa/vue-org-tree --save-dev</code></pre>]]></content>
      
      
      <categories>
          
          <category> 新鲜技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript在vue项目中的应用</title>
      <link href="2020/10/30/ts-zai-vue-xiang-mu-zhong-de-ying-yong/"/>
      <url>2020/10/30/ts-zai-vue-xiang-mu-zhong-de-ying-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="1-引言"><a href="#1-引言" class="headerlink" title="1 引言"></a>1 引言</h1><p>TypeScript 是一种由微软开发的自由和开源的编程语言。它是 JavaScript 的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程。</p><p>TypeScript 优势：</p><ul><li>静态类型检查与代码提示</li><li>适用大型项目开发，如代码重构等</li><li>更好的协作</li><li>更强的生产力</li></ul><h1 id="2-ts语法知识"><a href="#2-ts语法知识" class="headerlink" title="2 ts语法知识"></a>2 ts语法知识</h1><h2 id="2-1类型系统"><a href="#2-1类型系统" class="headerlink" title="2.1类型系统"></a>2.1类型系统</h2><p><img src="https://7.dusays.com/2020/11/02/056c4d4f841cf.png" alt="类型注解"></p><h2 id="2-2类型保护"><a href="#2-2类型保护" class="headerlink" title="2.2类型保护"></a>2.2类型保护</h2><blockquote><p>类型保护是可执行运行时检查的一种表达式，用于确保该类型在一定的范围内。</p></blockquote><ol><li>as 操作符（类型断言）<br>当你比 ts 更确定其数据类型，你能使用 as 语法确定其类型，但需要遵守类型兼容转换。 另外一种写法：<typename>varName，但不建议使用</typename></li></ol><pre><code>function getDynamicValue(): number | string | undefined {  ...}const v = getDynamicValue(); // v:number|string|undefined，联合类型变量只允许访问所有类型共有的属性// 确定返回 string(v as string).trim();</code></pre><ol start="2"><li>typeof 操作符</li></ol><pre><code>function isNumber(val: any): val is number {  return typeof val === 'number';}const a: any = 1;if (isNumber(a)) {  // a:number}</code></pre><ol start="3"><li>instanceof 操作符</li></ol><pre><code>class Base {  ...}class A extends Base {  ...}const inst: Base = new A();if (inst instanceof A) {  // inst:A}</code></pre><ol start="4"><li>函数或变量后面添加 !</li></ol><p>当要去掉联合类型的可空类型（null | undefined）,可以使用 js if 语句或短路运算符实现类型保护，也可以使用 Typescript 2.0+ !语法</p><pre><code>const x: string | null = getDynamicValue();// if判断if (x) {  // x:string}// 短路运算符function f(sn: string | null) {  return sn || '';}// !语法x!.trim();// orconst r = [1, 2, 3, 4].find(x =&gt; x === 3)!; // r:number</code></pre><h1 id="3-开发环境准备"><a href="#3-开发环境准备" class="headerlink" title="3 开发环境准备"></a>3 开发环境准备</h1><h2 id="3-1-插件安装"><a href="#3-1-插件安装" class="headerlink" title="3.1 插件安装"></a>3.1 插件安装</h2><h3 id="3-1-1-Webpack-转译-Typescript-现有方案"><a href="#3-1-1-Webpack-转译-Typescript-现有方案" class="headerlink" title="3.1.1 Webpack 转译 Typescript 现有方案"></a>3.1.1 Webpack 转译 Typescript 现有方案</h3><h4 id="1-ts-loader-babel-loader-fork-ts-checker-webpack-plugin"><a href="#1-ts-loader-babel-loader-fork-ts-checker-webpack-plugin" class="headerlink" title="1.ts-loader + babel-loader + fork-ts-checker-webpack-plugin"></a>1.ts-loader + babel-loader + fork-ts-checker-webpack-plugin</h4><p>修改 webpack.config.js 的配置：</p><pre><code>{     test: /\.ts?$/,     loader: "ts-loader",    options: {        // .vue文件必须加        appendTsSuffixTo: [/\.vue$/]    },    exclude:/node_modules/}</code></pre><p>每次重建时，类型脚本的语义检查器必须检查所有文件,随着项目变得越来越大，编译时间线性增加。这时我们使用 fork-ts-checker-webpack-plugin 另外开一个线程来进行类型检查，安装依赖：</p><pre><code>npm install -D fork-ts-checker-webpack-plugin//使用：const ForkTsCheckerWebpackPlugin = require('fork-ts-checker-webpack-plugin');plugins:[    new ForkTsCheckerWebpackPlugin()]</code></pre><ul><li>这种方案，当 webpack 编译的时候，ts-loader 会调用 typescript（所以本地项目需要安装 typescript），然后 typescript 运行的时候会去读取本地的 tsconfig.json 文件。</li><li>默认情况下，ts-loader 会进行 转译 和 类型检查，每当文件改动时，都会重新去 转译 和 类型检查，当文件很多的时候，就会特别慢，影响开发速度。所以需要使用 fork-ts-checker-webpack-plugin ，开辟一个单独的线程去执行类型检查的任务，这样就不会影响 webpack 重新编译的速度。</li><li>fork-ts-checker-webpack-plugin  这个插件要求最低 Node.js 6.11.5，webpack 4，TypeScript 2.1 和可选的 ESLint 6（其本身要求最低 Node.js 8.10.0）。</li></ul><h4 id="2-babel-loader-babel-preset-typescript"><a href="#2-babel-loader-babel-preset-typescript" class="headerlink" title="2. babel-loader + @babel/preset-typescript"></a>2. babel-loader + @babel/preset-typescript</h4><p>修改webpack.config.js</p><pre><code>rules: [        {          test:/\.(tsx?|jsx?)$/,          // 默认会调用 @babel/core           use:'babel-loader'        }]</code></pre><p>.babelrc</p><pre><code>{    "presets": [        "@babel/env"        "@vue/babel-preset-jsx",        "@babel/preset-typescript"    ]}</code></pre><ul><li>这种方案，当 webpack 编译的时候，babel-loader 会读取 .babelrc 里的配置，不会调用 typescript（所以本地项目无需安装 typescript），不会去检查类型</li><li> 需要配置tsconfig.json的，因为需要在开发代码时，让 idea 提示错误信息</li></ul><h2 id="3-2-ts项目基本构成"><a href="#3-2-ts项目基本构成" class="headerlink" title="3.2 ts项目基本构成"></a>3.2 ts项目基本构成</h2><p>一个vue+ts项目的目录结构（<a href="https://github.com/leeycode/typeScript-vue-starter/">typeScript-vue-starter</a>）：</p><pre><code>├── /@types/                     # 全局类型声明├── /build/                      # webpack配置文件├── /src/                        # 源码目录│ ├── /assets/                   # 静态资源目录│ ├── /components/               # 公共组件目录│ ├── /constants/                # 项目constants目录│ │ ├── _const.less              # less常量│ ├── /pages/                    # UI组件目录│ ├── /services/                 # 请求服务目录│ ├── /router/                   # 路由目录│ ├── /store/                    # 存放store文件目录│ ├── /style/                    # 全局样式│ ├── /utils/                    # utils目录│ │ ├── request.ts               # 基于fetch封装的API请求工具│ │ ├── global.ts                # 公共方法库│ └── main.ts                    # 项目入口|——tsconfig.json                 # ts配置|——...</code></pre><h2 id="3-3-tsconfig-json"><a href="#3-3-tsconfig-json" class="headerlink" title="3.3 tsconfig.json"></a>3.3 tsconfig.json</h2><p>在项目根目录下，这个json文件规定了ts的编译选项，相见的编译选项配置：</p><pre><code>{  "compilerOptions": {    "baseUrl": ".",                             // 用于解析非相对模块名称的基目录    "outDir": "build/dist",                     // 指定输出目录    "module": "esnext",                         // 指定使用模块: 'commonjs', 'amd', 'system', 'umd' or 'es2015'    "target": "es5",                            // 指定 ECMAScript 目标版本:    "lib": ["dom", "esnext"],                   // 指定要包含在编译中的库文件    "sourceMap": true,                          // 生成相应的 '.map' 文件    "allowJs": true,                            // 允许编译 javascript 文件    "jsx": "preserve",                          // 指定 jsx 代码的生成: 'preserve', 'react-native'等    "moduleResolution": "node",                 // 选择模块解析策略： 'node' (Node.js) or 'classic'    "strict": true                              // 启用所有严格类型检查选项    ...  },  "include": ["src/**/*", "@types/**/*"],       // 编译包含的文件     "exclude": [                                  // 排除的文件                    "node_modules",    "build",    "scripts",    "acceptance-tests",    "webpack",    "jest",    "src/setupTests.ts",    "config"  ]}</code></pre><h2 id="3-4-声明文件"><a href="#3-4-声明文件" class="headerlink" title="3.4 声明文件"></a>3.4 声明文件</h2><h3 id="types"><a href="#types" class="headerlink" title="@types"></a>@types</h3><p>安装第三方库之前，我们可以<a href="https://microsoft.github.io/TypeSearch//">搜索DefinitelyTyped</a>，查看是否有第三方在维护类型声明。通过@types安装，就能在项目中使用它的类型声明。</p><pre><code>- Partial :把 interface 所有属性变成可选// node_modules/typescript/lib/lib.es5.d.ts,安装ts的时候生成type Partial&lt;T&gt; = {    [P in keyof T]?: T[P];};changeFilter: (filter: Partial&lt;IRequsetParams&gt;) =&gt; void;- Event// node_modules/@types/react/index.d.ts,通过@types安装react的时候生成  handleClick = (e: React.MouseEvent&lt;HTMLDivElement, MouseEvent&gt;) =&gt; {    e.stopPropagation();  };- RouteComponentProps:提供了 location、history 的类型定义// node_modules/@types/react-router/index.d.tsexport interface ILoginProps extends RouteComponentProps {  login: (values: IUser, history: H.History) =&gt; void;}</code></pre><h3 id="自定义声明文件"><a href="#自定义声明文件" class="headerlink" title="自定义声明文件"></a>自定义声明文件</h3><p>扩展名.d.ts 结尾就是项目中的声明文件。在上面的项目中，我们创建了一个名为@types的文件夹，用来维护项目中需要的变量声明。</p><ol><li>全局变量声明<pre><code>// configdeclare const config: {version: string;systemName: string;debug: boolean;...}// 约束后台返回的数据 declare interface IResponseBody&lt;T&gt; {data: T;code: number;total: number;}...</code></pre></li><li>非js资源</li></ol><pre><code>declare module '*.svg';declare module '*.png';declare module '*.jpg';declare module '*.module.css';declare module '*.module.scss' </code></pre><h1 id="4-组件编写的几种方法"><a href="#4-组件编写的几种方法" class="headerlink" title="4 组件编写的几种方法"></a>4 组件编写的几种方法</h1><h2 id="4-1-Vue-extend"><a href="#4-1-Vue-extend" class="headerlink" title="4.1 Vue.extend()"></a>4.1 Vue.extend()</h2><blockquote><p>Vue.extend():使用基础 Vue 构造器，创建一个“子类”。 这种方式最接近 Vue 的单文件组件的写法，如果一个完善 Vue 项目从 JS 改成 TS，用这种方法很快，只要加上 lang=ts和一些必要的变量类型就好了，然后用Vue.extend()包裹就好。</p></blockquote><p>main.js 改为 main.ts 内容改成：</p><pre><code>import Vue from "vue";import App from "./App.vue";new Vue({    el:"#app",    render:h=&gt;h(App)});</code></pre><p>组件写法：</p><pre><code>&lt;template&gt;    &lt;h1&gt;{{name}}&lt;/h1&gt;&lt;/template&gt;&lt;script lang="ts"&gt;//也执行tsx,也就是jsx语法import Vue from "vue";export default Vue.extend({    data(){        return {            name:'liwu'        }    }})&lt;/script&gt;&lt;style scoped&gt;h1{    color: rgb(55, 142, 230);}&lt;/style&gt;</code></pre><h2 id="4-2-vue-class-component"><a href="#4-2-vue-class-component" class="headerlink" title="4.2 vue-class-component"></a>4.2 vue-class-component</h2><blockquote><p>通常和vue-property-decorator一起搭配使用，，vue-property-decorator是在vue-class-component上扩展来的，并且提供了很多修饰器比如 @Prop和@Watch等等，使用这个可以编写类式组件。</p></blockquote><p>1.组件写法：</p><pre><code>&lt;template&gt;    &lt;h1&gt;{{name}}&lt;/h1&gt;&lt;/template&gt;&lt;script lang="ts"&gt;import Vue from "vue";import Component from 'vue-class-component';// @Component 装饰器使你的类成为Vue组件@Componentexport default class App extends Vue {    private name:string = 'liwu';}&lt;/script&gt;&lt;style scoped&gt;h1{    color: rgb(55, 142, 230);}&lt;/style&gt;</code></pre><p>修改tsconfig.js，支持装饰器语法</p><pre><code>"experimentalDecorators": true,</code></pre><h2 id="4-3-jsx"><a href="#4-3-jsx" class="headerlink" title="4.3 jsx"></a>4.3 jsx</h2><blockquote><p>JSX is an XML-like syntax extension to ECMAScript without any defined semantics. It’s NOT intended to be implemented by engines or browsers.</p></blockquote><p>1.jsx语法简介（写react的同学跳过）</p><ul><li>严格的标签闭合</li><li>组件名要大写，否则解析成html标签</li><li>变量用{}</li></ul><pre><code>let name = 'xxx';&lt;div&gt;{ name }&lt;/div&gt;</code></pre><ul><li>遍历用map</li></ul><pre><code>let list = ['李一','李二','李三'];&lt;div&gt;    {list.map((item, index) =&gt; {    return &lt;p key={index}&gt;this is {item}&lt;/p&gt;     })} &lt;/div&gt; </code></pre><ul><li>条件判断</li></ul><pre><code>&lt;div className={styles.wrapper}&gt;    {_.isEmpty(currRecord) ? null : (      &lt;Graph        graph={{ nodes, edges }}        options={this.options}        events={this.events}      /&gt;    )}&lt;/div&gt; </code></pre><ul><li>事件要用驼峰写法，传参要用bind</li></ul><pre><code>&lt;div    className={styles.content}    onMouseEnter={this.showSwitch}    onMouseLeave={this.hideSwitch}    onClick={this.handleClick.bind(this,params)}&gt;&lt;/div&gt;</code></pre><ul><li>使用domPropsInnerHTML来替代v-html</li></ul><pre><code>&lt;div    domPropsInnerHTML={this.htmlContent}&gt;&lt;/div&gt;</code></pre><p>2.组件写法</p><pre><code>import { Vue, Component } from 'vue-property-decorator';import { CreateElement } from 'vue';@Componentexport default class JSX extends Vue {  private count: number = 0;  private showInfo() {    this.count++;  }  protected render(h: CreateElement) {    return &lt;h2 onMouseenter={this.showInfo}&gt;JSX Test{this.count}&lt;/h2&gt;;  }}</code></pre><h1 id="5-class组件详细用法"><a href="#5-class组件详细用法" class="headerlink" title="5 class组件详细用法"></a>5 class组件详细用法</h1><h2 id="使用Data"><a href="#使用Data" class="headerlink" title="使用Data"></a>使用Data</h2><pre><code>@Componentexport default class HelloWorld extends Vue {  private msg: string = "welcome to my app"  private list: Array&lt;object&gt; = [    {        name: 'Melody',        age: '20'    },    {        name: 'James',        age: '20'    }  ]}</code></pre><p>与ts等效的js代码</p><pre><code>export default {  data() {    return {      msg: "welcome to my app",      list: [        {          name: 'Melody',          age: '20'        },        {          name: 'James',          age: '20'        }      ]    }}</code></pre><h2 id="使用props"><a href="#使用props" class="headerlink" title="使用props"></a>使用props</h2><p>可以添加 required, default, type 为props指定验证要求，同样也可以使用 readonly 禁止操作props</p><pre><code>import { Component, Prop, Vue } from 'vue-property-decorator'@Componentexport default class HelloWorld extends Vue {  @Prop() readonly msg!: string  @Prop({default: 'Joy Melody'}) readonly name: string  @Prop({required: true}) readonly age: number  @Prop({required: false, type: String, default: 'Developer'}) readonly job: string}</code></pre><p>与ts等效的js代码如下</p><pre><code>export default {  props: {    msg,    name: {      default: 'Joy Melody'    },    age: {      required: true,    },    address: {      type: String    },    job: {      required: false,      type: string,      default: 'Developer'    }  }}</code></pre><h2 id="Computed-属性"><a href="#Computed-属性" class="headerlink" title="Computed 属性"></a>Computed 属性</h2><pre><code>export default class HelloWorld extends Vue {  get fullName(): string {    return this.first+ ' '+ this.last  }}</code></pre><p>与ts等效的js代码如下</p><pre><code>export default {  fullName() {    return this.first + ' ' + this.last  }}</code></pre><p>复杂点的涉及到setter和getter的 computed属性，在ts中写法如下：</p><pre><code>export default class HelloWorld extends Vue {  get fullName(): string {    return this.first+ ' '+ this.last  }  set fullName(newValue: string) {    let names = newValue.split(' ')    this.first = names[0]    this.last = names[names.length - 1]  }}</code></pre><p>与ts等效的js写法如下</p><pre><code>fullName: {  get: function () {    return this.first + ' ' + this.last  },  set: function (newValue) {    let names = newValue.split(' ')    this.first = names[0]    this.last = names[names.length - 1]  }}</code></pre><h2 id="使用Watch"><a href="#使用Watch" class="headerlink" title="使用Watch"></a>使用Watch</h2><p>@Watch(path: string, options: WatchOptions = {}) </p><ul><li><p>@Watch 装饰器接收两个参数：path: string 被侦听的属性名<br>options?: WatchOptions={} options可以包含两个属性</p></li><li><p>immediate?:boolean 侦听开始之后是否立即调用该回调函数<br>deep?:boolean 被侦听的对象的属性被改变时，是否调用该回调函数</p></li></ul><pre><code>@Watch('child')onChildChanged (val: string, oldVal: string) {    if (val !== oldVal) {      window.console.log(val)    }}</code></pre><p>与ts等效的js代码如下</p><pre><code>watch: {    'child': {        handler: 'onChildChanged',        immediate: false,        deep: false     }},method: {    onChildChanged(val, oldVal) {        if (val !== oldVal) {          console.log(val)        }    }}</code></pre><p>也可以写成: @Watch(‘child’, { immediate: true, deep: true }), 等价于:</p><pre><code>watch: {    'child': {        handler: 'onChildChanged',        immediate: true,        deep: true     }},method: {    onChildChanged(val, oldVal) {        if (val !== oldVal) {          window.console.log(val)        }    }}</code></pre><h2 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h2><pre><code>export default class HelloWorld extends Vue {  public clickMe(): void {    console.log('clicked')    console.log(this.addNum(4, 2))  }  public addNum(num1: number, num2: number): number {    return num1 + num2  }}</code></pre><p>与ts等效的js代码如下</p><pre><code>export default {  methods: {    clickMe() {      console.log('clicked')      console.log(this.addNum(4, 2))    }    addNum(num1, num2) {      return num1 + num2    }  }}</code></pre><h2 id="Emit"><a href="#Emit" class="headerlink" title="Emit"></a>Emit</h2><p>子组件触发父组件的自定义事件并传递数据，在TypeScript中使用@Emit 装饰器</p><pre><code>import { Vue, Component, Emit } from 'vue-property-decorator'@Componentexport default class YourComponent extends Vue {  count = 0  @Emit()  addToCount(n: number) {    this.count += n  }}</code></pre><p>与ts等效的js代码如下</p><pre><code>export default {  data() {    return {      count: 0    }  },  methods: {    addToCount(n) {      this.count += n      this.$emit('add-to-count', n)    }  }}</code></pre><h2 id="Mixins"><a href="#Mixins" class="headerlink" title="Mixins"></a>Mixins</h2><p>假设当前已经有一个mixins/ProjectMixin文件 如何在其他组件里面使用方式如下</p><pre><code>&lt;template&gt;  &lt;div class="project-detail"&gt;    {{ projectDetail }}  &lt;/div&gt;&lt;/template&gt;&lt;script lang="ts"&gt;import { Component, Vue, Mixins } from 'vue-property-decorator'import ProjectMixin from '@/mixins/ProjectMixin'@Componentexport default class Project extends Mixins(ProjectMixin) {  get projectDetail(): string {    return this.projName + ' ' + 'HS'  }}&lt;/script&gt;</code></pre><p>与ts等效的js代码如下</p><pre><code>&lt;template&gt;  &lt;div class="project-detail"&gt;    {{ projectDetail }}  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import ProjectMixin from '@/mixins/ProjectMixin'export default {  mixins: [ ProjectMixin ],  computed: {    projectDetail() {      return this.projName + ' ' + 'HS'    }  }}&lt;/script&gt;</code></pre><p>多个混入的情况</p><pre><code>import { Component, Mixins } from 'vue-property-decorator'export default class Test extends Mixins(Mixin1, Mixin2) {    test() {      this.methodFromMixin2()      console.log(this.valFromMixin1)    }}</code></pre><h2 id="refs"><a href="#refs" class="headerlink" title="refs"></a>refs</h2><p>ts无法识别vue中的$refs,需要手动指定其类型：</p><pre><code>&lt;template&gt;  &lt;loading ref="loading"/&gt;  &lt;input type="text" ref="inputRef"&gt;&lt;/template&gt;&lt;script lang="ts"&gt;import { Component } from 'vue-property-decorator'import Loading from "@/components/Loading.vue";@Component({  components: { Loading }})export default class Project extends Vue { $refs!: {    loading: Loading;    inputRef: HTMLInputElement;  }; public mounted() {    this.$refs.loading.showLoading();    // (this.$refs.loading as Loading).showLoading();    this.$refs.inputRef.focus();  }}&lt;/script&gt;</code></pre><h1 id="6-路由"><a href="#6-路由" class="headerlink" title="6 路由"></a>6 路由</h1><h2 id="路由创建"><a href="#路由创建" class="headerlink" title="路由创建"></a>路由创建</h2><pre><code>import Vue from 'vue';import VueRouter, { RouteConfig } from 'vue-router';import Home from '@/pages/home/Home.vue';Vue.use(VueRouter);const routes: Array&lt;RouteConfig&gt; = [  {    path: '/',    name: 'home',    component: Home  },  {    path: '/about',    name: 'about',    component: () =&gt; import(/* webpackChunkName: "about" */ '@/pages/about/About.vue')  }];const router = new VueRouter({  routes});export default router;</code></pre><h2 id="组件中监听路由"><a href="#组件中监听路由" class="headerlink" title="组件中监听路由"></a>组件中监听路由</h2><pre><code>&lt;script lang="ts"&gt;import { Component, Vue, Watch } from 'vue-property-decorator';import { Route } from 'vue-router';@Componentexport default class About extends Vue {  @Watch('$route', { immediate: true })  private changeRouter(route: Route) {    console.log('route', route);  }}</code></pre><h2 id="组件中使用路由勾子函数"><a href="#组件中使用路由勾子函数" class="headerlink" title="组件中使用路由勾子函数"></a>组件中使用路由勾子函数</h2><p>main.ts中：</p><pre><code>import { Component } from 'vue-property-decorator';Component.registerHooks([  'beforeRouteEnter',  'beforeRouteLeave',  'beforeRouteUpdate']);</code></pre><p>组件中：</p><pre><code>&lt;script lang="ts"&gt;import { Component, Vue, Watch } from 'vue-property-decorator';import { Route } from 'vue-router';@Componentexport default class About extends Vue {  private beforeRouteEnter(to: Route, from: Route, next: () =&gt; void): void {    console.log('beforeRouteEnter', to, from, next);    next();   }  private beforeRouteUpdate(to: Route, from: Route, next: () =&gt; void): void {    console.log('beforeRouteUpdate'); // 暂时不生效，版本问题    next();  }  private beforeRouteLeave(to: Route, from: Route, next: () =&gt; void): void {    console.log('beforeRouteLeave');    next();  }}</code></pre><h1 id="7-数据请求"><a href="#7-数据请求" class="headerlink" title="7 数据请求"></a>7 数据请求</h1><p>对返回值和入参做类型约束：</p><pre><code>// global.d.ts declare interface ResponseBody&lt;T&gt; {  data: T;  code: number;  total: number;}declare interface ResponseStatus {  loading: boolean;  error: boolean;}declare interface Response&lt;T&gt; extends ResponseStatus {  res: IResponseBody&lt;T&gt;;}declare interface ResponseNotPage&lt;T&gt; extends ResponseStatus {  data: T;}declare interface PageParams {  page: number;  pageSize: number;}declare interface RequsetParams extends PageParams {  search: string;}// src/service/demo.tsexport const getInfo = (id: number) =&gt;  request&lt;ResponseBody&lt;{ id: number; address?: string; time?: string }&gt;&gt;(    Api.GET_LAST_TRACE_INFO,    {      router: { id }    }  );</code></pre><h1 id="8-全局状态管理"><a href="#8-全局状态管理" class="headerlink" title="8 全局状态管理"></a>8 全局状态管理</h1><h2 id="8-1-开始使用"><a href="#8-1-开始使用" class="headerlink" title="8.1 开始使用"></a>8.1 开始使用</h2><p>安装依赖</p><pre><code>npm install vuex-module-decorators --save-dev</code></pre><p>如果想通过名字空间的形式来使用module, 需在@Module装饰器中添加额外的参数. 例如, 以下示例代码中添加一个namespaced为home的module</p><pre><code>// src\store\module\home.tsimport { VuexModule, Module, Mutation, Action, getModule } from 'vuex-module-decorators';import store from '@/store';@Module({ namespaced: true, dynamic: true, name: 'home', store })export default class Home extends VuexModule {  public name: string = '';  public message: string = '';  get getMessage() {    return `当前时间${new Date()}：${this.message}`;  }  @Mutation  private SET_NAME(newName: string): void {    this.name = newName;  }  @Mutation  private SET_MESSAGE(message: string) {    this.message = message;  }  @Action  public updateMessage(newName: string): void {    this.SET_NAME(newName);    this.SET_MESSAGE('欢迎您,');  }}export const HomeModule = getModule(Home);</code></pre><p>与ts等效的js代码如下</p><pre><code>const UserModule = {    state: {        name: '',        message: ''    },    getters: {         getMessage: state =&gt; `当前时间${new Date()}：${state.user.message}`    },    mutations: {         SET_NAME: (state, name) =&gt; {            state.name = name        },        SET_MESSAGE: (state, message) =&gt; {            state.message = message        }    },    actions: {         updateMessage({commit}, newName){            commit("SET_NAME", newName);            commit("SET_MESSAGE", "欢迎您,");        }    },}</code></pre><p>dynamic模式下的store</p><pre><code>// \src\store\index.tsimport Vue from 'vue';import Vuex from 'vuex';Vue.use(Vuex);// Declare empty store first, dynamically register all modules later.export default new Vuex.Store({});</code></pre><p>组件中使用：</p><pre><code>// \src\pages\home\Home.vue&lt;template&gt;  &lt;div class="home"&gt;    &lt;img alt="Vue logo" src="../../assets/logo.png" /&gt;    &lt;hello-world msg="vue.js" /&gt;    {{ $store.state.home.name }}    &lt;br/&gt;    {{ info }}    &lt;button @click="handleClick"&gt;点击&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script lang="ts"&gt;import { Component, Vue } from 'vue-property-decorator';import HelloWorld from '@/components/HelloWorld.vue';import { HomeModule } from '@/store/modules/home';@Component({  components: {    HelloWorld  }})export default class Home extends Vue {  get info() {    return HomeModule.getMessage;  }  private handleClick() {    HomeModule.updateMessage('liwu');  }}&lt;/script&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 新鲜技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>当CORS遇到SameSite</title>
      <link href="2020/09/11/dang-cors-yu-dao-samesite-md/"/>
      <url>2020/09/11/dang-cors-yu-dao-samesite-md/</url>
      
        <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><blockquote><p>A cookie associated with a cross-site resource at <a href="http://a.com/">http://a.com/</a> was set without the ‘SameSite’ attribute. A future release of Chrome will only deliver cookies with cross-site requests if they are set with ‘SameSite=None’ and ‘Secure’. You can review cookies in developer tools under Application&gt;Storage&gt;Cookies and see more details at <a href="https://www.chromestatus.com/feature/5088147346030592">https://www.chromestatus.com/feature/5088147346030592</a> and <a href="https://www.chromestatus.com/feature/5633521622188032">https://www.chromestatus.com/feature/5633521622188032</a>.</p></blockquote><p>于是发现是 Chrome 升级 80 导致未设置 SameSite 的 Cookie 默认值是Lax。</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="1-紧急处理"><a href="#1-紧急处理" class="headerlink" title="1.紧急处理"></a>1.紧急处理</h2><p>其实是在服务方解决问题之前让用户先稍微兼容一下。方案很简单：</p><p>换个浏览器<br>or</p><p>打开 chrome://flags/#same-site-by-default-cookies，关掉 SameSite by default cookies 然后重启浏览器</p><h2 id="2-方法一：跨域-Set-Cookie"><a href="#2-方法一：跨域-Set-Cookie" class="headerlink" title="2. 方法一：跨域 + Set-Cookie"></a>2. 方法一：跨域 + Set-Cookie</h2><p>首先就是报错信息里提到的，让服务端同学在 Set-Cookie 的时候加上 SameSite=None; Secure。但是我们的后台系统都是对内使用的，很多域名都没有申请证书。而 “Secure” 属性却表示 Cookie 只能随 HTTPS 请求发送。<br>这就很尴尬。<br>要不申请证书，要不换域名。<br>但是长远来看，https是大趋势，趁着这个机会升级成 HTTPS 也是可取的。<br>然而有些版本的浏览器并不识别 SameSite=None，需要特殊处理。</p><h2 id="3-方法二：改成同域请求"><a href="#3-方法二：改成同域请求" class="headerlink" title="3. 方法二：改成同域请求"></a>3. 方法二：改成同域请求</h2><p>既然 SameSite=Lax 限制的是跨域 Cookie 携带，那么改成同域自然没有问题了。<br>但因为现在项目都是前后端分离部署的，所以请运维同学配了一下匹配到 ^/api/ 开头的请求都转发到服务端的地址。前端请求接口时直接用相对路径请求。<br>问题解决</p>]]></content>
      
      
      <categories>
          
          <category> 项目总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 踩的坑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BFC原理及应用</title>
      <link href="2020/08/30/bfc-yuan-li-ji-ying-yong/"/>
      <url>2020/08/30/bfc-yuan-li-ji-ying-yong/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/css.png"></p><h1 id="一、常见定位方案"><a href="#一、常见定位方案" class="headerlink" title="一、常见定位方案"></a>一、常见定位方案</h1><p>在讲 BFC 之前，我们先来了解一下常见的定位方案，定位方案是控制元素的布局，有三种常见方案:</p><ul><li>普通流 (normal flow)<br>在普通流中，元素按照其在 HTML 中的先后位置至上而下布局，在这个过程中，行内元素水平排列，直到当行被占满然后换行，块级元素则会被渲染为完整的一个新行，除非另外指定，否则所有元素默认都是普通流定位，也可以说，普通流中元素的位置由该元素在 HTML 文档中的位置决定。</li><li>浮动 (float)<br>在浮动布局中，元素首先按照普通流的位置出现，然后根据浮动的方向尽可能的向左边或右边偏移，其效果与印刷排版中的文本环绕相似。</li><li>绝对定位 (absolute positioning)<br>在绝对定位布局中，元素会整体脱离普通流，因此绝对定位元素不会对其兄弟元素造成影响，而元素具体的位置由绝对定位的坐标决定。</li></ul><h1 id="二、BFC-概念"><a href="#二、BFC-概念" class="headerlink" title="二、BFC 概念"></a>二、BFC 概念</h1><blockquote><p>Formatting context(格式化上下文) 是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。</p></blockquote><p>那么 BFC 是什么呢？</p><p>BFC 即 Block Formatting Contexts (块级格式化上下文)，它属于上述定位方案的普通流。<br>具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。<br>通俗一点来讲，可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。</p><h1 id="三、触发-BFC"><a href="#三、触发-BFC" class="headerlink" title="三、触发 BFC"></a>三、触发 BFC</h1><p>只要元素满足下面任一条件即可触发 BFC 特性：</p><ul><li>body 根元素</li><li>浮动元素：float 除 none 以外的值</li><li>绝对定位元素：position (absolute、fixed)</li><li>display 为 inline-block、table-cells、flex</li><li>overflow 除了 visible 以外的值 (hidden、auto、scroll)</li></ul><h1 id="四、BFC-特性及应用"><a href="#四、BFC-特性及应用" class="headerlink" title="四、BFC 特性及应用"></a>四、BFC 特性及应用</h1><h2 id="1-同一个-BFC-下外边距会发生折叠"><a href="#1-同一个-BFC-下外边距会发生折叠" class="headerlink" title="1. 同一个 BFC 下外边距会发生折叠"></a>1. 同一个 BFC 下外边距会发生折叠</h2><pre><code>&lt;head&gt;div{    width: 100px;    height: 100px;    background: lightblue;    margin: 100px;}&lt;/head&gt;&lt;body&gt;    &lt;div&gt;&lt;/div&gt;    &lt;div&gt;&lt;/div&gt;&lt;/body&gt;</code></pre><p>从效果上看，因为两个 div 元素都处于同一个 BFC 容器下 (这里指 body 元素) 所以第一个 div 的下边距和第二个 div 的上边距发生了重叠，所以两个盒子之间距离只有 100px，而不是 200px。<br><img src="https://7.dusays.com/2020/11/02/0afee71e5de5e.png"></p><p>首先这不是 CSS 的 bug，我们可以理解为一种规范，如果想要避免外边距的重叠，可以将其放在不同的 BFC 容器中。</p><pre><code>&lt;div class="container"&gt;    &lt;p&gt;&lt;/p&gt;&lt;/div&gt;&lt;div class="container"&gt;    &lt;p&gt;&lt;/p&gt;&lt;/div&gt;.container {    overflow: hidden;}p {    width: 100px;    height: 100px;    background: lightblue;    margin: 100px;}</code></pre><p>这时候，两个盒子边距就变成了 200px </p><p><img src="https://7.dusays.com/2020/11/02/0e302d5bce868.png"></p><h2 id="2-BFC-可以包含浮动的元素（清除浮动）"><a href="#2-BFC-可以包含浮动的元素（清除浮动）" class="headerlink" title="2. BFC 可以包含浮动的元素（清除浮动）"></a>2. BFC 可以包含浮动的元素（清除浮动）</h2><p>我们都知道，浮动的元素会脱离普通文档流，来看下下面一个例子</p><pre><code>&lt;div style="border: 1px solid #000;"&gt;    &lt;div style="width: 100px;height: 100px;background: #eee;float: left;"&gt;&lt;/div&gt;&lt;/div&gt;</code></pre><p><img src="https://7.dusays.com/2020/11/02/f461d5e0dbd0f.png"></p><p>由于容器内元素浮动，脱离了文档流，所以容器只剩下 2px 的边距高度。如果使触发容器的 BFC，那么容器将会包裹着浮动元素。</p><pre><code>&lt;div style="border: 1px solid #000;overflow: hidden"&gt;    &lt;div style="width: 100px;height: 100px;background: #eee;float: left;"&gt;&lt;/div&gt;&lt;/div&gt;</code></pre><p>效果如图：</p><p><img src="https://7.dusays.com/2020/11/02/b90051e64945c.png"></p><h2 id="3-BFC-可以阻止元素被浮动元素覆盖"><a href="#3-BFC-可以阻止元素被浮动元素覆盖" class="headerlink" title="3. BFC 可以阻止元素被浮动元素覆盖"></a>3. BFC 可以阻止元素被浮动元素覆盖</h2><p>先来看一个文字环绕效果：</p><pre><code>&lt;div style="height: 100px;width: 100px;float: left;background: lightblue"&gt;    我是一个左浮动的元素&lt;/div&gt;&lt;div style="width: 200px; height: 200px;background: #eee"&gt;    我是一个没有设置浮动, 也没有触发 BFC 元素, width: 200px; height:200px; background: #eee;&lt;/div&gt;</code></pre><p><img src="https://7.dusays.com/2020/11/02/aaf4c0ab57032.png"></p><p>这时候其实第二个元素有部分被浮动元素所覆盖，(但是文本信息不会被浮动元素所覆盖) 如果想避免元素被覆盖，可触第二个元素的 BFC 特性，在第二个元素中加入 overflow: hidden，就会变成：</p><p><img src="https://7.dusays.com/2020/11/02/4a7759227aae9.png"></p><p>这个方法可以用来实现两列自适应布局，效果不错，这时候左边的宽度固定，右边的内容自适应宽度(去掉上面右边内容的宽度)。</p>]]></content>
      
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hooks入门教程</title>
      <link href="2019/09/16/hooks-ru-men-jiao-cheng/"/>
      <url>2019/09/16/hooks-ru-men-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<p><img src="https://7.dusays.com/2020/11/02/d812bf44ed5ef.png" alt="react"></p><h1 id="Hooks的含义"><a href="#Hooks的含义" class="headerlink" title="Hooks的含义:"></a>Hooks的含义:</h1><p>React Hooks 的意思是，组件尽量写成<strong>纯函数</strong>，如果需要外部功能和副作用，就用钩子把外部代码”钩”进来。 React Hooks 就是那些钩子。</p><p>React默认提供了一些常用的钩子函数，你也可以自己定义钩子函数。</p><p>React 团队希望，组件不要变成复杂的容器，最好只是数据流的管道。开发者根据需要，组合管道即可。 <strong>组件的最佳写法应该是函数</strong>，而不是类。</p><p>React 约定，钩子一律使用<strong>use</strong>前缀命名，便于识别。</p><h1 id="常见的钩子函数"><a href="#常见的钩子函数" class="headerlink" title="常见的钩子函数"></a>常见的钩子函数</h1><h2 id="1-useState-状态钩子"><a href="#1-useState-状态钩子" class="headerlink" title="1. useState():状态钩子"></a>1. useState():状态钩子</h2><pre><code>useState用于为函数组件引入状态（state）。纯函数不能有状态，所以把状态放在钩子里面useState()这个函数接受状态的初始值，作为参数，返回一个数组，数组第一个成员是一个变量，指向状态的当前值。第二个成员是函数，用来更新状态，约定用set前缀加上状态的变量名。const [buttonText, setButtonText] = useState("Click me, please");</code></pre><h2 id="2-useContext-共享状态钩子"><a href="#2-useContext-共享状态钩子" class="headerlink" title="2. useContext()共享状态钩子"></a>2. useContext()共享状态钩子</h2><pre><code>如果组件之间需要共享状态，可以使用useContext()。&lt;div className="App"&gt;  &lt;Navbar/&gt;  &lt;Messages/&gt;&lt;/div&gt;如果Navbar跟Messages实现通信，第一步在组件外部建立一个context:const AppContext = React.creatContext({})组件封装的代码如下：&lt;AppContext.Provider value={{  username: 'superawesome'}}&gt;  &lt;div className="App"&gt;    &lt;Navbar/&gt;    &lt;Messages/&gt;  &lt;/div&gt;&lt;/AppContext.Provider&gt;在组件中的使用如下：const Navbar = () =&gt; {  const { username } = useContext(AppContext);  return (    &lt;div className="navbar"&gt;      &lt;p&gt;AwesomeSite&lt;/p&gt;      &lt;p&gt;{username}&lt;/p&gt;    &lt;/div&gt;  );}</code></pre><h2 id="3-useReducer-action钩子"><a href="#3-useReducer-action钩子" class="headerlink" title="3. useReducer():action钩子"></a>3. useReducer():action钩子</h2><pre><code>React 本身不提供状态管理功能，通常需要使用外部库。这方面最常用的库是 Redux。Redux 的核心概念是，组件发出 action 与状态管理器通信。状态管理器收到 action 以后，使用 Reducer 函数算出新的状态，Reducer 函数的形式是(state, action) =&gt; newState。useReducers()钩子用来引入 Reducer 功能。const [state, dispatch] = useReducer(reducer, initialState);</code></pre><h2 id="4-useEffect-副作用钩子"><a href="#4-useEffect-副作用钩子" class="headerlink" title="4. useEffect():副作用钩子"></a>4. useEffect():副作用钩子</h2><pre><code>useEffect()用来引入具有副作用的操作，最常见的就是向服务器请求数据。以前，放在componentDidMount里面的代码，现在可以放在useEffect()。useEffect()的用法如下。useEffect(()  =&gt;  {  // Async Action}, [dependencies])useEffect()接受两个参数。第一个参数是函数，异步操作的代码放里面，第二个参数是一个数组，用于给出Effect的依赖，只要这个数组发生变化，useEffect()就会执行。第二个参数可以省略，这时每次组件渲染时，就会执行useEffect()。</code></pre><p>React首次渲染和之后的每次渲染都会调用一遍useEffect函数，而之前我们要用两个生命周期函数分别表示首次渲染(componentDidMonut)和更新导致的重新渲染(componentDidUpdate)。</p><p>useEffect中定义的函数的执行不会阻碍浏览器更新视图，也就是说这些函数时异步执行的，而componentDidMonut和componentDidUpdate中的代码都是同步执行的。个人认为这个有好处也有坏处吧，比如我们要根据页面的大小，然后绘制当前弹出窗口的大小，如果时异步的就不好操作了。</p>]]></content>
      
      
      <categories>
          
          <category> 新鲜技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
            <tag> hooks </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单的在线数据mock</title>
      <link href="2019/08/30/jian-dan-de-zai-xian-shu-ju-mock/"/>
      <url>2019/08/30/jian-dan-de-zai-xian-shu-ju-mock/</url>
      
        <content type="html"><![CDATA[<h1 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h1><p>在接口调试前，前端根据定义好的接口文档，模拟数据，发起请求，编写完整的页面逻辑，等真正开始调试的时候，将请求地址更换即可。</p><p>本文只介绍在线 mock 数据的方式，在线 mock 跟本地 mock 比较，可以省去安装配置，运行服务，多人协作数据不通的多种问题。</p><h1 id="一个简单的列子"><a href="#一个简单的列子" class="headerlink" title="一个简单的列子"></a>一个简单的列子</h1><p><img src="https://7.dusays.com/2020/11/02/98aaa2c403dd1.png"></p><p>返回结果：</p><p><img src="https://7.dusays.com/2020/11/02/a2df1d69cadcf.png"></p><h1 id="Mock-语法简介"><a href="#Mock-语法简介" class="headerlink" title="Mock 语法简介"></a>Mock 语法简介</h1><h2 id="base"><a href="#base" class="headerlink" title="base"></a>base</h2><pre><code>{    "base": {    "range": "@range(3, 7)",    "string": "@string(7, 20)",    "character": "@character(\"abcde\")",    "float": "@float(60, 100)",    "integer": "@integer(60, 100)",    "natural": "@natural(60, 100)",    "boolean": "@boolean"  },}</code></pre><p>预览：</p><pre><code>"base": {    "range": [3,4,5,6],    "string": "qg3)zBWiLlbrsisX",    "character": "c",    "float": 66.87535733306,    "integer": 66,    "natural": 71,    "boolean": false  },</code></pre><h2 id="date"><a href="#date" class="headerlink" title="date"></a>date</h2><pre><code>"date": {    "date": "@date",    "time": "@time",    "datetime": "@datetime",    "now": "@now"  },</code></pre><p>预览：</p><pre><code>"date": {    "date": "1971-10-18",    "time": "02:04:17",    "datetime": "1985-03-10 22:47:49",    "now": "2019-09-25 13:56:44"    }</code></pre><h2 id="image"><a href="#image" class="headerlink" title="image"></a>image</h2><pre><code> "image": {    "image": "@image(\"200x200\", \"#50B347\", \"#FFF\", \"FastMock\")"  },</code></pre><p>预览：</p><pre><code>"image": {    "image": "http://dummyimage.com/200x200/50B347/FFF&amp;text=FastMock"  },</code></pre><h2 id="text"><a href="#text" class="headerlink" title="text"></a>text</h2><pre><code>"text": {    "paragraph": "@paragraph(1, 3)",    "sentence": "@sentence(3, 5)",    "word": "@word(3, 5)",    "title": "@title(3, 5)",    "cparagraph": "@cparagraph(1, 3)",    "csentence": "@csentence(3, 5)",    "cword": "@cword(\"零一二三四五六七八九十\", 5, 7)",    "ctitle": "@ctitle(3, 5)"  },</code></pre><p>预览：</p><pre><code> "text": {    "paragraph": "Gifp ifnk hrreyi foajbgielv doijqrd ffaooi hlwstfcfw nrgsioum wtgashcoiy sintskl hnjk ebcsec. Bhlhghu embjvvs bckwkibqhs qgqz psu mjsodprwf exidxyqnq cdyqoatr xkezagaqu ijrcqrj vvxwdwgq ivv jxcpeybpus sojcn cscdlnmi kopzvuqfin.",    "sentence": "Xuqxp qvek ttgiq.",    "word": "ynug",    "title": "Cdnsxa Yjhrlbb Rmofrixln Jubgpxm Gjpdujgryi",    "cparagraph": "装增克体都月每手物即用周几想军点程。将角权响金华生候社根利情也龙。化必去边织众东位史回际平马至。",    "csentence": "存断实。",    "cword": "三七九六六",    "ctitle": "油眼采小"  },</code></pre><h2 id="name"><a href="#name" class="headerlink" title="name"></a>name</h2><pre><code>"name": {    "first": "@first",    "last": "@last",    "name": "@name",    "cfirst": "@cfirst",    "clast": "@clast",    "cname": "@cname"  },</code></pre><p>预览：</p><pre><code>"name": {    "first": "Jennifer",    "last": "Anderson",    "name": "Laura Moore",    "cfirst": "胡",    "clast": "秀兰",    "cname": "姜敏"  },</code></pre><h2 id="web"><a href="#web" class="headerlink" title="web"></a>web</h2><pre><code>"web": {    "url": "@url",    "domain": "@domain",    "protocol": "@protocol",    "tld": "@tld",    "email": "@email",    "ip": "@ip"  },</code></pre><p>预览：</p><pre><code>"web": {    "url": "mid://nypjj.kr/mizdvfhl",    "domain": "jbgmh.cn",    "protocol": "ftp",    "tld": "fj",    "email": "r.bdwejkiuy@ltatgpp.an",    "ip": "175.52.62.226"  },</code></pre><h2 id="address"><a href="#address" class="headerlink" title="address"></a>address</h2><pre><code>"address": {    "region": "@region",    "province": "@province",    "city": "@city(true)",    "county": "@county(true)",    "zip": "@zip"  },</code></pre><p>预览：</p><pre><code>"address": {    "region": "华中",    "province": "云南省",    "city": "天津 天津市",    "county": "台湾 金门县 金宁乡",    "zip": "539375"  },</code></pre><h2 id="miscellaneous"><a href="#miscellaneous" class="headerlink" title="miscellaneous"></a>miscellaneous</h2><pre><code> "miscellaneous": {    "id": "@id",    "guid": "@guid",    "increment": "@increment(1000)"  }</code></pre><p>预览：</p><pre><code> "miscellaneous": {    "id": "370000201504299208",    "guid": "6E6155c0-f5b5-F3F6-5F0D-23EB44C21313",    "increment": 253109  }</code></pre><h1 id="Mock-高阶用法"><a href="#Mock-高阶用法" class="headerlink" title="Mock 高阶用法"></a>Mock 高阶用法</h1><blockquote><p>Mock 能支持 function，function 中不能用上面的@XX,用 Mock.mock(“@xxx”)替代。function 中还能获取全部请求头和参数。</p></blockquote><table><thead><tr><th>对象</th><th>描述</th></tr></thead><tbody><tr><td>Mock</td><td>Mock 对象</td></tr><tr><td>_req.url</td><td>获得请求 url 地址</td></tr><tr><td>_req.method</td><td>获取请求方法</td></tr><tr><td>_req.params</td><td>获取 url 参数对象</td></tr><tr><td>_req.querystring</td><td>获取查询参数字符串(url 中?后面的部分)，不包含 ?</td></tr><tr><td>_req.query</td><td>将查询参数字符串进行解析并以对象的形式返回，如果没有查询参数字字符串则返回一个空对象</td></tr><tr><td>_req.body</td><td>当 post 请求以 x-www-form-urlencoded 方式提交时，我们可以拿到请求的参数对象</td></tr></tbody></table><h2 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h2><pre><code>{  code: function({    _req  }) {    const userName = _req.query.userName;    return userName ? 0 : -1;  },  data: function({    _req,    Mock  }) {    const userName = _req.query.userName;    return userName ? {      token: Mock.mock("@guid()"),      userId: Mock.mock("@id(5)"),      name: userName,      avatar: Mock.mock("@image(200x100, #FF6600)"),      message: "登录成功"    } : {      message: "登录失败"    }  }}</code></pre><p>预览：</p><p><img src="https://note.youdao.com/yws/public/resource/633e9bc706a3a274d9926f95b1806671/xmlnote/1C6017CB352F41DD9B758D064EBCFD4B/15016" alt="image"></p><h1 id="常用的在线-mock-工具"><a href="#常用的在线-mock-工具" class="headerlink" title="常用的在线 mock 工具"></a>常用的在线 mock 工具</h1><ul><li><p>💛 <a href="https://www.fastmock.site/">fast-mock</a></p></li><li><p>💗 <a href="https://easy-mock.com/">easy-mock</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue组件编码规范</title>
      <link href="2019/08/13/vue-zu-jian-bian-ma-gui-fan/"/>
      <url>2019/08/13/vue-zu-jian-bian-ma-gui-fan/</url>
      
        <content type="html"><![CDATA[<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><blockquote><p>本规范提供了一种统一的编码规范来编写 Vue.js 代码。这使得代码具有如下的特性：</p></blockquote><ul><li>其它开发者或是团队成员更容易阅读和理解。</li><li>IDEs 更容易理解代码，从而提供高亮、格式化等辅助功能</li><li>更容易使用现有的工具</li><li>更容易实现缓存以及代码包的分拆</li></ul><h1 id="基于模块开发"><a href="#基于模块开发" class="headerlink" title="基于模块开发"></a>基于模块开发</h1><p>始终基于模块的方式来构建你的 app，每一个子模块只做一件事情。</p><p>Vue.js 的设计初衷就是帮助开发者更好的开发界面模块。一个模块是应用程序中独立的一个部分。</p><h2 id="怎么做？"><a href="#怎么做？" class="headerlink" title="怎么做？"></a>怎么做？</h2><blockquote><p>每一个 Vue 组件（等同于模块）首先必须专注于解决一个单一的问题，独立的、可复用的、微小的 和 可测试的。</p></blockquote><p>如果你的组件做了太多的事或是变得臃肿，请将其拆分成更小的组件并保持单一的原则。一般来说，尽量保证每一个文件的代码行数不要超过 100 行。也请保证组件可独立的运行。</p><h1 id="vue-组件命名"><a href="#vue-组件命名" class="headerlink" title="vue 组件命名"></a>vue 组件命名</h1><p>组件的命名需遵从以下原则：</p><ul><li><p><strong>有意义的</strong>: 不过于具体，也不过于抽象</p></li><li><p><strong>简短</strong>: 2 到 3 个单词</p></li><li><p><strong>具有可读性</strong>: 以便于沟通交流<br>同时还需要注意：</p></li><li><p>必须符合<strong>自定义元素规范</strong>: 使用连字符分隔单词，切勿使用保留字。</p></li><li><p>app- 前缀作为命名空间:</p></li></ul><p>如果非常通用的话可使用一个单词来命名，这样可以方便于其它项目里复用。</p><h2 id="为什么？"><a href="#为什么？" class="headerlink" title="为什么？"></a>为什么？</h2><ul><li>组件是通过组件名来调用的。所以组件名必须简短、富有含义并且具有可读性。</li></ul><h2 id="如何做？"><a href="#如何做？" class="headerlink" title="如何做？"></a>如何做？</h2><pre><code>!-- 推荐 --&gt;&lt;app-header&gt;&lt;/app-header&gt;&lt;user-list&gt;&lt;/user-list&gt;&lt;range-slider&gt;&lt;/range-slider&gt;&lt;!-- 避免 --&gt;&lt;btn-group&gt;&lt;/btn-group&gt; &lt;!-- 虽然简短但是可读性差. 使用 `button-group` 替代 --&gt;&lt;ui-slider&gt;&lt;/ui-slider&gt; &lt;!-- ui 前缀太过于宽泛，在这里意义不明确 --&gt;&lt;slider&gt;&lt;/slider&gt; &lt;!-- 与自定义元素规范不兼容 --&gt;</code></pre><h1 id="组件表达式简单化"><a href="#组件表达式简单化" class="headerlink" title="组件表达式简单化"></a>组件表达式简单化</h1><p>Vue.js 的表达式是 100% 的 Javascript 表达式。这使得其功能性很强大，但也带来潜在的复杂性。因此，你应该尽量保持表达式的简单化。</p><h2 id="为什么？-1"><a href="#为什么？-1" class="headerlink" title="为什么？"></a>为什么？</h2><ul><li>复杂的行内表达式难以阅读。</li><li>行内表达式是不能够通用的，这可能会导致重复编码的问题。</li><li>IDE 基本上不能识别行内表达式语法，所以使用行内表达式 IDE 不能提供自动补全和语法校验功能。</li></ul><h2 id="怎么做？-1"><a href="#怎么做？-1" class="headerlink" title="怎么做？"></a>怎么做？</h2><p>如果你发现写了太多复杂并难以阅读的行内表达式，那么可以使用 method 或是 computed 属性来替代其功能。</p><pre><code>&lt;!-- 推荐 --&gt;&lt;template&gt;  &lt;h1&gt;    {{ `${year}-${month}` }}  &lt;/h1&gt;&lt;/template&gt;&lt;script type="text/javascript"&gt;  export default {    computed: {      month() {        return this.twoDigits((new Date()).getUTCMonth() + 1);      },      year() {        return (new Date()).getUTCFullYear();      }    },    methods: {      twoDigits(num) {        return ('0' + num).slice(-2);      }    },  };&lt;/script&gt;&lt;!-- 避免 --&gt;&lt;template&gt;  &lt;h1&gt;    {{ `${(new Date()).getUTCFullYear()}-${('0' + ((new Date()).getUTCMonth()+1)).slice(-2)}` }}  &lt;/h1&gt;&lt;/template&gt;</code></pre><h1 id="组件-props-原子化"><a href="#组件-props-原子化" class="headerlink" title="组件 props 原子化"></a>组件 props 原子化</h1><p>虽然 Vue.js 支持传递复杂的 JavaScript 对象通过 props 属性，但是你应该尽可能的使用原始类型的数据。尽量只使用 JavaScript 原始类型（字符串、数字、布尔值）和函数。尽量避免复杂的对象。</p><h2 id="为什么？-2"><a href="#为什么？-2" class="headerlink" title="为什么？"></a>为什么？</h2><ul><li>使得组件 API 清晰直观。</li><li>只使用原始类型和函数作为 props 使得组件的 API 更接近于 HTML(5) 原生元素。</li><li>其它开发者更好的理解每一个 prop 的含义、作用。</li><li>传递过于复杂的对象使得我们不能够清楚的知道哪些属性或方法被自定义组件使用，这使得代码难以重构和维护。</li></ul><h2 id="怎么做？-2"><a href="#怎么做？-2" class="headerlink" title="怎么做？"></a>怎么做？</h2><p>组件的每一个属性单独使用一个 props，并且使用函数或是原始类型的值。</p><pre><code>&lt;!-- 推荐 --&gt;&lt;range-slider  :values="[10, 20]"  :min="0"  :max="100"  :step="5"  @on-slide="updateInputs"  @on-end="updateResults"&gt;&lt;/range-slider&gt;&lt;!-- 避免 --&gt;&lt;range-slider :config="complexConfigObject"&gt;&lt;/range-slider&gt;</code></pre><h1 id="验证组件的-props"><a href="#验证组件的-props" class="headerlink" title="验证组件的 props"></a>验证组件的 props</h1><p>在 Vue.js 中，组件的 props 即 API，一个稳定并可预测的 API 会使得你的组件更容易被其他开发者使用。</p><p>组件 props 通过自定义标签的属性来传递。属性的值可以是 Vue.js 字符串(:attr=”value” 或 v-bind:attr=”value”)或是不传。你需要保证组件的 props 能应对不同的情况。</p><h2 id="为什么？-3"><a href="#为什么？-3" class="headerlink" title="为什么？"></a>为什么？</h2><p>验证组件 props 可以保证你的组件永远是可用的（防御性编程）。即使其他开发者并未按照你预想的方法使用时也不会出错。</p><h2 id="怎么做？-3"><a href="#怎么做？-3" class="headerlink" title="怎么做？"></a>怎么做？</h2><ul><li>提供默认值。</li><li>使用 type 属性校验类型。</li><li>使用 props 之前先检查该 prop 是否存在。</li></ul><pre><code>&lt;template&gt;  &lt;input type="range" v-model="value" :max="max" :min="min"&gt;&lt;/template&gt;&lt;script type="text/javascript"&gt;  export default {    props: {      max: {        type: Number, // 这里添加了数字类型的校验        default() { return 10; },      },      min: {        type: Number,        default() { return 0; },      },      value: {        type: Number,        default() { return 4; },      },    },  };&lt;/script&gt;</code></pre><h1 id="将-this-赋值给-component-变量"><a href="#将-this-赋值给-component-变量" class="headerlink" title="将 this 赋值给 component 变量"></a>将 this 赋值给 component 变量</h1><p>在 Vue.js 组件上下文中，this指向了组件实例。因此当你切换到了不同的上下文时，要确保 this 指向一个可用的 component 变量。</p><p>换句话说，如果你正在使用 ES6 的话，就不要再编写 var self = this; 这样的代码了，您可以安全地使用 Vue 组件。</p><h2 id="为什么？-4"><a href="#为什么？-4" class="headerlink" title="为什么？"></a>为什么？</h2><ul><li>使用 ES6，就不再需要将 this 保存到一个变量中了。</li><li>一般来说，当你使用箭头函数时，会保留 this 的作用域。（译者注：箭头函数没有它自己的 this 值，箭头函数内的 this 值继承自外围作用域。）</li><li>如果你没有使用 ES6，当然也就不会使用 箭头函数 啦，那你必须将 “this” 保存到到某个变量中。这是唯一的例外。</li></ul><h2 id="怎么做？-4"><a href="#怎么做？-4" class="headerlink" title="怎么做？"></a>怎么做？</h2><pre><code>&lt;script type="text/javascript"&gt;export default {  methods: {    hello() {      return 'hello';    },    printHello() {      console.log(this.hello());    },  },};&lt;/script&gt;&lt;!-- 避免 --&gt;&lt;script type="text/javascript"&gt;export default {  methods: {    hello() {      return 'hello';    },    printHello() {      const self = this; // 没有必要      console.log(self.hello());    },  },};&lt;/script&gt;</code></pre><h1 id="组件结构化"><a href="#组件结构化" class="headerlink" title="组件结构化"></a>组件结构化</h1><p>按照一定的结构组织，使得组件便于理解。</p><h2 id="为什么？-5"><a href="#为什么？-5" class="headerlink" title="为什么？"></a>为什么？</h2><ul><li>导出一个清晰、组织有序的组件，使得代码易于阅读和理解。同时也便于标准化。</li><li>按首字母排序 properties、data、computed、watches 和 methods 使得这些对象内的属性便于查找。</li><li>合理组织，使得组件易于阅读。（name; extends; props, data 和 computed; components; watch 和 methods; lifecycle methods 等）。</li><li>使用 name 属性。借助于 vue devtools 可以让你更方便的测试。</li><li>合理的 CSS 结构，如 BEM 或 rscss - 详情？。</li><li>使用单文件 .vue 文件格式来组件代码。</li></ul><h2 id="怎么做？-5"><a href="#怎么做？-5" class="headerlink" title="怎么做？"></a>怎么做？</h2><p>组件结构化</p><pre><code>&lt;template lang="html"&gt;  &lt;div class="Ranger__Wrapper"&gt;    &lt;!-- ... --&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script type="text/javascript"&gt;  export default {    // 不要忘记了 name 属性    name: 'RangeSlider',    // 使用组件 mixins 共享通用功能    mixins: [],    // 组成新的组件    extends: {},    // 组件属性、变量    props: {      bar: {}, // 按字母顺序      foo: {},      fooBar: {},    },    // 变量    data() {},    computed: {},    // 使用其它组件    components: {},    // 方法    watch: {},    methods: {},    // 生命周期函数    beforeCreate() {},    mounted() {},  };&lt;/script&gt;&lt;style scoped&gt;  .Ranger__Wrapper { /* ... */ }&lt;/style&gt;</code></pre><h1 id="避免-this-parent"><a href="#避免-this-parent" class="headerlink" title="避免 this.$parent"></a>避免 this.$parent</h1><p>Vue.js 支持组件嵌套，并且子组件可访问父组件的上下文。访问组件之外的上下文违反了基于模块开发的第一原则。因此你应该尽量避免使用 this.$parent。</p><h2 id="为什么？-6"><a href="#为什么？-6" class="headerlink" title="为什么？"></a>为什么？</h2><ul><li>组件必须相互保持独立，Vue 组件也是。如果组件需要访问其父层的上下文就违反了该原则。</li><li>如果一个组件需要访问其父组件的上下文，那么该组件将不能在其它上下文中复用。</li></ul><h2 id="怎么做？-6"><a href="#怎么做？-6" class="headerlink" title="怎么做？"></a>怎么做？</h2><ul><li>通过 props 将值传递给子组件。</li><li>通过 props 传递回调函数给子组件来达到调用父组件方法的目的。</li><li>通过在子组件触发事件来通知父组件。</li></ul><h1 id="谨慎使用-this-refs"><a href="#谨慎使用-this-refs" class="headerlink" title="谨慎使用 this.$refs"></a>谨慎使用 this.$refs</h1><p>Vue.js 支持通过 ref 属性来访问其它组件和 HTML 元素。并通过 this.$refs 可以得到组件或 HTML 元素的上下文。在大多数情况下，通过 this.$refs来访问其它组件的上下文是可以避免的。在使用的的时候你需要注意避免调用了不恰当的组件 API，所以应该尽量避免使用 this.$refs。</p><h2 id="为什么？-7"><a href="#为什么？-7" class="headerlink" title="为什么？"></a>为什么？</h2><ul><li>组件必须是保持独立的，如果一个组件的 API 不能够提供所需的功能，那么这个组件在设计、实现上是有问题的。</li><li>组件的属性和事件必须足够的给大多数的组件使用。</li></ul><h2 id="怎么做？-7"><a href="#怎么做？-7" class="headerlink" title="怎么做？"></a>怎么做？</h2><ul><li>提供良好的组件 API。</li><li>总是关注于组件本身的目的。</li><li>拒绝定制代码。如果你在一个通用的组件内部编写特定需求的代码，那么代表这个组件的 API 不够通用，或者你可能需要一个新的组件来应对该需求。</li><li>检查所有的 props 是否有缺失的，如果有提一个 issue 或是完善这个组件。</li><li>检查所有的事件。子组件向父组件通信一般是通过事件来实现的，但是大多数的开发者更多的关注于 props 从忽视了这点。</li><li>Props向下传递，事件向上传递！。以此为目标升级你的组件，提供良好的 API 和 独立性。</li><li>当遇到 props 和 events 难以实现的功能时，通过 this.$refs来实现。</li><li>当需要操作 DOM 无法通过指令来做的时候可使用 this.$ref 而不是 JQuery、document.getElement*、document.queryElement。</li></ul><pre><code>&lt;!-- 推荐，并未使用 this.$refs --&gt;&lt;range :max="max"  :min="min"  @current-value="currentValue"  :step="1"&gt;&lt;/range&gt;</code></pre><pre><code>&lt;!-- 使用 this.$refs 的适用情况--&gt;&lt;modal ref="basicModal"&gt;  &lt;h4&gt;Basic Modal&lt;/h4&gt;  &lt;button class="primary" @click="$refs.basicModal.hide()"&gt;Close&lt;/button&gt;&lt;/modal&gt;&lt;button @click="$refs.basicModal.open()"&gt;Open modal&lt;/button&gt;&lt;!-- Modal component --&gt;&lt;template&gt;  &lt;div v-show="active"&gt;    &lt;!-- ... --&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  export default {    // ...    data() {      return {        active: false,      };    },    methods: {      open() {        this.active = true;      },      hide() {        this.active = false;      },    },    // ...  };&lt;/script&gt;</code></pre><pre><code>&lt;!-- 如果可通过 emited 来做则避免通过 this.$refs 直接访问 --&gt;&lt;template&gt;  &lt;range :max="max"    :min="min"    ref="range"    :step="1"&gt;&lt;/range&gt;&lt;/template&gt;&lt;script&gt;  export default {    // ...    methods: {      getRangeCurrentValue() {        return this.$refs.range.currentValue;      },    },    // ...  };&lt;/script&gt;</code></pre><h1 id="使用组件名作为样式作用域空间"><a href="#使用组件名作为样式作用域空间" class="headerlink" title="使用组件名作为样式作用域空间"></a>使用组件名作为样式作用域空间</h1><p>Vue.js 的组件是自定义元素，这非常适合用来作为样式的根作用域空间。可以将组件名作为 CSS 类的命名空间。</p><h2 id="为什么？-8"><a href="#为什么？-8" class="headerlink" title="为什么？"></a>为什么？</h2><ul><li>给样式加上作用域空间可以避免组件样式影响外部的样式。</li><li>保持模块名、目录名、样式根作用域名一样，可以很好的将其关联起来，便于开发者理解。</li></ul><h2 id="怎么做？-8"><a href="#怎么做？-8" class="headerlink" title="怎么做？"></a>怎么做？</h2><p>使用组件名作为样式命名的前缀，可基于 BEM 或 OOCSS 范式。同时给 style 标签加上 scoped 属性。加上 scoped 属性编译后会给组件的 class 自动加上唯一的前缀从而避免样式的冲突。</p><pre><code>&lt;style scoped&gt;  /* 推荐 */  .MyExample { }  .MyExample li { }  .MyExample__item { }  /* 避免 */  .My-Example { } /* 没有用组件名或模块名限制作用域, 不符合 BEM 规范 */&lt;/style&gt;</code></pre><h1 id="尽可能使用-mixins"><a href="#尽可能使用-mixins" class="headerlink" title="尽可能使用 mixins"></a>尽可能使用 mixins</h1><h2 id="为什么"><a href="#为什么" class="headerlink" title="为什么?"></a>为什么?</h2><p>Mixins 封装可重用的代码，避免了重复。如果两个组件共享有相同的功能，则可以使用 mixin。通过 mixin，你可以专注于单个组件的任务和抽象的通用代码。这有助于更好地维护你的应用程序。</p><h2 id="怎么做"><a href="#怎么做" class="headerlink" title="怎么做?"></a>怎么做?</h2><p>假设你有一个移动端和桌面端的菜单组件，它们共享一些功能。我们可以抽象出这两个组件的核心功能到一个 mixin 中，例如：</p><pre><code>const MenuMixin = {  data () {    return {      language: 'EN'    }  },  methods: {    changeLanguage () {      if (this.language === 'DE') this.$set(this, 'language', 'EN')      if (this.language === 'EN') this.$set(this, 'language', 'DE')    }  }}export default MenuMixin</code></pre><p>要使用 mixin，只需将其导入到两个组件中（我只展示移动组件）。</p><pre><code>&lt;template&gt;  &lt;ul class="mobile"&gt;    &lt;li @click="changeLanguage"&gt;Change language&lt;/li&gt;  &lt;/ul&gt;&lt;/template&gt;&lt;script&gt;  import MenuMixin from './MenuMixin'  export default {    mixins: [MenuMixin]  }&lt;/script&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端规范 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端规范 </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端命名规范</title>
      <link href="2019/08/13/qian-duan-ming-ming-gui-fan/"/>
      <url>2019/08/13/qian-duan-ming-ming-gui-fan/</url>
      
        <content type="html"><![CDATA[<h1 id="驼峰式命名法介绍"><a href="#驼峰式命名法介绍" class="headerlink" title="驼峰式命名法介绍"></a>驼峰式命名法介绍</h1><ul><li>Pascal Case 大驼峰式命名法：首字母大写。eg：StudentInfo、UserInfo、ProductInfo</li><li>Camel Case 小驼峰式命名法：首字母小写。eg：studentInfo、userInfo、productInfo</li></ul><h1 id="文件资源命名"><a href="#文件资源命名" class="headerlink" title="文件资源命名"></a>文件资源命名</h1><ul><li>文件名不得含有空格</li><li>文件名建议只使用小写字母，不使用大写字母。( 为了醒目，某些说明文件的文件名，可以使用大写字母，比如README、LICENSE。 )</li><li>文件名包含多个单词时，单词之间建议使用半角的连词线 ( - ) 分隔。</li><li>引入资源使用相对路径，不要指定资源所带的具体协议 ( http:,https: ) ，除非这两者协议都不可用。</li></ul><h1 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h1><ul><li>命名方式 : 小驼峰式命名方法</li><li>命名规范 : 类型+对象描述的方式，如果没有明确的类型，就可以使前缀为名词</li></ul><table><thead><tr><th>类型</th><th>小写字母</th></tr></thead><tbody><tr><td>array</td><td>a</td></tr><tr><td>boolean</td><td>b</td></tr><tr><td>function</td><td>fn</td></tr><tr><td>int</td><td>i</td></tr><tr><td>object</td><td>o</td></tr><tr><td>string</td><td>s</td></tr></tbody></table><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><ul><li>命名方式 : 小驼峰方式 ( 构造函数使用大驼峰命名法 )</li><li>命名规则 : 前缀为动词</li></ul><table><thead><tr><th>动词</th><th>含义</th><th>返回值</th></tr></thead><tbody><tr><td>can</td><td>判断是否可执行某个动作 ( 权限 )</td><td>函数返回一个布尔值。true：可执行；false：不可执行</td></tr><tr><td>has</td><td>判断是否含有某个值</td><td>函数返回一个布尔值。true：含有此值；false：不含有此值</td></tr><tr><td>is</td><td>判断是否为某个值</td><td>函数返回一个布尔值。true：为某个值；false：不为某个值</td></tr><tr><td>get</td><td>获取某个值</td><td>函数返回一个非布尔值</td></tr><tr><td>set</td><td>设置某个值</td><td>无返回值、返回是否设置成功或者返回链式对象</td></tr></tbody></table><h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><ul><li>命名方法 : 全部大写</li><li>命名规范 : 使用大写字母和下划线来组合命名，下划线用以分割单词。<br>推荐：</li></ul><pre><code> var MAX_COUNT = 10; var URL = 'http://www.baidu.com';</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端规范 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css编写规范</title>
      <link href="2019/08/13/css-bian-xie-gui-fan/"/>
      <url>2019/08/13/css-bian-xie-gui-fan/</url>
      
        <content type="html"><![CDATA[<h1 id="id和class的命名"><a href="#id和class的命名" class="headerlink" title="id和class的命名"></a>id和class的命名</h1><p>ID和class的名称总是使用可以反应元素目的和用途的名称，或其他通用的名称，代替表象和晦涩难懂的名称</p><p>不推荐 :</p><pre><code>.fw-800 {  font-weight: 800;}.red {  color: red;}</code></pre><p>推荐 :</p><pre><code>.heavy {  font-weight: 800;}.important {  color: red;}</code></pre><h1 id="合理的使用ID"><a href="#合理的使用ID" class="headerlink" title="合理的使用ID"></a>合理的使用ID</h1><p>一般情况下ID不应该被用于样式，并且ID的权重很高，所以不使用ID解决样式的问题，而是使用class</p><p>不推荐：</p><pre><code>#content .title {  font-size: 2em;}</code></pre><p>推荐：</p><pre><code>.content .title {  font-size: 2em;}</code></pre><h1 id="css选择器中避免使用标签名"><a href="#css选择器中避免使用标签名" class="headerlink" title="css选择器中避免使用标签名"></a>css选择器中避免使用标签名</h1><p>从结构、表现、行为分离的原则来看，应该尽量避免css中出现HTML标签，并且在css选择器中出现标签名会存在潜在的问题。</p><h1 id="使用子选择器"><a href="#使用子选择器" class="headerlink" title="使用子选择器"></a>使用子选择器</h1><p>很多前端开发人员写选择器链的时候不使用 直接子选择器（注：直接子选择器和后代选择器的区别）。<br>有时，这可能会导致疼痛的设计问题并且有时候可能会很耗性能。然而，在任何情况下，这是一个非常不好的做法。<br>如果你不写很通用的，需要匹配到DOM末端的选择器， 你应该总是考虑直接子选择器。不推荐:</p><pre><code>.content .title {  font-size: 2rem;}</code></pre><p>推荐</p><pre><code>.content &gt; .title {  font-size: 2rem;}</code></pre><h1 id="尽量使用缩写属性"><a href="#尽量使用缩写属性" class="headerlink" title="尽量使用缩写属性"></a>尽量使用缩写属性</h1><p>尽量使用缩写属性对于代码效率和可读性是很有用的，比如font属性。不推荐：</p><pre><code>border-top-style: none;font-family: palatino, georgia, serif;font-size: 100%;line-height: 1.6;padding-bottom: 2em;padding-left: 1em;padding-right: 1em;padding-top: 0;</code></pre><p>推荐：</p><pre><code>border-top: 0;font: 100%/1.6 palatino, georgia, serif;padding: 0 1em 2em;</code></pre><h1 id="0后面不带单位"><a href="#0后面不带单位" class="headerlink" title="0后面不带单位"></a>0后面不带单位</h1><p>省略0后面的单位，</p><p>不推荐：</p><pre><code>padding-bottom: 0px;margin: 0em;</code></pre><p>推荐：</p><pre><code>padding-bottom: 0;margin: 0;</code></pre><h1 id="属性格式"><a href="#属性格式" class="headerlink" title="属性格式"></a>属性格式</h1><ul><li>为了保证一致性和可扩展性，每个声明应该用分号结束，每个声明换行。</li><li>属性名的冒号后使用一个空格。出于一致性的原因，属性和值（但属性和冒号之间没有空格）的之间始终使用一个空格。</li><li>每个选择器和属性声明总是使用新的一行。</li><li>属性选择器或属性值用双引号（””），而不是单引号（”）括起来。</li><li>URL值（url()）不要使用引号。</li></ul><p>作为最佳实践，我们应该遵循以下顺序（应该按照下表的顺序）：<br>结构性属性：</p><ul><li>display</li><li>position, left, top, right etc.</li><li>overflow, float, clear etc.</li><li>margin, padding</li></ul><p>表现性属性：</p><ul><li>background, border etc.</li><li>font, text</li></ul><p>不推荐：</p><pre><code> .box {  font-family: 'Arial', sans-serif;  border: 3px solid #ddd;  left: 30%;  position: absolute;  text-transform: uppercase;  background-color: #eee;  right: 30%;  isplay: block;  font-size: 1.5rem;  overflow: hidden;  padding: 1em;  margin: 1em;}</code></pre><p>推荐：</p><pre><code>.box {  display: block;  position: absolute;  left: 30%;  right: 30%;  overflow: hidden;  margin: 1em;  padding: 1em;  background-color: #eee;  border: 3px solid #ddd;  font-family: 'Arial', sans-serif;  font-size: 1.5rem;  text-transform: uppercase;}</code></pre><h1 id="ID-和-Class（类）-名的分隔符"><a href="#ID-和-Class（类）-名的分隔符" class="headerlink" title="ID 和 Class（类） 名的分隔符"></a>ID 和 Class（类） 名的分隔符</h1><p>使用连字符（中划线）分隔ID和Class（类）名中的单词。为了增强课理解性，在选择器中不要使用除了连字符（中划线）以为的任何字符（包括没有）来连接单词和缩写。</p><p>另外，作为该标准，预设属性选择器能识别连字符（中划线）作为单词[attribute|=value]的分隔符，<br>所以最好的坚持使用连字符作为分隔符。</p><p>不推荐</p><pre><code>.demoimage {}.error_status {}</code></pre><p>推荐</p><pre><code>#video-id {}.ads-sample {}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端规范 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
            <tag> 前端规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端请求方式：xhr、ajax、axios与fetch的区别比较</title>
      <link href="2017/06/13/qian-duan-qing-qiu-fang-shi-xhr-ajax-axios-yu-fetch-de-qu-bie-bi-jiao/"/>
      <url>2017/06/13/qian-duan-qing-qiu-fang-shi-xhr-ajax-axios-yu-fetch-de-qu-bie-bi-jiao/</url>
      
        <content type="html"><![CDATA[<p>这些都是异步请求数据的方法。在不重新刷新页面的情况下与服务器通信，交换数据，或更新页面。</p><h1 id="XMLHttpRequest对象"><a href="#XMLHttpRequest对象" class="headerlink" title="XMLHttpRequest对象"></a>XMLHttpRequest对象</h1><p>优点：</p><ul><li>不重新加载页面的情况下更新网页</li><li>在页面已加载后从服务器请求/接收数据</li><li>在后台向服务器发送数据</li></ul><p>缺点：</p><ul><li>使用起来也比较繁琐，需要设置很多值。</li><li>早期的IE浏览器有自己的实现，这样需要写兼容代码。</li></ul><p>示例：</p><pre><code>if (window.XMLHttpRequest) { // model browser  xhr = new XMLHttpRequest()} else if (window.ActiveXObject) { // IE 6 and older  xhr = new ActiveXObject('Microsoft.XMLHTTP')}xhr.open('POST', url, true)xhr.send(data)xhr.onreadystatechange = function () {if (request.readyState === 4) { // 成功完成        // 判断响应状态码        if (request.status === 200) {            // 成功，通过responseText拿到响应的文本:            return success(request.responseText);        } else {            // 失败，根据响应码判断失败原因:            return fail(request.status);        }    } else {        // HTTP请求还在继续...    }}</code></pre><h1 id="jQuery-ajax"><a href="#jQuery-ajax" class="headerlink" title="jQuery ajax"></a>jQuery ajax</h1><p>AJAX请求也兼容了各浏览器，对XMLHttpRequest对象的封装。</p><p>优点：</p><ul><li>对原生XHR的封装，做了兼容处理，简化了使用。</li><li>增加了对JSONP的支持，可以简单处理部分跨域。</li></ul><p>缺点：</p><ul><li>如果有多个请求，并且有依赖关系的话，容易形成回调地狱。</li><li>本身是针对MVC的编程，不符合现在前端MVVM的浪潮。</li><li>ajax是jQuery中的一个方法。如果只是要使用ajax却要引入整个jQuery非常的不合理。</li></ul><p>示例：</p><pre><code>$.ajax({  type: 'POST',  url: url,   data: data,  dataType: dataType,  success: function () {},  error: function () {}})</code></pre><h1 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h1><p>Axios是一个基于promise的HTTP库，可以用在浏览器和 node.js 中。它本质也是对原生XMLHttpRequest的封装，只不过它是Promise的实现版本，符合最新的ES规范。</p><p>优点：</p><ul><li>从浏览器中创建XMLHttpRequests</li><li>从 node.js 创建 http 请求</li><li>支持 Promise API</li><li>拦截请求和响应</li><li>转换请求数据和响应数据</li><li>取消请求</li><li>自动转换 JSON 数据</li><li>客户端支持防御 XSRF</li></ul><p>缺点：</p><ul><li>只持现代代浏览器。</li></ul><pre><code>axios({    method: 'post',    url: '/user/12345',    data: {      firstName: 'liu',      lastName: 'weiqin'    }  })  .then(res =&gt; console.log(res))  .catch(err =&gt; console.log(err))</code></pre><h1 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h1><p>优点：</p><ul><li>语法简洁，更加语义化</li><li>基于标准 Promise 实现，支持 async/await</li></ul><p>缺点：</p><ul><li>Fetch 请求默认是不带 cookie 的，需要设置 fetch(url, {credentials: ‘include’})</li><li>服务器返回 400，500 错误码时并不会 reject，只有网络错误这些导致请求不能完成时，fetch 才会被 reject。</li></ul><p>示例：</p><pre><code>fetch('http://example.com/movies.json')  .then(function(response) {    return response.json();  })  .then(function(myJson) {    console.log(myJson);  });</code></pre><p>ts对fetch简单封装下：</p><pre><code>import _ from 'lodash';import 'whatwg-fetch';interface ReqInit extends RequestInit {  headers?: Record&lt;string, string&gt;;  /** eg. ?a=1 */  params?: { [key: string]: any };  /** eg. /:id/.. */  router?: { [key: string]: any };  /** 超时时间，默认3000 */  timeout?: number;}async function request&lt;T = any&gt;(path: string, init: ReqInit = {}): Promise&lt;T&gt; {  const mergeInit = {    ...request.default,    ...init,    headers: { ...request.default.headers, ...init.headers },  };  const { params, router, body, timeout, headers } = mergeInit;  let url = path;  if (router) {    url = path.replace(/:([A-Za-z]+)/g, (substring, p1: string) =&gt; router[p1]);  }  if (params) {    url += _(      _.reduce(params, (prev, val, key) =&gt; `${prev}${key}=${val}&amp;`, '?'),    ).trimEnd('&amp;');  }  if (!Reflect.get(headers, 'Content-Type')) {    if (typeof body === 'string') {      Reflect.set(headers, 'Content-Type', 'application/json');    }  }  try {    const response: Response = await Promise.race([      fetch(url, mergeInit),      new Promise&lt;any&gt;((resolve, reject) =&gt; {        setTimeout(          () =&gt; reject({ status: 408, statusText: 'TIME_OUT_ERR', url }),          timeout,        );      }),    ]);    if (response.ok) {      if (request.interceptors.response) {        return await request.interceptors.response(response);      }      return await response.json();    }    throw response;  } catch (error) {    if (request.interceptors.catch) {      request.interceptors.catch(error);    }    throw error;  }}request.default = {  method: 'GET',  headers: {    Accept: '*/*',  },  mode: 'cors',  timeout: 3000,  // credentials: 'include' // send cookies} as ReqInit;request.interceptors = {  response: null,  catch: null,} as {  response: ((response: Response) =&gt; Promise&lt;any&gt;) | null;  catch: ((error: Partial&lt;Response&gt;) =&gt; void) | null;};export default request;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据请求 </tag>
            
            <tag> 前端基础 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
