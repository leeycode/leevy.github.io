<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>金字塔原理读后感</title>
      <link href="2022/08/02/du-shu-jin-zi-ta-yuan-li-du-hou-gan/"/>
      <url>2022/08/02/du-shu-jin-zi-ta-yuan-li-du-hou-gan/</url>
      
        <content type="html"><![CDATA[<blockquote><p>我们平时表达、思考、解决问题的时候，可能会无意识地用到金字塔原理。但有时候又会忘记使用金字塔原理去思考，主要原因是没有把思考流程标准化。金字塔原理这本书，就将表达、思考、解决问题的逻辑标准化了。仔细研读，收获颇丰。</p></blockquote><h2 id="金字塔原理内容概括"><a href="#金字塔原理内容概括" class="headerlink" title="金字塔原理内容概括"></a>金字塔原理内容概括</h2><p><a href="https://imgtu.com/i/vEkAaR"><img src="https://s1.ax1x.com/2022/08/02/vEkAaR.png" alt="vEkAaR.png"></a></p><hr><h2 id="表达的逻辑"><a href="#表达的逻辑" class="headerlink" title="表达的逻辑"></a>表达的逻辑</h2><p><strong>为什么要用金字塔结构</strong></p><p>表达的目的是让读者理解内容，而使用金字塔原理表达思想，可以提高读者的理解效率。人类大脑在理解内容的时候，会习惯性地将有共性的任何事物组织在一起。将读到的思想进行归类分组和总结概括，以便记住。金字塔原理组织的内容，正好符合读者理解和记忆思想的习惯。</p><p><strong>金字塔内部结构</strong><br>纵向关系：自上而下，结论先行。上一层的思想必须是下一层思想的概括总结或者是下一层思想的结论。读者先看到结论，再去阅读细节，符合读者阅读习惯。</p><p>横向关系：横向各思想之间有两种关系，即演绎关系和归纳关系。演绎关系是从因到果，推理层层递进，推理的结论就是上一层级思想；归纳关系是子思想之间有共性，上一层级思想就是对子思想的概括总结，或者说可以用一个名词进行归纳。</p><p><strong>如何构建金字塔</strong><br><em>自上而下法：</em></p><p><a href="https://imgtu.com/i/vEkiqJ"><img src="https://s1.ax1x.com/2022/08/02/vEkiqJ.png" alt="vEkiqJ.png"></a></p><p>金字塔结构 </p><ol><li>提出主题思想 </li><li>设想受众的主要疑问<br>想清楚要解决谁的什么问题。 </li><li>写序言：背景-冲突-疑问-回答<br>背景是问题产生的前提条件，冲突是背景中发生了哪些能使读者产生疑问的“冲突”，疑问是我们要解决的问题，回答就是主题思想。 </li><li>与受众进行疑问、回答式对话<br>疑问、回答式对话，就是自上而下的金字塔结构。从上一层思想到下一层思想。 5.对受众的新疑问，重复进行疑问/回答式对话思想慢慢开展，层级慢慢丰富。</li></ol><p><em>自下而上法：</em><br>如果没有确定要讨论的主题思想，可以向下移动一个层次，从关键句层次下手。</p><ol><li>列出你想表达的所有思想要点 </li><li>找出各要点之间的逻辑关系 </li><li>得出结论</li></ol><h2 id="思考的逻辑"><a href="#思考的逻辑" class="headerlink" title="思考的逻辑"></a>思考的逻辑</h2><p>构建金字塔的过程是：确定主题、回答主要疑问&gt;&gt;想好序言&gt;&gt;提出中心思想和关键句要点&gt;&gt;在关键句要点下展开讨论。思考的逻辑，主要解决的问题就是理清关键句下的论述逻辑。</p><h3 id="应用逻辑顺序"><a href="#应用逻辑顺序" class="headerlink" title="应用逻辑顺序"></a>应用逻辑顺序</h3><p>金字塔原理第二条规则规定，所有列入同一组中的思想必须具有某种逻辑顺序。<br><strong>时间顺序：</strong>在按照时间顺序组织的思想组中，需要按照采取行动的顺序依次表述达到某一结果必须要采取的行动。当步骤较多时，还需要将步骤分组，一般超过 7 个就要进行分组。</p><p><strong>结构顺序：</strong>结构顺序就是当你使用示意图、地图、图画或照片想象某事务时的顺序，如组织结构图、关键成功要素示意图等。<br>结构顺序中，分组后的各部分需要符合 MECE 原则：1.各部分之间相互独立，相互排斥，没有重叠；2.所有部分完全穷尽，没有遗漏。<br><strong>程度顺序</strong>：也称重要性顺序。是对一组因为具有某种共同特点而被聚集在一起的事务时所采用的顺序。在每组中，根据各个问题具有该特性的程度高低排序。最具有该特性的问题排在第一位，按照先重要后次要的顺序排列。</p><h3 id="概括各组思想"><a href="#概括各组思想" class="headerlink" title="概括各组思想"></a>概括各组思想</h3><p>位于金字塔结构每一个层次上的思想，都必须是对其下面一个层次思想的提炼、概括。<br>如果是自下而上构建金字塔，那就需要思考概括各分组的思想。<br>概括行动性思想（介绍采取的行动、行为、步骤、流程），应该要说明采取行动后取得的结果（效果、目标）<br>概括描述性思想（介绍背景、信息等）时，应该说明这些思想具有“共同的含义” </p><h2 id="解决问题的逻辑"><a href="#解决问题的逻辑" class="headerlink" title="解决问题的逻辑"></a>解决问题的逻辑</h2><p>解决问题的流程，主要分为以下四个步骤：</p><p><a href="https://imgtu.com/i/vEkkZ9"><img src="https://s1.ax1x.com/2022/08/02/vEkkZ9.png" alt="vEkkZ9.png"></a></p><blockquote><p>解决问题流程</p></blockquote><h3 id="界定问题"><a href="#界定问题" class="headerlink" title="界定问题"></a>界定问题</h3><p>界定问题是解决问题的第一步，界定问题可以采用连续分析法。 </p><ol><li>是否有/是否可能有问题（或机会）？<br>判断是否有问题，需要对比期望结果和非期望结果。一般来说，如果期望结果低于非期望结果，则说明存在问题。</li><li>问题在哪里？<br>寻找问题的位置，需要从背景入手。 </li><li>为什么存在？<br>寻找问题的原因，寻找流程上或者结构中潜在的问题。 </li><li>我们能做什么？<br>其实就是根据问题，罗列可能的解决方案。 </li><li>我们应该做什么？<br>根据所有罗列的解决方案，选择一个最适合的方案去执行。</li></ol><h3 id="结构化分析问题"><a href="#结构化分析问题" class="headerlink" title="结构化分析问题"></a>结构化分析问题</h3><p>结构化分析问题，分为以下四个步骤</p><p><a href="https://imgtu.com/i/vEkPr4"><img src="https://s1.ax1x.com/2022/08/02/vEkPr4.png" alt="vEkPr4.png"></a></p><p>分析问题流程</p><p>分析问题的主要目的，是为了找出各种可能的原因。<br>收集信息，需要在锁定的问题所涉及的背景范围内，进行收集。<br>描述发现，其实是尽可能找出产生问题的原因。找出原因有三种方法：呈现有形结构、寻找因果关系、归类分组。<br><strong>呈现有形结构：</strong>需要画一幅系统的现况或理想状况的图，帮助决定是否要回答这些问题，并找到和分析产生问题的原因。<br><strong>寻找因果关系</strong>：寻找具有因果关系的要素、行为或任务，得出结果。<br><strong>归类分组：</strong>将所有可能的原因按相似性分类，前提是这种预先的分类有助于综合分析各种事实。<br>归类分组中的要素，需要遵循相互独立，完全穷尽的原则。</p><h2 id="总结与感悟"><a href="#总结与感悟" class="headerlink" title="总结与感悟"></a>总结与感悟</h2><p>以上就是本书的主要内容，总结一下。</p><ol><li><p>什么是金字塔原理呢？<br> 金字塔原理就是把任何一件事情都能归纳出一个中心论点。在每个论点下面又有不超过 7 个的论据来支持。每一个论据又可以成为下一级的论点。</p></li><li><p>组织思想的方法<br> 可以按照时间、空间、重要性以及逻辑演绎的顺序来组织我们的思想。</p></li><li><p>我们怎么样让别人对自己的观点感兴趣呢？<br> 就是用 SCQ 背景、冲突、疑问的方法讲故事，吸引大家对自己的方法感兴趣。</p></li></ol><p>使用金字塔原理来表达，有一个明显的优势，就是别人理解起来更容易。因为大脑的工作方式就是自动将零散的信息按照逻辑归纳在一起。例如古人在仰望星空的时候记住的不是散乱的星星，而是星星组成的各种图案。去超市采购，打算买苹果、酸奶、地瓜、橘子、牛奶、土豆、葡萄、胡萝卜等等，这一大堆，到超市的时候可能一个也记不住，但如果我们换个说法，计划一共买三类东西，水果、蔬菜和奶。水果买三种，苹果、橘子和葡萄，蔬菜三种，土豆、胡萝卜和地瓜，奶买两种，牛奶和酸奶，这样会更容易记住。</p><h3 id="那金字塔原理具体怎么用呢？"><a href="#那金字塔原理具体怎么用呢？" class="headerlink" title="那金字塔原理具体怎么用呢？"></a>那金字塔原理具体怎么用呢？</h3><ol><li>自下而上的思考<br>相当于建造金字塔的过程。思考问题，分三步，<br> 第一步是列出所有的相关信息，就是想到什么都先写下来，<br> 第二步，是从纷繁复杂的信息里找到共性和差异，然后合并同类项，简化成几个有逻辑相关的要点，<br> 第三个，是以点带面得出结论。</li></ol><p>举例子，比如说有一家书店，怎么赚更多的钱？一瞬间就有很多个想法，比如说卖咖啡，卖工艺品，多营业几个小时，少雇几个人，位置偏僻一点儿，位置更好一点，装修特色一点，装修简单一点，场地对外出租。提供礼品包装服务，办签售活动，办读书俱乐部等等，这些散乱的信息毫无逻辑，甚至有一些还自相矛盾。如果把这些零散的点结构化的组织起来，效果就完全不一样。怎么结构化？这些动作可以划分成三大类，增量、开源和节流。增量就是比如说包括多营业几个小时，位置更好一点，装修特色一点，办签售活动，这几个都属于帮助增加书的销量。第二个是开源，比如说卖咖啡，卖工艺品，场地对外出租，办读书俱乐部，提供礼品包装服务，这几个都属于增加营收的类目。最后一个节流，比如说少雇几个人，位置偏僻一点，装修简单一点，这几个都属于降低成本支出。</p><p>自下而上的搭建结构，有一个操作标准，叫做 MECE 法则，翻译成中文就是在分类的时候做到既不重叠又不遗漏。比如有机器猫、黑猫警长、变形金刚、一休哥这四个卡通形象，如果分成猫和机器人这两类，那机器猫就被重复出现了，一休哥就被漏掉了。所以更好的分类方法是人类和非人类，或者是来自东方和来自西方。</p><ol start="2"><li>自上而下的表达<br>就是跟别人描述金字塔的过程，假设工作需要你尽快安排个会议，通知王总、老张和小刘开会，半小时以后你回复说，小刘说系统出了问题，四点钟之前都不能参加，老张说他时间都 OK，最好别在十一点半之前。对了，今天的会议室都被定了，没有空的会议室了。另外呢，王总的秘书说了，王总今天晚上才能从外地回来，所以会议安排在明天可以吗？听完这一堆，同事可能无法准确理解信息。</li></ol><p>按照结论先行的方法，得先把会议得安排在明天这个结论放在第一句说，然后把原因归类分组一下，比如说有些是关于人的原因，有些是关于会议室的原因，人的原因，可以概括成王总、老张和小刘，今天都各有各的情况，但他们明天的时间都 OK。再者还要注意逻辑的递进，这几个原因要有先后顺序，比如王总，老张和小刘是不是可以按照职务的顺序来说，当你的表达有了明确的逻辑之后，听的人会更容易理解和记忆。按照结论先行归类分组，逻辑递进的原则，你可以这么回复同事，会议改到明天可以吗？因为明天王总、老张和小刘都有时间参加会议，而且会议是空着，可以预定。这样表达简洁清楚了许多。</p><p>金字塔原理有两个执行方法。第一个叫做自下而上的思考，就是从最底层思考所有的可行性，一层一层的归纳提炼。第二个，叫做自上而下的表达，简单说三个词。结论先行，归类分组，逻辑递进。</p><p>希望自己能在工作生活中熟练的使用金字塔原理，提高效率，节约时间。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浮点数运算的精度问题</title>
      <link href="2022/01/10/fu-dian-shu-yun-suan-de-jing-du-wen-ti/"/>
      <url>2022/01/10/fu-dian-shu-yun-suan-de-jing-du-wen-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在项目中涉及到商品价格的计算，经常会出现计算精度问题，引发意想不到的BUG。这是因为在 JavaScript 中整数和浮点数都属于 Number 数据类型，所有数字都是以 64 位浮点数形式储存，即便整数也是如此。 所以我们在打印 1.00 这样的浮点数的结果是 1 而非 1.00 。</p><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><h2 id="浮点运算的问题"><a href="#浮点运算的问题" class="headerlink" title="浮点运算的问题"></a>浮点运算的问题</h2><p>在一些特殊的数值表示中，例如金额，这样看上去有点变扭，但是至少值是正确了。然而要命的是，当浮点数做数学运算的时候，你经常会发现一些问题，举几个例子：</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 加法 =====================</span><span class="token comment" spellcheck="true">// 0.1 + 0.2 = 0.30000000000000004</span><span class="token comment" spellcheck="true">// 0.7 + 0.1 = 0.7999999999999999</span><span class="token comment" spellcheck="true">// 0.2 + 0.4 = 0.6000000000000001</span><span class="token comment" spellcheck="true">// 2.22 + 0.1 = 2.3200000000000003</span><span class="token comment" spellcheck="true">// 减法 =====================</span><span class="token comment" spellcheck="true">// 1.5 - 1.2 = 0.30000000000000004</span><span class="token comment" spellcheck="true">// 0.3 - 0.2 = 0.09999999999999998</span><span class="token comment" spellcheck="true">// 乘法 =====================</span><span class="token comment" spellcheck="true">// 19.9 * 100 = 1989.9999999999998</span><span class="token comment" spellcheck="true">// 19.9 * 10 * 10 = 1990</span><span class="token comment" spellcheck="true">// 1306377.64 * 100 = 130637763.99999999</span><span class="token comment" spellcheck="true">// 1306377.64 * 10 * 10 = 130637763.99999999</span><span class="token comment" spellcheck="true">// 0.7 * 180 = 125.99999999999999</span><span class="token comment" spellcheck="true">// 9.7 * 100 = 969.9999999999999</span><span class="token comment" spellcheck="true">// 39.7 * 100 = 3970.0000000000005</span><span class="token comment" spellcheck="true">// 除法 =====================</span><span class="token comment" spellcheck="true">// 0.3 / 0.1 = 2.9999999999999996</span><span class="token comment" spellcheck="true">// 0.69 / 10 = 0.06899999999999999</span></code></pre><h2 id="整数的精度问题"><a href="#整数的精度问题" class="headerlink" title="整数的精度问题"></a>整数的精度问题</h2><p>在 Javascript 中，整数精度同样存在问题，先来看看问题：</p><p>JavaScript 代码:</p><pre class=" language-js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">19571992547450991</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//=> 19571992547450990</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">19571992547450991</span><span class="token operator">===</span><span class="token number">19571992547450992</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//=> true</span></code></pre><p>同样的原因，在 JavaScript 中 Number类型统一按浮点数处理，整数是按最大54位来算最大(253 - 1，Number.MAX_SAFE_INTEGER,9007199254740991) 和最小(-(253 - 1)，Number.MIN_SAFE_INTEGER,-9007199254740991) 安全整数范围的。所以只要超过这个范围，就会存在被舍去的精度问题。</p><p>当然这个问题并不只是在 Javascript 中才会出现，几乎所有的编程语言都采用了 IEEE-745 浮点数表示法，任何使用二进制浮点数的编程语言都会有这个问题，只不过在很多其他语言中已经封装好了方法来避免精度的问题，而 JavaScript 是一门弱类型的语言，从设计思想上就没有对浮点数有个严格的数据类型，所以精度误差的问题就显得格外突出。</p><h2 id="toFixed的问题"><a href="#toFixed的问题" class="headerlink" title="toFixed的问题"></a>toFixed的问题</h2><pre class=" language-js"><code class="language-js"><span class="token number">1.35</span><span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 1.4 正确</span><span class="token number">1.335</span><span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 1.33  错误</span><span class="token number">1.3335</span><span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 1.333 错误</span><span class="token number">1.33335</span><span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 1.3334 正确</span><span class="token number">1.333335</span><span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 1.33333 错误</span><span class="token number">1.3333335</span><span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 1.333333 错误</span></code></pre><h1 id="问题的原因"><a href="#问题的原因" class="headerlink" title="问题的原因"></a>问题的原因</h1><h2 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h2><p>JavaScript 里的数字是采用 IEEE 754 标准的 64 位双精度浮点数。该规范定义了浮点数的格式，对于64位的浮点数在内存中的表示，最高的1位是符号位，接着的11位是指数，剩下的52位为有效数字，具体：</p><ul><li>第0位：符号位， s 表示 ，0表示正数，1表示负数；</li><li>第1位到第11位：储存指数部分， e 表示 ；</li><li>第12位到第63位：储存小数部分（即有效数字），f 表示，</li></ul><p>如图：<br><img src="https://bu.dusays.com/2022/01/10/4108f12333606.jpg"></p><p>符号位决定了一个数的正负，指数部分决定了数值的大小，小数部分决定了数值的精度。 IEEE 754规定，有效数字第一位默认总是1，不保存在64位浮点数之中。也就是说，有效数字总是1.xx…xx的形式，其中xx..xx的部分保存在64位浮点数之中，最长可能为52位。因此，JavaScript提供的有效数字最长为53个二进制位（64位浮点的后52位+有效数字第一位的1）。</p><h2 id="计算过程"><a href="#计算过程" class="headerlink" title="计算过程"></a>计算过程</h2><p>比如在 JavaScript 中计算 0.1 + 0.2时，到底发生了什么呢？</p><p>首先，十进制的0.1和0.2都会被转换成二进制，但由于浮点数用二进制表达时是无穷的，例如。</p><p>JavaScript 代码:</p><pre class=" language-js"><code class="language-js"><span class="token number">0.1</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token number">0.0001</span> <span class="token number">1001</span> <span class="token number">1001</span> <span class="token number">1001</span><span class="token operator">...</span><span class="token punctuation">(</span><span class="token number">1100</span>循环<span class="token punctuation">)</span><span class="token number">0.2</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token number">0.0011</span> <span class="token number">0011</span> <span class="token number">0011</span> <span class="token number">0011</span><span class="token operator">...</span><span class="token punctuation">(</span><span class="token number">0011</span>循环<span class="token punctuation">)</span></code></pre><p> IEEE 754 标准的 64 位双精度浮点数的小数部分最多支持53位二进制位，所以两者相加之后得到二进制为：</p><pre class=" language-js"><code class="language-js"><span class="token number">0.0100110011001100110011001100110011001100110011001100</span> </code></pre><p>因浮点数小数位的限制而截断的二进制数字，再转换为十进制，就成了0.30000000000000004。所以在进行算术计算时会产生误差。</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="类库"><a href="#类库" class="headerlink" title="类库"></a>类库</h2><p>通常这种对精度要求高的计算都应该交给后端去计算和存储，因为后端有成熟的库来解决这种计算问题。前端也有几个不错的类库：</p><h3 id="Math-js"><a href="#Math-js" class="headerlink" title="Math.js"></a>Math.js</h3><p>Math.js 是专门为 JavaScript 和 Node.js 提供的一个广泛的数学库。它具有灵活的表达式解析器，支持符号计算，配有大量内置函数和常量，并提供集成解决方案来处理不同的数据类型<br>像数字，大数字(超出安全数的数字)，复数，分数，单位和矩阵。 功能强大，易于使用。</p><p>官网：<a href="http://mathjs.org/">http://mathjs.org/</a></p><p>GitHub：<a href="https://github.com/josdejong/mathjs">https://github.com/josdejong/mathjs</a></p><h3 id="decimal-js"><a href="#decimal-js" class="headerlink" title="decimal.js"></a>decimal.js</h3><p>为 JavaScript 提供十进制类型的任意精度数值。</p><p>官网：<a href="http://mikemcl.github.io/decimal.js/">http://mikemcl.github.io/decimal.js/</a></p><p>GitHub：<a href="https://github.com/MikeMcl/decimal.js">https://github.com/MikeMcl/decimal.js</a></p><h3 id="big-js"><a href="#big-js" class="headerlink" title="big.js"></a>big.js</h3><p>官网：<a href="http://mikemcl.github.io/big.js">http://mikemcl.github.io/big.js</a></p><p>GitHub：<a href="https://github.com/MikeMcl/big.js/">https://github.com/MikeMcl/big.js/</a></p><p>这几个类库帮我们解决很多这类问题，不过通常我们前端做这类运算通常只用于表现层，应用并不是很多。所以很多时候，一个函数能解决的问题不需要引用一个类库来解决。</p><h2 id="整数表示"><a href="#整数表示" class="headerlink" title="整数表示"></a>整数表示</h2><p>对于整数，我们可以通过用<strong>String</strong>类型的表示来取值或传值，否则会丧失精度。</p><h2 id="格式化数字、金额、保留几位小数等"><a href="#格式化数字、金额、保留几位小数等" class="headerlink" title="格式化数字、金额、保留几位小数等"></a>格式化数字、金额、保留几位小数等</h2><h3 id="Numeral-js"><a href="#Numeral-js" class="headerlink" title="Numeral.js"></a>Numeral.js</h3><p>一个用于格式化和操作数字的JavaScript库。数字可以被格式化为货币，百分比，时间，几个小数位数，千分位等等。 您也可以随时创建自定义格式。</p><p>官网及文档：<a href="http://numeraljs.com/">http://numeraljs.com/</a></p><p>GitHub：<a href="https://github.com/adamwdraper/Numeral-js">https://github.com/adamwdraper/Numeral-js</a></p><h3 id="accounting-js"><a href="#accounting-js" class="headerlink" title="accounting.js"></a>accounting.js</h3><p>一个轻量级的JavaScript库，用于格式化数字，金额和货币等。</p><p>官网及文档：<a href="http://openexchangerates.github.io/accounting.js/">http://openexchangerates.github.io/accounting.js/</a></p><p>GitHub：<a href="https://github.com/openexchangerates/accounting.js">https://github.com/openexchangerates/accounting.js</a></p><h2 id="解决toFixed"><a href="#解决toFixed" class="headerlink" title="解决toFixed"></a>解决toFixed</h2><p>针对toFixed的兼容性问题，我们可以把toFix重写一下来解决，代码如下：</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// toFixed兼容方法</span>Number<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toFixed <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>len<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>len<span class="token operator">></span><span class="token number">20</span> <span class="token operator">||</span> len<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RangeError</span><span class="token punctuation">(</span><span class="token string">'toFixed() digits argument must be between 0 and 20'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// .123转为0.123</span>    <span class="token keyword">var</span> number <span class="token operator">=</span> <span class="token function">Number</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isNaN</span><span class="token punctuation">(</span>number<span class="token punctuation">)</span> <span class="token operator">||</span> number <span class="token operator">>=</span> Math<span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">21</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> number<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token punctuation">(</span>len<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'undefined'</span> <span class="token operator">||</span> len <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">round</span><span class="token punctuation">(</span>number<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">var</span> result <span class="token operator">=</span> number<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        numberArr <span class="token operator">=</span> result<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>numberArr<span class="token punctuation">.</span>length<span class="token operator">&lt;</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//整数的情况</span>        <span class="token keyword">return</span> <span class="token function">padNum</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">var</span> intNum <span class="token operator">=</span> numberArr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//整数部分</span>        deciNum <span class="token operator">=</span> numberArr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//小数部分</span>        lastNum <span class="token operator">=</span> deciNum<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>len<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//最后一个数字</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>deciNum<span class="token punctuation">.</span>length <span class="token operator">==</span> len<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//需要截取的长度等于当前长度</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>deciNum<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> len<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//需要截取的长度大于当前长度 1.3.toFixed(2)</span>        <span class="token keyword">return</span> <span class="token function">padNum</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//需要截取的长度小于当前长度，需要判断最后一位数字</span>    result <span class="token operator">=</span> intNum <span class="token operator">+</span> <span class="token string">'.'</span> <span class="token operator">+</span> deciNum<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">parseInt</span><span class="token punctuation">(</span>lastNum<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token operator">>=</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//最后一位数字大于5，要进位</span>        <span class="token keyword">var</span> times <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//需要放大的倍数</span>        <span class="token keyword">var</span> changedInt <span class="token operator">=</span> <span class="token function">Number</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">,</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//截取后转为整数</span>        changedInt<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//整数进位</span>        changedInt <span class="token operator">/</span><span class="token operator">=</span> times<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//整数转为小数，注：有可能还是整数</span>        result <span class="token operator">=</span> <span class="token function">padNum</span><span class="token punctuation">(</span>changedInt<span class="token operator">+</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//对数字末尾加0</span>    <span class="token keyword">function</span> <span class="token function">padNum</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">var</span> dotPos <span class="token operator">=</span> num<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>dotPos <span class="token operator">===</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//整数的情况</span>            num <span class="token operator">+</span><span class="token operator">=</span> <span class="token string">'.'</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>len<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                num <span class="token operator">+</span><span class="token operator">=</span> <span class="token string">'0'</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> num<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//小数的情况</span>            <span class="token keyword">var</span> need <span class="token operator">=</span> len <span class="token operator">-</span> <span class="token punctuation">(</span>num<span class="token punctuation">.</span>length <span class="token operator">-</span> dotPos <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>need<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                num <span class="token operator">+</span><span class="token operator">=</span> <span class="token string">'0'</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> num<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>我们通过判断最后一位是否大于等于5来决定需不需要进位，如果需要进位先把小数乘以倍数变为整数，加1之后，再除以倍数变为小数，这样就不用一位一位的进行判断。</p>]]></content>
      
      
      <categories>
          
          <category> ES语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器相关知识汇总</title>
      <link href="2022/01/08/liu-lan-qi-xiang-guan-zhi-shi-hui-zong/"/>
      <url>2022/01/08/liu-lan-qi-xiang-guan-zhi-shi-hui-zong/</url>
      
        <content type="html"><![CDATA[<h1 id="浏览器如何渲染UI"><a href="#浏览器如何渲染UI" class="headerlink" title="浏览器如何渲染UI"></a>浏览器如何渲染UI</h1><ol><li>浏览器获取HTML文件，然后对文件进行解析，形成DOM Tree</li><li>与此同时，进行CSS解析，生成Style Rules</li><li>接着将DOM Tree与Style Rules合成为 Render Tree</li><li>接着进入布局（Layout）阶段，也就是为每个节点分配一个应出现在屏幕上的确切坐标</li><li>随后调用GPU进行绘制（Paint），遍历Render Tree的节点，并将元素呈现出来</li></ol><p><img src="https://bu.dusays.com/2022/02/08/3d60d09942ab5.png" alt="image.png"></p><h1 id="浏览器如何解析CSS"><a href="#浏览器如何解析CSS" class="headerlink" title="浏览器如何解析CSS"></a>浏览器如何解析CSS</h1><p>浏览器会『从右往左』解析CSS选择器。<br>DOM Tree与Style Rules合成为 Render Tree，实际上是需要将Style Rules附着到DOM Tree上，因此需要根据选择器提供的信息对DOM Tree进行遍历，才能将样式附着到对应的DOM元素上。</p><pre class=" language-js"><code class="language-js"><span class="token punctuation">.</span>mod<span class="token operator">-</span>nav h3 span <span class="token punctuation">{</span>font<span class="token operator">-</span>size<span class="token punctuation">:</span> 16px<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><img src="https://bu.dusays.com/2022/02/08/fb4af500748f0.png" alt="image _1_.png"></p><p>从右至左的匹配过程是：</p><ol><li>先找到所有的最右节点 span，对于每一个 span，向上寻找节点 h3</li><li>由 h3再向上寻找 class=mod-nav 的节点</li><li>最后找到根元素 html 则结束这个分支的遍历。</li></ol><h1 id="DOM-Tree是如何构建的"><a href="#DOM-Tree是如何构建的" class="headerlink" title="DOM Tree是如何构建的"></a>DOM Tree是如何构建的</h1><ol><li>转码: 浏览器将接收到的二进制数据按照指定编码格式转化为HTML字符串</li><li>生成Tokens: 之后开始parser，浏览器会将HTML字符串解析成Tokens</li><li>构建Nodes: 对Node添加特定的属性，通过指针确定 Node 的父、子、兄弟关系和所属 treeScope</li><li>生成DOM Tree: 通过node包含的指针确定的关系构建出DOM Tree</li></ol><p><img src="https://bu.dusays.com/2022/02/08/541d4de2022f2.png" alt="image _2_.png"></p><h1 id="浏览器重绘与重排的区别"><a href="#浏览器重绘与重排的区别" class="headerlink" title="浏览器重绘与重排的区别"></a>浏览器重绘与重排的区别</h1><ul><li>重排: 部分渲染树（或者整个渲染树）需要重新分析并且节点尺寸需要重新计算，表现为重新生成布局，重新排列元素。如改变元素尺寸<strong>边距、填充、边框、宽度和高度</strong>等，<strong>添加或者删除</strong>可见的DOM元素</li><li>重绘: 由于节点的几何属性发生改变或者由于样式发生改变，例如改变元素背景色时，屏幕上的部分内容需要更新，表现为某些元素的外观被改变。如<br>改变元素的<strong>color、background、box-shadow</strong>等属性</li></ul><p>单单改变元素的外观，肯定不会引起网页重新生成布局，但当浏览器完成重排之后，将会重新绘制受到此次重排影响的部分</p><p>重排和重绘代价是高昂的，它们会破坏用户体验，并且让UI展示非常迟缓，而相比之下重排的性能影响更大，在两者无法避免的情况下，一般我们宁可选择代价更小的重绘。</p><h1 id="如何触发重排和重绘"><a href="#如何触发重排和重绘" class="headerlink" title="如何触发重排和重绘"></a>如何触发重排和重绘</h1><p>任何改变用来构建渲染树的信息都会导致一次重排或重绘：</p><ul><li>添加、删除、更新DOM节点</li><li>通过display: none隐藏一个DOM节点-触发重排和重绘</li><li>通过visibility: hidden隐藏一个DOM节点-只触发重绘，因为没有几何变化</li><li>移动或者给页面中的DOM节点添加动画</li><li>添加一个样式表，调整样式属性</li><li>用户行为，例如调整窗口大小，改变字号，或者滚动。</li><li>查询某些属性或调用某些方法。比如说：<br>offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight</li></ul><h1 id="如何避免重绘或者重排"><a href="#如何避免重绘或者重排" class="headerlink" title="如何避免重绘或者重排"></a>如何避免重绘或者重排</h1><ul><li>集中改变样式</li><li>使用DocumentFragment</li><li>提升为合成层</li><li>缓存需要修改的DOM元素</li><li>尽量只修改position：absolute或fixed元素，对其他元素影响不大<br>动画开始GPU加速，translate使用3D变化</li></ul><p><img src="https://bu.dusays.com/2022/02/08/0efbbd6b78be8.png" alt="image _3_.png"></p><p>transform 不重绘，不回流是因为transform属于合成属性，对合成属性进行transition/animate动画时，将会创建一个合成层。这使得动画元素在一个独立的层中进行渲染。当元素的内容没有发生改变，就没有必要进行重绘。浏览器会通过重新复合来创建动画帧。</p>]]></content>
      
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端常见的代码问题汇总</title>
      <link href="2022/01/05/qian-duan-chang-jian-de-dai-ma-wen-ti-hui-zong/"/>
      <url>2022/01/05/qian-duan-chang-jian-de-dai-ma-wen-ti-hui-zong/</url>
      
        <content type="html"><![CDATA[<p>代码评审中，经常发现小组成员使用”古老”的 es 语法，造成代码冗余臃肿，不够幽雅，特此总结下，也提醒自己不断总结，坚持学习！</p><h1 id="取值"><a href="#取值" class="headerlink" title="取值"></a>取值</h1><p>从 obj 中取值，经常有人喜欢用对象的点语法：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>  a<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>  b<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span>  c<span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">,</span>  d<span class="token punctuation">:</span> <span class="token number">4</span><span class="token punctuation">,</span>  e<span class="token punctuation">:</span> <span class="token number">5</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">const</span> a <span class="token operator">=</span> obj<span class="token punctuation">.</span>a<span class="token punctuation">;</span><span class="token keyword">const</span> b <span class="token operator">=</span> obj<span class="token punctuation">.</span>b<span class="token punctuation">;</span><span class="token keyword">const</span> c <span class="token operator">=</span> obj<span class="token punctuation">.</span>c<span class="token punctuation">;</span><span class="token keyword">const</span> d <span class="token operator">=</span> obj<span class="token punctuation">.</span>d<span class="token punctuation">;</span><span class="token keyword">const</span> e <span class="token operator">=</span> obj<span class="token punctuation">.</span>e<span class="token punctuation">;</span></code></pre><p><strong>改进</strong><br>用 ES6 的解构赋值</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token punctuation">{</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> d<span class="token punctuation">,</span> e <span class="token punctuation">}</span> <span class="token operator">=</span> obj<span class="token punctuation">;</span><span class="token keyword">const</span> f <span class="token operator">=</span> a <span class="token operator">+</span> d<span class="token punctuation">;</span><span class="token keyword">const</span> g <span class="token operator">=</span> c <span class="token operator">+</span> e<span class="token punctuation">;</span></code></pre><p>另外，如果对象的属性值跟自己创建的对象名不一致，可以这样写：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token punctuation">{</span> a<span class="token punctuation">:</span> a1 <span class="token punctuation">}</span> <span class="token operator">=</span> obj<span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1</span></code></pre><p><strong>注意</strong><br>ES6 的解构赋值虽然好用。但是要注意解构的对象不能为 undefined、null。否则会报错，故要给被解构的对象一个默认值。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token punctuation">{</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> d<span class="token punctuation">,</span> e <span class="token punctuation">}</span> <span class="token operator">=</span> obj <span class="token operator">||</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><h1 id="合并数据"><a href="#合并数据" class="headerlink" title="合并数据"></a>合并数据</h1><p>比如合并两个数组，合并两个对象。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">const</span> b <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">const</span> c <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//[1,2,3,1,5,6]</span><span class="token keyword">const</span> obj1 <span class="token operator">=</span> <span class="token punctuation">{</span>  a<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">const</span> obj2 <span class="token operator">=</span> <span class="token punctuation">{</span>  b<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">const</span> obj <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> obj1<span class="token punctuation">,</span> obj2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//{a:1,b:1}</span></code></pre><p><strong>改进</strong><br>利用 ES6 扩展运算改进后：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">const</span> b <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">const</span> c <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">...</span>a<span class="token punctuation">,</span> <span class="token operator">...</span>b<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//[1,2,3,5,6]</span><span class="token keyword">const</span> obj1 <span class="token operator">=</span> <span class="token punctuation">{</span>  a<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">const</span> obj2 <span class="token operator">=</span> <span class="token punctuation">{</span>  b<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token operator">...</span>obj1<span class="token punctuation">,</span> <span class="token operator">...</span>obj2 <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//{a:1,b:1}</span></code></pre><h1 id="拼接字符串"><a href="#拼接字符串" class="headerlink" title="拼接字符串"></a>拼接字符串</h1><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> name <span class="token operator">=</span> <span class="token string">"小明"</span><span class="token punctuation">;</span><span class="token keyword">const</span> score <span class="token operator">=</span> <span class="token number">59</span><span class="token punctuation">;</span><span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>score <span class="token operator">></span> <span class="token number">60</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  result <span class="token operator">=</span> <span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">的考试成绩及格`</span></span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>  result <span class="token operator">=</span> <span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">的考试成绩不及格`</span></span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>改进</strong></p><p>ES6 字符串模板在${}中可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> name <span class="token operator">=</span> <span class="token string">"小明"</span><span class="token punctuation">;</span><span class="token keyword">const</span> score <span class="token operator">=</span> <span class="token number">59</span><span class="token punctuation">;</span><span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>score <span class="token operator">></span> <span class="token number">60</span> <span class="token operator">?</span> <span class="token string">"的考试成绩及格"</span> <span class="token punctuation">:</span> <span class="token string">"的考试成绩不及格"</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">;</span></code></pre><h1 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h1><p>经常看到这样的写法：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">if</span><span class="token punctuation">(</span>    type <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">||</span>    type <span class="token operator">==</span> <span class="token number">2</span> <span class="token operator">||</span>    type <span class="token operator">==</span> <span class="token number">3</span> <span class="token operator">||</span>    type <span class="token operator">==</span> <span class="token number">4</span> <span class="token operator">||</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">//...</span><span class="token punctuation">}</span></code></pre><p><strong>改进</strong><br>includes 方法返回一个布尔值，表示某个数组是否包含给定的值,可以简化上面的写法：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> condition <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>condition<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//...</span><span class="token punctuation">}</span></code></pre><h1 id="扁平化数组"><a href="#扁平化数组" class="headerlink" title="扁平化数组"></a>扁平化数组</h1><p>一个部门 JSON 数据中，属性名是部门 id，属性值是个部门成员 id 数组集合，现在要把有部门的成员 id 都提取到一个数组集合中。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> deps <span class="token operator">=</span> <span class="token punctuation">{</span>  采购部<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  人事部<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  行政部<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">14</span><span class="token punctuation">,</span> <span class="token number">79</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  运输部<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">64</span><span class="token punctuation">,</span> <span class="token number">105</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">let</span> member <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> item <span class="token keyword">in</span> deps<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">const</span> value <span class="token operator">=</span> deps<span class="token punctuation">[</span>item<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    member <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>member<span class="token punctuation">,</span> <span class="token operator">...</span>value<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span>member <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span>member<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre><p><strong>改进</strong></p><p>利用<code>Object.values</code>获取对象的全部属性，然后 ES6 提供的<code>flat</code>方法来扁平化：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> deps <span class="token operator">=</span> <span class="token punctuation">{</span>  采购部<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  人事部<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  行政部<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">14</span><span class="token punctuation">,</span> <span class="token number">79</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  运输部<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">64</span><span class="token punctuation">,</span> <span class="token number">105</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">let</span> member <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span>deps<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">flat</span><span class="token punctuation">(</span><span class="token number">Infinity</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h1 id="获取对象属性"><a href="#获取对象属性" class="headerlink" title="获取对象属性"></a>获取对象属性</h1><p>业务代码中经常会遇到这样的情况，a对象有个属性b,b 也是一个对象有个属性 c,我们需要访问 c，经常会写成 a.b.c，但是如果 f 不存在时，就会出错。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span>a<span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span><span class="token operator">=</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span><span class="token punctuation">{</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span>b<span class="token punctuation">:</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span><span class="token punctuation">{</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span>c<span class="token punctuation">:</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span><span class="token number">123</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>b<span class="token punctuation">.</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//&amp;nbsp;123;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>f<span class="token punctuation">.</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//&amp;nbsp;f不存在所以会报错</span></code></pre><p><strong>改进</strong><br><code>可选链运算符</code>解决该问题，通过在.之前添加一个?将键名变成可选</p><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span>person<span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span><span class="token operator">=</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person<span class="token operator">?</span><span class="token punctuation">.</span>profile<span class="token operator">?</span><span class="token punctuation">.</span>age<span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span><span class="token operator">?</span><span class="token operator">?</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span><span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//&amp;nbsp;18</span></code></pre><h1 id="空值判断"><a href="#空值判断" class="headerlink" title="空值判断"></a>空值判断</h1><p>在处理输入框相关业务时，往往会判断输入框未输入值的场景。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">if</span><span class="token punctuation">(</span>value <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> value <span class="token operator">!==</span> undefined <span class="token operator">&amp;&amp;</span> value <span class="token operator">!==</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//...</span><span class="token punctuation">}</span></code></pre><p><strong>改进</strong><br><code>空值合并运算符</code>与<code>||运算</code>很像，但是可以省略很多代码，可读性也增强。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>value<span class="token operator">?</span><span class="token operator">?</span><span class="token string">''</span><span class="token punctuation">)</span> <span class="token operator">!==</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//...</span><span class="token punctuation">}</span></code></pre><p><strong>注意</strong><br>假设变量a不存在，我们希望给系统一个默认值，一般我们会使用||运算符。但是在javascript中空字符串，0，false都会执行||运算符，所以ECMAScript2020引入合并空运算符解决该问题，只允许在值为null或未定义时使用默认值。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span>name<span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span><span class="token operator">=</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span><span class="token string">''</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span><span class="token operator">||</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span><span class="token string">'yd'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//&amp;nbsp;yd;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span><span class="token operator">?</span><span class="token operator">?</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span><span class="token string">'yd'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//&amp;nbsp;'';</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> ES语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es </tag>
            
            <tag> 项目总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编写高性能的JavaScript</title>
      <link href="2022/01/04/bian-xie-gao-xing-neng-de-javascript/"/>
      <url>2022/01/04/bian-xie-gao-xing-neng-de-javascript/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>随着计算机硬件的不断升级，开发者越发觉得<code>Javascript</code>性能优化的好不好对网页的执行效率影响不明显，所以一些性能方面的知识被很多开发者忽视。但在某些情况下，不优化的<code>Javascript</code>代码必然会影响用户的体验。因此，即使在当前硬件性能已经大大提升的时代，在编写<code>Javascript</code>代码时，若能遵循<code>Javascript</code>规范和注意一些性能方面的知识，对于提升代码的可维护性和优化性能将大有好处。那么，接下来我们讨论几种能够提高<code>JavaScript性能</code>的方法。</p><h2 id="1、js文件加载和执行"><a href="#1、js文件加载和执行" class="headerlink" title="1、js文件加载和执行"></a>1、js文件加载和执行</h2><p>（1）将<code>&lt;script&gt;</code>标签放到<code>&lt;body&gt;</code>标签的底部</p><p>（2）可以合并多个<code>js</code>文件，减少页面中<code>&lt;script&gt;</code>标签改善性能</p><p>（3）使用 <code>defer</code> 属性，加载后续文档元素的过程将和<code>script.js</code>的加载并行进行，但是 <code>script.js</code> 的执行要在所有元素解析完成之后，<code>DOMContentLoaded </code>事件触发之前完成。</p><p>（4）使用 <code>async</code> 属性，加载和渲染后续文档元素的过程将和<code>script.js</code>的加载与执行并行进行</p><p>（5）动态加载脚本元素，无论在何时启动瞎子，文件的下载和执行过程都不会阻塞页面其它进程</p><pre><code>var script = document.createElement('script');script.type = 'text/javascript';script.src = 'file.js';document.getElementsByTagName('head')[0].appendChild(script);</code></pre><h2 id="2、标识符所在的作用域链的位置越深"><a href="#2、标识符所在的作用域链的位置越深" class="headerlink" title="2、标识符所在的作用域链的位置越深"></a>2、标识符所在的作用域链的位置越深</h2><p>标识符所在的作用域链的位置越深，那么它的标识符解析的性能就越慢。所以一个好的性能提升的经验法则是：如果某个跨作用域的值在函数中被引用一次以上，那么就把它存储到局部变量里。</p><pre><code>function fun1() {  // 将全局变量的引用先存储在一个局部变量中，然后使用这个局部变量代替全局变量，从而提高         // 性能；不然每次(3次)都要遍历整个作用域链找到document  var doc = document;    var bd = doc.body;   var links = doc.getElementsByTagName('a');   doc.getElementById('btn').onclick = function(){    console.log('btn');   }}</code></pre><h2 id="3、避免过长原型链继承"><a href="#3、避免过长原型链继承" class="headerlink" title="3、避免过长原型链继承"></a>3、避免过长原型链继承</h2><p>方法或属性在原型链中存在的位置越深，搜索它的性能也就越慢，所以要避免N多层原型链的写法。</p><h2 id="4、对象成员嵌套过深"><a href="#4、对象成员嵌套过深" class="headerlink" title="4、对象成员嵌套过深"></a>4、对象成员嵌套过深</h2><p>对象的嵌套成员，对象成员嵌套越深，读取速度也就越慢。所以好的经验法则是：如果在函数中需要多次读取一个对象属性，最佳做法是将该属性值保存在局部变量中，避免多次查找带来的性能开销。</p><pre><code>function f() {  // 因为在以下函数中需要3次用到DOM对象属性，所以先将它存储在一个局部变量         // 中，然后使用这个局部变量代替它进行后续操作，从而提高性能  var dom = YaHOO.util.Dom;  if(Dom.hasClass(element,'selected')){     Dom.removeClass(elemet,'selected');  }else{     Dom.addClass(elemet,'selected');   }}</code></pre><h2 id="5、DOM操作"><a href="#5、DOM操作" class="headerlink" title="5、DOM操作"></a>5、DOM操作</h2><p>用<code>js</code>访问和操作<code>DOM</code>都会带来性能损失，可通过以下几点来减少性能损失：</p><p>（1）尽可能减少<code>DOM</code>访问次数；</p><p>（2）如果需要多次访问某个<code>DOM</code>节点，请使用局部变量存储它的引用；</p><p>（3）小心处理<code>HTML</code>集合，因为它实时连系着底层文档；我们可以把集合的长度缓存到一个变量中，并在迭代中使用它；</p><p>（4）下述情况会发生重排：</p><ul><li>添加或删除可见的<code>DOM</code>元素；</li><li>元素位置改变；</li><li>元素尺寸改变（包括：外边距、内边距、边框厚度、宽度、高度等属性）；</li><li>内容改变（例如：文本改变或图片被另一个不同尺寸的图片改变）；</li><li>页面渲染器初始化；</li><li>浏览器窗口尺寸改变</li></ul><p>可通过以下方式减少重排：</p><ul><li>留意上面会导致重排的操作，尽量避免；</li><li>获取布局信息的操作会导致强制渲染队列重排，应该尽量避免使用以下获取布局信息的操作方法或属性或者缓存布局信息，例如：<code>offsetTop,offsetLeft,offsetWidthoffsetHeight,``scrollTop,scrollLeft,scrollWidth,scrollHeight,clientTop,clientLeft,clientWidth,clientHeight,getComputedStyle()</code>等;</li><li>批量修改样式，例如使用：</li></ul><pre><code>function f() {    // 推荐使用以下操作    var el1 = document.getElementById('mydiv');    el1.style.cssText = 'border:1px;padding:2px;margin:3px';    // 不推荐使用以下操作    var el2 = document.getElementById('mydiv');    el2.style.border = '1px';    el2.style.padding = '2px';    el2.style.margin = '3px';}</code></pre><ul><li><p>当需要批量修改<code>DOM</code>时，可以通过以下步骤减少重绘和重排的次数：</p></li><li><ul><li>使元素脱离文档流（隐藏元素、拷贝元素）</li><li>对其应用多重改变；</li><li>把元素带回文档中</li></ul></li><li><p>使用事件委托（事件逐层冒泡并能被父级元素捕获，使用事件代理，只需给外层元素绑定一个处理器，就可以处理其子元素上触发的所用事件），因为给<code>DOM</code>元素绑定事件以及浏览器需要跟踪每个事件处理器都需要消耗性能。</p></li></ul><h2 id="6、字符串连接"><a href="#6、字符串连接" class="headerlink" title="6、字符串连接"></a>6、字符串连接</h2><pre><code>str += 'one'+'two';str= str+'one'+'two';</code></pre><p>后者方式会比前者少在内存中创建一个临时字符串，所以性能有相应的提升，所以，所以推荐后者的写法。</p><h2 id="7、直接使用字面量"><a href="#7、直接使用字面量" class="headerlink" title="7、直接使用字面量"></a>7、直接使用字面量</h2><p>创建对象和数组推荐使用字面量，因为这不仅是性能最优也有助于节省代码量。</p><pre><code>var obj = {    name:'tom',     age:15,     sex:'男'}</code></pre><p>​    </p><h2 id="8、数组长度缓存"><a href="#8、数组长度缓存" class="headerlink" title="8、数组长度缓存"></a>8、数组长度缓存</h2><p>如果需要遍历数组，应该先缓存数组长度，将数组长度放入局部变量中，避免多次查询数组长度。</p><h2 id="9、循环比较"><a href="#9、循环比较" class="headerlink" title="9、循环比较"></a>9、循环比较</h2><p><code>JS</code>提供了三种循环：<code>for(;;)、while()、for(in)</code>。在这三种循环中 <code>for(in)</code>的效率最差，因为它需要查询Hash键，因此应尽量少用<code>for(in)</code>循环，<code>for(;;)、while()</code>循环的性能基本持平。</p><h2 id="10、少用eval"><a href="#10、少用eval" class="headerlink" title="10、少用eval"></a>10、少用eval</h2><p>尽量少使用<code>eval</code>，每次使用<code>eval</code>需要消耗大量时间，这时候使用<code>JS</code>所支持的闭包可以实现函数模板。</p><h2 id="11、字符串转换"><a href="#11、字符串转换" class="headerlink" title="11、字符串转换"></a>11、字符串转换</h2><p>当需要将数字转换成字符时，采用如下方式：<code>"" + 1</code>。从性能上来看，将数字转换成字符时，有如下公式：<code>("" +) &gt; String() &gt; .toString() &gt; new String()</code>。<code>String()</code>属于内部函数，所以速度很快。而<code>.toString()</code>要查询原型中的函数，所以速度逊色一些，<code>new String()</code>需要重新创建一个字符串对象，速度最慢。</p><h2 id="12、浮点数转换整形"><a href="#12、浮点数转换整形" class="headerlink" title="12、浮点数转换整形"></a>12、浮点数转换整形</h2><p>当需要将浮点数转换成整型时，应该使用<code>Math.floor()</code>或者<code>Math.round()</code>。而不是使用<code>parseInt()</code>,该方法用于将字符串转换成数字。而且<code>Math</code>是内部对象，所以<code>Math.floor()</code>其实并没有多少查询方法和调用时间，速度是最快的。</p>]]></content>
      
      
      <categories>
          
          <category> ES语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx实现灰度发布</title>
      <link href="2021/08/09/nginx-shi-xian-hui-du-fa-bu/"/>
      <url>2021/08/09/nginx-shi-xian-hui-du-fa-bu/</url>
      
        <content type="html"><![CDATA[<blockquote><p>灰度发布（又名金丝雀发布，英文一般称为GrayRelease或Dark launch）是为了能够让用户逐步过渡到新功能一种发布方式。 一般是产品上线一个功能，希望在线上可以进行A/B testing，即让一部分用户继续用产品特性A，一部分用户开始用产品特性B，如果用户对B没有什么反对意见，那么逐步扩大范围，把所有用户都迁移到B上面来。</p></blockquote><p>优点:</p><ul><li>灰度发布可以保证整体系统的稳定，在初始灰度的时候就可以发现、调整问题，以保证其影响度。</li><li>灰度发布可以让部分用户尽快体验到最新的功能，提高用户的积极性，进而收集用户反馈改善产品。</li></ul><p>灰度发布在谷歌和Facebook等很多公司已经使用的相当成熟，具体的分流规则也有很多，下面简单介绍下几种常见的分流规则，并分别使用nginx来配置实现。</p><h2 id="基于COOKIE分流"><a href="#基于COOKIE分流" class="headerlink" title="基于COOKIE分流"></a>基于COOKIE分流</h2><p>使用Cookie分流的原理为：在用户首次登录时查询该用户是否是灰度用户，并为其设置标识Cookie，后续采用Cookie标识来进行分流。<br>本文采用dark字段作为标识，如果cookie中dark的值true则分流到灰度环境，其他情况则分流到生产环境。<br>在nginx的原生变量中，$http_cookie的值为所有Cookie以key=value的形式拼接，而$cookie_dark则只获得Cookie中dark的值。所以可以采用两种方式来判断：</p><ul><li>使用$http_cookie，则里面需要包含dark=true；</li><li>使用$cookie_dark，则其值需要为true。</li></ul><p>最终nginx.conf文件中的核心配置如下：</p><pre class=" language-js"><code class="language-js">upstream normal <span class="token punctuation">{</span>    server <span class="token number">127.0</span><span class="token punctuation">.</span><span class="token number">0.1</span><span class="token punctuation">:</span><span class="token number">8080</span><span class="token punctuation">;</span><span class="token punctuation">}</span>upstream dark <span class="token punctuation">{</span>    server <span class="token number">127.0</span><span class="token punctuation">.</span><span class="token number">0.1</span><span class="token punctuation">:</span><span class="token number">8081</span><span class="token punctuation">;</span><span class="token punctuation">}</span>server <span class="token punctuation">{</span>    listen       <span class="token number">80</span><span class="token punctuation">;</span>    server_name  localhost<span class="token punctuation">;</span>    <span class="token keyword">set</span> $group normal<span class="token punctuation">;</span>    #或者使用 <span class="token keyword">if</span> <span class="token punctuation">(</span>$cookie_dark <span class="token operator">~</span><span class="token operator">*</span> <span class="token string">"^true&amp;"</span><span class="token punctuation">)</span> 来判断    <span class="token keyword">if</span> <span class="token punctuation">(</span>$http_cookie <span class="token operator">~</span><span class="token operator">*</span> <span class="token string">"dark=true"</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token keyword">set</span> $group dark<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    location <span class="token operator">/</span> <span class="token punctuation">{</span>        proxy_pass http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>$group<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="基于Header分流"><a href="#基于Header分流" class="headerlink" title="基于Header分流"></a>基于Header分流</h2><p>基于Header分流的原理和用法都和Cookie类似。只有两点不同：</p><ul><li>– 获取灰度标识，使用的是$http_dark（即$http_header名）的写法；<br>Header不能像Cookie一样在客户端保留，所以一般是在多层网络中使用，即入口层给Header赋值，分流层再去分流。</li></ul><p>这里为了演示ngx_http_map_module的用法，使用了map替代了上面的set if判断方法。</p><pre class=" language-js"><code class="language-js">map $http_dark $group <span class="token punctuation">{</span>    <span class="token operator">~</span><span class="token operator">*</span><span class="token boolean">true</span>$ dark<span class="token punctuation">;</span>     <span class="token keyword">default</span> normal<span class="token punctuation">;</span><span class="token punctuation">}</span>server <span class="token punctuation">{</span>    listen       <span class="token number">80</span><span class="token punctuation">;</span>    server_name  localhost<span class="token punctuation">;</span>    location <span class="token operator">/</span> <span class="token punctuation">{</span>        proxy_pass http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>$group<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="基于IP分流"><a href="#基于IP分流" class="headerlink" title="基于IP分流"></a>基于IP分流</h2><p>于IP分流原理：校验客户端的IP是否在我们的灰度IP列表中。<br>所以关键有两点：</p><ul><li>如何获取客户端IP？</li><li>灰度IP列表怎么保存？其实可以保存在配置文件或数据库等任意地方。</li></ul><p>假设我们有一张mysql的表存着配置的所有需要分发到灰度的IP地址，如果请求的IP在表中能够查到的话，则分流到灰度环境。我们这边最简单的创建了一个表，并插入一条IP地址。</p><pre class=" language-js"><code class="language-js">CREATE TABLE <span class="token template-string"><span class="token string">`test`</span></span><span class="token punctuation">.</span><span class="token template-string"><span class="token string">`dark_launch_ips`</span></span><span class="token punctuation">(</span> <span class="token template-string"><span class="token string">`ip`</span></span> <span class="token function">VARCHAR</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span> NOT NULL<span class="token punctuation">,</span> PRIMARY KEY <span class="token punctuation">(</span><span class="token template-string"><span class="token string">`ip`</span></span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> INSERT INTO <span class="token template-string"><span class="token string">`test`</span></span><span class="token punctuation">.</span><span class="token template-string"><span class="token string">`dark_launch_ips`</span></span> <span class="token punctuation">(</span><span class="token template-string"><span class="token string">`ip`</span></span><span class="token punctuation">)</span> VALUES <span class="token punctuation">(</span><span class="token string">'1.1.1.1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>本节使用了lua脚本来判断分流，在Nginx里面使用lua需要Nginx额外增加lua-nginx-module模块，或者直接使用打包好的OpenResty。为了演示，我们依然使用了两个location，只是不再使用upstrem，而是使用content_by_lua简单返回一个字符串，目的是能够在区分分流的前提下尽量简化其他细节，以突出核心逻辑。在Nginx中连接mysql的方法参考lua-resty-mysql模块。最终Nginx的核心配置如下：</p><pre class=" language-js"><code class="language-js">location @normal <span class="token punctuation">{</span>    content_by_lua <span class="token string">'ngx.say("normal")'</span><span class="token punctuation">;</span><span class="token punctuation">}</span>location @dark <span class="token punctuation">{</span>    content_by_lua <span class="token string">'ngx.say("dark")'</span><span class="token punctuation">;</span><span class="token punctuation">}</span>location <span class="token operator">/</span>test <span class="token punctuation">{</span>    access_by_lua '        local mysql <span class="token operator">=</span> require <span class="token string">"resty.mysql"</span>        local db<span class="token punctuation">,</span> err <span class="token operator">=</span> mysql<span class="token punctuation">:</span><span class="token keyword">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> not db then            ngx<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>ngx<span class="token punctuation">.</span>ERR<span class="token punctuation">,</span> <span class="token string">"failed to instantiate mysql: "</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>            ngx<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token string">"@normal"</span><span class="token punctuation">)</span>        end        local ok<span class="token punctuation">,</span> err<span class="token punctuation">,</span> errcode<span class="token punctuation">,</span> sqlstate <span class="token operator">=</span> db<span class="token punctuation">:</span>connect <span class="token punctuation">{</span>            host <span class="token operator">=</span> <span class="token string">"127.0.0.1"</span><span class="token punctuation">,</span>            port <span class="token operator">=</span> <span class="token number">3306</span><span class="token punctuation">,</span>            database <span class="token operator">=</span> <span class="token string">"test"</span><span class="token punctuation">,</span>            user <span class="token operator">=</span> <span class="token string">"root"</span><span class="token punctuation">,</span>            password <span class="token operator">=</span> <span class="token string">"root"</span><span class="token punctuation">,</span>            charset <span class="token operator">=</span> <span class="token string">"utf8"</span><span class="token punctuation">,</span>            max_packet_size <span class="token operator">=</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">,</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> not ok then            ngx<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>ngx<span class="token punctuation">.</span>ERR<span class="token punctuation">,</span> <span class="token string">"failed to connect: "</span><span class="token punctuation">,</span> err<span class="token punctuation">,</span> <span class="token string">": "</span><span class="token punctuation">,</span> errcode<span class="token punctuation">,</span> <span class="token string">" "</span><span class="token punctuation">,</span> sqlstate<span class="token punctuation">)</span>            ngx<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token string">"@normal"</span><span class="token punctuation">)</span>        end        <span class="token operator">--</span> 以上代码是连接数据库操作，下面代码是获取IP并去数据库查询验证        local req_ip <span class="token operator">=</span> ngx<span class="token punctuation">.</span><span class="token keyword">var</span><span class="token punctuation">.</span>http_x_real_ip or ngx<span class="token punctuation">.</span><span class="token keyword">var</span><span class="token punctuation">.</span>http_x_forwarded_for or ngx<span class="token punctuation">.</span><span class="token keyword">var</span><span class="token punctuation">.</span>remote_addr or <span class="token string">"0.0.0.0"</span>        local name <span class="token operator">=</span> ngx<span class="token punctuation">.</span><span class="token function">unescape_uri</span><span class="token punctuation">(</span>req_ip<span class="token punctuation">)</span>        local quoted_name <span class="token operator">=</span> ngx<span class="token punctuation">.</span><span class="token function">quote_sql_str</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token operator">--</span> 防SQL注入        local res<span class="token punctuation">,</span> err<span class="token punctuation">,</span> errcode<span class="token punctuation">,</span> sqlstate <span class="token operator">=</span> db<span class="token punctuation">:</span><span class="token function">query</span><span class="token punctuation">(</span><span class="token string">"SELECT COUNT(*) AS cnt FROM dark_launch_ips WHERE ip = "</span> <span class="token punctuation">.</span><span class="token punctuation">.</span> quoted_name<span class="token punctuation">)</span>        <span class="token keyword">if</span> not res then            ngx<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>ngx<span class="token punctuation">.</span>ERR<span class="token punctuation">,</span> <span class="token string">"bad result: "</span><span class="token punctuation">,</span> err<span class="token punctuation">,</span> <span class="token string">": "</span><span class="token punctuation">,</span> errcode<span class="token punctuation">,</span> <span class="token string">": "</span><span class="token punctuation">,</span> sqlstate<span class="token punctuation">,</span> <span class="token string">"."</span><span class="token punctuation">)</span>            ngx<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token string">"@normal"</span><span class="token punctuation">)</span>        end        <span class="token keyword">if</span> <span class="token function">tonumber</span><span class="token punctuation">(</span>res<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">"cnt"</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> then            ngx<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token string">"@dark"</span><span class="token punctuation">)</span>        end        ngx<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token string">"@normal"</span><span class="token punctuation">)</span>    '<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="基于URL分流"><a href="#基于URL分流" class="headerlink" title="基于URL分流"></a>基于URL分流</h2><p>下面再介绍下URL分流，例如以下场景：如果url以dark结尾，则分流到灰度。本文继续使用一个新的模块ngx.balancer来做负载均衡。</p><pre class=" language-js"><code class="language-js">upstream balancer <span class="token punctuation">{</span>    server <span class="token number">0.0</span><span class="token punctuation">.</span><span class="token number">0.1</span><span class="token punctuation">;</span>   # 这里写一个不存在的IP，作为占位填充    balancer_by_lua_block <span class="token punctuation">{</span>        local balancer <span class="token operator">=</span> require <span class="token string">"ngx.balancer"</span>        <span class="token operator">--</span> 下面一般是根据某些参数来计算要分流到哪里        local host <span class="token operator">=</span> <span class="token string">"127.0.0.1"</span>        local port <span class="token operator">=</span> <span class="token number">8080</span>        local m<span class="token punctuation">,</span> err <span class="token operator">=</span> ngx<span class="token punctuation">.</span>re<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>ngx<span class="token punctuation">.</span><span class="token keyword">var</span><span class="token punctuation">.</span>uri<span class="token punctuation">,</span> <span class="token string">"dark$"</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> m then            port <span class="token operator">=</span> <span class="token number">8081</span>        end        local ok<span class="token punctuation">,</span> err <span class="token operator">=</span> balancer<span class="token punctuation">.</span><span class="token function">set_current_peer</span><span class="token punctuation">(</span>host<span class="token punctuation">,</span> port<span class="token punctuation">)</span>        <span class="token keyword">if</span> not ok then            ngx<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>ngx<span class="token punctuation">.</span>ERR<span class="token punctuation">,</span> <span class="token string">"failed to set the current peer: "</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>            <span class="token keyword">return</span> ngx<span class="token punctuation">.</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span>        end    <span class="token punctuation">}</span>    keepalive <span class="token number">10</span><span class="token punctuation">;</span>  # connection pool<span class="token punctuation">}</span></code></pre><p>访问<a href="http://localhost/someurl-dark">http://localhost/someurl-dark</a> 访问的是灰度节点；访问<a href="http://localhost/someurl">http://localhost/someurl</a> 访问的是生产节点。</p><h2 id="基于cookie访问不同的目录"><a href="#基于cookie访问不同的目录" class="headerlink" title="基于cookie访问不同的目录"></a>基于cookie访问不同的目录</h2><pre class=" language-JS"><code class="language-JS">location / {    set $rooturl /xxx/xxx/xxx/xxx;    if ($http_cookie ~* "key=value") {         set $rooturl /selfWorkspace/xxx/xxx/xxx;    }    root   $rooturl;}</code></pre><p>就是加个if判断即可，重新设置root 的路径即可，注意如果404的情况下可能是目录属组或者权限问题。</p>]]></content>
      
      
      <categories>
          
          <category> nginx专题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx中root&amp;alias区别</title>
      <link href="2021/08/09/nginx-zhong-root-alias-qu-bie/"/>
      <url>2021/08/09/nginx-zhong-root-alias-qu-bie/</url>
      
        <content type="html"><![CDATA[<p>Nginx指定文件路径有两种方式root和alias，两种指令有不同的使用方法和作用域。</p><ul><li>root可以配置在http、server、location、if区块中</li><li>alias只能配置在location区块中。</li></ul><p>root与alias主要区别在于Nginx如何解释location后面的uri，这会使两者分别以不同的方式将请求映射到服务器文件上。</p><h2 id="root的处理方式"><a href="#root的处理方式" class="headerlink" title="root的处理方式"></a>root的处理方式</h2><p>root路径＋location路径，会使用url上的文件名</p><pre class=" language-JS"><code class="language-JS">location ^~ /appImg/{    root /home/nginx;}</code></pre><p>这个location相当于访问服务器上的文件路径： /home/nginx/appImg/abc.jpg</p><h2 id="alias的处理方式"><a href="#alias的处理方式" class="headerlink" title="alias的处理方式"></a>alias的处理方式</h2><p>alias的处理结果是：使用alias路径替换location路径</p><pre class=" language-JS"><code class="language-JS">location ^~ /appImg/{    alias /home/nginx/;}</code></pre><p>这个location相当于访问服务器上的文件目录：/home/nginx/abc.jpg(即alias不会使用location后面配置的路径)，而且如果alias 指定的是目录，后面一定要加上 /，否则会找不到文件。</p>]]></content>
      
      
      <categories>
          
          <category> nginx专题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx的localtion配置</title>
      <link href="2021/05/13/nginx-de-localtion-pei-zhi/"/>
      <url>2021/05/13/nginx-de-localtion-pei-zhi/</url>
      
        <content type="html"><![CDATA[<p><img src="https://7.dusays.com/2021/05/13/1128409d75ed2.png" alt="nginx"></p><h2 id="location-的作用"><a href="#location-的作用" class="headerlink" title="location 的作用"></a>location 的作用</h2><p>location 指令的作用是根据用户请求 URI 来执行不同的应用，location 会根据用户请求网站 URL 进行匹配定位到某个 location 区块。 如果匹配成功将会处理 location 块的规则。</p><h2 id="语法规则"><a href="#语法规则" class="headerlink" title="语法规则"></a>语法规则</h2><pre class=" language-js"><code class="language-js">location  <span class="token operator">=</span>     <span class="token operator">/</span>uri   ┬      ┬       ┬   │      │       │   │      │       │   │      │       │   │      │       │   │      │       └─────────────── 前缀<span class="token operator">|</span>正则   │      └──────────────────── 可选的修饰符（用于匹配模式及优先级）   └───────────────────────── 必须</code></pre><h2 id="修饰符说明"><a href="#修饰符说明" class="headerlink" title="修饰符说明"></a>修饰符说明</h2><p>以下从上到下，第一个优先级最高</p><pre class=" language-js"><code class="language-js"><span class="token operator">=</span>      <span class="token operator">|</span>   location <span class="token operator">=</span> <span class="token operator">/</span>uri<span class="token operator">^</span><span class="token operator">~</span>     <span class="token operator">|</span>   location <span class="token operator">^</span><span class="token operator">~</span> <span class="token operator">/</span>uri<span class="token operator">~</span>      <span class="token operator">|</span>   location <span class="token operator">~</span> pattern<span class="token operator">~</span><span class="token operator">*</span>     <span class="token operator">|</span>   location <span class="token operator">~</span><span class="token operator">*</span> pattern<span class="token operator">/</span>uri   <span class="token operator">|</span>   location <span class="token operator">/</span>uri@      <span class="token operator">|</span>   location @err</code></pre><h2 id="优先级顺序"><a href="#优先级顺序" class="headerlink" title="优先级顺序"></a>优先级顺序</h2><p><em>优先级不分编辑 location 前后顺序</em></p><ol><li>= ，精确匹配，表示严格相等</li></ol><pre class=" language-js"><code class="language-js">location <span class="token operator">=</span> <span class="token operator">/</span><span class="token keyword">static</span> <span class="token punctuation">{</span>  default_type text<span class="token operator">/</span>html<span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">200</span> <span class="token string">"hello world"</span><span class="token punctuation">;</span><span class="token punctuation">}</span># http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>localhost<span class="token operator">/</span><span class="token keyword">static</span>   <span class="token punctuation">[</span>成功<span class="token punctuation">]</span># http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>localhost<span class="token operator">/</span>Static   <span class="token punctuation">[</span>失败<span class="token punctuation">]</span></code></pre><ol start="2"><li>^~ ，匹配以 URI 开头</li></ol><pre class=" language-js"><code class="language-js">location <span class="token operator">^</span><span class="token operator">~</span> <span class="token operator">/</span><span class="token keyword">static</span> <span class="token punctuation">{</span>  default_type text<span class="token operator">/</span>html<span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">200</span> <span class="token string">"hello world"</span><span class="token punctuation">;</span><span class="token punctuation">}</span># http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>localhost<span class="token operator">/</span><span class="token keyword">static</span><span class="token operator">/</span><span class="token number">1</span><span class="token punctuation">.</span>txt    <span class="token punctuation">[</span>成功<span class="token punctuation">]</span># http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>localhost<span class="token operator">/</span><span class="token keyword">public</span><span class="token operator">/</span><span class="token number">1</span><span class="token punctuation">.</span>txt    <span class="token punctuation">[</span>失败<span class="token punctuation">]</span></code></pre><ol start="3"><li>~ ，对大小写敏感, 使用正则 注意：某些操作系统对大小写敏感是不生效的，比如 windows 操作系统</li></ol><pre class=" language-js"><code class="language-js">location <span class="token operator">~</span> <span class="token operator">^</span><span class="token operator">/</span><span class="token keyword">static</span>$ <span class="token punctuation">{</span>  default_type text<span class="token operator">/</span>html<span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">200</span> <span class="token string">"hello world"</span><span class="token punctuation">;</span><span class="token punctuation">}</span># http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>localhost<span class="token operator">/</span><span class="token keyword">static</span>         <span class="token punctuation">[</span>成功<span class="token punctuation">]</span># http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>localhost<span class="token operator">/</span><span class="token keyword">static</span><span class="token operator">?</span>v<span class="token operator">=</span><span class="token number">1</span>     <span class="token punctuation">[</span>成功<span class="token punctuation">]</span> 忽略查询字符串# http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>localhost<span class="token operator">/</span>STATic         <span class="token punctuation">[</span>失败<span class="token punctuation">]</span># http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>localhost<span class="token operator">/</span><span class="token keyword">static</span><span class="token operator">/</span>        <span class="token punctuation">[</span>失败<span class="token punctuation">]</span> 多了斜杠</code></pre><ol start="4"><li><del>* ，与</del>相反，忽略大小写敏感, 使用正则</li></ol><pre class=" language-js"><code class="language-js">location <span class="token operator">~</span><span class="token operator">*</span> <span class="token operator">^</span><span class="token operator">/</span><span class="token keyword">static</span>$ <span class="token punctuation">{</span>  default_type text<span class="token operator">/</span>html<span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">200</span> <span class="token string">"hello world"</span><span class="token punctuation">;</span><span class="token punctuation">}</span># http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>localhost<span class="token operator">/</span><span class="token keyword">static</span>         <span class="token punctuation">[</span>成功<span class="token punctuation">]</span># http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>localhost<span class="token operator">/</span><span class="token keyword">static</span><span class="token operator">?</span>v<span class="token operator">=</span><span class="token number">1</span>     <span class="token punctuation">[</span>成功<span class="token punctuation">]</span> 忽略查询字符串# http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>localhost<span class="token operator">/</span>STATic         <span class="token punctuation">[</span>成功<span class="token punctuation">]</span># http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>localhost<span class="token operator">/</span><span class="token keyword">static</span><span class="token operator">/</span>        <span class="token punctuation">[</span>失败<span class="token punctuation">]</span> 多了斜杠</code></pre><ol start="5"><li>/uri ，匹配以/uri 开头的地址</li></ol><pre class=" language-js"><code class="language-js">location  <span class="token operator">/</span><span class="token keyword">static</span> <span class="token punctuation">{</span>  default_type text<span class="token operator">/</span>html<span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">200</span> <span class="token string">"hello world"</span><span class="token punctuation">;</span><span class="token punctuation">}</span># http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>localhost<span class="token operator">/</span><span class="token keyword">static</span>              <span class="token punctuation">[</span>成功<span class="token punctuation">]</span># http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>localhost<span class="token operator">/</span>STATIC<span class="token operator">?</span>v<span class="token operator">=</span><span class="token number">1</span>          <span class="token punctuation">[</span>成功<span class="token punctuation">]</span># http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>localhost<span class="token operator">/</span><span class="token keyword">static</span><span class="token operator">/</span><span class="token number">1</span>            <span class="token punctuation">[</span>成功<span class="token punctuation">]</span># http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>localhost<span class="token operator">/</span><span class="token keyword">static</span><span class="token operator">/</span><span class="token number">1</span><span class="token punctuation">.</span>txt        <span class="token punctuation">[</span>成功<span class="token punctuation">]</span></code></pre><ol start="6"><li>@ 用于定义一个 Location 块，且该块不能被外部 Client 所访问，只能被 nginx 内部配置指令所访问，比如 try_files or error_page</li></ol><pre class=" language-js"><code class="language-js">location  <span class="token operator">/</span> <span class="token punctuation">{</span>  root   <span class="token regex">/root/</span><span class="token punctuation">;</span>  error_page <span class="token number">404</span> @err<span class="token punctuation">;</span><span class="token punctuation">}</span>location  @err <span class="token punctuation">{</span>  # 规则  default_type text<span class="token operator">/</span>html<span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">200</span> <span class="token string">"err"</span><span class="token punctuation">;</span><span class="token punctuation">}</span># 如果 http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>localhost<span class="token operator">/</span><span class="token number">1</span><span class="token punctuation">.</span>txt <span class="token number">404</span>，将会跳转到@err并输出err</code></pre>]]></content>
      
      
      <categories>
          
          <category> nginx专题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx中的rewrite配置</title>
      <link href="2021/04/19/nginx-zhong-de-rewrite-pei-zhi/"/>
      <url>2021/04/19/nginx-zhong-de-rewrite-pei-zhi/</url>
      
        <content type="html"><![CDATA[<h2 id="Rewrite-规则"><a href="#Rewrite-规则" class="headerlink" title="Rewrite 规则"></a>Rewrite 规则</h2><p>nginx 通过 ngx_http_rewrite_module 模块支持 URI 重写、支持 if 条件判断，但不支持 else，使用 nginx 提供的全局变量或自己设置的变量，结合正则表达式和标志位实现 url 重写以及重定向。</p><p>rewrite 只能放在 *server{},location{},if{}*中，并且只能对域名后边的除去传递的参数外的字符串起作用，例如 <a href="http://seanlook.com/a/we/index.php?id=1&amp;u=str">http://seanlook.com/a/we/index.php?id=1&amp;u=str</a> 只对/a/we/index.php 重写。</p><blockquote><p>语法: rewrite regex replacement [flag];</p></blockquote><p>如果相对域名或参数字符串起作用，可以使用全局变量匹配，也可以使用 proxy_pass 反向代理。</p><h2 id="指令执行顺序"><a href="#指令执行顺序" class="headerlink" title="指令执行顺序"></a>指令执行顺序</h2><p>表明看 rewrite 和 location 功能有点像，都能实现跳转，主要区别在于 rewrite 是在同一域名内更改获取资源的路径，而 location 是对一类路径做控制访问或反向代理，可以 proxy_pass 到其他机器。很多情况下 rewrite 也会写在 location 里，它们的执行顺序是：</p><ol><li>执行 server 块的 rewrite 指令</li><li>执行 location 匹配</li><li>执行选定的 location 中的 rewrite 指令</li></ol><p>如果其中某步 URI 被重写，则重新循环执行 1-3，直到找到真实存在的文件；循环超过 10 次，则返回 500 Internal Server Error 错误。</p><h2 id="flag-标志位"><a href="#flag-标志位" class="headerlink" title="flag 标志位"></a>flag 标志位</h2><ul><li>last : 相当于 Apache 的[L]标记，表示完成 rewrite</li><li>break : 停止执行当前虚拟主机的后续 rewrite 指令集</li><li>redirect : 返回 302 临时重定向，地址栏会显示跳转后的地址</li><li>permanent : 返回 301 永久重定向，地址栏会显示跳转后的地址</li></ul><p>因为 301 和 302 不能简单的只返回状态码，还必须有重定向的 URL，这就是 return 指令无法返回 301,302 的原因了。这里 last 和 break 区别有点难以理解：</p><ol><li>last 一般写在 server 和 if 中，而 break 一般使用在 location 中</li><li>last 不终止重写后的 url 匹配，即新的 url 会再从 server 走一遍匹配流程，而 break 终止重写后的匹配</li><li>break 和 last 都能组织继续执行后面的 rewrite 指令</li></ol><p>例子：</p><pre class=" language-js"><code class="language-js">rewrite <span class="token operator">^</span><span class="token operator">/</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token operator">*</span><span class="token punctuation">)</span> http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>www<span class="token punctuation">.</span>baidu<span class="token punctuation">.</span>com<span class="token operator">/</span>$<span class="token number">1</span> permanent<span class="token punctuation">;</span></code></pre><p>说明：</p><ul><li>rewrite 为固定关键字，表示开始进行 rewrite 匹配规则。</li><li>regex 为 ^/(.*)。 这是一个正则表达式，匹配完整的域名和后面的路径地址。</li><li>replacement 就是 <a href="http://www.baidu.com/1%E8%BF%99%E5%9D%97%E4%BA%86%EF%BC%8C%E5%85%B6%E4%B8%AD1%E6%98%AF%E5%8F%96regex%E9%83%A8%E5%88%86()%E9%87%8C%E9%9D%A2%E7%9A%84%E5%86%85%E5%AE%B9%E3%80%82%E5%A6%82%E6%9E%9C%E5%8C%B9%E9%85%8D%E6%88%90%E5%8A%9F%E5%90%8E%E8%B7%B3%E8%BD%AC%E5%88%B0%E7%9A%84URL">http://www.baidu.com/1这块了，其中1是取regex部分()里面的内容。如果匹配成功后跳转到的URL</a>。</li><li>flag 就是 permanent，代表永久重定向的含义，即跳转到 <a href="http://www.baidu.com/$1">http://www.baidu.com/$1</a> 地址上。</li></ul><h2 id="理解-if-指令"><a href="#理解-if-指令" class="headerlink" title="理解 if 指令"></a>理解 if 指令</h2><p>该指令用来支持条件判断的，并且根据条件判断结果来选择不同的 nginx 的配置，我们可以在 server 块或 location 块中配置该指令，它的语法结构为：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">if</span> <span class="token punctuation">(</span>condition<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// ....</span><span class="token punctuation">}</span></code></pre><p>比如如果用户代理是手机访问的话，直接跳转到某个页面去，也可以使用 if 判断。比如如下：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">if</span> <span class="token punctuation">(</span> $http_user_agent <span class="token operator">~</span><span class="token operator">*</span> <span class="token string">"(Android)|(iPhone)|(Mobile)|(WAP)|(UCWEB)"</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>  rewrite <span class="token operator">^</span><span class="token operator">/</span>$  http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>www<span class="token punctuation">.</span>cnblogs<span class="token punctuation">.</span>com  permanent；<span class="token punctuation">}</span></code></pre><p>Rewrite 指令可用的全局变量如下：</p><ol><li>$args: 该变量中存放了请求 URL 中的请求指令。比如 <a href="http://127.0.0.1:3001/?arg1=value1&amp;arg2=value2">http://127.0.0.1:3001?arg1=value1&amp;arg2=value2</a> 中的<br>“arg1=value1&amp;arg2=value2”。</li><li>$content_length: 该变量中存放了请求头中的 Content-length 字段。</li><li>$content_type: 该变量中存放了请求头中的 Content-type 字段。</li><li>$document_root: 该变量中存放了针对当前请求的根路径。</li><li>$document_uri: 该变量中存放了请求的当前 URI, 但是不包括请求指令。比如 <a href="http://xxx.abc.com/home/1?arg1=value1">http://xxx.abc.com/home/1?arg1=value1</a>&amp;<br>arg2=value2; 中的 “/home/1”</li><li>$host: 变量中存放了请求的 URL 中的主机部分字段，比如<a href="http://xxx.abc.com:8080/home">http://xxx.abc.com:8080/home</a>中的 xxx.abc.com.</li><li>$http_host: 该变量与$host 唯一区别带有端口号：比如上面的是 xxx.abc.com:8080</li><li>$http_user_agent: 变量中存放客户端的代理信息。</li><li>$http_cookie, 该变量中存放客户端的 cookie 信息。</li><li>$remote_addr 该变量中存放客户端的地址。</li><li>$remote_port 该变量中存放了客户端与服务器建立连接的端口号。</li><li>$remote_user 变量中存放客户端的用户名。</li><li>$request_body_file 变量中存放了发给后端服务器的本地文件资源的名称</li><li>$request_method 变量中存放了客户端的请求方式，比如 ‘GET’、’POST’等。</li><li>$request_filename 变量中存放了当前请求的资源文件的路径名。</li><li>$request_uri 变量中存放了当前请求的 URI，并且带请求指令。</li><li>$query_string 和变量$args 含义一样。</li><li>$scheme 变量中存放了客户端请求使用的协议，比如 ‘http’, ‘https’等。</li><li>$server_protocol 变量中存放了客户端请求协议的版本, 比如 ‘HTTP/1.0’、’HTTP/1.1’ 等。</li></ol><pre class=" language-js"><code class="language-js">例：http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>localhost<span class="token punctuation">:</span><span class="token number">88</span><span class="token operator">/</span>test1<span class="token operator">/</span>test2<span class="token operator">/</span>test<span class="token punctuation">.</span>php$host：localhost$server_port：<span class="token number">88</span>$request_uri：http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>localhost<span class="token punctuation">:</span><span class="token number">88</span><span class="token operator">/</span>test1<span class="token operator">/</span>test2<span class="token operator">/</span>test<span class="token punctuation">.</span>php$document_uri：<span class="token operator">/</span>test1<span class="token operator">/</span>test2<span class="token operator">/</span>test<span class="token punctuation">.</span>php$document_root：<span class="token operator">/</span><span class="token keyword">var</span><span class="token operator">/</span>www<span class="token operator">/</span>html$request_filename：<span class="token operator">/</span><span class="token keyword">var</span><span class="token operator">/</span>www<span class="token operator">/</span>html<span class="token operator">/</span>test1<span class="token operator">/</span>test2<span class="token operator">/</span>test<span class="token punctuation">.</span>php</code></pre><p>现在我们使用if指令来对nginx加一些判断；比如说我们访问<a href="http://xxx.abc.com:8080/home%E6%97%B6%E5%80%99%EF%BC%8C%E5%A6%82%E6%9E%9C$host">http://xxx.abc.com:8080/home时候，如果$host</a> = ‘xxx.abc.com’ 的时候，就做重定向跳转，nginx配置代码如下：</p><pre class=" language-js"><code class="language-js">server <span class="token punctuation">{</span>  listen <span class="token number">8088</span><span class="token punctuation">;</span>  server_name xxx<span class="token punctuation">.</span>abc<span class="token punctuation">.</span>com<span class="token punctuation">;</span>  location <span class="token operator">/</span> <span class="token punctuation">{</span>    proxy_pass http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span><span class="token number">127.0</span><span class="token punctuation">.</span><span class="token number">0.1</span><span class="token punctuation">:</span><span class="token number">3001</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>$host <span class="token operator">=</span> <span class="token string">'xxx.abc.com'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      rewrite <span class="token operator">^</span><span class="token operator">/</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token operator">*</span><span class="token punctuation">)</span> http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>www<span class="token punctuation">.</span>baidu<span class="token punctuation">.</span>com redirect<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="常用正则"><a href="#常用正则" class="headerlink" title="常用正则"></a>常用正则</h2><ul><li><p>. ： 匹配除换行符以外的任意字符</p></li><li><p>? ： 重复 0 次或 1 次</p></li><li><p>+ ： 重复 1 次或更多次</p></li><li><p>* ： 重复 0 次或更多次</p></li><li><p>\d ：匹配数字</p></li><li><p>^ ： 匹配字符串的开始</p></li><li><p>$ ： 匹配字符串的介绍</p></li><li><p>{n} ： 重复 n 次</p></li><li><p>{n,} ： 重复 n 次或更多次</p></li><li><p>[c] ： 匹配单个字符 c</p></li><li><p>[a-z] ： 匹配 a-z 小写字母的任意一个</p><p>小括号()之间匹配的内容，可以在后面通过$1 来引用，$2 表示的是前面第二个()里的内容。正则里面容易让人困惑的是\转义特殊字符。</p></li></ul><h3 id="对变量进行匹配"><a href="#对变量进行匹配" class="headerlink" title="对变量进行匹配"></a>对变量进行匹配</h3><p>‘<del>‘ 表示匹配过程中对大小写敏感。<br>‘</del><em>‘ 表示匹配过程中对大小写不敏感。<br>‘!<del>‘ 如果 ‘</del>‘ 匹配失败时，那么该条件就为true。<br>‘!~</em>‘ 如果 ‘~*’ 匹配失败时，那么该条件就为true。</p><p>比如如果用户代理是手机访问的话，直接跳转到某个页面去，也可以使用 if 判断。比如如下：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">if</span> <span class="token punctuation">(</span> $http_user_agent <span class="token operator">~</span><span class="token operator">*</span> <span class="token string">"(Android)|(iPhone)|(Mobile)|(WAP)|(UCWEB)"</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>  rewrite <span class="token operator">^</span><span class="token operator">/</span>$  http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>www<span class="token punctuation">.</span>cnblogs<span class="token punctuation">.</span>com  permanent；<span class="token punctuation">}</span></code></pre><h3 id="判断请求的文件是否存在"><a href="#判断请求的文件是否存在" class="headerlink" title="判断请求的文件是否存在"></a>判断请求的文件是否存在</h3><p>-f’ 如果请求的文件存在，那么该条件为true。<br>‘!-f’ 如果该文件的目录存在，该文件不存在，那么返回true。如果该文件和目录都不存在，则为false。<br>如果请求的目录不存在，请求的文件存在，也为false。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">-</span>f $request_filename<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 判断请求的文件是否存在</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token operator">-</span>f $request_filename<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 判断请求的文件是否不存在</span><span class="token punctuation">}</span></code></pre><h3 id="判断请求的目录是否存"><a href="#判断请求的目录是否存" class="headerlink" title="判断请求的目录是否存"></a>判断请求的目录是否存</h3><p>使用 ‘-d’，如果请求的目录存在，则返回true。否则返回false。<br>使用 ‘!-d’, 如果请求的目录不存在，但是该请求的上级目录存在，则返回true。如果该上级目录不存在，则返回false…. 等等其他一些语法，不多介绍。</p>]]></content>
      
      
      <categories>
          
          <category> nginx专题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>outlook邮箱样式问题</title>
      <link href="2021/02/22/outlook-you-xiang-yang-shi-wen-ti/"/>
      <url>2021/02/22/outlook-you-xiang-yang-shi-wen-ti/</url>
      
        <content type="html"><![CDATA[<p>最近项目中发送html格式的邮件到邮箱客户端，发现邮件样式千奇百怪，不堪入目。在google里面baidu了下,才发现问题严重了。因为安全原因，各大邮箱服务商及邮件客户端都会对邮件内容进行一定程度上的处理，不会按照你写的原本 HTML 展示，尤其是前端搅屎棍微软开发的OutLook，一向特立独行，使得outlook邮箱的样式成为最难写的样式。特意总结下，留给有缘人参考。</p><h2 id="Doctype"><a href="#Doctype" class="headerlink" title="Doctype"></a>Doctype</h2><p>目前，兼容性最好的Doctype是XHTML 1.0 Strict，事实上Gmail和Hotmail会删掉你的Doctype，换上这个Doctype。使用这个Doctype，也就意味着，不能使用HTML5的语法。</p><pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span><span class="token operator">!</span>DOCTYPE html PUBLIC <span class="token string">"-//W3C//DTD XHTML 1.0 Transitional//EN"</span> <span class="token string">"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"</span><span class="token operator">></span><span class="token operator">&lt;</span>html xmlns<span class="token operator">=</span><span class="token string">"http://www.w3.org/1999/xhtml"</span><span class="token operator">></span>　<span class="token operator">&lt;</span>head<span class="token operator">></span>　　<span class="token operator">&lt;</span>meta http<span class="token operator">-</span>equiv<span class="token operator">=</span><span class="token string">"Content-Type"</span> content<span class="token operator">=</span><span class="token string">"text/html; charset=UTF-8"</span> <span class="token operator">/</span><span class="token operator">></span>　　<span class="token operator">&lt;</span>title<span class="token operator">></span>HTML Email编写指南<span class="token operator">&lt;</span><span class="token operator">/</span>title<span class="token operator">></span>　　<span class="token operator">&lt;</span>meta name<span class="token operator">=</span><span class="token string">"viewport"</span> content<span class="token operator">=</span><span class="token string">"width=device-width, initial-scale=1.0"</span><span class="token operator">/</span><span class="token operator">></span>　<span class="token operator">&lt;</span><span class="token operator">/</span>head<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>html<span class="token operator">></span></code></pre><p>我们知道完整的 HTML 包括 DOCTYPE 声明、html 和 head 标签及其内容、body 标签，对于在一个 iframe 中显示邮件内容的邮箱还好，会保留上述结构，但是有些邮件（如 Gmail）都是在 div 中直接包含，这就对安全要求极为苛刻。安全原因邮箱会默认把上述结构做删除处理，所以写了几乎没有作用，在可能的情况下尽量把内容写到 body 内，甚至建议从 table 开写，直接放弃 DOCTYPE / html / head / body 标签。</p><h2 id="页面布局"><a href="#页面布局" class="headerlink" title="页面布局"></a>页面布局</h2><p>页面布局必须使用table，因为各个邮箱对 div + css 这一套布局的解析问题很大（如 float / position 等 CSS 都会被过滤，甚至 margin: 0 auto; 都不起作用），基本各大邮箱都会解析混乱，这就意味着 HTML 邮件中几乎只有这几个元素——table / tr / td / span / img / a，尽量避免使用 div / p 或是其他标签。</p><p>而且并不是所有邮箱都支持 colspan / rowspan 属性，所以所有布局都需要使用 table 嵌套解决。</p><p>使用表格布局导致的最直接的问题就是会产生多余的空白像素，所以要养成习惯给每个 table 都加上边框 border，单元格内边距 cellpadding，单元格间距 cellspacing，边框合并属性 border-collapse 这些属性：</p><pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span>table border<span class="token operator">=</span><span class="token string">"0"</span> cellpadding<span class="token operator">=</span><span class="token string">"0"</span> cellspacing<span class="token operator">=</span><span class="token string">"0"</span> style<span class="token operator">=</span><span class="token string">"border-collapse: collapse;"</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> <span class="token operator">...</span> <span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>table<span class="token operator">></span></code></pre><h2 id="使用内联样式"><a href="#使用内联样式" class="headerlink" title="使用内联样式"></a>使用内联样式</h2><p>有些版本的邮箱解析的时候会将head里面的内容直接删了，导致样式失效。html邮件也不支持外联的css,这就意味着只有內联CSS是唯一可靠的编写样式途径。</p><h2 id="属性优先"><a href="#属性优先" class="headerlink" title="属性优先"></a>属性优先</h2><p>并不是使用 style 属性就保险了，很多邮箱会对特定标签的属性做强制改造。</p><p>比如在 OutLook 中，图片使用以下方式来设置宽高是无效的：</p><pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span>img style<span class="token operator">=</span><span class="token string">"width: 10px; height: 10px;"</span> src<span class="token operator">=</span><span class="token string">"*.png"</span> <span class="token operator">/</span><span class="token operator">></span></code></pre><p>正确的设置方法：</p><pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span>img width<span class="token operator">=</span><span class="token string">"10"</span> height<span class="token operator">=</span><span class="token string">"10"</span> src<span class="token operator">=</span><span class="token string">"*.png"</span> <span class="token operator">/</span><span class="token operator">></span></code></pre><p>所以在有属性能够实现样式效果的时候尽量使用属性，常见的可用属性有：</p><pre class=" language-js"><code class="language-js">widthheightbgcoloralignvalign……</code></pre><h2 id="样式继承"><a href="#样式继承" class="headerlink" title="样式继承"></a>样式继承</h2><p>html邮件中某些属性的继承可能失效，比如 font-family，OutLook 中若想改变字体，至少每个 table 中都要指定 font-family，而在 QQ 邮箱甚至必须每个 td 都设置 font-family 才能全部生效。因此，每个标签单独写样式是很有必要的。</p><h2 id="背景图片"><a href="#背景图片" class="headerlink" title="背景图片"></a>背景图片</h2><p>style 内容里面 background 可以设置 color，但是 image 会被过滤，就是说不能通过 CSS 来设置背景图片了。但是有一个很有意思的元素属性，也叫 background，里面可以定义一个图片路径，但是功能有限，比如无法定位背景图片等。</p><p>例如要给一个单元格加一个背景，必须这样写：</p><pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span>td background<span class="token operator">=</span><span class="token string">"*.png"</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> <span class="token operator">...</span> <span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>td<span class="token operator">></span></code></pre><h2 id="字体相关"><a href="#字体相关" class="headerlink" title="字体相关"></a>字体相关</h2><p>在 HTML 邮件中，font-family 只支持系统字体，不支持自定义字体，也不支持 font 简写，color 尽可能也不要使用简写：</p><pre class=" language-js"><code class="language-js">font<span class="token punctuation">:</span> 12px <span class="token operator">/</span> 14px Arial<span class="token punctuation">,</span> sans<span class="token operator">-</span>serif<span class="token punctuation">;</span> color<span class="token punctuation">:</span> #<span class="token number">999</span><span class="token punctuation">;</span></code></pre><p>需要写成：</p><pre class=" language-js"><code class="language-js">line<span class="token operator">-</span>height<span class="token punctuation">:</span> 14px<span class="token punctuation">;</span> font<span class="token operator">-</span>size<span class="token punctuation">:</span> 12px<span class="token punctuation">;</span> font<span class="token operator">-</span>family<span class="token punctuation">:</span> <span class="token string">"微软雅黑"</span><span class="token punctuation">,</span> Arial<span class="token punctuation">,</span> sans<span class="token operator">-</span>serif<span class="token punctuation">;</span> color<span class="token punctuation">:</span> #<span class="token number">999999</span><span class="token punctuation">;</span></code></pre><p>对于加粗字体，我们可以使用 b 标签而不是 CSS 的 font-weight，前文说过，HTML 标签和属性能解决的样式决不使用 CSS 样式。</p><h2 id="行高"><a href="#行高" class="headerlink" title="行高"></a>行高</h2><p>在 OutLook 中会有个默认的行高最小值，特别是当设置 font-family 为微软雅黑时，默认的行高差不多为 Word 中的两倍行距，如果 line-height 设置的值小于默认的行高，无论你设置的是多少，则始终使用默认值，在很多情况下这是不能忍的，好在有个神奇的 mso-line-height-rule，使用行高时添加 mso-line-height-rule:exactly; 就能使行高始终等于我们所设置的值。</p><pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span>td style<span class="token operator">=</span><span class="token string">"mso-line-height-rule: exactly; line-height: 36px;"</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> <span class="token operator">...</span> <span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>td<span class="token operator">></span></code></pre><p>这只是微软的 CSS 属性，对其他客户端没影响。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://www.ruanyifeng.com/blog/2013/06/html_email.html">HTML Email 编写指南</a></p>]]></content>
      
      
      <categories>
          
          <category> 项目总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 踩的坑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端缓存问题</title>
      <link href="2021/02/20/qian-duan-huan-cun-wen-ti/"/>
      <url>2021/02/20/qian-duan-huan-cun-wen-ti/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>彻底禁止缓存，这个需求是错误的。缓存是浏览器的功能特性，又不是 Bug。但是前端知道如何处理浏览器缓存，用户并不一定了解，特别是一些静态资源的缓存，让用户一脸懵逼，因此特意总结了下。</p><h2 id="浏览器缓存的原理"><a href="#浏览器缓存的原理" class="headerlink" title="浏览器缓存的原理"></a>浏览器缓存的原理</h2><p>浏览器的缓存分为强制缓存和协商缓存。当二次打开网页时，浏览器会先对缓存发起http请求，只要请求的资源存在缓存并且该资源的请求头expires和cache-control中存在缓存的标志，那就默认读取缓存，如果缓存失效但缓存依然存在，这时有会对服务器发出http请求，通过last-modified和etag两个请求头验证是否存在协商缓存，存在协商缓存就让浏览器照样读取缓存。</p><p>当然，如果你资源已经不存在了或者明确禁止缓存，那浏览器也不可能使用缓存，这也是解决缓存问题的办法</p><p><img src="https://7.dusays.com/2021/02/20/689c4e15f25a7.png" alt="第一次发起http请求"></p><h3 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h3><p>设置强制缓存有两个属性expires和cache-control，cache-control优先级高于 expires,常用有5个值：</p><ol><li>public:所有内容都将被缓存（客户端和代理服务器都可缓存）</li><li>private:所有内容只有客户端可以缓存</li><li>no-cache: 客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定</li><li>no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存 </li><li>max-age=xxx (xxx is numeric)：缓存内容将在xxx秒后失效</li></ol><p><img src="https://7.dusays.com/2021/02/20/0bbd461ec7cf5.png" alt="2.png"></p><p>强制缓存是否生效，可以查看控制台的network选项，下面的size属性，一般就是from memory cache或者from disk cache，一个是从内存中加载缓存，一个是硬盘中加载缓存，区别就是内存要快些，一般先是读取硬盘中的缓存，要是你刷新一下，就从内存中读取，不然刷新的时候怎么那么快</p><p><img src="https://7.dusays.com/2021/02/20/016d4a97ceaa7.png" alt="3.png"></p><h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p>当强制缓存失败，浏览器就请求服务器，如果服务器觉得用缓存没问题，资源又没有更新，那么，即使缓存设了到期时间，浏览器依然会读取，此时服务器返回304，如果资源更新了，就从服务器请求更新，返回200。如何判断资源是否更新，就是靠last-modified和etag两个请求头，这里我就不多讲了</p><p>但是要注意，强制缓存要优先于协商缓存，所以嘛，就算你更新了，浏览器依旧会读取缓存，</p><h2 id="前端解决缓存的办法"><a href="#前端解决缓存的办法" class="headerlink" title="前端解决缓存的办法"></a>前端解决缓存的办法</h2><h3 id="meta缓存头设置为禁止缓存"><a href="#meta缓存头设置为禁止缓存" class="headerlink" title="meta缓存头设置为禁止缓存"></a>meta缓存头设置为禁止缓存</h3><pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> 在入口文件index<span class="token punctuation">.</span>html中，头部添加meta标签 <span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span>meta http<span class="token operator">-</span>equiv<span class="token operator">=</span><span class="token string">"Expires"</span> content<span class="token operator">=</span><span class="token string">"0"</span><span class="token operator">></span><span class="token operator">&lt;</span>meta http<span class="token operator">-</span>equiv<span class="token operator">=</span><span class="token string">"Pragma"</span> content<span class="token operator">=</span><span class="token string">"no-cache"</span><span class="token operator">></span><span class="token operator">&lt;</span>meta http<span class="token operator">-</span>equiv<span class="token operator">=</span><span class="token string">"Cache-control"</span> content<span class="token operator">=</span><span class="token string">"no-cache"</span><span class="token operator">></span><span class="token operator">&lt;</span>meta http<span class="token operator">-</span>equiv<span class="token operator">=</span><span class="token string">"Cache"</span> content<span class="token operator">=</span><span class="token string">"no-cache"</span><span class="token operator">></span></code></pre><h3 id="静态资源加上版本号"><a href="#静态资源加上版本号" class="headerlink" title="静态资源加上版本号"></a>静态资源加上版本号</h3><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// webpack.prod.conf.js</span><span class="token keyword">const</span> Version <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>output<span class="token punctuation">:</span> <span class="token punctuation">{</span>    path<span class="token punctuation">:</span> config<span class="token punctuation">.</span>build<span class="token punctuation">.</span>assetsRoot<span class="token punctuation">,</span>    filename<span class="token punctuation">:</span> utils<span class="token punctuation">.</span><span class="token function">assetsPath</span><span class="token punctuation">(</span><span class="token string">'js/[name].[chunkhash].'</span><span class="token operator">+</span>_Version<span class="token operator">+</span><span class="token string">'js'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    chunkFilename<span class="token punctuation">:</span> utils<span class="token punctuation">.</span><span class="token function">assetsPath</span><span class="token punctuation">(</span><span class="token string">'js/[id].[chunkhash].'</span><span class="token operator">+</span>_Version<span class="token operator">+</span><span class="token string">'js'</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h3 id="服务端配置"><a href="#服务端配置" class="headerlink" title="服务端配置"></a>服务端配置</h3><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// nginx端配置</span>location <span class="token operator">=</span> <span class="token operator">/</span>index<span class="token punctuation">.</span>html <span class="token punctuation">{</span>    add_header Cache<span class="token operator">-</span>Control <span class="token string">"no-cache, no-store"</span><span class="token punctuation">;</span>    # add_header Cache<span class="token operator">-</span>Control no<span class="token operator">-</span>store<span class="token punctuation">;</span>    # add_header Pragma no<span class="token operator">-</span>cache<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="快速清理浏览器缓存"><a href="#快速清理浏览器缓存" class="headerlink" title="快速清理浏览器缓存"></a>快速清理浏览器缓存</h2><ul><li>Ctrl+shift+Del 清空浏览数据设置的快捷键，可以清除浏览数据呀，cookie呀，缓存呀，这是清除浏览器所有的缓存</li></ul><p><img src="https://7.dusays.com/2021/02/20/7380544e1f4c1.png"></p><ul><li>控制台禁止缓存 这个隐藏在控制台network选项里的，对于开发人员很好用，默认禁止缓存</li></ul><p><img src="https://7.dusays.com/2021/02/20/371f279c2667a.png"></p>]]></content>
      
      
      <categories>
          
          <category> 项目总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 踩的坑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nodejs从零起飞-模块</title>
      <link href="2021/01/20/nodejs-cong-ling-qi-fei-mo-kuai/"/>
      <url>2021/01/20/nodejs-cong-ling-qi-fei-mo-kuai/</url>
      
        <content type="html"><![CDATA[<h2 id="nodejs和javascript的区别"><a href="#nodejs和javascript的区别" class="headerlink" title="nodejs和javascript的区别"></a>nodejs和javascript的区别</h2><p>W3C 是规定 web 标准的，如 html css js-web-api 等，和 nodejs 没关系。</p><p>ECMA 是规范 js 语法的，例如变量，函数，class，if 语句等这些语法的，和具体 API 没关系。</p><p>前端 js = ECMA + js-web-api</p><p>nodejs = ECMA + node-api</p><h2 id="commonjs"><a href="#commonjs" class="headerlink" title="commonjs"></a>commonjs</h2><p>commonjs是nodejs默认有的模块化规范,每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。</p><p>module,exports,require是关键词，下列示例中演示b.js引用a.js的方式，第三方库的引用方式。</p><h3 id="module对象"><a href="#module对象" class="headerlink" title="module对象"></a>module对象</h3><p>Node内部提供一个Module构建函数。所有模块都是Module的实例。每个模块内部，都有一个module对象，代表当前模块。</p><p>module.exports属性表示当前模块对外输出的接口，其他文件加载该模块，实际上就是读取module.exports变量。</p><h3 id="require命令"><a href="#require命令" class="headerlink" title="require命令"></a>require命令</h3><p>Node使用CommonJS模块规范，内置的require命令用于加载模块文件。</p><p>require命令的基本功能是，读入并执行一个JavaScript文件，然后返回该模块的exports对象。如果没有发现指定模块，会报错。</p><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><p>a.js文件中</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">mul</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> a <span class="token operator">*</span> b<span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 单个导出</span><span class="token comment" spellcheck="true">// module.exports.add = add</span><span class="token comment" spellcheck="true">// 全部导出</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    add<span class="token punctuation">,</span>    mul<span class="token punctuation">}</span></code></pre><p>b文件中</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// node 模块导出的都是对象，所以导入 node 模块就是对一个对象进行取值。</span><span class="token keyword">const</span> <span class="token punctuation">{</span> add<span class="token punctuation">,</span> mul <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./a'</span><span class="token punctuation">)</span><span class="token keyword">const</span> _ <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'lodash'</span><span class="token punctuation">)</span><span class="token keyword">const</span> sum <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token function">mul</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token keyword">const</span> arr <span class="token operator">=</span> _<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'arr...'</span><span class="token punctuation">,</span> arr<span class="token punctuation">)</span></code></pre><h2 id="CommonJS模块的特点"><a href="#CommonJS模块的特点" class="headerlink" title="CommonJS模块的特点"></a>CommonJS模块的特点</h2><ul><li>所有代码都运行在模块作用域，不会污染全局作用域。</li><li>模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。</li><li>模块加载的顺序，按照其在代码中出现的顺序。</li></ul><h2 id="ES-modules"><a href="#ES-modules" class="headerlink" title="ES modules"></a>ES modules</h2><p>Node.js从v13.2.0，宣布开始支持ES modules。在此之前，想要在node中使用ES modules，需要添加–experimental-module。<br>v13.2.0版本后，可以直接使用ES modules了。<strong>该特性依然是实验性的（Stability: 1），不建议在生产环境中使用该功能。</strong></p><h3 id="在node中使用ES-modules"><a href="#在node中使用ES-modules" class="headerlink" title="在node中使用ES modules"></a>在node中使用ES modules</h3><p>想要在项目中使用ES modules，有以下两种方法：</p><ol><li>文件后缀名使用.mjs</li></ol><pre class=" language-js"><code class="language-js"><span class="token operator">|</span>____component<span class="token operator">|</span> <span class="token operator">|</span>____a<span class="token punctuation">.</span>mjs<span class="token operator">|</span>____index<span class="token punctuation">.</span>mjs</code></pre><p>文件内容如下：</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// a.mjs</span><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token string">'Hello World'</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> a<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// index.mjs</span><span class="token keyword">import</span> a <span class="token keyword">from</span> <span class="token string">'./a.mjs'</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ol start="2"><li>文件依然使用.js的后缀名，在项目的package.json中设置：type:module</li></ol><pre class=" language-js"><code class="language-js"><span class="token operator">|</span>____component<span class="token operator">|</span> <span class="token operator">|</span>____a<span class="token punctuation">.</span>js<span class="token operator">|</span>____package<span class="token punctuation">.</span>json<span class="token operator">|</span>____index<span class="token punctuation">.</span>js</code></pre><p>各个文件内容如下：</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// component/a.js</span><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token string">'This is component a'</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> a<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// index.js</span><span class="token keyword">import</span> a <span class="token keyword">from</span> <span class="token string">'./component/a.mjs'</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// package.json</span><span class="token punctuation">{</span>  <span class="token operator">...</span>  <span class="token string">"type"</span><span class="token punctuation">:</span> <span class="token string">"module"</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 必须要有这一行</span>  <span class="token operator">...</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> nodeJs专栏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nodejs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack基础06-公共资源提取</title>
      <link href="2021/01/17/webpack-ji-chu-06-gong-gong-zi-yuan-ti-qu/"/>
      <url>2021/01/17/webpack-ji-chu-06-gong-gong-zi-yuan-ti-qu/</url>
      
        <content type="html"><![CDATA[<h2 id="基础库分离：React示例"><a href="#基础库分离：React示例" class="headerlink" title="基础库分离：React示例"></a>基础库分离：React示例</h2><p>思路：将react、react-dom 基础包通过cdn引入，不打入bundle</p><h3 id="使用html-webpack-extends-plugin"><a href="#使用html-webpack-extends-plugin" class="headerlink" title="使用html-webpack-extends-plugin"></a>使用html-webpack-extends-plugin</h3><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> HtmlWebpackExternalsPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'html-webpack-externals-plugin'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>plugins<span class="token punctuation">:</span> <span class="token punctuation">[</span>    <span class="token keyword">new</span> <span class="token class-name">HtmlWebpackExternalsPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        externals<span class="token punctuation">:</span> <span class="token punctuation">[</span>          <span class="token punctuation">{</span>            module<span class="token punctuation">:</span> <span class="token string">'react'</span><span class="token punctuation">,</span>            entry<span class="token punctuation">:</span> <span class="token string">'https://11.url.cn/now/lib/16.2.0/react.min.js'</span><span class="token punctuation">,</span>            global<span class="token punctuation">:</span> <span class="token string">'React'</span><span class="token punctuation">,</span>          <span class="token punctuation">}</span><span class="token punctuation">,</span>          <span class="token punctuation">{</span>            module<span class="token punctuation">:</span> <span class="token string">'react-dom'</span><span class="token punctuation">,</span>            entry<span class="token punctuation">:</span> <span class="token string">'https://11.url.cn/now/lib/16.2.0/react-dom.min.js'</span><span class="token punctuation">,</span>            global<span class="token punctuation">:</span> <span class="token string">'ReactDOM'</span><span class="token punctuation">,</span>          <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">]</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">]</span></code></pre><p>效果如图 </p><p><img src="https://7.dusays.com/2021/01/18/729f3fe8cc21d.png" alt="image"></p><h3 id="使用-SplitChunksPlugin-进行公共脚本分离"><a href="#使用-SplitChunksPlugin-进行公共脚本分离" class="headerlink" title="使用 SplitChunksPlugin 进行公共脚本分离"></a>使用 SplitChunksPlugin 进行公共脚本分离</h3><p>webpack4 内置的，替代 CommonsChunkPlugin（webpack3使用的多） 插件，SplitChunksPlugin介绍请参考官方文档</p><p>chunks参数说明：</p><ul><li>async: 异步引入的库进行分离（默认）</li><li>initial: 同步引入的库进行分离</li><li>all: 所以引入的库进行分离（推荐）</li></ul><pre class=" language-js"><code class="language-js">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//...</span>  optimization<span class="token punctuation">:</span> <span class="token punctuation">{</span>    splitChunks<span class="token punctuation">:</span> <span class="token punctuation">{</span>      chunks<span class="token punctuation">:</span> <span class="token string">'async'</span><span class="token punctuation">,</span>      minSize<span class="token punctuation">:</span> <span class="token number">30000</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 分离包体积的大小</span>      maxSize<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span>      minChunks<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">// 设置最小引用次数为2次</span>      maxAsyncRequests<span class="token punctuation">:</span> <span class="token number">5</span><span class="token punctuation">,</span>        maxInitialRequests<span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">,</span>      automaticNameDelimiter<span class="token punctuation">:</span> <span class="token string">'~'</span><span class="token punctuation">,</span>      automaticNameMaxLength<span class="token punctuation">:</span> <span class="token number">30</span><span class="token punctuation">,</span>      name<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>      cacheGroups<span class="token punctuation">:</span> <span class="token punctuation">{</span>        vendors<span class="token punctuation">:</span> <span class="token punctuation">{</span>          test<span class="token punctuation">:</span> <span class="token regex">/[\\/]node_modules[\\/]/</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">// 匹配出需要分离的包</span>          priority<span class="token punctuation">:</span> <span class="token operator">-</span><span class="token number">10</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token keyword">default</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>          minChunks<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span>          priority<span class="token punctuation">:</span> <span class="token operator">-</span><span class="token number">20</span><span class="token punctuation">,</span>          reuseExistingChunk<span class="token punctuation">:</span> <span class="token boolean">true</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//三方库分离</span> optimization<span class="token punctuation">:</span><span class="token punctuation">{</span>        splitChunks<span class="token punctuation">:</span> <span class="token punctuation">{</span>            cacheGroups<span class="token punctuation">:</span> <span class="token punctuation">{</span>                commons<span class="token punctuation">:</span> <span class="token punctuation">{</span>                    test<span class="token punctuation">:</span> <span class="token regex">/(react|react-dom)/</span><span class="token punctuation">,</span>                    name<span class="token punctuation">:</span> <span class="token string">"vendors"</span><span class="token punctuation">,</span>                    chunks<span class="token punctuation">:</span> <span class="token string">"all"</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//公共脚本分离</span> optimization<span class="token punctuation">:</span><span class="token punctuation">{</span>        splitChunks<span class="token punctuation">:</span> <span class="token punctuation">{</span>            minSize<span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">,</span>            cacheGroups<span class="token punctuation">:</span> <span class="token punctuation">{</span>                commons<span class="token punctuation">:</span><span class="token punctuation">{</span>                    name<span class="token punctuation">:</span><span class="token string">'commons'</span><span class="token punctuation">,</span>                    chunks<span class="token punctuation">:</span><span class="token string">"all"</span><span class="token punctuation">,</span>                    minChunks<span class="token punctuation">:</span><span class="token number">2</span> <span class="token comment" spellcheck="true">//至少引用2次，才打包出commons文件</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>引入方法</p><pre class=" language-js"><code class="language-js"><span class="token keyword">new</span> <span class="token class-name">HTMLWebpackPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  chunks<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token string">"vendors"</span><span class="token punctuation">,</span>pageName<span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> webpack专区 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack基础05-多页面打包的方案</title>
      <link href="2021/01/07/webpack-ji-chu-05-duo-ye-mian-da-bao/"/>
      <url>2021/01/07/webpack-ji-chu-05-duo-ye-mian-da-bao/</url>
      
        <content type="html"><![CDATA[<h1 id="多页面（MPA）应用打包方案"><a href="#多页面（MPA）应用打包方案" class="headerlink" title="多页面（MPA）应用打包方案"></a>多页面（MPA）应用打包方案</h1><blockquote><p>每次页面跳转，服务器都会返回一个新的html文档，这中类型的网站就叫多页面应用。</p></blockquote><h2 id="多页面应用方案"><a href="#多页面应用方案" class="headerlink" title="多页面应用方案"></a>多页面应用方案</h2><p>在webpack里，每个页面对应一个 entry，一个html-webpack-plugin。<br>缺点：每次新增或删除页面都需要修改 webpack 配置。</p><pre class=" language-javascript"><code class="language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    entry<span class="token punctuation">:</span> <span class="token punctuation">{</span>        index<span class="token punctuation">:</span> <span class="token string">'./src/index.js'</span><span class="token punctuation">,</span>        search<span class="token punctuation">:</span> <span class="token string">'./src/search.js'</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><ol><li><p>解决方案1：动态获取 entry 和设置 html-webpack-plugin 数量</p></li><li><p>解决方案2：利用 glob.sync</p></li></ol><p>glob库</p><pre class=" language-javascript"><code class="language-javascript">entry<span class="token punctuation">:</span> glob<span class="token punctuation">.</span><span class="token function">sync</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'./src/*/index.js'</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>这两个解决方案的前提是把入口文件放到 /src/*/index.js 下，所以的入口文件都叫index.js，通过二级目录来区分。</p><pre class=" language-javascript"><code class="language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    entry<span class="token punctuation">:</span> <span class="token punctuation">{</span>        index<span class="token punctuation">:</span> <span class="token string">'./src/index/index.js'</span><span class="token punctuation">,</span>        search<span class="token punctuation">:</span> <span class="token string">'./src/search/index.js'</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>如果使用glob库的话，</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> setMPA <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> entry <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> htmlWebpackPlugins <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> entryFiles <span class="token operator">=</span> glob<span class="token punctuation">.</span><span class="token function">sync</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'./src/*/index.js'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>entryFiles<span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">const</span> entryFile <span class="token operator">=</span> entryFiles<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// '/Users/cpselvis/my-project/src/index/index.js'</span>            <span class="token keyword">const</span> match <span class="token operator">=</span> entryFile<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span><span class="token regex">/src\/(.*)\/index\.js/</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">const</span> pageName <span class="token operator">=</span> match <span class="token operator">&amp;&amp;</span> match<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            entry<span class="token punctuation">[</span>pageName<span class="token punctuation">]</span> <span class="token operator">=</span> entryFile<span class="token punctuation">;</span>            htmlWebpackPlugins<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>                <span class="token keyword">new</span> <span class="token class-name">HtmlWebpackPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>                    inlineSource<span class="token punctuation">:</span> <span class="token string">'.css$'</span><span class="token punctuation">,</span>                    template<span class="token punctuation">:</span> path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token template-string"><span class="token string">`src/</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>pageName<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">/index.html`</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span>                    filename<span class="token punctuation">:</span> <span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>pageName<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">.html`</span></span><span class="token punctuation">,</span>                    chunks<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'vendors'</span><span class="token punctuation">,</span> pageName<span class="token punctuation">]</span><span class="token punctuation">,</span>                    inject<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>                    minify<span class="token punctuation">:</span> <span class="token punctuation">{</span>                        html5<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>                        collapseWhitespace<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>                        preserveLineBreaks<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>                        minifyCSS<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>                        minifyJS<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>                        removeComments<span class="token punctuation">:</span> <span class="token boolean">false</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span>            <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">{</span>        entry<span class="token punctuation">,</span>        htmlWebpackPlugins    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">const</span> <span class="token punctuation">{</span>entry <span class="token punctuation">,</span>htmlWebpackPlugins<span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">setMPA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>module<span class="token punctuation">.</span><span class="token keyword">export</span> <span class="token operator">=</span> <span class="token punctuation">{</span>     entry<span class="token punctuation">:</span> entry<span class="token punctuation">,</span>     plugins<span class="token punctuation">:</span> <span class="token punctuation">[</span>        <span class="token keyword">new</span> <span class="token class-name">CleanWebpackPlugin</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>htmlWebpackPlugins<span class="token punctuation">)</span>    <span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> webpack专区 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端权限管理</title>
      <link href="2021/01/05/qian-duan-quan-xian-guan-li/"/>
      <url>2021/01/05/qian-duan-quan-xian-guan-li/</url>
      
        <content type="html"><![CDATA[<h2 id="接口权限"><a href="#接口权限" class="headerlink" title="接口权限"></a>接口权限</h2><blockquote><p>接口权限目前一般采用==jwt==的形式来验证，没有通过的话一般返回401，跳转到登录页面重新进行登录。</p></blockquote><p>登录完拿到token，将token存起来，通过axios请求拦截器进行拦截，每次请求的时候头部携带token。</p><pre><code>axios.interceptors.request.use(config =&gt; {    config.headers['token'] = cookie.get('token')    return config})axios.interceptors.response.use(res=&gt;{},{response}=&gt;{    if (response.data.code === 40099 || response.data.code === 40098) { //token过期或者错误        router.push('/login')    }})</code></pre><h2 id="路由权限控制"><a href="#路由权限控制" class="headerlink" title="路由权限控制"></a>路由权限控制</h2><blockquote><p>用户登录后只能看到自己有权访问的导航菜单，也只能访问自己有权访问的路由地址，否则将跳转 4xx 提示页</p></blockquote><p>初始化即挂载全部路由，并且在路由上标记相应的权限信息，每次路由跳转前做校验。</p><pre><code>const routerMap = [  {    path: '/permission',    component: Layout,    redirect: '/permission/index',    alwaysShow: true, // will always show the root menu    meta: {      title: 'permission',      icon: 'lock',      roles: ['admin', 'editor'] // you can set roles in root nav    },    children: [{      path: 'page',      component: () =&gt; import('@/views/permission/page'),      name: 'pagePermission',      meta: {        title: 'pagePermission',        roles: ['admin'] // or you can only set roles in sub nav      }    }, {      path: 'directive',      component: () =&gt; import('@/views/permission/directive'),      name: 'directivePermission',      meta: {        title: 'directivePermission'        // if do not set roles, means: this page does not require permission      }    }]  }]</code></pre><p>登录后，获取用户的权限信息，然后筛选有权限访问的路由，在全局路由守卫里进行调用==addRoutes==添加路由</p><pre><code>import router from './router'import store from './store'import { Message } from 'element-ui'import NProgress from 'nprogress' // progress barimport 'nprogress/nprogress.css'// progress bar styleimport { getToken } from '@/utils/auth' // getToken from cookieNProgress.configure({ showSpinner: false })// NProgress Configuration// permission judge functionfunction hasPermission(roles, permissionRoles) {  if (roles.indexOf('admin') &gt;= 0) return true // admin permission passed directly  if (!permissionRoles) return true  return roles.some(role =&gt; permissionRoles.indexOf(role) &gt;= 0)}const whiteList = ['/login', '/authredirect']// no redirect whitelistrouter.beforeEach((to, from, next) =&gt; {  NProgress.start() // start progress bar  if (getToken()) { // determine if there has token    /* has token*/    if (to.path === '/login') {      next({ path: '/' })      NProgress.done() // if current page is dashboard will not trigger afterEach hook, so manually handle it    } else {      if (store.getters.roles.length === 0) { // 判断当前用户是否已拉取完user_info信息        store.dispatch('GetUserInfo').then(res =&gt; { // 拉取user_info          const roles = res.data.roles // note: roles must be a array! such as: ['editor','develop']          store.dispatch('GenerateRoutes', { roles }).then(() =&gt; { // 根据roles权限生成可访问的路由表            router.addRoutes(store.getters.addRouters) // 动态添加可访问路由表            next({ ...to, replace: true }) // hack方法 确保addRoutes已完成 ,set the replace: true so the navigation will not leave a history record          })        }).catch((err) =&gt; {          store.dispatch('FedLogOut').then(() =&gt; {            Message.error(err || 'Verification failed, please login again')            next({ path: '/' })          })        })      } else {        // 没有动态改变权限的需求可直接next() 删除下方权限判断 ↓        if (hasPermission(store.getters.roles, to.meta.roles)) {          next()//        } else {          next({ path: '/401', replace: true, query: { noGoBack: true }})        }        // 可删 ↑      }    }  } else {    /* has no token*/    if (whiteList.indexOf(to.path) !== -1) { // 在免登录白名单，直接进入      next()    } else {      next('/login') // 否则全部重定向到登录页      NProgress.done() // if current page is login will not trigger afterEach hook, so manually handle it    }  }})router.afterEach(() =&gt; {  NProgress.done() // finish progress bar})</code></pre><p>按需挂载，路由就需要知道用户的路由权限，也就是在用户登录进来的时候就要知道当前用户拥有哪些路由权限</p><p>这种方式也存在了以下的缺点：</p><ul><li>全局路由守卫里，每次路由跳转都要做判断</li><li>菜单信息写死在前端，要改个显示文字或权限信息，需要重新编译</li><li>菜单跟路由耦合在一起，定义路由的时候还有添加菜单显示标题，图标之类的信息，而且路由不一定作为菜单显示，还要多加字段进行标识</li></ul><h2 id="菜单权限"><a href="#菜单权限" class="headerlink" title="菜单权限"></a>菜单权限</h2><p>菜单权限可以理解成将页面与路由进行解耦</p><h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h3><p>菜单与路由分离，菜单由后端返回<br>前端定义路由信息</p><pre><code>{    name: "login",    path: "/login",    component: () =&gt; import("@/pages/Login.vue")}</code></pre><p>name字段都不为空，需要根据此字段与后端返回菜单做关联，后端返回的菜单信息中必须要有name对应的字段，并且做唯一性校验</p><p>全局路由守卫里做判断</p><pre><code>function hasPermission(router, accessMenu) {  if (whiteList.indexOf(router.path) !== -1) {    return true;  }  let menu = Util.getMenuByName(router.name, accessMenu);  if (menu.name) {    return true;  }  return false;}Router.beforeEach(async (to, from, next) =&gt; {  if (getToken()) {    let userInfo = store.state.user.userInfo;    if (!userInfo.name) {      try {        await store.dispatch("GetUserInfo")        await store.dispatch('updateAccessMenu')        if (to.path === '/login') {          next({ name: 'home_index' })        } else {          //Util.toDefaultPage([...routers], to.name, router, next);          next({ ...to, replace: true })//菜单权限更新完成,重新进一次当前路由        }      }        catch (e) {        if (whiteList.indexOf(to.path) !== -1) { // 在免登录白名单，直接进入          next()        } else {          next('/login')        }      }    } else {      if (to.path === '/login') {        next({ name: 'home_index' })      } else {        if (hasPermission(to, store.getters.accessMenu)) {          Util.toDefaultPage(store.getters.accessMenu,to, routes, next);        } else {          next({ path: '/403',replace:true })        }      }    }  } else {    if (whiteList.indexOf(to.path) !== -1) { // 在免登录白名单，直接进入      next()    } else {      next('/login')    }  }  let menu = Util.getMenuByName(to.name, store.getters.accessMenu);  Util.title(menu.title);});Router.afterEach((to) =&gt; {  window.scrollTo(0, 0);});</code></pre><p>每次路由跳转的时候都要判断权限，这里的判断也很简单，因为菜单的name与路由的name是一一对应的，而后端返回的菜单就已经是经过权限过滤的。</p><p>如果根据路由name找不到对应的菜单，就表示用户有没权限访问。</p><p>如果路由很多，可以在应用初始化的时候，只挂载不需要权限控制的路由。取得后端返回的菜单后，根据菜单与路由的对应关系，筛选出可访问的路由，通过==addRoutes==动态挂载。</p><p>这种方式的缺点：</p><ul><li>菜单需要与路由做一一对应，前端添加了新功能，需要通过菜单管理功能添加新的菜单，如果菜单配置的不对会导致应用不能正常使用</li><li>全局路由守卫里，每次路由跳转都要做判断</li></ul><h3 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h3><p>菜单和路由都由后端返回，<br>前端统一定义路由组件。</p><pre><code>const Home = () =&gt; import("../pages/Home.vue");const UserInfo = () =&gt; import("../pages/UserInfo.vue");export default {    home: Home,    userInfo: UserInfo};</code></pre><p>后端路由组件返回以下格式</p><pre><code>[    {        name: "home",        path: "/",        component: "home"    },    {        name: "home",        path: "/userinfo",        component: "userInfo"    }]</code></pre><p>在将后端返回路由通过addRoutes动态挂载之间，需要将数据处理一下，将component字段换为真正的组件<br>如果有嵌套路由，后端功能设计的时候，要注意添加相应的字段，前端拿到数据也要做相应的处理。</p><p>这种方法也会存在缺点：</p><ul><li>全局路由守卫里，每次路由跳转都要做判断</li><li>前后端的配合要求更高</li></ul><h2 id="按钮权限"><a href="#按钮权限" class="headerlink" title="按钮权限"></a>按钮权限</h2><h3 id="方案一-1"><a href="#方案一-1" class="headerlink" title="方案一"></a>方案一</h3><p>按钮权限也可以用v-if判断<br>但是如果页面过多，每个页面页面都要获取用户权限role和路由表里的meta.btnPermissions，然后再做判断<br>这种方式就不展开举例了</p><h3 id="方案二-1"><a href="#方案二-1" class="headerlink" title="方案二"></a>方案二</h3><blockquote><p>通过自定义指令进行按钮权限的判断</p></blockquote><p>首先配置路由</p><pre><code>{    path: '/permission',    component: Layout,    name: '权限测试',    meta: {        btnPermissions: ['admin', 'supper', 'normal']    },    //页面需要的权限    children: [{        path: 'supper',        component: _import('system/supper'),        name: '权限测试页',        meta: {            btnPermissions: ['admin', 'supper']        } //页面需要的权限    },    {        path: 'normal',        component: _import('system/normal'),        name: '权限测试页',        meta: {            btnPermissions: ['admin']        } //页面需要的权限    }]}</code></pre><p>自定义权限鉴定指令</p><pre><code>import Vue from 'vue'/**权限指令**/const has = Vue.directive('has', {    bind: function (el, binding, vnode) {        // 获取页面按钮权限        let btnPermissionsArr = [];        if(binding.value){            // 如果指令传值，获取指令参数，根据指令参数和当前登录人按钮权限做比较。            btnPermissionsArr = Array.of(binding.value);        }else{            // 否则获取路由中的参数，根据路由的btnPermissionsArr和当前登录人按钮权限做比较。            btnPermissionsArr = vnode.context.$route.meta.btnPermissions;        }        if (!Vue.prototype.$_has(btnPermissionsArr)) {            el.parentNode.removeChild(el);        }    }});// 权限检查方法Vue.prototype.$_has = function (value) {    let isExist = false;    // 获取用户按钮权限    let btnPermissionsStr = sessionStorage.getItem("btnPermissions");    if (btnPermissionsStr == undefined || btnPermissionsStr == null) {        return false;    }    if (value.indexOf(btnPermissionsStr) &gt; -1) {        isExist = true;    }    return isExist;};export {has}</code></pre><p>在使用的按钮中只需要引用v-has指令</p><pre><code>&lt;el-button @click='editClick' type="primary" v-has&gt;编辑&lt;/el-button&gt;</code></pre><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>关于权限如何选择哪种合适的方案，可以根据自己项目的方案项目，如考虑路由与菜单是否分离<br>权限需要前后端结合，前端尽可能的去控制，更多的需要后台判断</p>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> 项目总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx超时设置</title>
      <link href="2020/12/16/nginx-chao-shi-she-zhi/"/>
      <url>2020/12/16/nginx-chao-shi-she-zhi/</url>
      
        <content type="html"><![CDATA[<p>nginx访问出现504 Gateway Time-out，一般是由于程序执行时间过长导致响应超时，例如程序需要执行90秒，而nginx最大响应等待时间为30秒，这样就会出现超时。</p><h2 id="导致超时的场景"><a href="#导致超时的场景" class="headerlink" title="导致超时的场景"></a>导致超时的场景</h2><ol><li>程序在处理大量数据，导致等待超时。</li><li>程序中调用外部请求，而外部请求响应超时。</li><li>连接数据库失败而没有停止，死循环重新连。</li></ol><h2 id="nginx常用的超时配置说明"><a href="#nginx常用的超时配置说明" class="headerlink" title="nginx常用的超时配置说明"></a>nginx常用的超时配置说明</h2><h3 id="client-header-timeout"><a href="#client-header-timeout" class="headerlink" title="client_header_timeout"></a>client_header_timeout</h3><p>语法 client_header_timeout time<br>默认值 60s<br>上下文 http server<br>说明 指定等待client发送一个请求头的超时时间（例如：GET / HTTP/1.1）.仅当在一次read中，没有收到请求头，才会算成超时。如果在超时时间内，client没发送任何东西，nginx返回HTTP状态码408(“Request timed out”)</p><h3 id="client-body-timeout"><a href="#client-body-timeout" class="headerlink" title="client_body_timeout"></a>client_body_timeout</h3><p>语法 client_body_timeout time<br>默认值 60s<br>上下文 http server location<br>说明 该指令设置请求体（request body）的读超时时间。仅当在一次readstep中，没有得到请求体，就会设为超时。超时后，nginx返回HTTP状态码408(“Request timed out”)</p><h3 id="keepalive-timeout"><a href="#keepalive-timeout" class="headerlink" title="keepalive_timeout"></a>keepalive_timeout</h3><p>语法 keepalive_timeout timeout [ header_timeout ]<br>默认值 75s<br>上下文 http server location<br>说明 第一个参数指定了与client的keep-alive连接超时时间。服务器将会在这个时间后关闭连接。可选的第二个参数指定了在响应头Keep-Alive: timeout=time中的time值。这个头能够让一些浏览器主动关闭连接，这样服务器就不必要去关闭连接了。没有这个参数，nginx不会发送Keep-Alive响应头（尽管并不是由这个头来决定连接是否“keep-alive”）<br>两个参数的值可并不相同</p><p>注意不同浏览器怎么处理“keep-alive”头<br>MSIE和Opera忽略掉”Keep-Alive: timeout=<n>“ header.<br>MSIE保持连接大约60-65秒，然后发送TCP RST<br>Opera永久保持长连接<br>Mozilla keeps the connection alive for N plus about 1-10 seconds.<br>Konqueror保持长连接N秒</n></p><h3 id="lingering-timeout"><a href="#lingering-timeout" class="headerlink" title="lingering_timeout"></a>lingering_timeout</h3><p>语法 lingering_timeout time<br>默认值 5s<br>上下文 http server location<br>说明 lingering_close生效后，在关闭连接前，会检测是否有用户发送的数据到达服务器，如果超过lingering_timeout时间后还没有数据可读，就直接关闭连接；否则，必须在读取完连接缓冲区上的数据并丢弃掉后才会关闭连接。</p><h3 id="resolver-timeout"><a href="#resolver-timeout" class="headerlink" title="resolver_timeout"></a>resolver_timeout</h3><p>语法 resolver_timeout time<br>默认值 30s<br>上下文 http server location<br>说明 该指令设置DNS解析超时时间</p><h3 id="proxy-connect-timeout"><a href="#proxy-connect-timeout" class="headerlink" title="proxy_connect_timeout"></a>proxy_connect_timeout</h3><p>语法 proxy_connect_timeout time<br>默认值 60s<br>上下文 http server location<br>说明 该指令设置与upstream server的连接超时时间，有必要记住，这个超时不能超过75秒。<br>这个不是等待后端返回页面的时间，那是由proxy_read_timeout声明的。如果你的upstream服务器起来了，但是hanging住了（例如，没有足够的线程处理请求，所以把你的请求放到请求池里稍后处理），那么这个声明是没有用的，由于与upstream服务器的连接已经建立了。</p><h3 id="proxy-read-timeout"><a href="#proxy-read-timeout" class="headerlink" title="proxy_read_timeout"></a>proxy_read_timeout</h3><p>语法 proxy_read_timeout time<br>默认值 60s<br>上下文 http server location<br>说明 该指令设置与代理服务器的读超时时间。它决定了nginx会等待多长时间来获得请求的响应。这个时间不是获得整个response的时间，而是两次reading操作的时间。</p><h3 id="proxy-send-timeout"><a href="#proxy-send-timeout" class="headerlink" title="proxy_send_timeout"></a>proxy_send_timeout</h3><p>语法 proxy_send_timeout time<br>默认值 60s<br>上下文 http server location<br>说明 这个指定设置了发送请求给upstream服务器的超时时间。超时设置不是为了整个发送期间，而是在两次write操作期间。如果超时后，upstream没有收到新的数据，nginx会关闭连接</p><h3 id="proxy-upstream-fail-timeout（fail-timeout）"><a href="#proxy-upstream-fail-timeout（fail-timeout）" class="headerlink" title="proxy_upstream_fail_timeout（fail_timeout）"></a>proxy_upstream_fail_timeout（fail_timeout）</h3><p>语法 server address [fail_timeout=30s]<br>默认值 10s<br>上下文 upstream<br>说明 Upstream模块下 server指令的参数，设置了某一个upstream后端失败了指定次数（max_fails）后，该后端不可操作的时间，默认为10秒</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="请求超时"><a href="#请求超时" class="headerlink" title="请求超时"></a>请求超时</h3><pre><code>http {    include       mime.types;    server_names_hash_bucket_size  512;         default_type  application/octet-stream;    sendfile        on;    keepalive_timeout  65;  #保持    tcp_nodelay on;    client_header_timeout 15;    client_body_timeout 15;    send_timeout 25;    include vhosts/*.conf;}</code></pre><h3 id="后端服务器处理请求的时间设置"><a href="#后端服务器处理请求的时间设置" class="headerlink" title="后端服务器处理请求的时间设置"></a>后端服务器处理请求的时间设置</h3><p>如果只集成了一台nginx机器不用设置</p><pre><code>location / {        ...        proxy_read_timeout 150;  # 秒        ...    }</code></pre>]]></content>
      
      
      <categories>
          
          <category> nginx专题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack基础04-文件指纹策略</title>
      <link href="2020/12/11/webpack-ji-chu-04-wen-jian-zhi-wen-ce-lue/"/>
      <url>2020/12/11/webpack-ji-chu-04-wen-jian-zhi-wen-ce-lue/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>webpack的指纹策略是通过给文件加上hash后缀，做到当代码有修改时打包出来的文件后缀也会修改，从而可以把静态资源开启持久缓存，这样每次有更新的代码打包后生成的都是新的问题件，从而最大程度上使用缓存。</p><h2 id="文件指纹类型"><a href="#文件指纹类型" class="headerlink" title="文件指纹类型"></a>文件指纹类型</h2><p>webpack提供了三种hash类似</p><h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><p>和整个项目构建相关，只要一个文件有修改，整个项目的hash值就会改变。<br>例如</p><pre><code>// webpack.prod.jsentry: {    index: "./src/index",        search: "./src/search"},output: {    path: path.join(__dirname, "dist"),    filename: "[name]_[hash:8].js",    publicPath: "./dist"}</code></pre><p>它的问题是当项目有多入口或者使用code spliting，只要有一个文件修改打包的生成的js代码hash都会改变。不利于缓存。</p><h3 id="chunkhash"><a href="#chunkhash" class="headerlink" title="chunkhash"></a>chunkhash</h3><p>模块的hash，根据模块的修改才改变对应的hash值。<br>根据不同的入口文件(Entry)进行依赖文件解析、构建对应的chunk，生成对应的哈希值。我们在生产环境里把一些公共库和程序入口文件区分开，单独打包构建，接着我们采用chunkhash的方式生成哈希值，那么只要我们不改动公共库的代码，就可以保证其哈希值不会受影响</p><pre><code>output: {    path: path.resolve(__dirname, 'dist'),    filename: '[name]_[chunkhash:8].js'},</code></pre><h3 id="contenthash"><a href="#contenthash" class="headerlink" title="contenthash"></a>contenthash</h3><p>据文件内容来定义 hash ，文件内容不变，则 contenthash 不变。</p><p>某个页面既有js资源，又有css资源。如果css资源也使用Chunkhash。如果修改了js。由于css资源使用了Chunkhash，就会导致css内容没有变化，发布上线的文件却发生了变化。因此，通常对css资源使用Contenthash。这个时候可以使用mini-css-extract-plugin里的contenthash值，保证即使css文件所处的模块里就算其他文件内容改变，只要css文件内容不变，那么不会重复构建</p><pre><code>module.exports = {    entry: {        app: './src/app.js',        search: './src/search.js'    },    output: {        filename: '[name][chunkhash:8].js',        path: __dirname + '/dist'    },    plugins: [        new MiniCssExtractPlugin({            filename: `[name][contenthash:8].css`        }),    ]};</code></pre><h3 id="图片，字体文件的文件指纹设置"><a href="#图片，字体文件的文件指纹设置" class="headerlink" title="图片，字体文件的文件指纹设置"></a>图片，字体文件的文件指纹设置</h3><p>设置 file-loader（或url-loader） 的 name，使用 [hash]<br>图片，字体文件的hash和css/js资源的hash概念不一样，图片，字体文件的hash是由内容决定的</p><pre><code>{    test: /\.(png|svg|jpg|gif)$/,    use: [{        loader: 'file-loader',        options: {            name: 'img/[name][hash:8].[ext] '        }    }]}</code></pre>]]></content>
      
      
      <categories>
          
          <category> webpack专区 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack基础03-文件监听</title>
      <link href="2020/12/10/webpack-ji-chu-03-wen-jian-jian-ting/"/>
      <url>2020/12/10/webpack-ji-chu-03-wen-jian-jian-ting/</url>
      
        <content type="html"><![CDATA[<p>文件监听是指发现源码改变，自动重新构建出新的输出文件。</p><h2 id="webpack文件监听方式"><a href="#webpack文件监听方式" class="headerlink" title="webpack文件监听方式"></a>webpack文件监听方式</h2><p>webpack开启文件监听的方式有两种：</p><ol><li>启动webpack时带上 –watch参数,但是需要手动刷新浏览器</li></ol><pre><code>"scripts": {    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1",    "build": "webpack",    "watch": "webpack --watch"  },</code></pre><p>唯一缺点需要手动刷新浏览器。</p><ol start="2"><li>在配置webpack.config.js中设置watch:true</li></ol><pre><code>module.export = {        // 默认false也就是不开启        watch: true，        watchOptions: {            // 监听到数据变化后延迟600毫秒            aggregateTimeout: 600,            // 监听大量文件会导致大量的 CPU 或内存占用。可以使用正则排除            ignored: /node_modules/,            // 指定毫秒为单位进行轮询,每一秒检查一次变动            poll:1000        }    }</code></pre><h2 id="文件监听原理分析"><a href="#文件监听原理分析" class="headerlink" title="文件监听原理分析"></a>文件监听原理分析</h2><p>在webpack中监听一个文件发生变化的原理是定时的去获取这个文件的最后编辑时间，每次都存下最新的最后编辑时间，如果发现当前获取的和最后一次保存的最后编辑时间不一致，就认为该文件发生了变化。配置项中的watchOptions.poll就是用于控制定时检查的周期，具体含义是检查多少次。</p><p>当发现某个文件发生了变化，并不会立刻告诉监听者，而是先换成起来，收集一段时间的变化后，再一次性告诉监听者，配置项中的watchOptions.aggregateTimeout就是用于配置这个等待时间。这样做的目的是因为我们在编辑代码的过程中可能会高频的输入文字导致文件变化的事件高频的发生，如果每次都重新执行构建就会让构建卡死。</p><h2 id="热更新方式和原理"><a href="#热更新方式和原理" class="headerlink" title="热更新方式和原理"></a>热更新方式和原理</h2><h3 id="热更新的两种方式"><a href="#热更新的两种方式" class="headerlink" title="热更新的两种方式"></a>热更新的两种方式</h3><ol><li>webpack-dev-server</li></ol><p>wds 通常与 HotModuleReplacementPlugin插件一起使用，wds的一个比较大的优势是，它没有磁盘的io,输出完之后放到内存中，而不是输出为文件，所以构建速度会有一个较大的优势。</p><pre><code>const webpack = require('webpack')module.exports = {  devServer: {    // 开启 HMR 特性    hot: true  },  plugins: [    // HMR 特性所需要的插件    new webpack.HotModuleReplacementPlugin()  ]}</code></pre><ol start="2"><li>webpack-dev-middleware</li></ol><p>WDM 将 webpack 输出的文件传输给服务器,使用于灵活的定制场景。</p><pre><code>const express = require('express');const webpack = require('webpack');const webpackDevMiddleware = require('webpack-dev-middleware');const app = express();const config = require('./webpack.config.js');const compiler = webpack(config);app.use(webpackDevMiddleware(compiler,{    publicPath: config.output.publicPath}));app.listen(3000,function(){    console.log('Example app listening on post 3000\n')})</code></pre><h3 id="热更新原理"><a href="#热更新原理" class="headerlink" title="热更新原理"></a>热更新原理</h3><ul><li>Webpack Compile: 将JS编译成Bundle</li><li>HMR Server： 将热更新的文件输出给HMR Runtime</li><li>Bundle server: 提供文件在浏览器的访问</li><li>HMR Runtime: 会被注入到浏览器，更新文件的变化</li><li>bundle.js 构建输出的文件</li></ul><p><img src="https://7.dusays.com/2020/12/11/04a511854b09e.png"></p>]]></content>
      
      
      <categories>
          
          <category> webpack专区 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack基础02-静态资源处理</title>
      <link href="2020/12/08/webpack-ji-chu-02-jing-tai-zi-yuan-chu-li/"/>
      <url>2020/12/08/webpack-ji-chu-02-jing-tai-zi-yuan-chu-li/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文主要讲述样式文件，图片和字体资源的解析，html,css,js的压缩</p></blockquote><h2 id="解析css-sass-less"><a href="#解析css-sass-less" class="headerlink" title="解析css,sass,less"></a>解析css,sass,less</h2><p>css-loader: 用于加载.css文件，并且转换成commomjs对象<br>style-loader: 将样式通过<style>标签插入到head中<br>less-loader:将less转换成css</p><pre><code>module: &#123;        rules: [            &#123;                 test: /\.css$/,                 use: [                    &#39;style-loader&#39;,                    &#39;css-loader&#39;                ]            &#125;,            &#123;                 test: /\.less$/,                 use: [                    &#39;style-loader&#39;,                    &#39;css-loader&#39;,                    &#39;less-loader&#39;                ]            &#125;        ]    &#125;</code></pre><h2 id="图片和字体资源解析"><a href="#图片和字体资源解析" class="headerlink" title="图片和字体资源解析"></a>图片和字体资源解析</h2><p>file-loader: 用于处理图片和字体</p><pre><code>module: &#123;        rules: [            &#123;                 test: /\.(png|svg|jpg|gif)$/,                 use: [                    &#39;file-loader&#39;                ]            &#125;,            &#123;                 test: /\.(woff|woff2|eot|otf)$/,                 use: [                    &#39;file-loader&#39;                ]            &#125;        ]    &#125;</code></pre><p>url-loader： 也可以处理图片和字体，可以设置较小资源自动base64。</p><pre><code>module: &#123;        rules: [            &#123;                 test: /\.(png|svg|jpg|gif)$/,                 use: [&#123;                        loader: &#39;url-loader&#39;,                        options: &#123;                            limit: 10240                        &#125;                    &#125;]            &#125;        ]    &#125;</code></pre><h2 id="html压缩"><a href="#html压缩" class="headerlink" title="html压缩"></a>html压缩</h2><p>html的压缩用’html-webpack-plugin’这个插件。</p><pre><code>const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);module.exports = &#123;    ...    plugins: [        new HtmlWebpackPlugin(&#123;        title: &#39;Custom template&#39;,        template: &#39;./src/index.html&#39;, //指定要打包的html路径和文件名        filename:&#39;../index.html&#39; //指定输出路径和文件名      &#125;),    ]</code></pre><h2 id="js文件压缩、"><a href="#js文件压缩、" class="headerlink" title="js文件压缩、"></a>js文件压缩、</h2><p>webpack 4之前的版本是通过webpack.optimize.CommonsChunkPlugin来压缩js，webpack 4版本之后被移除了，<br>webpack4内置了uglifyjs-webpack-plugin这个插件，所以默认打包后js已经压缩了。</p><pre><code>var UglifyJsPlugin = require(&#39;uglifyjs-webpack-plugin&#39;)var OptimizeCssAssetsPlugin = require(&#39;optimize-css-assets-webpack-plugin&#39;)module.exports = &#123;  optimization: &#123;    minimizer: [      // 自定义js优化配置，将会覆盖默认配置      new UglifyJsPlugin(&#123;        exclude: /\.min\.js$/, // 过滤掉以&quot;.min.js&quot;结尾的文件，我们认为这个后缀本身就是已经压缩好的代码，没必要进行二次压缩        cache: true,        parallel: true, // 开启并行压缩，充分利用cpu        sourceMap: false,        extractComments: false, // 移除注释        uglifyOptions: &#123;          compress: &#123;            unused: true,            warnings: false,            drop_debugger: true          &#125;,          output: &#123;            comments: false          &#125;        &#125;      &#125;),      // 用于优化css文件      new OptimizeCssAssetsPlugin(&#123;        assetNameRegExp: /\.css$/g,        cssProcessorOptions: &#123;          safe: true,          autoprefixer: &#123; disable: true &#125;,           discardComments: &#123;            removeAll: true // 移除注释          &#125;        &#125;,        canPrint: true      &#125;)    ]  &#125;&#125;</code></pre><h2 id="css压缩"><a href="#css压缩" class="headerlink" title="css压缩"></a>css压缩</h2><p>css-loader在1.0以上版本没有了压缩配置，webpage4常用css压缩插件是’optimize-css-assets-webpack-plugin’，<br>需要配合安装css处理器’cssnano’。</p><pre><code>const optimizeCss = require(&#39;optimize-css-assets-webpack-plugin&#39;);module.exports = &#123;    .....,    //    plugins: [        new optimizeCss(&#123;            assetNameRegExp: /\.style\.css$/g,            cssProcessor: require(&#39;cssnano&#39;),            cssProcessorOptions: &#123; discardComments: &#123; removeAll: true &#125; &#125;,            canPrint: true        &#125;),    ],&#125;</code></pre><h2 id="补齐css3前缀"><a href="#补齐css3前缀" class="headerlink" title="补齐css3前缀"></a>补齐css3前缀</h2><p>利用postcss-loader和autoperfixer这两个插件</p><pre><code>&#123;  test: /\.css$/,  use: [    &#39;style-loader&#39;,    &#39;css-loader&#39;,    &#123;      loader: &#39;postcss-loader&#39;,      options: &#123;        plugins: [          require(&#39;autoprefixer&#39;)        ]      &#125;    &#125;  ]&#125;</code></pre><h2 id="移动端中rem转换"><a href="#移动端中rem转换" class="headerlink" title="移动端中rem转换"></a>移动端中rem转换</h2><p>使用px2rem-loader + lib-flexiable</p><pre><code>&#123;  test: /\.css$/,  use: [    &#39;style-loader&#39;,    &#39;css-loader&#39;,    &#39;less-loader&#39;,    &#123;      loader: &#39;px2rem-loader&#39;,      options: &#123;        remUnit: 75,//这是rem适配的配置  注意： remUnit在这里要根据lib-flexible的规则来配制，如果您的设计稿是750px的，用75就刚刚好。        remPrecision: 8      &#125;    &#125;  ]&#125;</code></pre></style></p>]]></content>
      
      
      <categories>
          
          <category> webpack专区 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack基础01-核心概念</title>
      <link href="2020/12/06/webpack-ji-chu-01-he-xin-gai-nian/"/>
      <url>2020/12/06/webpack-ji-chu-01-he-xin-gai-nian/</url>
      
        <content type="html"><![CDATA[<h1 id="默认安装"><a href="#默认安装" class="headerlink" title="默认安装"></a>默认安装</h1><p>npm init -y</p><h2 id="安装webpack相关"><a href="#安装webpack相关" class="headerlink" title="安装webpack相关"></a>安装webpack相关</h2><p>npm install webpack webpack-cli –save-dev</p><h2 id="检查webpack版本-cd-node-modules-bin"><a href="#检查webpack版本-cd-node-modules-bin" class="headerlink" title="检查webpack版本 cd node_modules/.bin"></a>检查webpack版本 cd node_modules/.bin</h2><p>webpack -v</p><h2 id="通过npm-stript运行webpack-否则只能在-bin下面执行"><a href="#通过npm-stript运行webpack-否则只能在-bin下面执行" class="headerlink" title="通过npm stript运行webpack,否则只能在.bin下面执行"></a>通过npm stript运行webpack,否则只能在.bin下面执行</h2><pre><code>package.json中添加 **build": "webpack"**</code></pre><h1 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h1><h2 id="entry"><a href="#entry" class="headerlink" title="entry"></a>entry</h2><p>entry是webpack打包文件的入口。入口可以设置多个，比如多页面应用。两者的写法有差异，但入口接收一个字符串，多入口写成对象的形式。</p><h3 id="单入口写法"><a href="#单入口写法" class="headerlink" title="单入口写法"></a>单入口写法</h3><pre><code>module.exports = {    entry: "./path/to/my/entry/file.js"}</code></pre><h3 id="多入口写法"><a href="#多入口写法" class="headerlink" title="多入口写法"></a>多入口写法</h3><pre><code>module.exports = {    entry: {        app: './src/app.js',        adminApp: './src/adminApp.js'    }}</code></pre><h2 id="output"><a href="#output" class="headerlink" title="output"></a>output</h2><p>output用来指定打包输出。多个文件的时候通过占位符做区分 ，比如[name]。</p><pre><code>module.exports = {    output: {        filename: '[name].js',        path: __dirname + '/dist/    }}</code></pre><h2 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h2><p>webpack原生只支持js,json两种文件类型，通过loader去支持其他文件类型并把他们转化成有效的模块，并添加到依赖图中。</p><p>本身是一个函数，接受源文件作为参数，返回转换的结果。</p><h3 id="常见的loader"><a href="#常见的loader" class="headerlink" title="常见的loader"></a>常见的loader</h3><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>babel-loader</td><td>转换ES6等新特性语法</td></tr><tr><td>css-loader</td><td>.css文件的加载和解析</td></tr><tr><td>less-loader</td><td>将less文件转为css</td></tr><tr><td>ts-loader</td><td>将TS转为js</td></tr><tr><td>file-loader</td><td>进行字体，图片的打包</td></tr><tr><td>raw-loader</td><td>将文件以字符串的形式导入</td></tr><tr><td>thread-loader</td><td>多线程打包css，js</td></tr></tbody></table><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>放在module中，test用来指定匹配规则，use指定使用的loader名称</p><pre><code>module: {        rules: [            { test: /\.txt$/, use: 'raw-loader'}        ]    }</code></pre><h2 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h2><p>插件用于bundle文件的优化，资源管理，环境变量的注入，作用于整个构建过程。loader没法做的事情，都是plugins来完成。</p><h3 id="常见的plugins"><a href="#常见的plugins" class="headerlink" title="常见的plugins"></a>常见的plugins</h3><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>html-webpack-plugin</td><td>创建html文件去承载输出的bundle</td></tr><tr><td>clean-webpack-plugin</td><td>用于在打包前清理上一次项目生成的 bundle 文件</td></tr><tr><td>splitChunks</td><td>提取被重复引入的文件，单独生成一个或多个文件，这样避免在多入口重复打包文件（替换CommonsChunkPlugin）</td></tr><tr><td>copy-webpack-plugin</td><td>将文件或文件夹拷贝到构建的输出目录</td></tr><tr><td>extract-text-webpack-plugin</td><td>抽离 css 样式,防止将样式打包在 js 中引起页面样式加载错乱的现象</td></tr><tr><td>UglifyJsPlugin</td><td>压缩js</td></tr><tr><td>ZipWebpackPlugin</td><td>将打包的出的资源生成一个zip包</td></tr><tr><td>MiniCssExtractPlugin</td><td>提取 JS 中引入的 CSS 打包到单独文件中，然后通过标签 <link>添加到头部</td></tr></tbody></table><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><p>放在plugins数组中：</p><pre><code>plugins: [        //moment这个库中，如果引用了./locale/目录的内容，就忽略掉，不会打包进去        new Webpack.IgnorePlugin(/\.\/locale/, /moment/),    ]</code></pre><h2 id="mode"><a href="#mode" class="headerlink" title="mode"></a>mode</h2><p>用来指定当前node的构建环境，有三种类型的值:production,development,none。(webpack4)<br>可用webpack内置函数来设置。</p><h3 id="选项描述"><a href="#选项描述" class="headerlink" title="选项描述"></a>选项描述</h3><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>development</td><td>会将 DefinePlugin 中 process.env.NODE_ENV 的值设置为 development。启用 NamedChunksPlugin 和 NamedModulesPlugin</td></tr><tr><td>production</td><td>会将 DefinePlugin 中 process.env.NODE_ENV 的值设置为 production。启用 FlagDependencyUsagePlugin, FlagIncludedChunksPlugin, ModuleConcatenationPlugin, NoEmitOnErrorsPlugin, OccurrenceOrderPlugin, SideEffectsFlagPlugin 和 TerserPlugin。</td></tr><tr><td>none</td><td>不开启任何优化选项</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> webpack专区 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>this指向</title>
      <link href="2020/11/25/this-zhi-xiang/"/>
      <url>2020/11/25/this-zhi-xiang/</url>
      
        <content type="html"><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p><code>this</code> 既不指向函数自身也不指向函数的作用域，在函数真正被调用执行的时候确定的，函数定义的时候确定不了。</p><ol><li><code>this</code>的指向，<strong>是在函数被调用的时候确定的</strong>，也就是执行上下文被创建时确定的；</li><li><code>this</code> 的指向和函数声明的位置没有任何关系，只取决于函数的调用位置（也即由谁、在什么地方调用这个函数）；</li><li>正因为在执行上下文的创建阶段<code>this</code>的指向就已经被确定了，在执行阶段<code>this</code>指向不可再被更改。</li></ol><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>    a<span class="token punctuation">:</span> <span class="token string">"1891"</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span> <span class="token operator">=</span> obj<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//报错，因为在执行阶段试图修改this的指向</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h1 id="this的指向规则"><a href="#this的指向规则" class="headerlink" title="this的指向规则"></a>this的指向规则</h1><h2 id="默认指向"><a href="#默认指向" class="headerlink" title="默认指向"></a>默认指向</h2><h3 id="独立函数调用"><a href="#独立函数调用" class="headerlink" title="独立函数调用"></a>独立函数调用</h3><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// this指向全局对象</span><span class="token punctuation">}</span><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//>> 2</span></code></pre><p>对于<strong>默认指向</strong>来说，决定<code>this</code>指向对象的并不是<strong>调用位置</strong>是否处于严格模式，而是函数体是否处于严格模式。如果函数体处于严格模式，<code>this</code>会指向<code>undefined</code>，否则<code>this</code>会指向全局对象。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token string">"use strict"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//函数体处于严格模式下，this指向undefined</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token string">"1891"</span><span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//>> 报错</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token string">"1891"</span><span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token string">"use strict"</span><span class="token punctuation">;</span>  <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//>> 1891</span>  <span class="token comment" spellcheck="true">//这里输出 1891 而不是报错，是因为严格模式下，this的指向与func的调用位置无关</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="SetTimeout或SetInterval中的this指向"><a href="#SetTimeout或SetInterval中的this指向" class="headerlink" title="SetTimeout或SetInterval中的this指向"></a>SetTimeout或SetInterval中的this指向</h3><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Obj</span> <span class="token punctuation">{</span>    <span class="token function">constructor</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>num <span class="token operator">=</span> num<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"setTimeout:"</span><span class="token operator">+</span><span class="token keyword">this</span><span class="token punctuation">.</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token function">func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Obj</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>obj<span class="token punctuation">.</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//>> 1　             输出的是obj.num</span>obj<span class="token punctuation">.</span><span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//>> setTimeout:0　  输出的是window.num</span>obj<span class="token punctuation">.</span><span class="token function">func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//>> 0 0 0 0 ……　    输出的是window.num</span></code></pre><p>可以发现在setInterval和setTimeout中传入函数时，函数中的this会指向window对象。</p><h2 id="隐式指向"><a href="#隐式指向" class="headerlink" title="隐式指向"></a>隐式指向</h2><ol><li><p>如果一个函数中有this，这个函数有被上一级的对象所调用，那么this指向的就是上一级的对象。</p></li><li><p>如果一个函数中有this，这个函数中包含多个对象，尽管这个函数是被最外层的对象所调用，this指向的也只是它上一级的对象。</p></li></ol><pre class=" language-javaScript"><code class="language-javaScript">var o = {    a:10,    b:{        // a:12,        fn:function(){            console.log(this.a); //undefined        }    }}o.b.fn();</code></pre><p>尽管对象b中没有属性a，这个this指向的也是对象b，因为this只会指向它的上一级对象，不管这个对象中有没有this要的东西。</p><h2 id="隐式丢失"><a href="#隐式丢失" class="headerlink" title="隐式丢失"></a>隐式丢失</h2><pre class=" language-javaScript"><code class="language-javaScript">var o = {    a:10,    b:{        a:12,        fn:function(){            console.log(this.a); //undefined            console.log(this); //window        }    }}var j = o.b.fn;j();   //this指向window</code></pre><p>这里this指向的是window,this永远指向的是最后调用它的对象。</p><p><strong>隐式丢失最容易在赋值时发生</strong>；隐式丢失发生时，调用这个函数会应用<strong>默认指向规则</strong>。下面再举一段更具迷惑性的例子：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token keyword">var</span> o <span class="token operator">=</span> <span class="token punctuation">{</span> a<span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">,</span> func<span class="token punctuation">:</span> func <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">var</span> p <span class="token operator">=</span> <span class="token punctuation">{</span> a<span class="token punctuation">:</span> <span class="token number">4</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>o<span class="token punctuation">.</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//>> 3</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>func <span class="token operator">=</span> o<span class="token punctuation">.</span>func<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//>> 2</span><span class="token comment" spellcheck="true">// 赋值表达式 p.func=o.func 的返回值是目标函数的引用，也就是 func 函数的引用</span><span class="token comment" spellcheck="true">// 因此调用位置是 func() 而不是 p.func() 或者 o.func()</span></code></pre><h2 id="显式指向"><a href="#显式指向" class="headerlink" title="显式指向"></a>显式指向</h2><p>JavaScript内置对象<code>Function</code>的三个原型方法<code>call()</code>、<code>apply()</code>和<code>bind()</code>，它们的第一个参数是一个对象，它们会把这个对象绑定到<code>this</code>，接着在调用函数时让<code>this</code>指向这个对象。</p><h3 id="call-apply-改变this的指向"><a href="#call-apply-改变this的指向" class="headerlink" title="call(),apply()改变this的指向"></a>call(),apply()改变this的指向</h3><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token string">"makai"</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>    a<span class="token punctuation">:</span><span class="token string">"coffe1891"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>func<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//>> coffe1891</span><span class="token comment" spellcheck="true">// 在调用 func 时强制把它的 this 绑定到 obj 上</span></code></pre><p>通过在call方法，给第一个参数添加要把b添加到哪个环境中，简单来说，this就会指向那个对象。</p><p>call方法除了第一个参数以外还可以添加多个参数，如下：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>    user<span class="token punctuation">:</span><span class="token string">"追梦子"</span><span class="token punctuation">,</span>    fn<span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span>ee<span class="token punctuation">)</span><span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//追梦子</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token operator">+</span>ee<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//3</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">var</span> b <span class="token operator">=</span> a<span class="token punctuation">.</span>fn<span class="token punctuation">;</span>b<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>注意如果call和apply的第一个参数写的是null，那么this指向的是window对象.</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>    user<span class="token punctuation">:</span><span class="token string">"追梦子"</span><span class="token punctuation">,</span>    fn<span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//Window {external: Object, chrome: Object, document: document, a: Object, speechSynthesis: SpeechSynthesis…}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">var</span> b <span class="token operator">=</span> a<span class="token punctuation">.</span>fn<span class="token punctuation">;</span>b<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="bind-改变this的指向"><a href="#bind-改变this的指向" class="headerlink" title="bind()改变this的指向"></a>bind()改变this的指向</h3><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>    user<span class="token punctuation">:</span><span class="token string">"追梦子"</span><span class="token punctuation">,</span>    fn<span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">var</span> b <span class="token operator">=</span> a<span class="token punctuation">.</span>fn<span class="token punctuation">;</span>b<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>我们发现代码没有被打印，对，这就是bind和call、apply方法的不同，实际上bind方法返回的是一个修改过后的函数。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>    user<span class="token punctuation">:</span><span class="token string">"追梦子"</span><span class="token punctuation">,</span>    fn<span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">var</span> b <span class="token operator">=</span> a<span class="token punctuation">.</span>fn<span class="token punctuation">;</span><span class="token keyword">var</span> c <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//function() { [native code] }</span></code></pre><p>那么我们现在执行一下函数c看看，能不能打印出对象a里面的user。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>    user<span class="token punctuation">:</span><span class="token string">"追梦子"</span><span class="token punctuation">,</span>    fn<span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//追梦子</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">var</span> b <span class="token operator">=</span> a<span class="token punctuation">.</span>fn<span class="token punctuation">;</span><span class="token keyword">var</span> c <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>同样bind也可以有多个参数，并且参数可以执行的时候再次添加，但是要注意的是，参数是按照形参的顺序进行的,且绑定在函数表达式上。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>    user<span class="token punctuation">:</span><span class="token string">"追梦子"</span><span class="token punctuation">,</span>    fn<span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span>d<span class="token punctuation">,</span>f<span class="token punctuation">)</span><span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//追梦子</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span>d<span class="token punctuation">,</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//10 1 2</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">var</span> b <span class="token operator">=</span> a<span class="token punctuation">.</span>fn<span class="token punctuation">;</span><span class="token keyword">var</span> c <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">c</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>另外，使用<code>bind</code>可以修正SetTimeout和SetInterval的this指向:</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Obj</span> <span class="token punctuation">{</span>    <span class="token function">constructor</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>num <span class="token operator">=</span> num<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"setTimeout:"</span><span class="token operator">+</span><span class="token keyword">this</span><span class="token punctuation">.</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//bind</span>    <span class="token punctuation">}</span>    <span class="token function">func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//bind</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Obj</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>obj<span class="token punctuation">.</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//>> 1　             输出的是obj.num</span>obj<span class="token punctuation">.</span><span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//>> setTimeout:1　  输出的是obj.num</span>obj<span class="token punctuation">.</span><span class="token function">func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//>> 1 1 1 1 ……　    输出的是obj.num</span></code></pre><p>总结：call和apply都是改变上下文中的this并立即执行这个函数，bind方法可以让对应的函数想什么时候调就什么时候调用，并且可以将参数在执行的时候添加，这是它们的区别，根据自己的实际情况来选择使用。</p><h2 id="“new”操作符指向"><a href="#“new”操作符指向" class="headerlink" title="“new”操作符指向"></a>“new”操作符指向</h2><p>在JavaScript 中，<strong>构造函数</strong>只是一些<strong>使用<code>new</code>操作符时被调用的函数</strong>。它们并不会属于某个类，也不会实例化一个类。实际上，它们甚至都不能算是一种特殊的类型（class），它们<strong>只是被<code>new</code>操作符调用的普通函数而已</strong>。</p><p>使用<code>new</code> 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作：</p><ol><li>创建（或者说构造）一个全新的对象；</li><li>将构造函数的作用域赋给新对象（因此<code>this</code>就指向了这个新对象）；</li><li>执行构造函数中的代码（为这个新对象添加属性、方法等）；</li><li>如果函数没有返回其他对象，那么返回这个新对象。</li></ol><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>user <span class="token operator">=</span> <span class="token string">"Caraxiong"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//Caraxiong</span></code></pre><p>这里之所以对象a可以点出函数Fn里面的user是因为new关键字可以改变this的指向，将这个this指向对象a.调用这个函数Fn的是对象a，那么this指向的自然是对象a，那么为什么对象Fn中会有user，因为你已经复制了一份Fn函数到对象a中，用了new关键字就等同于复制了一份。</p><h2 id="箭头函数的this"><a href="#箭头函数的this" class="headerlink" title="箭头函数的this"></a>箭头函数的this</h2><p>箭头函数内部的this是语法作用域，由上下文确定，有了箭头函数，可以修复this的指向，this总是指向语法作用域，也就是外层调用者。即箭头函数的this指向是<strong>根据函数定义时的作用域来决定 <code>this</code> 的指向</strong>。何谓“定义时的作用域”？就是你定义这个箭头函数的时候，该箭头函数在哪个函数里，那么箭头函数体内的this就是它父函数的this。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 返回一个箭头函数</span>  <span class="token keyword">return</span> a <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//this 继承自 func()</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> obj1 <span class="token operator">=</span> <span class="token punctuation">{</span>  a<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">var</span> obj2 <span class="token operator">=</span> <span class="token punctuation">{</span>  a<span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">var</span> bar <span class="token operator">=</span> func<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj1<span class="token punctuation">)</span><span class="token punctuation">;</span>bar<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//>> 2         不是 3 ！</span><span class="token comment" spellcheck="true">// func() 内部创建的箭头函数会捕获调用时 func() 的 this。</span><span class="token comment" spellcheck="true">// 由于 func() 的 this 绑定到 obj1， bar（引用箭头函数）的 this 也会绑定到 obj1，</span><span class="token comment" spellcheck="true">// this一旦被确定，就不可更改，所以箭头函数的绑定无法被修改。（new 也不行！）</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> ES语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>执行上下文相关概念</title>
      <link href="2020/11/16/zhi-xing-shang-xia-wen/"/>
      <url>2020/11/16/zhi-xing-shang-xia-wen/</url>
      
        <content type="html"><![CDATA[<h1 id="执行上下文（Execution-Context）"><a href="#执行上下文（Execution-Context）" class="headerlink" title="执行上下文（Execution Context）"></a>执行上下文（Execution Context）</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>执行上下文就是当前 JavaScript 代码被解析和执行时所在的环境，也叫作执行环境。</p><p>它是一个抽象概念，JavaScript 中运行任何的代码都是在执行上下文中运行，在该执行上下文的创建阶段，变量对象（Variable Object，本文接下来会详述）、作用域链、this指向会分别被确定。</p><p><img src="https://7.dusays.com/2020/11/16/9349c5ea172d6.png"></p><h2 id="执行上下文类型"><a href="#执行上下文类型" class="headerlink" title="执行上下文类型"></a>执行上下文类型</h2><p>执行上下文总共有三种类型：</p><ul><li><strong>全局执行上下文</strong>：这是默认的、最基础的执行上下文。不在任何函数中的代码都位于全局执行上下文中。它做了两件事：</li></ul><ol><li>创建一个全局对象，在浏览器中这个全局对象就是 window 对象；</li><li>将 this 指针指向这个全局对象。一个程序中只能存在一个全局执行上下文。</li></ol><ul><li><strong>函数执行上下文</strong>：每次调用函数时，都会为该函数创建一个新的执行上下文。每个函数都拥有自己的执行上下文，但是只有在函数被调用的时候才会被创建。一个程序中可以存在任意数量的函数执行上下文。每当一个新的执行上下文被创建，它都会按照特定的顺序执行一系列步骤，具体过程将在本文后面讨论。</li><li>eval执行上下文：运行在 eval 函数中的代码也获得了自己的执行上下文，ES6 之后不再推荐使用 eval 函数，所以本书出于面试实用考虑，不会深入讨论eval。</li></ul><h2 id="执行上下文的生命周期"><a href="#执行上下文的生命周期" class="headerlink" title="执行上下文的生命周期"></a>执行上下文的生命周期</h2><p>执行上下文的生命周期包括三个阶段：创建阶段 → 执行阶段 → 回收阶段，本文重点介绍创建阶段。</p><h3 id="a-创建阶段"><a href="#a-创建阶段" class="headerlink" title="a. 创建阶段"></a>a. 创建阶段</h3><p>当函数被调用，但未执行任何其内部代码之前，会做以下三件事：</p><ul><li>创建变量对象：首先初始化函数的参数 arguments，提升函数声明和变量声明（变量的<strong>声明提前</strong>有赖于<code>var</code>关键字）。</li><li>创建作用域链：在执行期上下文的创建阶段，作用域链是在变量对象之后创建的。作用域链本身包含变量对象。作用域链用于解析变量。当被要求解析变量时，JavaScript 始终从代码嵌套的最内层开始，如果最内层没有找到变量，就会跳转到上一层父作用域中查找，直到找到该变量。</li><li>确定 this 指向。</li></ul><h3 id="b-执行阶段"><a href="#b-执行阶段" class="headerlink" title="b. 执行阶段"></a>b. 执行阶段</h3><p>创建完成之后，就会开始执行代码，在这个阶段，会完成变量赋值、函数引用、以及执行其他代码。</p><h3 id="c-回收阶段"><a href="#c-回收阶段" class="headerlink" title="c. 回收阶段"></a>c. 回收阶段</h3><p>函数调用完毕后，函数出栈，对应的执行上下文也出栈，等待垃圾回收器回收执行上下文。</p><p><img src="https://7.dusays.com/2020/11/16/d7d64d01245e3.png"></p><h2 id="执行上下文栈"><a href="#执行上下文栈" class="headerlink" title="执行上下文栈"></a>执行上下文栈</h2><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token string">"coffe"</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//1.进入全局执行上下文</span><span class="token keyword">function</span> <span class="token function">out</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token string">"18"</span><span class="token punctuation">;</span>    <span class="token keyword">function</span> <span class="token function">inner</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token string">"91"</span><span class="token punctuation">;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token operator">+</span>b<span class="token operator">+</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">inner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//3.进入inner函数的执行上下文</span><span class="token punctuation">}</span><span class="token function">out</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//2.进入out函数的执行上下文</span></code></pre><p> 在代码开始执行时，首先会产生一个<strong>全局执行上下文</strong>，调用函数时，会产生<strong>函数执行上下文</strong>，函数调用完成后，它的执行上下文以及其中的数据都会被销毁，重新回到全局执行环境，网页关闭后全局执行环境也会销毁。其实这是一个入栈出栈的过程，<strong>全局上下文永远在栈底，而当前正在函数执行上下文在栈顶</strong>。以上代码的执行会经历以下过程：</p><ol><li>当代码开始执行时就<strong>创建全局执行上下文，全局执行上下文入栈</strong>。</li><li>全局执行上下文入栈后，其中的代码开始执行，进行赋值、函数调用等操作，执行到<code>out()</code>时，<strong>激活函数<code>out</code>创建自己的执行上下文，<code>out</code>函数执行上下文入栈</strong>。</li><li><code>out</code>函数执行上下文入栈后，其中的代码开始执行，进行赋值、函数调用等操作，执行到<code>inner()</code>时，<strong>激活函数<code>inner</code>创建自己的执行上下文，<code>inner</code>函数执行上下文入栈</strong>。</li><li><code>inner</code>函数上下文入栈后，其中的代码开始执行，进行赋值、函数调用、打印等操作，由于里面没有可以生成其他执行上下文的需要，所有代码执行完毕后，**<code>inner</code>函数上下文出栈**。</li><li><code>inner</code>函数执行上下文出栈，又回到了<code>out</code>函数执行上下文环境，接着执行<code>out</code>函数中后面剩下的代码，由于后面没有可以生成其他执行上下文的需要，所有代码执行完毕后，**<code>out</code>函数执行上下文出栈**。</li><li><code>out</code>函数执行上下文出栈后，又回到了全局执行上下文环境，直到浏览器窗口关闭，<strong>全局执行上下文出栈</strong>。</li></ol><p><img src="https://7.dusays.com/2020/11/16/55431837a2be8.png"></p><p>我们可以发现：</p><ol><li>全局执行上下文在代码开始执行时就创建，有且只有一个，永远在执行上下文栈的栈底，浏览器窗口关闭时它才出栈。</li><li>函数被调用的时候创建函数的执行上下文环境，并且入栈。</li><li>只有栈顶的执行上下文才是处于活动状态的，也即只有栈顶的变量对象才会变成活动对象。</li></ol><h1 id="变量对象（Variable-Object，VO"><a href="#变量对象（Variable-Object，VO" class="headerlink" title="变量对象（Variable Object，VO)"></a>变量对象（Variable Object，VO)</h1><p>变量对象（VO）是一个类似于容器的对象，与作用域链、执行上下文息息相关。</p><h2 id="变量对象的创建过程的三条规则："><a href="#变量对象的创建过程的三条规则：" class="headerlink" title="变量对象的创建过程的三条规则："></a>变量对象的创建过程的三条规则：</h2><ol><li><strong>建立<code>arguments</code>对象</strong>。检查当前执行上下文中的参数，建立该对象下的属性与属性值。</li><li><strong>检查当前执行上下文的函数声明，也就是使用<code>function</code>关键字声明的函数</strong>。在变量对象中以函数名建立一个属性，属性值为指向该函数所在内存地址的引用。如果该属性之前已经存在，那么该属性将会被新的引用所覆盖。</li><li><strong>检查当前执行上下文中的变量声明，每找到一个变量声明，就在变量对象中以变量名建立一个属性，属性值为<code>undefined</code>**。</strong>如果该变量名的属性已经存在，为了防止同名的函数被修改为<code>undefined</code>，则会直接跳过，原属性值不会被修改**。</li></ol><p><img src="https://7.dusays.com/2020/11/16/7fad446d8076c.png"></p><p>可以用以下伪代码来表示变量对象：</p><pre class=" language-javascript"><code class="language-javascript">VO<span class="token operator">=</span><span class="token punctuation">{</span>    Arguments<span class="token punctuation">:</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//实参</span>    Param_Variable<span class="token punctuation">:</span>具体值<span class="token punctuation">,</span><span class="token comment" spellcheck="true">//形参</span>    Function<span class="token punctuation">:</span><span class="token operator">&lt;</span><span class="token keyword">function</span> reference<span class="token operator">></span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//函数的引用</span>    Variable<span class="token punctuation">:</span>undefined<span class="token comment" spellcheck="true">//其他变量</span><span class="token punctuation">}</span></code></pre><p>当执行上下文进入执行阶段后，变量对象会变为<strong>活动对象</strong>（Active Object，AO）。此时原先声明的变量会被赋值。<strong>变量对象和活动对象都是指同一个对象，只是处于执行上下文的不同阶段</strong>。</p><p>我们可以通过以下伪代码来表示活动对象：</p><pre class=" language-javascript"><code class="language-javascript">AO<span class="token operator">=</span><span class="token punctuation">{</span>    Arguments<span class="token punctuation">:</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//实参</span>    Param_Variable<span class="token punctuation">:</span>具体值<span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">//形参</span>    Function<span class="token punctuation">:</span><span class="token operator">&lt;</span><span class="token keyword">function</span> reference<span class="token operator">></span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//函数的引用</span>    Variable<span class="token punctuation">:</span>具体值<span class="token comment" spellcheck="true">//注意，这里已经赋值了喔</span><span class="token punctuation">}</span></code></pre><p>未进入执行上下文的执行阶段之前，变量对象中的属性都不能访问。但是<strong>进入执行阶段之后，变量对象转变为了活动对象（被激活了）</strong>，里面的属性可以被访问了，然后开始进行执行阶段的操作。</p><h2 id="全局执行上下文的变量对象"><a href="#全局执行上下文的变量对象" class="headerlink" title="全局执行上下文的变量对象"></a>全局执行上下文的变量对象</h2><p>全局执行上下文的变量对象是<code>window</code>对象，而这个特殊，在<code>this</code>指向上也同样适用，<code>this</code>也是指向<code>window</code>。</p><p>除此之外，全局执行上下文的生命周期，与程序的生命周期一致，只要程序运行不结束（比如关掉浏览器窗口），全局执行上下文就会一直存在。其他所有的执行上下文，都能直接访问全局执行上下文里的内容。</p><h2 id="再看一段代码，留意注释"><a href="#再看一段代码，留意注释" class="headerlink" title="再看一段代码，留意注释"></a>再看一段代码，留意注释</h2><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'function func'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> func <span class="token operator">=</span> <span class="token string">"coffe"</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//>> coffe</span><span class="token comment" spellcheck="true">// 以上代码中，按三条规则，变量声明的 func 遇到函数声明的 func 应该会跳过，</span><span class="token comment" spellcheck="true">// 可是为什么最后 func 的输出结果仍然是被覆盖了显示"coffe"呢？</span><span class="token comment" spellcheck="true">// 那是因为三条规则仅仅适用于变量对象的创建阶段，也即执行上下文的创建阶段。</span><span class="token comment" spellcheck="true">// 而 func="coffe" 是在执行上下文的执行阶段中运行的，输出结果自然会是"coffe"。</span></code></pre><p>这种现象很容易让人费解，其实也是因为<code>var</code>声明的变量允许重名导致的，若使用关键字<code>let</code>来声明变量，就可以避免这种令人费解的情况发生。</p><h1 id="作用域链（Scope-Chain）"><a href="#作用域链（Scope-Chain）" class="headerlink" title="作用域链（Scope Chain）"></a>作用域链（Scope Chain）</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p><strong>多个作用域对应的变量对象串联起来组成的链表就是作用域链，</strong>这个链表是以引用的形式保持对变量对象的访问<strong>。</strong>作用域链保证了当前执行上下文对符合访问权限的变量和函数的有序访问。</p><p><img src="https://7.dusays.com/2020/11/16/867543641bca6.png" alt="作用域链的图示"></p><p>作用域链的最顶端一定是当前作用域（local scope）对应的变量对象，最底端一定是全局作用域对应的变量对象（全局VO）。</p><p>作用域链可以形象地比如为一个蒸笼。</p><p><img src="https://7.dusays.com/2020/11/16/8dc21cd5da203.png" alt="蒸笼"></p><p>最底下的一屉，相当于是全局作用域，它里面的蒸汽（变量和函数的可见性）可以渗透到整个蒸笼，底层之上的其他屉相当于局部作用域，这些上面屉的蒸汽只能影响更上面的屉。</p><p>作用域链可以理解为下面这种伪代码格式：</p><pre class=" language-text"><code class="language-text">{    Scope: [        { //当前作用域对应的VO            实参,            形参,            变量,            函数        },         { //第二个作用域对应的VO            实参,            形参,            变量,            函数        },        ...         { //全局作用域对应的VO            变量,            函数        }    ]}</code></pre><h2 id="变量-函数的查找机制"><a href="#变量-函数的查找机制" class="headerlink" title="变量/函数的查找机制"></a>变量/函数的查找机制</h2><p>  查找变量/函数时JS引擎是从里离它最近作用域开始的查找的，也即从离它最近的变量对象（VO）开始查找。</p><p>如果在当前的变量对象里面找不到目标变量/函数，就在上一级作用域的变量对象里面查找。若这时找到了目标变量/函数，则停止查找；若找不到，一直回溯到全局作用域的变量对象里查找，若仍找不到目标变量/函数，停止查找。</p>]]></content>
      
      
      <categories>
          
          <category> ES语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从es7到es12</title>
      <link href="2020/11/10/cong-es7-dao-es12/"/>
      <url>2020/11/10/cong-es7-dao-es12/</url>
      
        <content type="html"><![CDATA[<h1 id="本篇导读"><a href="#本篇导读" class="headerlink" title="本篇导读"></a>本篇导读</h1><p>JavaScript是一门支持多种编程范式的语言，灵活性很高，功能也十分强大。因为灵活性，JavaScript有很多种使用方式，被应用到浏览器、客户端软件、嵌入式硬件等多种场景下。在面向对象（OOP）这种编程范式大行其道的今天，这种变化多端的语言因其编程范式多样，每种场景下使用形态各异，使用者之间思维差别大，见解又各不相同，因此也就被误解得极深。正是由于这种相对的复杂性，前端工程师们有必要更系统、深入地对这门语言进行学习和研究。</p><p>现在，JavaScript在TC39（TC39由包括浏览器厂商在内的各方组成，他们开会推动JavaScript特性的提案沿着一条严格的流程推进）的推动下正加速地迭代更新，每年都会有一些新特性出现。前端工程师们有必要了解一下这些新特性，以便更好地在一线互联网企业发挥出自己的能量。</p><h1 id="JavaScript-和-ECMAScript-6-的关系"><a href="#JavaScript-和-ECMAScript-6-的关系" class="headerlink" title="JavaScript 和 ECMAScript 6 的关系"></a>JavaScript 和 ECMAScript 6 的关系</h1><p>JavaScript起源于1995年Netscape为自家游览器创造的脚本语言LiveScript。后来因为Sun公司的Java语言兴起，Netscape为了沾热度将LiveScript改名为JavaScript，但其实Java和JavaScript没有一点关系。</p><p>1997年Netscape将JavaScript规范提交到 Ecma International（<a href="https://www.ecma-international.org/">www.ecma-international.org</a>，简称EI），诞生了ECMAScript （简称“ES”）第1个版本。</p><p>随后在1999年诞生了十分稳定的ES 3，也就是2009年12月之前前端工程师们最广泛使用的版本。</p><p>在2009年12月诞生了ES 5。你可能会问ES 4 呢，抱歉，版本4因为太激进，EI委员会成员之间的意见不一，最后胎死腹中，改由更加平滑温和的版本5继承版本4的一些新特性和功能。</p><p>EI于2015年6月发布了ES 6，也就是我们今天广泛使用的版本。这之后每年6月发布一个极小更新的ES版本。</p><p>综上可见，<strong>JavaScript是ECMAScript规范的一种实现</strong>。为方便读者理解交流，而且由于ECAMScript 6 之后变化并不是特别大，如果没有特别说明，本书后面讲述的JavaScript对应的规范默认为 ES 6。</p><p>本文下面会介绍ES 7~12的新特性。</p><h1 id="ES-7-新特性"><a href="#ES-7-新特性" class="headerlink" title="ES 7 新特性"></a>ES 7 新特性</h1><table><thead><tr><th align="left">新特性</th><th align="left">中文说明</th></tr></thead><tbody><tr><td align="left"><code>Array.prototype.includes</code></td><td align="left"></td></tr><tr><td align="left">Exponentiation operator</td><td align="left">指数函数的中缀表示法</td></tr></tbody></table><h2 id="Array-prototype-includes"><a href="#Array-prototype-includes" class="headerlink" title="Array.prototype.includes"></a>Array.prototype.includes</h2><p>includes是一个Array上很有用的方法，用于快速查找数组中是否包含某个元素，包括NaN（所以和indexOf不一样)。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">NaN</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//查找2是否存在于arr数组中</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"找到了!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//>> 找到了！</span>  <span class="token punctuation">}</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>arr<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//第二个参数3表示数组下标为3的项，也即第4项开始查找</span>    console<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">"不存在!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//>> 不存在！</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//下面两句说明incluedes和indexOf的区别</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span><span class="token number">NaN</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//true</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token number">NaN</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//false</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="指数函数的中缀表示法"><a href="#指数函数的中缀表示法" class="headerlink" title="指数函数的中缀表示法"></a>指数函数的中缀表示法</h2><p>这个是与<code>Math.pow</code>有关的特性，还记得<code>i++</code>,<code>x += x</code>这种写法吗，指数函数的中缀表示法与之类似。与python语言一样，JavaScript也采用两个星符号<code>**</code>来表示<code>Math.pow</code>。好处有两个：<br>a. 中缀表示法比函数表示法更简洁，这使它更可取。<br>b. 方便数学、物理、机器人学等领域的计算。</p><p>用法示例如下：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//用法一：x ** y</span><span class="token keyword">let</span> squared <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">**</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//等同于: 2 * 2</span><span class="token keyword">let</span> cubed <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">**</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//等同于: 2 * 2 * 2</span></code></pre><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//用法二：x **= y</span><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>a <span class="token operator">**</span><span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//等同于: a = a * a;</span><span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>b <span class="token operator">**</span><span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//等同于: b = b * b * b;</span></code></pre><h1 id="ES-8-新特性"><a href="#ES-8-新特性" class="headerlink" title="ES 8 新特性"></a>ES 8 新特性</h1><table><thead><tr><th align="left">新特性</th><th align="left">中文说明</th></tr></thead><tbody><tr><td align="left"><code>Object.values</code> / <code>Object.entries</code></td><td align="left"></td></tr><tr><td align="left">String padding</td><td align="left">字符串追加</td></tr><tr><td align="left"><code>Object.getOwnPropertyDescriptors</code></td><td align="left"></td></tr><tr><td align="left">Trailing commas in function parameter lists and calls</td><td align="left">结尾允许逗号</td></tr><tr><td align="left">Async functions</td><td align="left">异步函数</td></tr><tr><td align="left">Shared memory and atomics</td><td align="left">共享内存和 Atomics 对象</td></tr></tbody></table><h2 id="Object-values-Object-entries"><a href="#Object-values-Object-entries" class="headerlink" title="Object.values() / Object.entries"></a>Object.values() / Object.entries</h2><p>定义是<code>Object.values(obj)</code>，<code>obj</code> 参数是对目标对象的操作，它可以是一个对象或者数组。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token string">'xxx'</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>Object<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ['xxx', 1]</span><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'e'</span><span class="token punctuation">,</span> <span class="token string">'s'</span><span class="token punctuation">,</span> <span class="token string">'8'</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 等同于 { 0: 'e', 1: 's', 2: '8' };</span>Object<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ['e', 's', '8']</span><span class="token comment" spellcheck="true">//当把数字对象的当键的时候，返回的数组以键的值升序排序</span><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">10</span><span class="token punctuation">:</span> <span class="token string">'xxx'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">:</span> <span class="token string">'yyy'</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">:</span> <span class="token string">'zzz'</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>Object<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ['yyy', 'zzz', 'xxx']</span>Object<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token string">'es8'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ['e', 's', '8']</span></code></pre><p><code>Object.entries</code>方法返回一个给定对象可枚举属性值的数组[key, value]，与<code>Object.values</code>类似。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token string">'xxx'</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>Object<span class="token punctuation">.</span><span class="token function">entries</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [['x', 'xxx'], ['y', 1]]</span><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'e'</span><span class="token punctuation">,</span> <span class="token string">'s'</span><span class="token punctuation">,</span> <span class="token string">'8'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>Object<span class="token punctuation">.</span><span class="token function">entries</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [['0', 'e'], ['1', 's'], ['2', '8']]</span><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">10</span><span class="token punctuation">:</span> <span class="token string">'xxx'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">:</span> <span class="token string">'yyy'</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">:</span> <span class="token string">'zzz'</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>Object<span class="token punctuation">.</span><span class="token function">entries</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [['1', 'yyy'], ['3', 'zzz'], ['10', 'xxx']]</span>Object<span class="token punctuation">.</span><span class="token function">entries</span><span class="token punctuation">(</span><span class="token string">'es8'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [['0', 'e'], ['1', 's'], ['2', '8']]</span></code></pre><h2 id="字符串追加"><a href="#字符串追加" class="headerlink" title="字符串追加"></a>字符串追加</h2><p>在 ES 8 中String新增了两个实例函数<code>String.prototype.padStart</code>和<code>String.prototype.padEnd</code>，允许将空字符串或其他字符串添加到原始字符串的开头或结尾。</p><ul><li><p><code>String.padStart(targetLength,[padString])</code><br>_targetLength：_当前字符串需要填充到的目标长度。如果这个数值小于当前字符串的长度，则返回当前字符串本身。</p><p>_padString：_(可选)填充字符串。如果字符串太长，使填充后的字符串长度超过了目标长度，则只保留最左侧的部分，其他部分会被截断，此参数的缺省值为空格。</p></li><li><p><code>String.padEnd(targetLength,padString])</code> 参数释义同上。</p></li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token string">'es8'</span><span class="token punctuation">.</span><span class="token function">padStart</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 'es8'</span><span class="token string">'es8'</span><span class="token punctuation">.</span><span class="token function">padStart</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// '  es8'</span><span class="token string">'es8'</span><span class="token punctuation">.</span><span class="token function">padStart</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token string">'1891'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// '189es8'</span><span class="token string">'es8'</span><span class="token punctuation">.</span><span class="token function">padStart</span><span class="token punctuation">(</span><span class="token number">14</span><span class="token punctuation">,</span> <span class="token string">'coffe'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 'coffecoffeces8'</span><span class="token string">'es8'</span><span class="token punctuation">.</span><span class="token function">padStart</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token string">'0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// '0000es8'</span><span class="token string">'es8'</span><span class="token punctuation">.</span><span class="token function">padEnd</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 'es8'</span><span class="token string">'es8'</span><span class="token punctuation">.</span><span class="token function">padEnd</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 'es8  '</span><span class="token string">'es8'</span><span class="token punctuation">.</span><span class="token function">padEnd</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token string">'1891'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 'es8189'</span><span class="token string">'es8'</span><span class="token punctuation">.</span><span class="token function">padEnd</span><span class="token punctuation">(</span><span class="token number">14</span><span class="token punctuation">,</span> <span class="token string">'coffe'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 'es8coffecoffec'</span><span class="token string">'es8'</span><span class="token punctuation">.</span><span class="token function">padEnd</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token string">'9'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 'es89999'</span></code></pre><h2 id="Object-getOwnPropertyDescriptors"><a href="#Object-getOwnPropertyDescriptors" class="headerlink" title="Object.getOwnPropertyDescriptors"></a>Object.getOwnPropertyDescriptors</h2><p><code>getOwnPropertyDescriptors</code>方法返回一指定对象自己所有的属性内容，并且属性内容只是自身直接定义的，而不是从object的原型继承而来的。<br>定义是：<code>Object.getOwnPropertyDescriptors(obj)</code>，<code>obj</code> 是指目标对象，这个方法返回的值可能是 configurable、enumerable、writable、get、set 和 value。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>   <span class="token keyword">get</span> <span class="token function">es7</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token number">7</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token keyword">get</span> <span class="token function">es8</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token number">8</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>Object<span class="token punctuation">.</span><span class="token function">getOwnPropertyDescriptors</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// {</span><span class="token comment" spellcheck="true">//   es7: {</span><span class="token comment" spellcheck="true">//     configurable: true,</span><span class="token comment" spellcheck="true">//     enumerable: true,</span><span class="token comment" spellcheck="true">//     get: function es7(){}, //the getter function</span><span class="token comment" spellcheck="true">//     set: undefined</span><span class="token comment" spellcheck="true">//   },</span><span class="token comment" spellcheck="true">//   es8: {</span><span class="token comment" spellcheck="true">//     configurable: true,</span><span class="token comment" spellcheck="true">//     enumerable: true,</span><span class="token comment" spellcheck="true">//     get: function es8(){}, //the getter function</span><span class="token comment" spellcheck="true">//     set: undefined</span><span class="token comment" spellcheck="true">//   }</span><span class="token comment" spellcheck="true">// }</span></code></pre><h2 id="结尾允许逗号"><a href="#结尾允许逗号" class="headerlink" title="结尾允许逗号"></a>结尾允许逗号</h2><p>用法示例如下：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//定义参数时</span><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>    param1<span class="token punctuation">,</span>    param2<span class="token punctuation">,</span><span class="token comment" spellcheck="true">//结尾逗号</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//传参时</span><span class="token function">foo</span><span class="token punctuation">(</span>    <span class="token string">'coffe'</span><span class="token punctuation">,</span>    <span class="token string">'1891'</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//结尾逗号</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//对象中</span><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token string">"a"</span><span class="token punctuation">:</span> <span class="token string">'coffe'</span><span class="token punctuation">,</span>    <span class="token string">"b"</span><span class="token punctuation">:</span> <span class="token string">'1891'</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//结尾逗号</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//数组中</span><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span>    <span class="token string">'coffe'</span><span class="token punctuation">,</span>    <span class="token string">'1891'</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//结尾逗号</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre><p>这样改动的好处有两点：</p><ul><li>重新排列项目更简单，因为如果最后一项更改其位置，则不必添加和删除逗号。</li><li>可以帮助git等版本控制系统跟踪实际发生的变化，在查看代码改动、合并代码的时候，少报一些无用信息。例如，从</li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token punctuation">[</span>    <span class="token string">'coffe'</span><span class="token punctuation">]</span></code></pre><p>变更为</p><pre class=" language-javascript"><code class="language-javascript"><span class="token punctuation">[</span>    <span class="token string">'coffe'</span><span class="token punctuation">,</span>    <span class="token string">'1891'</span><span class="token punctuation">]</span></code></pre><p>在git里它会报同时修改了两行代码，采用结尾逗号<code>'coffe',</code>之后，就只会报仅有一行代码<code>'1891',</code>的变动，这样做代码review（代码复查）的时候就更省眼力了。</p><h2 id="异步函数"><a href="#异步函数" class="headerlink" title="异步函数"></a>异步函数</h2><p>Async Functions也就是我们常说的Async/Await，相信大家对于这个概念都已经不陌生了。Async/Await是一种用于处理JS异步操作的语法糖，可以帮助我们摆脱<strong>回调地狱</strong>（callback hell），编写更加优雅的代码。</p><p>通俗的理解，<code>async</code>关键字的作用是告诉编译器对于标定的函数要区别对待。当编译器遇到标定的函数中的<code>await</code>关键字时，要暂时停止运行，等到<code>await</code>标定的函数处理完毕后，再进行相应操作。如果该函数fulfiled了，则返回值是fulfillment value，否则得到的就是reject value。</p><p>下面通过拿普通的promise写法来对比，就很好理解了：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">asyncFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">otherAsyncFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// otherAsyncFunc()返回一个Promise对象</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 等同于:</span><span class="token keyword">function</span> <span class="token function">asyncFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">otherAsyncFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// otherAsyncFunc()返回一个Promise对象</span>    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>result <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>按顺序处理多个异步函数的时候优势更为明显：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">asyncFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> result1 <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">otherAsyncFunc1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// otherAsyncFunc1()返回一个Promise对象</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> result2 <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">otherAsyncFunc2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// otherAsyncFunc2()返回一个Promise对象</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 等同于:</span><span class="token keyword">function</span> <span class="token function">asyncFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">otherAsyncFunc1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// otherAsyncFunc1()返回一个Promise对象</span>    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>result1 <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result1<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">otherAsyncFunc2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// otherAsyncFunc2()返回一个Promise对象</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>result2 <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>并行处理多个异步函数：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">asyncFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> <span class="token punctuation">[</span>result1<span class="token punctuation">,</span> result2<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">await</span> Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token punctuation">[</span>        <span class="token function">otherAsyncFunc1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">// otherAsyncFunc1()返回一个Promise对象</span>        <span class="token function">otherAsyncFunc2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// otherAsyncFunc2()返回一个Promise对象</span>    <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result1<span class="token punctuation">,</span> result2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 等同于:</span><span class="token keyword">function</span> <span class="token function">asyncFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token punctuation">[</span>        <span class="token function">otherAsyncFunc1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">// otherAsyncFunc1()返回一个Promise对象</span>        <span class="token function">otherAsyncFunc2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// otherAsyncFunc2()返回一个Promise对象</span>    <span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">[</span>result1<span class="token punctuation">,</span> result2<span class="token punctuation">]</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result1<span class="token punctuation">,</span> result2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>处理错误：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">asyncFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">await</span> <span class="token function">otherAsyncFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// otherAsyncFunc()返回一个Promise对象</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">err</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 等同于:</span><span class="token keyword">function</span> <span class="token function">asyncFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">otherAsyncFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// otherAsyncFunc()返回一个Promise对象</span>    <span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span>err <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>Async Functions若是要展开讲可以占很大的篇幅，鉴于本篇是一篇介绍性文章，故此不再进行深入论述。</p><h2 id="共享内存和-Atomics-对象"><a href="#共享内存和-Atomics-对象" class="headerlink" title="共享内存和 Atomics 对象"></a>共享内存和 Atomics 对象</h2><p>SharedArrayBuffer 对象用来表示一个通用的，固定长度的原始二进制数据缓冲区，类似于 ArrayBuffer对象（如果之前你没有接触过ArrayBuffer相关知识的话，建议从<a href="https://hacks.mozilla.org/2017/06/a-cartoon-intro-to-arraybuffers-and-sharedarraybuffers/">内存管理速成教程系列漫画解说入门</a>） ，它们都可以用来在共享内存（shared memory）上创建视图。与 ArrayBuffer 不同的是，SharedArrayBuffer 不能被分离。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">/** *  * @param {*} length 所创建的数组缓冲区的大小，以字节(byte)为单位。   * @returns {SharedArrayBuffer} 一个大小指定的新 SharedArrayBuffer 对象。其内容被初始化为 0。 */</span><span class="token keyword">new</span> <span class="token class-name">SharedArrayBuffer</span><span class="token punctuation">(</span>length<span class="token punctuation">)</span></code></pre><p>Atomics 对象提供了一组静态方法用来对 SharedArrayBuffer 对象进行原子操作，这些原子操作属于 Atomics 模块。Atomics 不是构造函数，因此不能使用 new 操作符调用，也不能将其当作函数直接调用。Atomics 的所有属性和方法都是静态的（与 Math 对象一样）。</p><table><thead><tr><th align="left">方法名</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">Atomics.add()</td><td align="left">将指定位置上的数组元素与给定的值相加，并返回相加前该元素的值。</td></tr><tr><td align="left">Atomics.and()</td><td align="left">将指定位置上的数组元素与给定的值相与，并返回与操作前该元素的值。</td></tr><tr><td align="left">Atomics.compareExchange()</td><td align="left">如果数组中指定的元素与给定的值相等，则将其更新为新的值，并返回该元素原先的值。</td></tr><tr><td align="left">Atomics.exchange()</td><td align="left">将数组中指定的元素更新为给定的值，并返回该元素更新前的值。</td></tr><tr><td align="left">Atomics.load()</td><td align="left">返回数组中指定元素的值。</td></tr><tr><td align="left">Atomics.or()</td><td align="left">将指定位置上的数组元素与给定的值相或，并返回或操作前该元素的值。</td></tr><tr><td align="left">Atomics.store()</td><td align="left">将数组中指定的元素设置为给定的值，并返回该值。</td></tr><tr><td align="left">Atomics.sub()</td><td align="left">将指定位置上的数组元素与给定的值相减，并返回相减前该元素的值。</td></tr><tr><td align="left">Atomics.xor()</td><td align="left">将指定位置上的数组元素与给定的值相异或，并返回异或操作前该元素的值。</td></tr><tr><td align="left">Atomics.wait()</td><td align="left">检测数组中某个指定位置上的值是否仍然是给定值，是则保持挂起直到被唤醒或超时。返回值为 “ok”、”not-equal” 或 “time-out”。调用时，如果当前线程不允许阻塞，则会抛出异常（大多数浏览器都不允许在主线程中调用 wait()）。</td></tr><tr><td align="left">Atomics.wake()</td><td align="left">唤醒等待队列中正在数组指定位置的元素上等待的线程。返回值为成功唤醒的线程数量。</td></tr><tr><td align="left">Atomics.isLockFree(size)</td><td align="left">可以用来检测当前系统是否支持硬件级的原子操作。对于指定大小的数组，如果当前系统支持硬件级的原子操作，则返回 true；否则就意味着对于该数组，Atomics 对象中的各原子操作都只能用锁来实现。此静态方法面向的是技术专家。</td></tr></tbody></table><h1 id="ES-9-新特性"><a href="#ES-9-新特性" class="headerlink" title="ES 9 新特性"></a>ES 9 新特性</h1><table><thead><tr><th align="left">新特性</th><th align="left">中文说明</th></tr></thead><tbody><tr><td align="left">Asynchronous Iteration</td><td align="left">异步迭代器</td></tr><tr><td align="left"><code>Promise.prototype.finally</code></td><td align="left"></td></tr><tr><td align="left">Lifting template literal restriction</td><td align="left">重新修订了字面量的转义</td></tr><tr><td align="left">Rest/Spread Properties</td><td align="left">Rest/Spread 属性</td></tr><tr><td align="left"><code>s</code> (dotAll) flag for regular expressions</td><td align="left">正则表达式dotAll模式</td></tr><tr><td align="left">RegExp named capture groups</td><td align="left">正则表达式命名捕获组</td></tr><tr><td align="left">RegExp Lookbehind Assertions</td><td align="left">正则表达式反向断言</td></tr><tr><td align="left">RegExp Unicode Property Escapes</td><td align="left">正则表达式 Unicode 转义</td></tr></tbody></table><h2 id="异步迭代器"><a href="#异步迭代器" class="headerlink" title="异步迭代器"></a>异步迭代器</h2><p>在<code>async</code>/<code>await</code>的某些时刻，你可能尝试在同步循环中调用异步函数。例如：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">func</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token keyword">of</span> array<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">await</span> <span class="token function">someFunc</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这段代码不会达到预期目的，下面这段同样也不会：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">func</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span> <span class="token punctuation">{</span>  array<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">async</span> i <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">await</span> <span class="token function">someFunc</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>上面这段代码中，循环本身依旧保持同步，并在内部异步函数之前全部调用完成。</p><p>引入异步迭代器后，就像常规迭代器，除了<code>next()</code>方法返回一个Promise。因此<code>await</code>可以和<code>for...of</code>循环一起使用，以串行的方式运行异步操作。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">func</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">for</span> <span class="token keyword">await</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token keyword">of</span> array<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//异步迭代</span>    <span class="token function">someFunc</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally"></a>Promise.prototype.finally</h2><p>一个Promise调用链要么成功到达最后一个<code>.then()</code>，要么失败触发<code>.catch()</code>。在某些情况下，你想要在无论Promise运行成功还是失败，运行相同的代码，例如清除数组、删除对话、关闭数据库连接等，<code>.finally()</code>允许实现这样的目的。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">promiseFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//返回一个Promise对象</span>    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span>err <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token keyword">finally</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">//无论promiseFunc()运行成功还是失败，这里的代码会被调用到</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="重新修订了字面量的转义"><a href="#重新修订了字面量的转义" class="headerlink" title="重新修订了字面量的转义"></a>重新修订了字面量的转义</h2><p>ES9 之前，<code>\u</code>表示 unicode 转义，<code>\x</code>表示十六进制转义，<code>\</code>后跟一个数字表示八进制转义，这使得创建特定的字符串变得不可能，例如Windows文件路径<code>C:\uuu\xxx\111</code>。</p><p>要取消转义序列的语法限制，可在模板字符串之前使用标记函数<code>String.raw</code>。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token template-string"><span class="token string">`\u{54}`</span></span> <span class="token comment" spellcheck="true">//会转义成unicode "T"</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//>> T</span><span class="token keyword">let</span> str <span class="token operator">=</span> String<span class="token punctuation">.</span>raw<span class="token template-string"><span class="token string">`\u{54}`</span></span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//不会被转义</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//>> \u{54}</span></code></pre><h2 id="Rest-Spread"><a href="#Rest-Spread" class="headerlink" title="Rest / Spread"></a>Rest / Spread</h2><p>这个就是我们通常所说的三个点<code>...</code>，这项特性在ES6中已经引入，但是ES6中的作用对象仅限于数组。在ES9中，为对象提供了像数组一样的rest参数和扩展运算符：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>  a<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>  b<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span>  c<span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token punctuation">{</span> a<span class="token punctuation">,</span> <span class="token operator">...</span>param <span class="token punctuation">}</span> <span class="token operator">=</span> obj<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//这里...是rest</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//>> 1</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//>> {b: 2, c: 3}</span><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">{</span> a<span class="token punctuation">,</span> <span class="token operator">...</span>param <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//这里...还是rest</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//>> 1</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//>> {b: 2, c: 3}</span><span class="token punctuation">}</span><span class="token keyword">const</span> param <span class="token operator">=</span> <span class="token punctuation">{</span> b<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span> c<span class="token punctuation">:</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">{</span> a<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">...</span>param <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//此处...为spread</span></code></pre><h2 id="正则表达式dotAll模式"><a href="#正则表达式dotAll模式" class="headerlink" title="正则表达式dotAll模式"></a>正则表达式dotAll模式</h2><p>正则表达式中点<code>.</code>匹配除回车外的任何单字符，标记<code>s</code>改变这种行为，允许匹配回车换行。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token regex">/hello.world/</span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">'hello\nworld'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// false</span><span class="token operator">/</span>hello<span class="token punctuation">.</span>world<span class="token operator">/</span>s<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">'hello\nworld'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token operator">/</span>hello<span class="token punctuation">.</span>world<span class="token operator">/</span>s<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`helloworld`</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">//>> true</span></code></pre><h2 id="正则表达式命名捕获组"><a href="#正则表达式命名捕获组" class="headerlink" title="正则表达式命名捕获组"></a>正则表达式命名捕获组</h2><p>Javascript正则表达式中使用<code>exec()</code>匹配后，能够返回一个包含匹配字符串的类数组对象。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> reDate <span class="token operator">=</span> <span class="token regex">/(\d{4})-(\d{2})-(\d{2})/</span><span class="token punctuation">,</span>  match <span class="token operator">=</span> reDate<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token string">"2018-08-06"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>match<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//>> [2018-08-06, 2018, 08, 06]</span><span class="token comment" spellcheck="true">//这样就可以直接用索引来获取年月日：</span><span class="token keyword">let</span> year <span class="token operator">=</span> match<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//>> 2018</span><span class="token keyword">let</span> month <span class="token operator">=</span> match<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//>> 08</span><span class="token keyword">let</span> day <span class="token operator">=</span> match<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//>> 06</span></code></pre><p>返回数组的第0项为与正则表达式相匹配的文本，第 1 项是与 <code>reDate</code> 的第 1 个分组<code>\d{4}</code>相匹配的文本（如果有的话），第 2 项是与 <code>reDate</code> 的第 2 个分组<code>\d{2}</code>相匹配的文本（如果有的话），以此类推。正则表达式的组以<code>()</code>包起来。</p><p>上面的案例，若是日期格式变成<code>月日年</code>，那么改变正则表达式的结构后，还有可能会改变变量的赋值部分的代码。如下示例：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> reDate <span class="token operator">=</span> <span class="token regex">/(\d{2})-(\d{2})-(\d{4})/</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//表达式结构变化了</span>  match <span class="token operator">=</span> reDate<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token string">"08-06-2018"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>match<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//>> [08-06-2018, 08, 06, 2018]</span><span class="token comment" spellcheck="true">//此时年月日的赋值代码也要改了,改的地方真多啊！怎么办？</span><span class="token keyword">let</span> year <span class="token operator">=</span> match<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//>> 2018</span><span class="token keyword">let</span> month <span class="token operator">=</span> match<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//>> 08</span><span class="token keyword">let</span> day <span class="token operator">=</span> match<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//>> 06</span></code></pre><p>可以发现上面的写法改的地方太多了，有没有办法少改点代码省省事呢？有！ ES9 允许使用符号<code>?&lt;name&gt;</code>来命名<strong>捕获组</strong>（也即“匹配到的组”），示例如下：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> reDate <span class="token operator">=</span> <span class="token regex">/(?&lt;year>\d{4})-(?&lt;month>\d{2})-(?&lt;day>\d{2})/</span><span class="token punctuation">,</span>  match <span class="token operator">=</span> reDate<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token string">"2018-08-06"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>match<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//>> [2018-08-06, 08, 06, 2018, groups: {day: 06, month: 08, year: 2018}]</span><span class="token comment" spellcheck="true">//此时用groups对象来获取年月日，无论正则表达式怎么变换，这下面三行不用改了，省事！</span><span class="token keyword">let</span> year <span class="token operator">=</span> match<span class="token punctuation">.</span>groups<span class="token punctuation">.</span>year<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//>> 2018</span><span class="token keyword">let</span> month <span class="token operator">=</span> match<span class="token punctuation">.</span>groups<span class="token punctuation">.</span>month<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//>> 08</span><span class="token keyword">let</span> day <span class="token operator">=</span> match<span class="token punctuation">.</span>groups<span class="token punctuation">.</span>day<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//>> 06</span></code></pre><p>命名捕获组的写法相当于是把每个捕获组都定义了一个名字，然后存储到返回值的<code>groups</code>属性中。</p><h3 id="正则表达式后行断言"><a href="#正则表达式后行断言" class="headerlink" title="正则表达式后行断言"></a>正则表达式后行断言</h3><p>先看看正则表达式<strong>先行断言</strong>示例：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> re1 <span class="token operator">=</span> <span class="token regex">/\D(\d+)/</span><span class="token punctuation">,</span>    re2 <span class="token operator">=</span> <span class="token regex">/\D(?=\d+)/</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//"?="是正向先行断言</span>    match1 <span class="token operator">=</span> re1<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token string">"$123.45"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    match2 <span class="token operator">=</span> re2<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token string">"$123.45"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>match1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//>> $123</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>match2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//>> $</span></code></pre><blockquote><p><strong>(?=pattern)</strong> 零宽正向先行断言(zero-width positive lookahead assertion)<br>代表字符串中的一个位置，<strong>紧接该位置之后</strong>的字符序列<strong>能够匹配</strong>pattern；</p><p>(<strong>?!pattern)</strong> 零宽负向先行断言(zero-width negative lookahead assertion)<br>代表字符串中的一个位置，<strong>紧接该位置之后</strong>的字符序列<strong>不能匹配</strong>pattern；</p><p><strong>(?&lt;=pattern)</strong> 零宽正向后行断言(zero-width positive lookbehind assertion)<br>代表字符串中的一个位置，<strong>紧接该位置之前</strong>的字符序列<strong>能够匹配</strong>pattern；</p><p><strong>(?&lt;!pattern)</strong> 零宽负向后行断言(zero-width negative lookbehind assertion)<br>代表字符串中的一个位置，<strong>紧接该位置之前</strong>的字符序列<strong>不能匹配</strong>pattern。</p></blockquote><p>在ES9中，可以允许使用<code>?&lt;=</code>进行<strong>正向后行断言</strong>，可以获取货币的价格而忽略货币符号。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> re<span class="token operator">=</span> <span class="token regex">/(?&lt;=\D)[\d\.]+/</span><span class="token punctuation">,</span>    match <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token string">"$123.45"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>match<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//>> 123.45</span></code></pre><p>上面的正向后行断言，也就是说<code>\D</code>这个条件必须满足，但<code>\D</code>匹配的字符不会作为结果输出（因为<strong>先行/后行断言</strong>其实只是匹配了一个位置）。如果是下面这样：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> re<span class="token operator">=</span> <span class="token regex">/(?&lt;=\D)[\d\.]+/</span><span class="token punctuation">,</span>    match1 <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token string">"123.45"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    match2 <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token string">"12345"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>match1 <span class="token operator">&amp;&amp;</span> match1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//>> 45</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>match2 <span class="token operator">&amp;&amp;</span> match1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//>> null</span></code></pre><p>可以看到<code>match1</code>匹配到的是<code>45</code>,这是由于在<code>.</code>前面没有任何符合<code>\D</code>的匹配内容，它会一直找到符合<code>\D</code>的内容，也就是<code>.</code>然后返回后面的内容。而<code>match2</code>若是没有满足前面肯定反向断言的条件的话，则结果返回<code>null</code>。</p><h2 id="正则表达式-Unicode-转义"><a href="#正则表达式-Unicode-转义" class="headerlink" title="正则表达式 Unicode 转义"></a>正则表达式 Unicode 转义</h2><p>ES9 之前，在正则表达式中本地访问 Unicode 字符属性是不被允许的。ES9 添加了 Unicode 属性转义，形式为<code>\p{...}</code>和<code>\P{...}</code>，在正则表达式中使用标记 <code>u</code> (unicode) 设置，在<code>\p</code>的<code>{...}</code>内，可用键值对的方式设置需要匹配的属性而非具体内容。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> regex <span class="token operator">=</span> <span class="token regex">/\p{Script=Greek}/u</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//Greek为希腊语的意思</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>regex<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//>> flase</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>regex<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">'Σ'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//>> true</span></code></pre><h1 id="ES-10-新特性"><a href="#ES-10-新特性" class="headerlink" title="ES 10 新特性"></a>ES 10 新特性</h1><table><thead><tr><th align="left">新特性</th><th align="left">中文说明</th></tr></thead><tbody><tr><td align="left">Optional <code>catch</code> binding</td><td align="left">可选的 catch 变量绑定</td></tr><tr><td align="left">JSON superset</td><td align="left">JSON超集</td></tr><tr><td align="left"><code>Symbol.prototype.description</code></td><td align="left">Symbol 对象的 description 属性</td></tr><tr><td align="left"><code>Function.prototype.toString</code> revision</td><td align="left">修订<code>Function.prototype.toString</code></td></tr><tr><td align="left"><code>Object.fromEntries</code></td><td align="left"></td></tr><tr><td align="left">Well-formed <code>JSON.stringify</code></td><td align="left">更加友好的JSON.stringify</td></tr><tr><td align="left"><code>String.prototype.{trimStart,trimEnd}</code></td><td align="left"></td></tr><tr><td align="left"><code>Array.prototype.{flat,flatMap}</code></td><td align="left"></td></tr></tbody></table><h2 id="可选的-catch-变量绑定"><a href="#可选的-catch-变量绑定" class="headerlink" title="可选的 catch 变量绑定"></a>可选的 catch 变量绑定</h2><p>在 ES10 之前，我们必须通过语法为 catch 子句绑定异常变量，无论是否有必要。很多时候 catch 块是多余的，而 ES10 使我们能够简单的把变量省略掉。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//之前是</span><span class="token keyword">try</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//ES10之后可以写成，</span><span class="token keyword">try</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//省掉了变量e</span></code></pre><h2 id="JSON超集"><a href="#JSON超集" class="headerlink" title="JSON超集"></a>JSON超集</h2><p>什么是 JSON 超集？简单来说就是 JSON 是 ECMAScript 的子集，也就是说让 ECMAScript 兼容 JSON 的内容所支持的全部文本。</p><p>ECMAScript 在标准 <a href="https://tc39.es/ecma262/#sec-json.parse">JSON.parse</a> 部分阐明了 JSON 确为其一个子集，但由于 JSON 的内容可以正常包含 <code>U+2028</code> 行分隔符与 <code>U+2029</code> 段落分隔符，而 ECMAScript 却不行，所以，该草案旨在解决这一问题。在这之前，如果你使用 <code>JSON.parse()</code> 执行带如上特殊字符的字符串时，只会收到 <code>SyntaxError</code> 的错误提示。该草案同样是向后兼容的，其对用户唯一的影响是保持原样，即在暂不支持特殊字符解析的运行环境中保持报错 <code>SyntaxError</code> 。</p><h2 id="Symbol-对象的-description-属性"><a href="#Symbol-对象的-description-属性" class="headerlink" title="Symbol 对象的 description 属性"></a>Symbol 对象的 description 属性</h2><p>ES10 中为 Symbol 对象添加了只读属性 <code>description</code> ，该对象返回包含 Symbol 描述的字符串。在创建Symbol时向其添加<code>description</code> (描述)，能够直接访问<code>description</code> ，对调试是很有用的。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> sym <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//添加的描述内容为“foo”</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>sym<span class="token punctuation">.</span>description<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//>> foo</span>sym <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>sym<span class="token punctuation">.</span>description<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//>> undefined</span><span class="token comment" spellcheck="true">//和 Symbol() 不同的是，用 Symbol.for() 方法创建的的 symbol 会被放入一个全局 </span><span class="token comment" spellcheck="true">//symbol 注册表中。Symbol.for() 并不是每次都会创建一个新的 symbol，它会首先检</span><span class="token comment" spellcheck="true">//查给定的 key 是否已经在注册表中了。假如是，则会直接返回上次存储的那个。否则，它</span><span class="token comment" spellcheck="true">//会再新建一个。</span>sym <span class="token operator">=</span> Symbol<span class="token punctuation">.</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token string">'bar'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>sym<span class="token punctuation">.</span>description<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//>> bar</span></code></pre><h2 id="修订Function-prototype-toString"><a href="#修订Function-prototype-toString" class="headerlink" title="修订Function.prototype.toString"></a>修订Function.prototype.toString</h2><p>函数原型上的方法<code>toString()</code>现在返回精确字符，包括空格和注释。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token comment" spellcheck="true">/* comment */</span> foo <span class="token comment" spellcheck="true">/* another comment */</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//ES10之前不会打印注释部分</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//>> function foo(){}</span><span class="token comment" spellcheck="true">//ES10里，会把注释一同打印</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//>> function </span><span class="token comment" spellcheck="true">/* comment */</span> foo <span class="token comment" spellcheck="true">/* another comment */</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//注意：</span><span class="token comment" spellcheck="true">//箭头函数是个例外</span><span class="token keyword">const</span> bar <span class="token comment" spellcheck="true">/* comment */</span> <span class="token operator">=</span> <span class="token comment" spellcheck="true">/* another comment */</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>bar<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//>> () => {}</span></code></pre><h2 id="Object-fromEntries"><a href="#Object-fromEntries" class="headerlink" title="Object.fromEntries"></a>Object.fromEntries</h2><p>在 JavaScript 操作中，数据在各种数据结构之间的转换都是很容易的，比如 Map 到数组、Map 到 Set、对象到 Map 等等。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span><span class="token string">'bar'</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> arr <span class="token operator">=</span> Array<span class="token punctuation">.</span><span class="token keyword">from</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> <span class="token keyword">set</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> foo<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> bar<span class="token punctuation">:</span> <span class="token boolean">false</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//下一句 Object.entries() 方法返回给定对象 obj 自身可枚举属性的键值对数组,</span><span class="token comment" spellcheck="true">//形如：[["foo",true],["bar",false]]</span><span class="token keyword">let</span> newMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">entries</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>但是如果我们需要将一个键值对列表转换为对象，就要写点费劲的代码了。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span><span class="token string">"foo"</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span><span class="token string">"bar"</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> obj <span class="token operator">=</span> Array<span class="token punctuation">.</span><span class="token keyword">from</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span>acc<span class="token punctuation">,</span> <span class="token punctuation">[</span>key<span class="token punctuation">,</span> val<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span>acc<span class="token punctuation">,</span> <span class="token punctuation">{</span>    <span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">:</span> val  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>该特性的目的在于为对象添加一个新的静态方法 <code>Object.fromEntries</code>，用于将符合键值对的列表（例如 Map、数组等）转换为一个对象。上一块的代码中的转换逻辑，现在我们只需要一行代码即可搞定。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span><span class="token string">"foo"</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span><span class="token string">"bar"</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> obj <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">fromEntries</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="更加友好的-JSON-stringify"><a href="#更加友好的-JSON-stringify" class="headerlink" title="更加友好的 JSON.stringify"></a>更加友好的 JSON.stringify</h2><p>ES10 之前，当你使用 <code>JSON.stringify()</code> 处理无法用 UTF-8 编码表示的字符时（U+D800 至 U+DFFF），返回的结果会是一个乱码 Unicode 字符“�”。该特性提出用<code>JSON.stringify()</code>来安全的表示这些不正常的UTF-8字符。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> r<span class="token punctuation">;</span>r <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span><span class="token string">"❤"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//正常的UTF-8字符原样输出</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//>> "❤"</span>r <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span><span class="token string">'\u2764'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//正常的UTF-8字符编码，输出解码之后的模样</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//>> "❤"</span>r <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span><span class="token string">"\uDF06\uD834"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//不正常的UTF-8字符编码，则以unicode形式输出</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//>> "\udf06\ud834"</span>r <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span><span class="token string">"\uDEAD"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//不正常的UTF-8字符编码，则以unicode形式输出</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//>> "\udead"</span></code></pre><h2 id="String-prototype-trimStart-trimEnd"><a href="#String-prototype-trimStart-trimEnd" class="headerlink" title="String.prototype.{trimStart,trimEnd}"></a>String.prototype.{trimStart,trimEnd}</h2><p>新增了String的<code>trimStart()</code>方法和<code>trimEnd()</code>方法，这两个方法很好理解，分别去除字符串首、尾的空白字符，就不举例占篇幅了。</p><h2 id="Array-prototype-flat-flatMap"><a href="#Array-prototype-flat-flatMap" class="headerlink" title="Array.prototype.{flat,flatMap}"></a>Array.prototype.{flat,flatMap}</h2><p>这个特性新创造了两个方法，其中：</p><ul><li><code>Array.prototype.flat</code> 数组的所有项会以指定的维度降维（扁平化），然后组成新数组返回；</li><li><code>Array.prototype.flatMap</code> 首先会执行一次<code>map()</code>方法，然后再通过类似<code>flat()</code>方法<strong>扁平化</strong>数组。它等同于执行完 <code>map()</code> 后再执行一次 <code>flat()</code> 方法，所以当你执行 <code>map()</code> 返回的结果如果是个数组，然后又要将其扁平化时，这个方法会显得方便。</li></ul><p>来看几个例子解释一下，首先 <code>flat()</code> 方法支持多维数组的扁平化，其中<code>Infinity</code>可以将多维数组压扁成一维数组。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> r<span class="token punctuation">;</span>r <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">"8"</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">"9"</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">"1"</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">flat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//4维数组，默认降维1，变成3维数组</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//>> [ '1', '8', [ '9', ['1'] ] ]</span>r <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">"8"</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">"9"</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">"1"</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">flat</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//4维数组，降维2，变成2维数组</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//>> [ '1', '8', '9', ['1'] ]</span>r <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">"8"</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">"9"</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">"1"</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">flat</span><span class="token punctuation">(</span><span class="token number">Infinity</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//4维数组，最多变成1维数组</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//>> [ '1', '8', '9', '1' ]</span></code></pre><p>接着来看看<code>flatMap()</code></p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> r<span class="token punctuation">;</span>r <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"I love"</span><span class="token punctuation">,</span> <span class="token string">"coffe 1891"</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>item <span class="token operator">=</span><span class="token operator">></span> item<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//>> [ [ 'I', 'love' ], [ 'coffe', '1891' ] ]</span>r <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"I love"</span><span class="token punctuation">,</span> <span class="token string">"coffe 1891"</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">flatMap</span><span class="token punctuation">(</span>item <span class="token operator">=</span><span class="token operator">></span> item<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//>>[ 'I', 'love', 'coffe', '1891' ]</span></code></pre><h1 id="ES-2020-ES11-新特性"><a href="#ES-2020-ES11-新特性" class="headerlink" title="ES 2020 (ES11) 新特性"></a>ES 2020 (ES11) 新特性</h1><p>因为太“新”，现在若想使用ES11新特性，则需要安装babel插件</p><pre class=" language-javascript"><code class="language-javascript">plugins<span class="token punctuation">:</span> <span class="token punctuation">[</span>    <span class="token string">"@babel/plugin-proposal-nullish-coalescing-operator"</span><span class="token punctuation">,</span>    <span class="token string">"@babel/plugin-proposal-optional-chaining"</span><span class="token punctuation">,</span>    <span class="token string">"@babel/plugin-proposal-class-properties"</span><span class="token punctuation">,</span>    <span class="token string">"@babel/plugin-proposal-private-methods"</span><span class="token punctuation">,</span>    <span class="token string">"@babel/plugin-syntax-bigint"</span><span class="token punctuation">]</span></code></pre><table><thead><tr><th align="left">新特性</th><th align="left">中文说明</th></tr></thead><tbody><tr><td align="left">Optional Chaining</td><td align="left">可选链操作符</td></tr><tr><td align="left">Nullish coalescing Operator</td><td align="left">空位合并操作符</td></tr><tr><td align="left"><code>String.prototype.matchAll</code></td><td align="left"></td></tr><tr><td align="left"><code>import()</code></td><td align="left">import()函数</td></tr><tr><td align="left"><code>Promise.allSettled</code></td><td align="left"></td></tr><tr><td align="left">Bigint</td><td align="left"></td></tr><tr><td align="left">globalThis</td><td align="left">全局this</td></tr></tbody></table><h2 id="Optional-Chaining"><a href="#Optional-Chaining" class="headerlink" title="Optional Chaining"></a>Optional Chaining</h2><p><strong>可选链操作符</strong> <code>?</code> 可让我们在查询具有多个层级的对象时，不再需要进行冗余的各种前置校验。</p><p>以前要读取一个对象的属性值，需要写一些防御性的前置校验代码，比如：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> second <span class="token operator">=</span> obj <span class="token operator">&amp;&amp;</span> obj<span class="token punctuation">.</span>first <span class="token operator">&amp;&amp;</span> obj<span class="token punctuation">.</span>first<span class="token punctuation">.</span>second<span class="token punctuation">;</span></code></pre><p>在访问 obj.first.second 之前，要先确认 obj 和 obj.first 的值非 null(且不是 undefined)。有了可选链式操作符，则可以大量简化类似繁琐的前置校验操作，而且更安全：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> second <span class="token operator">=</span> obj<span class="token operator">?</span><span class="token punctuation">.</span>first<span class="token operator">?</span><span class="token punctuation">.</span>second<span class="token punctuation">;</span></code></pre><p>如果 <code>obj</code> 或<code>obj.first</code>是<code>null</code>/<code>undefined</code>，表达式将会直接返回<code>undefined</code>。</p><h2 id="Nullish-coalescing-Operator-空值处理"><a href="#Nullish-coalescing-Operator-空值处理" class="headerlink" title="Nullish coalescing Operator(空值处理)"></a>Nullish coalescing Operator(空值处理)</h2><p>以前对于如下的情况：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> v <span class="token operator">=</span> a <span class="token operator">||</span> <span class="token string">"some value"</span><span class="token punctuation">;</span><span class="token keyword">let</span> z <span class="token operator">=</span> a <span class="token operator">?</span> a <span class="token punctuation">:</span> <span class="token string">"some value"</span><span class="token punctuation">;</span></code></pre><p>如果 a 的值是 <code>0</code> 、 空字符串<code>''</code> 、<code>false</code>等可能有意义的值，但是在上面的表达式中被认为是假值，因此v 和 z 也会被赋值为 <code>some value</code>。也即：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 0、''、false可能是有意义的</span><span class="token keyword">let</span> v <span class="token operator">=</span> a <span class="token operator">||</span> <span class="token string">"some value"</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//>> some value</span></code></pre><p>为解决这种问题，诞生了<code>??</code> ，如果表达式在<code>??</code>的左侧值为<code>undefined</code>或<code>null</code>，就返回右侧默认的值。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token keyword">let</span> v <span class="token operator">=</span> a <span class="token operator">?</span><span class="token operator">?</span> <span class="token string">"some value"</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//>> 0</span><span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token keyword">let</span> z <span class="token operator">=</span> b <span class="token operator">?</span><span class="token operator">?</span> <span class="token string">"some value"</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>z<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//>> some value</span></code></pre><h2 id="String-prototype-matchAll"><a href="#String-prototype-matchAll" class="headerlink" title="String.prototype.matchAll"></a>String.prototype.matchAll</h2><p><code>matchAll()</code> 方法返回一个包含所有匹配正则表达式及分组捕获结果的迭代器（iterator）。 在 <code>matchAll</code> 出现之前，通过在循环中调用<code>Regexp.exec</code>来获取所有匹配项信息（<code>Regexp</code>需使用<code>/g</code>标志）：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> regexp <span class="token operator">=</span> <span class="token function">RegExp</span><span class="token punctuation">(</span><span class="token string">'foo*'</span><span class="token punctuation">,</span><span class="token string">'g'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> str <span class="token operator">=</span> <span class="token string">'coffe football, foosball'</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>matches <span class="token operator">=</span> regexp<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`找到 </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>matches<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">，下一轮循环从位置 </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>regexp<span class="token punctuation">.</span>lastIndex<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> 开始`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//>> 找到 foo，下一轮循环从位置 9 开始</span>  <span class="token comment" spellcheck="true">//>> 找到 foo，下一轮循环从位置 19 开始</span><span class="token punctuation">}</span></code></pre><p>如果使用<code>matchAll</code> ，就可以不必使用<code>while</code>循环加<code>exec</code>方式（且正则表达式需使用<code>/g</code>标志）。使用<code>matchAll</code> 会得到一个迭代器的返回值，配合 <code>for...of</code>，<code>array spread</code>，<code>Array.from()</code> 可以更方便实现功能。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> regexp <span class="token operator">=</span> <span class="token function">RegExp</span><span class="token punctuation">(</span><span class="token string">'foo*'</span><span class="token punctuation">,</span><span class="token string">'g'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">const</span> str <span class="token operator">=</span> <span class="token string">'coffe football, foosball'</span><span class="token punctuation">;</span><span class="token keyword">let</span> matches <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">matchAll</span><span class="token punctuation">(</span>regexp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> match <span class="token keyword">of</span> matches<span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>match<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//>> [ "foo" ]</span><span class="token comment" spellcheck="true">//>> [ "foo" ]</span><span class="token comment" spellcheck="true">//注意：</span><span class="token comment" spellcheck="true">//matches的迭代器在for..of之后已经被消耗掉了，</span><span class="token comment" spellcheck="true">//需要再次调用matchAll创建一个新的迭代器</span>matches <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">matchAll</span><span class="token punctuation">(</span>regexp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> arr <span class="token operator">=</span> Array<span class="token punctuation">.</span><span class="token keyword">from</span><span class="token punctuation">(</span>matches<span class="token punctuation">,</span> m <span class="token operator">=</span><span class="token operator">></span> m<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//>> [ "foo", "foo" ]</span></code></pre><h2 id="import-函数"><a href="#import-函数" class="headerlink" title="import()函数"></a>import()函数</h2><p>这个特性为JavaScript添加了一个类函数（function-like）的<code>import()</code>功能，以便可以像函数传参那样传入参数实现<strong>动态</strong>（没错，<code>import</code>是静态引用的）引用模块（module）。下面有个单页应用简单示例，演示了用<code>import()</code>开启懒加载。</p><pre class=" language-markup"><code class="language-markup"><span class="token doctype">&lt;!DOCTYPE html></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>nav</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>books.html<span class="token punctuation">"</span></span> <span class="token attr-name">data-entry-module</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>books<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>书籍<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>movies.html<span class="token punctuation">"</span></span> <span class="token attr-name">data-entry-module</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>movies<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>电影<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>video-games.html<span class="token punctuation">"</span></span> <span class="token attr-name">data-entry-module</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>video-games<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>电视游戏<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>nav</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>main</span><span class="token punctuation">></span></span>内容将会加载到这里！<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>main</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">  <span class="token keyword">const</span> main <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">"main"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> link <span class="token keyword">of</span> document<span class="token punctuation">.</span><span class="token function">querySelectorAll</span><span class="token punctuation">(</span><span class="token string">"nav > a"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    link<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"click"</span><span class="token punctuation">,</span> e <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      e<span class="token punctuation">.</span><span class="token function">preventDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`./section-modules/</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>link<span class="token punctuation">.</span>dataset<span class="token punctuation">.</span>entryModule<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">.js`</span></span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//动态引用</span>        <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>module <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//加载模块成功以后，该模块会当作then方法的参数</span>          module<span class="token punctuation">.</span><span class="token function">loadPageInto</span><span class="token punctuation">(</span>main<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span>err <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//捕捉异常</span>          main<span class="token punctuation">.</span>textContent <span class="token operator">=</span> err<span class="token punctuation">.</span>message<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre><p>请注意<code>import()</code>和<code>import</code>的区别：</p><ul><li>import() 可以用在script脚本区，不止是模块内；</li><li>如果在模块内使用import()，它可以在任何地方任何级别执行，而不是被提升到顶级（优先执行）；</li><li>import() 是运行时执行，也即什么时候运行到这句，就会加载参数指定的模块；参数也可以是动态可变的，不止是静态参数；</li><li>import() 不建立可静态分析的依赖关系（静态分析的情况下可以做很多优化），但是，在一些比较简单的情况下，比如<code>import（“/foo.js”）</code>中，实现仍然可以执行静态分析优化。</li></ul><p>如果模块采用<code>default</code>的形式对外暴露接口，则可用<code>default</code>属性直接获得。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'./module.js'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>module <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>module<span class="token punctuation">.</span><span class="token keyword">default</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//直接通过default属性获得模块暴露的接口</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="Promise-allSettled"><a href="#Promise-allSettled" class="headerlink" title="Promise.allSettled"></a>Promise.allSettled</h2><p>为什么要有<code>Promise.allSettled()</code>？</p><p>举例说明，比如各位用户在页面上面同时填了3个独立的表单，这三个表单分三个接口提交到后端，三个接口独立，没有顺序依赖，这个时候我们需要等到请求全部完成后给与用户提示表单提交的情况。</p><p>在多个<code>promise</code>同时进行时咱们很快会想到使用<code>Promise.all</code>来进行包装，但是由于<code>Promise.all</code>的一票否决的特性，三个提交中若前面任意一个提交失败，则后面的表单也不会进行提交了，这就与咱们需求不符合。</p><p><code>Promise.allSettled</code>跟<code>Promise.all</code>类似，其参数接受一个<code>Promise</code>的数组，返回一个新的<code>Promise</code>，唯一的不同在于，其没有一票否决的特性，也就是说当<code>Promise</code>全部处理完成后我们可以拿到每个<code>Promise</code>的状态，而不管其是否处理成功。</p><pre class=" language-javascript"><code class="language-javascript">Promise<span class="token punctuation">.</span><span class="token function">allSettled</span><span class="token punctuation">(</span><span class="token punctuation">[</span>Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">"coffe"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span><span class="token string">"1891"</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>  arr <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//>> [ { status: "fulfilled", value: "coffe"},</span>                      <span class="token comment" spellcheck="true">//>>   { status: "rejected", reason: "1891" } ]</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="Bigint"><a href="#Bigint" class="headerlink" title="Bigint"></a>Bigint</h2><p>JavasSript 在数学计算领域很糟糕的原因之一是它只能安全的表示<code>-(2^53-1)</code>至 <code>2^53-1</code> 范的值，即<code>Number.MIN_SAFE_INTEGER</code> 至<code>Number.MAX_SAFE_INTEGER</code>，超出这个范围的整数计算或者表示会丢失精度。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> num <span class="token operator">=</span> Number<span class="token punctuation">.</span>MAX_SAFE_INTEGER<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// >> 9007199254740991</span>num <span class="token operator">=</span> num <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// >> 9007199254740992</span><span class="token comment" spellcheck="true">// 再次加 +1 后无法正常运算</span>num <span class="token operator">=</span> num <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// >> 9007199254740992</span><span class="token comment" spellcheck="true">// 两个不同的值，却返回了true</span><span class="token number">9007199254740992</span> <span class="token operator">===</span> <span class="token number">9007199254740993</span>  <span class="token comment" spellcheck="true">// >> true</span></code></pre><p>于是 BigInt 诞生了，<strong>它是JavaScript的第7个原始类型</strong>，可安全地进行大数整型计算。 你可以在BigInt上使用与普通数字相同的运算符，例如 +, -, /, *, %等等。</p><p>创建 BigInt 类型的值也非常简单，只需要在数字后面加上 <code>n</code> 即可。例如，123 变为 123n。也可以使用全局方法 BigInt(value) 转化，入参 value 为数字或数字字符串。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> aNumber <span class="token operator">=</span> <span class="token number">1891</span><span class="token punctuation">;</span><span class="token keyword">const</span> aBigInt <span class="token operator">=</span> <span class="token function">BigInt</span><span class="token punctuation">(</span>aNumber<span class="token punctuation">)</span><span class="token punctuation">;</span>aBigInt <span class="token operator">===</span> 1891n <span class="token comment" spellcheck="true">// true</span><span class="token keyword">typeof</span> aBigInt <span class="token operator">===</span> <span class="token string">'bigint'</span> <span class="token comment" spellcheck="true">// true</span><span class="token keyword">typeof</span> <span class="token number">1891</span> <span class="token comment" spellcheck="true">// "number"</span><span class="token keyword">typeof</span> 1891n <span class="token comment" spellcheck="true">// "bigint"</span></code></pre><p>只要在数字末尾加上 n，就可以正确计算大数：</p><pre class=" language-javascript"><code class="language-javascript">1234567890123456789n <span class="token operator">*</span> 123n<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// -> 151851850485185185047n</span></code></pre><p>最后要注意，不能将 BigInt与Number混合使用。比较Number和 BigInt是可以的，但是不能把它们相加。</p><pre class=" language-javascript"><code class="language-javascript">1n <span class="token operator">&lt;</span> <span class="token number">2</span> <span class="token comment" spellcheck="true">// true</span>1n <span class="token operator">+</span> <span class="token number">2</span> <span class="token comment" spellcheck="true">// Uncaught TypeError: Cannot mix BigInt and other types, use explicit conversions</span></code></pre><h2 id="globalThis"><a href="#globalThis" class="headerlink" title="globalThis"></a>globalThis</h2><p>globalThis 是一个全新的标准方法用来获取全局 this 。之前开发者会通过如下的一些方法获取：</p><ul><li>全局变量 window：是一个经典的获取全局对象的方法。但是它在 Node.js 和 Web Workers 中并不能使用</li><li>全局变量 self：通常只在 Web Workers 和浏览器中生效。但是它不支持 Node.js。一些人会通过判断 self 是否存在识别代码是否运行在 Web Workers 和浏览器中</li><li>全局变量 global：只在 Node.js 中生效</li></ul><p>过去获取全局对象，可通过一个全局函数：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// ES10之前的解决方案</span><span class="token keyword">const</span> getGlobal <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> self <span class="token operator">!==</span> <span class="token string">'undefined'</span><span class="token punctuation">)</span> <span class="token keyword">return</span> self  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> window <span class="token operator">!==</span> <span class="token string">'undefined'</span><span class="token punctuation">)</span> <span class="token keyword">return</span> window  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> global <span class="token operator">!==</span> <span class="token string">'undefined'</span><span class="token punctuation">)</span> <span class="token keyword">return</span> global  <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'unable to locate global object'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// ES10内置</span>globalThis<span class="token punctuation">.</span><span class="token function">Array</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// [0,1,2]</span><span class="token comment" spellcheck="true">// 定义一个全局对象v = { value:true } ,ES10用如下方式定义</span>globalThis<span class="token punctuation">.</span>v <span class="token operator">=</span> <span class="token punctuation">{</span> value<span class="token punctuation">:</span><span class="token boolean">true</span> <span class="token punctuation">}</span></code></pre><p>而 <strong>globalThis 目的就是提供一种标准化方式访问全局对象</strong>，有了 globalThis 后，你可以在任意上下文，任意时刻都能获取到全局对象。如果您在浏览器上，globalThis将为window，如果您在Node上，globalThis则将为global。因此，不再需要考虑不同的环境问题。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// worker</span>globalThis <span class="token operator">===</span> self<span class="token comment" spellcheck="true">// node</span>globalThis <span class="token operator">===</span> global<span class="token comment" spellcheck="true">// browser</span>globalThis <span class="token operator">===</span> window</code></pre><h1 id="ES-2021-ES12-等2021年发布"><a href="#ES-2021-ES12-等2021年发布" class="headerlink" title="ES 2021 (ES12) 等2021年发布"></a>ES 2021 (ES12) 等2021年发布</h1><table><thead><tr><th align="left">新特性</th><th align="left">中文说明</th></tr></thead><tbody><tr><td align="left">String.prototype.replaceAll</td><td align="left">替换所有符合的字符串</td></tr><tr><td align="left">Promise.any</td><td align="left">返回Promise列表中第一个resolve的结果状态</td></tr><tr><td align="left">WeakRefs</td><td align="left"></td></tr><tr><td align="left">逻辑运算符和赋值表达式</td><td align="left"></td></tr><tr><td align="left">数字分隔符</td><td align="left"></td></tr></tbody></table><h2 id="replaceAll"><a href="#replaceAll" class="headerlink" title="replaceAll"></a>replaceAll</h2><p>看到replaceAll这个词，相比很容易联想到replace。在JavaScript中，replace方法只能是替换字符串中匹配到的第一个实例字符，而不能进行全局多项匹配替换，唯一的办法是通过正则表达式进行相关规则匹配替换，而replaceAll则是返回一个全新的字符串，所有符合匹配规则的字符都将被替换掉，替换规则可以是字符串或者正则表达式。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> string <span class="token operator">=</span> <span class="token string">'I like javaScript,I like css'</span><span class="token comment" spellcheck="true">//使用replace</span><span class="token keyword">let</span> replaceStr <span class="token operator">=</span> string<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">'like'</span><span class="token punctuation">,</span><span class="token string">'love'</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>replaceStr<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 'I love javaScript,I like css'</span><span class="token comment" spellcheck="true">//replace使用正则匹配所有</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>string<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex">/like/g</span><span class="token punctuation">,</span><span class="token string">'love'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 'I love javaScript,I love css'</span><span class="token comment" spellcheck="true">//使用replaceAll</span><span class="token keyword">let</span> replaceAllStr <span class="token operator">=</span> string<span class="token punctuation">.</span><span class="token function">replaceAll</span><span class="token punctuation">(</span><span class="token string">'like'</span><span class="token punctuation">,</span><span class="token string">'love'</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>replaceAllStr<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 'I love javaScript,I love css'</span></code></pre><h2 id="Promise-any"><a href="#Promise-any" class="headerlink" title="Promise.any"></a>Promise.any</h2><p>当Promise列表中的任意一个promise成功resolve则返回第一个resolve的结果状态。</p><pre class=" language-javascript"><code class="language-javascript">Promise<span class="token punctuation">.</span><span class="token function">any</span><span class="token punctuation">(</span><span class="token punctuation">[</span>  <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">setTimeout</span><span class="token punctuation">(</span>reject<span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">,</span> <span class="token string">'哎呀，我被拒绝了'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">setTimeout</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">,</span> <span class="token string">'哎呀，她接受我了'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">setTimeout</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">,</span> <span class="token string">'哎呀，她也接受我了'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>value <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`输出结果: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>value<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">err</span> <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//输出结果:哎呀，她接受我了</span></code></pre><p>如果所有的promise均reject，则抛出异常表示所有请求失败。</p><pre class=" language-javascript"><code class="language-javascript">Promise<span class="token punctuation">.</span><span class="token function">any</span><span class="token punctuation">(</span><span class="token punctuation">[</span>  Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span><span class="token string">'Error 1'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span><span class="token string">'Error 2'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span><span class="token string">'Error 3'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>value <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`请求结果: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>value<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">err</span> <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//输出</span>AggregateError<span class="token punctuation">:</span> All promises were rejected</code></pre><h2 id="WeakRefs"><a href="#WeakRefs" class="headerlink" title="WeakRefs"></a>WeakRefs</h2><p>使用WeakRefs的Class类创建对对象的弱引用(对对象的弱引用是指当该对象应该被GC回收时不会阻止GC的回收行为)</p><p>当我们通过（const、let、var）创建一个变量时，垃圾收集器GC将永远不会从内存中删除该变量，只要它的引用仍然存在可访问。WeakRef对象包含对对象的弱引用。对对象的弱引用是不会阻止垃圾收集器GC恢复该对象的引用，则GC可以在任何时候删除它。</p><p>WeakRefs在很多情况下都很有用，比如使用Map对象来实现具有很多需要大量内存的键值缓存，在这种情况下最方便的就是尽快释放键值对占用的内存。</p><p>目前，可以通过WeakMap()或者WeakSet()来使用WeakRefs。</p><h2 id="数字分隔符"><a href="#数字分隔符" class="headerlink" title="数字分隔符"></a>数字分隔符</h2><p>数字分隔符，可以在数字之间创建可视化分隔符，通过_下划线来分割数字，使数字更具可读性。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> money <span class="token operator">=</span> 1_000_000_000<span class="token comment" spellcheck="true">//等价于</span><span class="token keyword">const</span> money <span class="token operator">=</span> <span class="token number">1000000000</span><span class="token keyword">const</span> totalFee <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">.</span>12_34<span class="token comment" spellcheck="true">//等价于</span><span class="token keyword">const</span> totalFee <span class="token operator">=</span> <span class="token number">1000.1234</span></code></pre><p>该新特性同样支持在八进制数中使用</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> number <span class="token operator">=</span> 0o123_456<span class="token comment" spellcheck="true">//等价于</span><span class="token keyword">const</span> number <span class="token operator">=</span> <span class="token number">0o123456</span></code></pre><h1 id="本篇结语"><a href="#本篇结语" class="headerlink" title="本篇结语"></a>本篇结语</h1><p>很显然ECMAScript接下来会持续不断地更新，按TC39的计划是每年都会发一个新版本。虽然节奏很快，但是我们完全没必要担心跟不上节奏。除了ES6这个史无前例的版本带来了超大量的新特性外，之后每年发的版本都仅仅带有少量的增量更新，你只需要花45分钟就能搞明白这一年更新的特性。保持一颗好奇的心，你会不断进步，变得更强！</p>]]></content>
      
      
      <categories>
          
          <category> ES语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spread和rest操作符</title>
      <link href="2020/11/09/spread-he-rest-cao-zuo-fu/"/>
      <url>2020/11/09/spread-he-rest-cao-zuo-fu/</url>
      
        <content type="html"><![CDATA[<h1 id="spread和rest的区别"><a href="#spread和rest的区别" class="headerlink" title="spread和rest的区别"></a>spread和rest的区别</h1><p>spread和rest运算符都是<code>...</code>+<code>变量/参数</code>的形式。是spread还是rest，要根据上下文情境来判断。</p><h2 id="1-spread"><a href="#1-spread" class="headerlink" title="1.spread"></a>1.spread</h2><p>当被用于迭代器中时，它是 spread 操作符：</p><pre class=" language-javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">...</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 1 2 3 4 5</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">...</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//[1,2,3,4,5]</span></code></pre><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">const</span> numbers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">38</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token operator">...</span>numbers<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 42</span></code></pre><p>spread主要形式是<code>...[Array]</code>，表示对数组的展开。</p><h2 id="2-rest"><a href="#2-rest" class="headerlink" title="2.rest"></a>2.rest</h2><p>当被用于定义函数的参数时，是 rest 操作符：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">...</span>items<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>items<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span><span class="token function">push</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//[4,1,2,3]</span></code></pre><p>rest主要是将函数的多个参数转化成数组，<strong>而且只能放在函数参数的最后一个位置</strong>，否则，比如<code>（array,...items,other）</code>会报错。 </p><p>而rest的出现，让已经不被推荐使用的<code>arguments</code>彻底寿终正寝了。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span> <span class="token punctuation">{</span>   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>args<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">...</span>arguments<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//spread形式的用法</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//>> 1,2,3</span><span class="token comment" spellcheck="true">//>> 1,2,3</span></code></pre><h1 id="用法示例"><a href="#用法示例" class="headerlink" title="用法示例"></a>用法示例</h1><h2 id="1-添加属性"><a href="#1-添加属性" class="headerlink" title="1.添加属性"></a>1.添加属性</h2><p>克隆一个对象，同时向(浅)拷贝对象添加附加属性。<br>在这个示例中，user 被(浅)拷贝，password 属性被添加到 userWithPass 中。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> user <span class="token operator">=</span> <span class="token punctuation">{</span> id<span class="token punctuation">:</span> <span class="token number">100</span><span class="token punctuation">,</span> name<span class="token punctuation">:</span> <span class="token string">'Howard Moon'</span><span class="token punctuation">}</span><span class="token keyword">const</span> userWithPass <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token operator">...</span>user<span class="token punctuation">,</span> password<span class="token punctuation">:</span> <span class="token string">'Password!'</span> <span class="token punctuation">}</span>user <span class="token comment" spellcheck="true">//>> { id: 100, name: 'Howard Moon' }</span>userWithPass <span class="token comment" spellcheck="true">//>> { id: 100, name: 'Howard Moon', password: 'Password!' }</span></code></pre><h2 id="2-对象合并"><a href="#2-对象合并" class="headerlink" title="2.对象合并"></a>2.对象合并</h2><p>将两个对象合并到一个新对象中。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> part1 <span class="token operator">=</span> <span class="token punctuation">{</span> id<span class="token punctuation">:</span> <span class="token number">100</span><span class="token punctuation">,</span> name<span class="token punctuation">:</span> <span class="token string">'Howard Moon'</span> <span class="token punctuation">}</span><span class="token keyword">const</span> part2 <span class="token operator">=</span> <span class="token punctuation">{</span> id<span class="token punctuation">:</span> <span class="token number">100</span><span class="token punctuation">,</span> password<span class="token punctuation">:</span> <span class="token string">'Password!'</span> <span class="token punctuation">}</span><span class="token keyword">const</span> user1 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token operator">...</span>part1<span class="token punctuation">,</span> <span class="token operator">...</span>part2 <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//>> { id: 100, name: 'Howard Moon', password: 'Password!' }</span></code></pre><p>对象也可以使用以下语法合并：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> partial <span class="token operator">=</span> <span class="token punctuation">{</span> id<span class="token punctuation">:</span> <span class="token number">100</span><span class="token punctuation">,</span> name<span class="token punctuation">:</span> <span class="token string">'Howard Moon'</span> <span class="token punctuation">}</span><span class="token keyword">const</span> user <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token operator">...</span>partial<span class="token punctuation">,</span> id<span class="token punctuation">:</span> <span class="token number">100</span><span class="token punctuation">,</span> password<span class="token punctuation">:</span> <span class="token string">'Password!'</span> <span class="token punctuation">}</span>user <span class="token comment" spellcheck="true">//>> { id: 100, name: 'Howard Moon', password: 'Password!' }</span></code></pre><h2 id="3-排除对象属性"><a href="#3-排除对象属性" class="headerlink" title="3.排除对象属性"></a>3.排除对象属性</h2><p>可以结合使用 rest 运算符删除属性。 在下面这个例子里，password 被删除 ，其余的属性作为 rest 返回。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> noPassword <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> password<span class="token punctuation">,</span> <span class="token operator">...</span>rest <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> rest<span class="token keyword">const</span> user <span class="token operator">=</span> <span class="token punctuation">{</span>  id<span class="token punctuation">:</span> <span class="token number">100</span><span class="token punctuation">,</span>  name<span class="token punctuation">:</span> <span class="token string">'coffe1891'</span><span class="token punctuation">,</span>  password<span class="token punctuation">:</span> <span class="token string">'Password!'</span><span class="token punctuation">}</span><span class="token function">noPassword</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//>> { id: 100, name: 'coffe1891' }</span></code></pre><h2 id="4-动态排除属性"><a href="#4-动态排除属性" class="headerlink" title="4.动态排除属性"></a>4.动态排除属性</h2><p>函数接受一个 prop 作为参数。使用计算对象属性名称，可以从克隆中动态地删除属性。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> user1 <span class="token operator">=</span> <span class="token punctuation">{</span>  id<span class="token punctuation">:</span> <span class="token number">100</span><span class="token punctuation">,</span>  name<span class="token punctuation">:</span> <span class="token string">'coffe1891'</span><span class="token punctuation">,</span>  password<span class="token punctuation">:</span> <span class="token string">'Password!'</span><span class="token punctuation">}</span><span class="token keyword">const</span> removeProperty <span class="token operator">=</span> prop <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token punctuation">[</span>prop<span class="token punctuation">]</span><span class="token punctuation">:</span> _<span class="token punctuation">,</span> <span class="token operator">...</span>rest <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> rest<span class="token comment" spellcheck="true">//                     ----       ------</span><span class="token comment" spellcheck="true">//                          \   /</span><span class="token comment" spellcheck="true">//                dynamic destructuring</span><span class="token keyword">const</span> removePassword <span class="token operator">=</span> <span class="token function">removeProperty</span><span class="token punctuation">(</span><span class="token string">'password'</span><span class="token punctuation">)</span><span class="token keyword">const</span> removeId <span class="token operator">=</span> <span class="token function">removeProperty</span><span class="token punctuation">(</span><span class="token string">'id'</span><span class="token punctuation">)</span><span class="token function">removePassword</span><span class="token punctuation">(</span>user1<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//>> { id: 100, name: 'coffe1891' }</span><span class="token function">removeId</span><span class="token punctuation">(</span>user1<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//>> { name: 'coffe1891', password: 'Password!' }</span></code></pre><h2 id="5-对属性进行排序"><a href="#5-对属性进行排序" class="headerlink" title="5.对属性进行排序"></a>5.对属性进行排序</h2><p>有时性质并不按照我们需要的顺序排列。 使用一些技巧，我们可以将属性推到列表的顶部，或者将它们移到底部。若要将 id 移动到第一个位置，在扩展对象之前将 <code>id: undefined</code> 添加到新的 Object 最前面。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> user3 <span class="token operator">=</span> <span class="token punctuation">{</span>  password<span class="token punctuation">:</span> <span class="token string">'Password!'</span><span class="token punctuation">,</span>  name<span class="token punctuation">:</span> <span class="token string">'Naboo'</span><span class="token punctuation">,</span>  id<span class="token punctuation">:</span> <span class="token number">300</span><span class="token punctuation">}</span><span class="token keyword">const</span> organize <span class="token operator">=</span> object <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">(</span><span class="token punctuation">{</span> id<span class="token punctuation">:</span> undefined<span class="token punctuation">,</span> <span class="token operator">...</span>object <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//                            -------------</span><span class="token comment" spellcheck="true">//                          /</span><span class="token comment" spellcheck="true">//  move id to the first property</span><span class="token function">organize</span><span class="token punctuation">(</span>user3<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//>> { id: 300, password: 'Password!', name: 'Naboo' }</span></code></pre><p>若要将 password 移到最后一个属性，请从对象中解构 password。然后在使用 Rest 操作符后重新设置 password 属性。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> user3 <span class="token operator">=</span> <span class="token punctuation">{</span>  password<span class="token punctuation">:</span> <span class="token string">'Password!'</span><span class="token punctuation">,</span>  name<span class="token punctuation">:</span> <span class="token string">'Naboo'</span><span class="token punctuation">,</span>  id<span class="token punctuation">:</span> <span class="token number">300</span><span class="token punctuation">}</span><span class="token keyword">const</span> organize <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> password<span class="token punctuation">,</span> <span class="token operator">...</span>object <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span>  <span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token operator">...</span>object<span class="token punctuation">,</span> password <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//              --------</span><span class="token comment" spellcheck="true">//             /</span><span class="token comment" spellcheck="true">// move password to last property</span><span class="token function">organize</span><span class="token punctuation">(</span>user3<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//>> { name: 'Naboo', id: 300, password: 'Password!' }</span></code></pre><h2 id="6-默认属性"><a href="#6-默认属性" class="headerlink" title="6.默认属性"></a>6.默认属性</h2><p>默认属性是仅当它们不包含在原始对象中时才设置的值。<br>在本例中，user2 不包含 quotes 属性。 setdefaults 函数确保所有对象都设置了 quotes 属性，否则它将被设置为<code>[]</code>。<br>当调用 setDefaults (user2)时，返回值将包含 quotes 属性: <code>[]</code>。<br>在调用 setDefaults (user4)时，因为 user4 已经有了 quotes 属性，所以不会修改该属性。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> user2 <span class="token operator">=</span> <span class="token punctuation">{</span>  id<span class="token punctuation">:</span> <span class="token number">200</span><span class="token punctuation">,</span>  name<span class="token punctuation">:</span> <span class="token string">'Vince Noir'</span><span class="token punctuation">}</span><span class="token keyword">const</span> user4 <span class="token operator">=</span> <span class="token punctuation">{</span>  id<span class="token punctuation">:</span> <span class="token number">400</span><span class="token punctuation">,</span>  name<span class="token punctuation">:</span> <span class="token string">'Bollo'</span><span class="token punctuation">,</span>  quotes<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"I've got a bad feeling about this..."</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token keyword">const</span> setDefaults <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> quotes <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">...</span>object<span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span>  <span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token operator">...</span>object<span class="token punctuation">,</span> quotes <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token function">setDefaults</span><span class="token punctuation">(</span>user2<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//>> { id: 200, name: 'Vince Noir', quotes: [] }</span><span class="token function">setDefaults</span><span class="token punctuation">(</span>user4<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//>> {</span><span class="token comment" spellcheck="true">//>>   id: 400,</span><span class="token comment" spellcheck="true">//>>   name: 'Bollo',</span><span class="token comment" spellcheck="true">//>>   quotes: ["I've got a bad feeling about this..."]</span><span class="token comment" spellcheck="true">//>> }</span></code></pre><p>如果你希望默认值先出现而不是后出现，也可以这样写：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> setDefaults <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token operator">...</span>object<span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">(</span><span class="token punctuation">{</span> quotes<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">...</span>object <span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><h2 id="7-属性重命名"><a href="#7-属性重命名" class="headerlink" title="7.属性重命名"></a>7.属性重命名</h2><p>通过结合上面的技术，可以创建一个函数来重命名属性。假设有一些大写 ID 的对象属性名应该是小写的 id。 首先从对象解构 ID 然后在对象 Spread 时将其作为 id 添加回去。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> renamed <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> ID<span class="token punctuation">,</span> <span class="token operator">...</span>object <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">(</span><span class="token punctuation">{</span> id<span class="token punctuation">:</span> ID<span class="token punctuation">,</span> <span class="token operator">...</span>object <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">const</span> user <span class="token operator">=</span> <span class="token punctuation">{</span>  ID<span class="token punctuation">:</span> <span class="token number">500</span><span class="token punctuation">,</span>  name<span class="token punctuation">:</span> <span class="token string">"Bob Fossil"</span><span class="token punctuation">}</span><span class="token function">renamed</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//>> { id: 500, name: 'Bob Fossil' }</span></code></pre><h2 id="8-添加条件属性"><a href="#8-添加条件属性" class="headerlink" title="8.添加条件属性"></a>8.添加条件属性</h2><p>在这个例子中，只有当 password 是真实的时候才会添加 password。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> user <span class="token operator">=</span> <span class="token punctuation">{</span> id<span class="token punctuation">:</span> <span class="token number">100</span><span class="token punctuation">,</span> name<span class="token punctuation">:</span> <span class="token string">'Howard Moon'</span> <span class="token punctuation">}</span><span class="token keyword">const</span> password <span class="token operator">=</span> <span class="token string">'Password!'</span><span class="token keyword">const</span> userWithPassword <span class="token operator">=</span> <span class="token punctuation">{</span>  <span class="token operator">...</span>user<span class="token punctuation">,</span>  id<span class="token punctuation">:</span> <span class="token number">100</span><span class="token punctuation">,</span>  <span class="token operator">...</span><span class="token punctuation">(</span>password <span class="token operator">&amp;&amp;</span> <span class="token punctuation">{</span> password <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span>userWithPassword <span class="token comment" spellcheck="true">//>> { id: 100, name: 'Howard Moon', password: 'Password!' }</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> ES语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue项目性能优化方案</title>
      <link href="2020/10/30/vue-xiang-mu-xing-neng-you-hua-fang-an/"/>
      <url>2020/10/30/vue-xiang-mu-xing-neng-you-hua-fang-an/</url>
      
        <content type="html"><![CDATA[<p><img src="https://7.dusays.com/2020/11/02/3ce96e73d8ee0.jpg" alt="vue.jpg"></p><h1 id="按需使用第三方库"><a href="#按需使用第三方库" class="headerlink" title="按需使用第三方库"></a>按需使用第三方库</h1><p>项目引入过多的第三方库会增大项目体积，带来性能问题<br>。以 Bootstrap 为例，如果你只是用一下它的响应式机制，还不如自己手写相关的 CSS，也不会太复杂，完全没有必要引入整个库。moment.js，Lodash.js这些库为了普适性，提供了尽可能多的功能，但你的项目可能只用了极少部分。我们不鼓励重复造轮子，但是要按需引入。现在很多库都提供了 ES 模块化的方式，也可以做到这一点。</p><p>采用按需引入的方式引入第三方组件，减少在入口文件全局引入。</p><h1 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a>路由懒加载</h1><p>路由懒加载也可以提高入口页面的加载速度，因为很多路由页面在多数情况下并没有被访问，在打包的时候放到单独的文件里可以减少入口页的体积。路由懒加载是通过 webpack 的动态 import来实现的。</p><pre><code>// in router.jsimport Home from '@/views/Home.vue'; // 静态 importconst About = () =&gt; import('@/views/About.vue'); // 动态 importconst router = new VueRouter({  routes: [    { path: '/', component: Home },    { path: '/about', component: About }  ]})</code></pre><p>另外，这些懒加载的路由还可以分组，让相关性模块的多个路由页面打包到同一个 chunk，算是一种折中方案：既实现了按需加载，又不会过于碎片化。适用于子路由页面。</p><pre><code>// in router.jsimport Home from '@/views/Home.vue'; // traditonal importsimport User from '@/views/User.vue';const About = () =&gt;  import('@/views/About.vue'); // dynamic importconst router = new VueRouter({  routes: [    { path: '/', component: Home },    { path: '/about', component: About },    { path: '/user/:id', component: User,       children: [        {          path: '/settings',          component: () =&gt; import(/* webpackChunkName: "user" */ '@/views/UserSettings')        },        {          path: '/articles',          component: () =&gt; import(/* webpackChunkName: "user" */ '@/views/UserArticles')        }      ]    }   ]})</code></pre><p>这是通过 webpack 的注释语法/* webpackChunkName: “user” */实现的，webpackChunkName相同的路由会打进同一个 chunk文件。</p><h1 id="只做展示用数据禁用响应式"><a href="#只做展示用数据禁用响应式" class="headerlink" title="只做展示用数据禁用响应式"></a>只做展示用数据禁用响应式</h1><p>默认情况下，定义在 Vue 组件data 里的数据都是响应式的，这种机制方便了数据绑定，当数据变化时界面得到自动更新。但有时候我们只是将数据显示到界面上，之后也不会改变它。这种情况下我们根本用不上响应式机制，而实现响应式是有性能代价的，特别是对于大对象和大列表。</p><p>建议将data还有Vuex 里面只用于展示的数据通过Object.freeze()禁用对象的响应式特性。</p><h1 id="资源释放"><a href="#资源释放" class="headerlink" title="资源释放"></a>资源释放</h1><ol><li> 如果在mounted/created 钩子中使用了$on，需要在beforeDestroy 中做对应解绑($off)处理</li><li> 如果在mounted/created 钩子中绑定了DOM/BOM 对象中的事件，需要在beforeDestroy 中做对应解绑处理</li><li> 如果在mounted/created 钩子中使用了第三方库初始化，需要在beforeDestroy 中做对应销毁处理</li><li> 如果使用setTimeout setInterval需要在beforeDestroy中做对应销毁处理，（最好不用）可以使用nextTick代替</li><li> 模块形成的闭包内部变量使用完后没有置成null</li><li> 全局变量没有回收</li><li> 绑在EventBus的事件没有解绑，注册的总线事件（Bus）要在组件销毁时(beforeDestroy/destroyed)卸载</li></ol><h1 id="v-if-和-v-show-区分使用场景"><a href="#v-if-和-v-show-区分使用场景" class="headerlink" title="v-if 和 v-show 区分使用场景"></a>v-if 和 v-show 区分使用场景</h1><p>v-if&nbsp;是&nbsp;真正&nbsp;的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</p><p>v-show&nbsp;就简单得多， 不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 的 display 属性进行切换。</p><p>所以，v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景；v-show 则适用于需要非常频繁切换条件的场景。</p><h1 id="computed-和-watch-区分使用场景"><a href="#computed-和-watch-区分使用场景" class="headerlink" title="computed 和 watch &nbsp;区分使用场景"></a>computed 和 watch &nbsp;区分使用场景</h1><p>（1）computed：&nbsp;是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed &nbsp;的值；</p><p>（2） watch：&nbsp;更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；</p><p>运用场景：</p><p>当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；</p><p>当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</p><h1 id="v-for-遍历必须为-item-添加-key，且避免同时使用-v-if"><a href="#v-for-遍历必须为-item-添加-key，且避免同时使用-v-if" class="headerlink" title="v-for 遍历必须为 item 添加 key，且避免同时使用 v-if"></a>v-for 遍历必须为 item 添加 key，且避免同时使用 v-if</h1><p>（1）v-for 遍历必须为 item 添加 key</p><p>在列表数据进行遍历渲染时，需要为每一项 item 设置唯一 key 值，方便 Vue.js 内部机制精准找到该条列表数据。当 state 更新时，新的状态值和旧的状态值对比，较快地定位到 diff 。</p><p>（2）v-for 遍历避免同时使用 v-if</p><p>v-for 比 v-if 优先级高，如果每一次都需要遍历整个数组，将会影响速度，尤其是当之需要渲染很小一部分的时候，必要情况下应该替换成 computed 属性。</p><pre><code>&lt;ul&gt;  &lt;li    v-for="user in activeUsers"    :key="user.id"&gt;    {{ user.name }}  &lt;/li&gt;&lt;/ul&gt;computed: {  activeUsers: function () {    return this.users.filter(function (user) {   return user.isActive    })  }}</code></pre><h1 id="减少-ES6-转为-ES5-的冗余代码"><a href="#减少-ES6-转为-ES5-的冗余代码" class="headerlink" title="减少 ES6 转为 ES5 的冗余代码"></a>减少 ES6 转为 ES5 的冗余代码</h1><p>Babel 插件会在将 ES6 代码转换成 ES5 代码时会注入一些辅助函数，例如下面的 ES6 代码：</p><pre><code>class HelloWebpack extends Component{...}</code></pre><p>这段代码再被转换成能正常运行的 ES5 代码时需要以下两个辅助函数：</p><pre><code>babel-runtime/helpers/createClass  // 用于实现 class 语法babel-runtime/helpers/inherits  // 用于实现 extends 语法</code></pre><p>在默认情况下， Babel 会在每个输出文件中内嵌这些依赖的辅助函数代码，如果多个源代码文件都依赖这些辅助函数，那么这些辅助函数的代码将会出现很多次，造成代码冗余。为了不让这些辅助函数的代码重复出现，可以在依赖它们时通过&nbsp;require(‘babel-runtime/helpers/createClass’)&nbsp;的方式导入，这样就能做到只让它们出现一次。babel-plugin-transform-runtime&nbsp;插件就是用来实现这个作用的，将相关辅助函数进行替换成导入语句，从而减小 babel 编译出来的代码的文件大小。</p><p>首先，安装 babel-plugin-transform-runtime ：</p><pre><code>npm install babel-plugin-transform-runtime --save-dev</code></pre><p>然后，修改 .babelrc  配置文件为：</p><pre><code>"plugins": [    "transform-runtime"]</code></pre><h1 id="开启gzip压缩"><a href="#开启gzip压缩" class="headerlink" title="开启gzip压缩"></a>开启gzip压缩</h1><p>首先，修改productionGzip 为true,<br>安装 compression-webpack-plugin ：</p><pre><code> //  npm install --save-dev compression-webpack-plugin  //(此处有坑) 如果打包报错，应该是版本问题 ，先卸载之前安装的此插件 ，然后安装低版本   npm install --save-dev compression-webpack-plugin@1.1.11</code></pre><p>修改nginx的配置</p><pre><code>http {  //在 http中配置如下代码，   gzip on;   gzip_disable "msie6";    gzip_vary on;    gzip_proxied any;   gzip_comp_level 8; #压缩级别   gzip_buffers 16 8k;   #gzip_http_version 1.1;   gzip_min_length 100; #不压缩临界值   gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png; }</code></pre><h1 id="图片懒加载"><a href="#图片懒加载" class="headerlink" title="图片懒加载"></a>图片懒加载</h1><p>如果应用里需要展示大量图片，通常的做法是懒加载图片。懒加载的基本原理是提前准备好图片 URL，当图片真正进入可视范围时才去加载。可以手动实现懒加载机制，不过更方便的是直接用现成的插件，比如 [vue-lazyload]<br>安装：</p><pre><code>npm i vue-lazyload -S</code></pre><p>引入：</p><pre><code>import VueLazyload from 'vue-lazyload'Vue.use(VueLazyload)</code></pre><p>使用：</p><pre><code> &lt;ul&gt;    &lt;li v-for="img in list"&gt;      &lt;img v-lazy="img.src"&gt;    &lt;/li&gt;  &lt;/ul&gt;</code></pre><h1 id="cdn加速"><a href="#cdn加速" class="headerlink" title="cdn加速"></a>cdn加速</h1><p>采用cdn加速去从别的服务器上加载第三方库而非自己的服务器，这样就会快很多.并且能节省自己服务器的带宽。</p><p>首先，在index.html中 将你所需的第三方库的链接加载进来：</p><pre><code>&lt;script src="https://cdn.bootcdn.net/ajax/libs/vue/3.0.0-beta.18/vue.cjs.js"&gt;&lt;/script&gt;</code></pre><p>在webpack.base.conf 中添加 externals 来告诉webpack我们这些第三方库不需要打包</p><pre><code>externals:{    // key表示第三方插件名称，value是暴露出的全局变量    'vue':'Vue'}</code></pre><p>在 主文件main.js 或者其他 js 修改引用这些配置的第三方插件</p><pre><code>// import Vue from 'vue';const Vue = require('vue');</code></pre><h1 id="Webpack-对图片进行压缩"><a href="#Webpack-对图片进行压缩" class="headerlink" title="Webpack 对图片进行压缩"></a>Webpack 对图片进行压缩</h1><p>安装 image-webpack-loader ：</p><pre><code>npm install image-webpack-loader --save-dev</code></pre><p>然后，在 webpack.base.conf.js  中进行配置：</p><pre><code>{  test: /\.(png|jpe?g|gif|svg)(\?.*)?$/,  use:[     {      loader: 'url-loader',      options: {        limit: 10000 ,        name: '[path][name].[ext]?[hash:6]!./dir/file.png'      }    },    /*对图片进行压缩*/    {      loader: 'image-webpack-loader',      query: {        progressive: true,        optimizationLevel: 7,        interlaced: false,        pngquant: {          quality: '65-90',          speed: 4        }      }    }  ]}</code></pre><h1 id="pax-ui框架相关"><a href="#pax-ui框架相关" class="headerlink" title="pax-ui框架相关"></a>pax-ui框架相关</h1><p>（1） 表单组件<br>pax组件的Form表单组件会对绑定数据监听，表单组件很多的情况下页面会卡顿，在pax-form上设置局部更新，会提升一部分性能。</p><pre><code>&lt;pax-form :form="form" :selfUpdate="true"&gt;&lt;/pax-form&gt;</code></pre><p>(2) select组件<br>select大数据量情况下，会造成页面元素较多，在ie上消耗更多的内存。建议采用虚拟滚动的方式：</p><pre><code>import { RecycleScroller} from 'vue-virtual-scroller';// 在Select预留卡槽中使用详情见文档：IE浏览器select大数据问题造成输入不流畅分析处理</code></pre><p>（3）tree组件<br>pax-tree在ie上问题严重,如果兼容ie，建议用@pa/vue-org-tree,使用方法参考ztree.js</p><pre><code>npm install @pa/vue-org-tree --save-dev</code></pre>]]></content>
      
      
      <categories>
          
          <category> VUE专题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript在vue项目中的应用</title>
      <link href="2020/10/30/ts-zai-vue-xiang-mu-zhong-de-ying-yong/"/>
      <url>2020/10/30/ts-zai-vue-xiang-mu-zhong-de-ying-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="1-引言"><a href="#1-引言" class="headerlink" title="1 引言"></a>1 引言</h1><p>TypeScript 是一种由微软开发的自由和开源的编程语言。它是 JavaScript 的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程。</p><p>TypeScript 优势：</p><ul><li>静态类型检查与代码提示</li><li>适用大型项目开发，如代码重构等</li><li>更好的协作</li><li>更强的生产力</li></ul><h1 id="2-ts语法知识"><a href="#2-ts语法知识" class="headerlink" title="2 ts语法知识"></a>2 ts语法知识</h1><h2 id="2-1类型系统"><a href="#2-1类型系统" class="headerlink" title="2.1类型系统"></a>2.1类型系统</h2><p><img src="https://7.dusays.com/2020/11/02/056c4d4f841cf.png" alt="类型注解"></p><h2 id="2-2类型保护"><a href="#2-2类型保护" class="headerlink" title="2.2类型保护"></a>2.2类型保护</h2><blockquote><p>类型保护是可执行运行时检查的一种表达式，用于确保该类型在一定的范围内。</p></blockquote><ol><li>as 操作符（类型断言）<br>当你比 ts 更确定其数据类型，你能使用 as 语法确定其类型，但需要遵守类型兼容转换。 另外一种写法：<typename>varName，但不建议使用</typename></li></ol><pre><code>function getDynamicValue(): number | string | undefined {  ...}const v = getDynamicValue(); // v:number|string|undefined，联合类型变量只允许访问所有类型共有的属性// 确定返回 string(v as string).trim();</code></pre><ol start="2"><li>typeof 操作符</li></ol><pre><code>function isNumber(val: any): val is number {  return typeof val === 'number';}const a: any = 1;if (isNumber(a)) {  // a:number}</code></pre><ol start="3"><li>instanceof 操作符</li></ol><pre><code>class Base {  ...}class A extends Base {  ...}const inst: Base = new A();if (inst instanceof A) {  // inst:A}</code></pre><ol start="4"><li>函数或变量后面添加 !</li></ol><p>当要去掉联合类型的可空类型（null | undefined）,可以使用 js if 语句或短路运算符实现类型保护，也可以使用 Typescript 2.0+ !语法</p><pre><code>const x: string | null = getDynamicValue();// if判断if (x) {  // x:string}// 短路运算符function f(sn: string | null) {  return sn || '';}// !语法x!.trim();// orconst r = [1, 2, 3, 4].find(x =&gt; x === 3)!; // r:number</code></pre><h1 id="3-开发环境准备"><a href="#3-开发环境准备" class="headerlink" title="3 开发环境准备"></a>3 开发环境准备</h1><h2 id="3-1-插件安装"><a href="#3-1-插件安装" class="headerlink" title="3.1 插件安装"></a>3.1 插件安装</h2><h3 id="3-1-1-Webpack-转译-Typescript-现有方案"><a href="#3-1-1-Webpack-转译-Typescript-现有方案" class="headerlink" title="3.1.1 Webpack 转译 Typescript 现有方案"></a>3.1.1 Webpack 转译 Typescript 现有方案</h3><h4 id="1-ts-loader-babel-loader-fork-ts-checker-webpack-plugin"><a href="#1-ts-loader-babel-loader-fork-ts-checker-webpack-plugin" class="headerlink" title="1.ts-loader + babel-loader + fork-ts-checker-webpack-plugin"></a>1.ts-loader + babel-loader + fork-ts-checker-webpack-plugin</h4><p>修改 webpack.config.js 的配置：</p><pre><code>{     test: /\.ts?$/,     loader: "ts-loader",    options: {        // .vue文件必须加        appendTsSuffixTo: [/\.vue$/]    },    exclude:/node_modules/}</code></pre><p>每次重建时，类型脚本的语义检查器必须检查所有文件,随着项目变得越来越大，编译时间线性增加。这时我们使用 fork-ts-checker-webpack-plugin 另外开一个线程来进行类型检查，安装依赖：</p><pre><code>npm install -D fork-ts-checker-webpack-plugin//使用：const ForkTsCheckerWebpackPlugin = require('fork-ts-checker-webpack-plugin');plugins:[    new ForkTsCheckerWebpackPlugin()]</code></pre><ul><li>这种方案，当 webpack 编译的时候，ts-loader 会调用 typescript（所以本地项目需要安装 typescript），然后 typescript 运行的时候会去读取本地的 tsconfig.json 文件。</li><li>默认情况下，ts-loader 会进行 转译 和 类型检查，每当文件改动时，都会重新去 转译 和 类型检查，当文件很多的时候，就会特别慢，影响开发速度。所以需要使用 fork-ts-checker-webpack-plugin ，开辟一个单独的线程去执行类型检查的任务，这样就不会影响 webpack 重新编译的速度。</li><li>fork-ts-checker-webpack-plugin  这个插件要求最低 Node.js 6.11.5，webpack 4，TypeScript 2.1 和可选的 ESLint 6（其本身要求最低 Node.js 8.10.0）。</li></ul><h4 id="2-babel-loader-babel-preset-typescript"><a href="#2-babel-loader-babel-preset-typescript" class="headerlink" title="2. babel-loader + @babel/preset-typescript"></a>2. babel-loader + @babel/preset-typescript</h4><p>修改webpack.config.js</p><pre><code>rules: [        {          test:/\.(tsx?|jsx?)$/,          // 默认会调用 @babel/core           use:'babel-loader'        }]</code></pre><p>.babelrc</p><pre><code>{    "presets": [        "@babel/env"        "@vue/babel-preset-jsx",        "@babel/preset-typescript"    ]}</code></pre><ul><li>这种方案，当 webpack 编译的时候，babel-loader 会读取 .babelrc 里的配置，不会调用 typescript（所以本地项目无需安装 typescript），不会去检查类型</li><li> 需要配置tsconfig.json的，因为需要在开发代码时，让 idea 提示错误信息</li></ul><h2 id="3-2-ts项目基本构成"><a href="#3-2-ts项目基本构成" class="headerlink" title="3.2 ts项目基本构成"></a>3.2 ts项目基本构成</h2><p>一个vue+ts项目的目录结构（<a href="https://github.com/leeycode/typeScript-vue-starter/">typeScript-vue-starter</a>）：</p><pre><code>├── /@types/                     # 全局类型声明├── /build/                      # webpack配置文件├── /src/                        # 源码目录│ ├── /assets/                   # 静态资源目录│ ├── /components/               # 公共组件目录│ ├── /constants/                # 项目constants目录│ │ ├── _const.less              # less常量│ ├── /pages/                    # UI组件目录│ ├── /services/                 # 请求服务目录│ ├── /router/                   # 路由目录│ ├── /store/                    # 存放store文件目录│ ├── /style/                    # 全局样式│ ├── /utils/                    # utils目录│ │ ├── request.ts               # 基于fetch封装的API请求工具│ │ ├── global.ts                # 公共方法库│ └── main.ts                    # 项目入口|——tsconfig.json                 # ts配置|——...</code></pre><h2 id="3-3-tsconfig-json"><a href="#3-3-tsconfig-json" class="headerlink" title="3.3 tsconfig.json"></a>3.3 tsconfig.json</h2><p>在项目根目录下，这个json文件规定了ts的编译选项，相见的编译选项配置：</p><pre><code>{  "compilerOptions": {    "baseUrl": ".",                             // 用于解析非相对模块名称的基目录    "outDir": "build/dist",                     // 指定输出目录    "module": "esnext",                         // 指定使用模块: 'commonjs', 'amd', 'system', 'umd' or 'es2015'    "target": "es5",                            // 指定 ECMAScript 目标版本:    "lib": ["dom", "esnext"],                   // 指定要包含在编译中的库文件    "sourceMap": true,                          // 生成相应的 '.map' 文件    "allowJs": true,                            // 允许编译 javascript 文件    "jsx": "preserve",                          // 指定 jsx 代码的生成: 'preserve', 'react-native'等    "moduleResolution": "node",                 // 选择模块解析策略： 'node' (Node.js) or 'classic'    "strict": true                              // 启用所有严格类型检查选项    ...  },  "include": ["src/**/*", "@types/**/*"],       // 编译包含的文件     "exclude": [                                  // 排除的文件                    "node_modules",    "build",    "scripts",    "acceptance-tests",    "webpack",    "jest",    "src/setupTests.ts",    "config"  ]}</code></pre><h2 id="3-4-声明文件"><a href="#3-4-声明文件" class="headerlink" title="3.4 声明文件"></a>3.4 声明文件</h2><h3 id="types"><a href="#types" class="headerlink" title="@types"></a>@types</h3><p>安装第三方库之前，我们可以<a href="https://microsoft.github.io/TypeSearch//">搜索DefinitelyTyped</a>，查看是否有第三方在维护类型声明。通过@types安装，就能在项目中使用它的类型声明。</p><pre><code>- Partial :把 interface 所有属性变成可选// node_modules/typescript/lib/lib.es5.d.ts,安装ts的时候生成type Partial&lt;T&gt; = {    [P in keyof T]?: T[P];};changeFilter: (filter: Partial&lt;IRequsetParams&gt;) =&gt; void;- Event// node_modules/@types/react/index.d.ts,通过@types安装react的时候生成  handleClick = (e: React.MouseEvent&lt;HTMLDivElement, MouseEvent&gt;) =&gt; {    e.stopPropagation();  };- RouteComponentProps:提供了 location、history 的类型定义// node_modules/@types/react-router/index.d.tsexport interface ILoginProps extends RouteComponentProps {  login: (values: IUser, history: H.History) =&gt; void;}</code></pre><h3 id="自定义声明文件"><a href="#自定义声明文件" class="headerlink" title="自定义声明文件"></a>自定义声明文件</h3><p>扩展名.d.ts 结尾就是项目中的声明文件。在上面的项目中，我们创建了一个名为@types的文件夹，用来维护项目中需要的变量声明。</p><ol><li>全局变量声明<pre><code>// configdeclare const config: {version: string;systemName: string;debug: boolean;...}// 约束后台返回的数据 declare interface IResponseBody&lt;T&gt; {data: T;code: number;total: number;}...</code></pre></li><li>非js资源</li></ol><pre><code>declare module '*.svg';declare module '*.png';declare module '*.jpg';declare module '*.module.css';declare module '*.module.scss' </code></pre><h1 id="4-组件编写的几种方法"><a href="#4-组件编写的几种方法" class="headerlink" title="4 组件编写的几种方法"></a>4 组件编写的几种方法</h1><h2 id="4-1-Vue-extend"><a href="#4-1-Vue-extend" class="headerlink" title="4.1 Vue.extend()"></a>4.1 Vue.extend()</h2><blockquote><p>Vue.extend():使用基础 Vue 构造器，创建一个“子类”。 这种方式最接近 Vue 的单文件组件的写法，如果一个完善 Vue 项目从 JS 改成 TS，用这种方法很快，只要加上 lang=ts和一些必要的变量类型就好了，然后用Vue.extend()包裹就好。</p></blockquote><p>main.js 改为 main.ts 内容改成：</p><pre><code>import Vue from "vue";import App from "./App.vue";new Vue({    el:"#app",    render:h=&gt;h(App)});</code></pre><p>组件写法：</p><pre><code>&lt;template&gt;    &lt;h1&gt;{{name}}&lt;/h1&gt;&lt;/template&gt;&lt;script lang="ts"&gt;//也执行tsx,也就是jsx语法import Vue from "vue";export default Vue.extend({    data(){        return {            name:'liwu'        }    }})&lt;/script&gt;&lt;style scoped&gt;h1{    color: rgb(55, 142, 230);}&lt;/style&gt;</code></pre><h2 id="4-2-vue-class-component"><a href="#4-2-vue-class-component" class="headerlink" title="4.2 vue-class-component"></a>4.2 vue-class-component</h2><blockquote><p>通常和vue-property-decorator一起搭配使用，，vue-property-decorator是在vue-class-component上扩展来的，并且提供了很多修饰器比如 @Prop和@Watch等等，使用这个可以编写类式组件。</p></blockquote><p>1.组件写法：</p><pre><code>&lt;template&gt;    &lt;h1&gt;{{name}}&lt;/h1&gt;&lt;/template&gt;&lt;script lang="ts"&gt;import Vue from "vue";import Component from 'vue-class-component';// @Component 装饰器使你的类成为Vue组件@Componentexport default class App extends Vue {    private name:string = 'liwu';}&lt;/script&gt;&lt;style scoped&gt;h1{    color: rgb(55, 142, 230);}&lt;/style&gt;</code></pre><p>修改tsconfig.js，支持装饰器语法</p><pre><code>"experimentalDecorators": true,</code></pre><h2 id="4-3-jsx"><a href="#4-3-jsx" class="headerlink" title="4.3 jsx"></a>4.3 jsx</h2><blockquote><p>JSX is an XML-like syntax extension to ECMAScript without any defined semantics. It’s NOT intended to be implemented by engines or browsers.</p></blockquote><p>1.jsx语法简介（写react的同学跳过）</p><ul><li>严格的标签闭合</li><li>组件名要大写，否则解析成html标签</li><li>变量用{}</li></ul><pre><code>let name = 'xxx';&lt;div&gt;{ name }&lt;/div&gt;</code></pre><ul><li>遍历用map</li></ul><pre><code>let list = ['李一','李二','李三'];&lt;div&gt;    {list.map((item, index) =&gt; {    return &lt;p key={index}&gt;this is {item}&lt;/p&gt;     })} &lt;/div&gt; </code></pre><ul><li>条件判断</li></ul><pre><code>&lt;div className={styles.wrapper}&gt;    {_.isEmpty(currRecord) ? null : (      &lt;Graph        graph={{ nodes, edges }}        options={this.options}        events={this.events}      /&gt;    )}&lt;/div&gt; </code></pre><ul><li>事件要用驼峰写法，传参要用bind</li></ul><pre><code>&lt;div    className={styles.content}    onMouseEnter={this.showSwitch}    onMouseLeave={this.hideSwitch}    onClick={this.handleClick.bind(this,params)}&gt;&lt;/div&gt;</code></pre><ul><li>使用domPropsInnerHTML来替代v-html</li></ul><pre><code>&lt;div    domPropsInnerHTML={this.htmlContent}&gt;&lt;/div&gt;</code></pre><p>2.组件写法</p><pre><code>import { Vue, Component } from 'vue-property-decorator';import { CreateElement } from 'vue';@Componentexport default class JSX extends Vue {  private count: number = 0;  private showInfo() {    this.count++;  }  protected render(h: CreateElement) {    return &lt;h2 onMouseenter={this.showInfo}&gt;JSX Test{this.count}&lt;/h2&gt;;  }}</code></pre><h1 id="5-class组件详细用法"><a href="#5-class组件详细用法" class="headerlink" title="5 class组件详细用法"></a>5 class组件详细用法</h1><h2 id="使用Data"><a href="#使用Data" class="headerlink" title="使用Data"></a>使用Data</h2><pre><code>@Componentexport default class HelloWorld extends Vue {  private msg: string = "welcome to my app"  private list: Array&lt;object&gt; = [    {        name: 'Melody',        age: '20'    },    {        name: 'James',        age: '20'    }  ]}</code></pre><p>与ts等效的js代码</p><pre><code>export default {  data() {    return {      msg: "welcome to my app",      list: [        {          name: 'Melody',          age: '20'        },        {          name: 'James',          age: '20'        }      ]    }}</code></pre><h2 id="使用props"><a href="#使用props" class="headerlink" title="使用props"></a>使用props</h2><p>可以添加 required, default, type 为props指定验证要求，同样也可以使用 readonly 禁止操作props</p><pre><code>import { Component, Prop, Vue } from 'vue-property-decorator'@Componentexport default class HelloWorld extends Vue {  @Prop() readonly msg!: string  @Prop({default: 'Joy Melody'}) readonly name: string  @Prop({required: true}) readonly age: number  @Prop({required: false, type: String, default: 'Developer'}) readonly job: string}</code></pre><p>与ts等效的js代码如下</p><pre><code>export default {  props: {    msg,    name: {      default: 'Joy Melody'    },    age: {      required: true,    },    address: {      type: String    },    job: {      required: false,      type: string,      default: 'Developer'    }  }}</code></pre><h2 id="Computed-属性"><a href="#Computed-属性" class="headerlink" title="Computed 属性"></a>Computed 属性</h2><pre><code>export default class HelloWorld extends Vue {  get fullName(): string {    return this.first+ ' '+ this.last  }}</code></pre><p>与ts等效的js代码如下</p><pre><code>export default {  fullName() {    return this.first + ' ' + this.last  }}</code></pre><p>复杂点的涉及到setter和getter的 computed属性，在ts中写法如下：</p><pre><code>export default class HelloWorld extends Vue {  get fullName(): string {    return this.first+ ' '+ this.last  }  set fullName(newValue: string) {    let names = newValue.split(' ')    this.first = names[0]    this.last = names[names.length - 1]  }}</code></pre><p>与ts等效的js写法如下</p><pre><code>fullName: {  get: function () {    return this.first + ' ' + this.last  },  set: function (newValue) {    let names = newValue.split(' ')    this.first = names[0]    this.last = names[names.length - 1]  }}</code></pre><h2 id="使用Watch"><a href="#使用Watch" class="headerlink" title="使用Watch"></a>使用Watch</h2><p>@Watch(path: string, options: WatchOptions = {}) </p><ul><li><p>@Watch 装饰器接收两个参数：path: string 被侦听的属性名<br>options?: WatchOptions={} options可以包含两个属性</p></li><li><p>immediate?:boolean 侦听开始之后是否立即调用该回调函数<br>deep?:boolean 被侦听的对象的属性被改变时，是否调用该回调函数</p></li></ul><pre><code>@Watch('child')onChildChanged (val: string, oldVal: string) {    if (val !== oldVal) {      window.console.log(val)    }}</code></pre><p>与ts等效的js代码如下</p><pre><code>watch: {    'child': {        handler: 'onChildChanged',        immediate: false,        deep: false     }},method: {    onChildChanged(val, oldVal) {        if (val !== oldVal) {          console.log(val)        }    }}</code></pre><p>也可以写成: @Watch(‘child’, { immediate: true, deep: true }), 等价于:</p><pre><code>watch: {    'child': {        handler: 'onChildChanged',        immediate: true,        deep: true     }},method: {    onChildChanged(val, oldVal) {        if (val !== oldVal) {          window.console.log(val)        }    }}</code></pre><h2 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h2><pre><code>export default class HelloWorld extends Vue {  public clickMe(): void {    console.log('clicked')    console.log(this.addNum(4, 2))  }  public addNum(num1: number, num2: number): number {    return num1 + num2  }}</code></pre><p>与ts等效的js代码如下</p><pre><code>export default {  methods: {    clickMe() {      console.log('clicked')      console.log(this.addNum(4, 2))    }    addNum(num1, num2) {      return num1 + num2    }  }}</code></pre><h2 id="Emit"><a href="#Emit" class="headerlink" title="Emit"></a>Emit</h2><p>子组件触发父组件的自定义事件并传递数据，在TypeScript中使用@Emit 装饰器</p><pre><code>import { Vue, Component, Emit } from 'vue-property-decorator'@Componentexport default class YourComponent extends Vue {  count = 0  @Emit()  addToCount(n: number) {    this.count += n  }}</code></pre><p>与ts等效的js代码如下</p><pre><code>export default {  data() {    return {      count: 0    }  },  methods: {    addToCount(n) {      this.count += n      this.$emit('add-to-count', n)    }  }}</code></pre><h2 id="Mixins"><a href="#Mixins" class="headerlink" title="Mixins"></a>Mixins</h2><p>假设当前已经有一个mixins/ProjectMixin文件 如何在其他组件里面使用方式如下</p><pre><code>&lt;template&gt;  &lt;div class="project-detail"&gt;    {{ projectDetail }}  &lt;/div&gt;&lt;/template&gt;&lt;script lang="ts"&gt;import { Component, Vue, Mixins } from 'vue-property-decorator'import ProjectMixin from '@/mixins/ProjectMixin'@Componentexport default class Project extends Mixins(ProjectMixin) {  get projectDetail(): string {    return this.projName + ' ' + 'HS'  }}&lt;/script&gt;</code></pre><p>与ts等效的js代码如下</p><pre><code>&lt;template&gt;  &lt;div class="project-detail"&gt;    {{ projectDetail }}  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import ProjectMixin from '@/mixins/ProjectMixin'export default {  mixins: [ ProjectMixin ],  computed: {    projectDetail() {      return this.projName + ' ' + 'HS'    }  }}&lt;/script&gt;</code></pre><p>多个混入的情况</p><pre><code>import { Component, Mixins } from 'vue-property-decorator'export default class Test extends Mixins(Mixin1, Mixin2) {    test() {      this.methodFromMixin2()      console.log(this.valFromMixin1)    }}</code></pre><h2 id="refs"><a href="#refs" class="headerlink" title="refs"></a>refs</h2><p>ts无法识别vue中的$refs,需要手动指定其类型：</p><pre><code>&lt;template&gt;  &lt;loading ref="loading"/&gt;  &lt;input type="text" ref="inputRef"&gt;&lt;/template&gt;&lt;script lang="ts"&gt;import { Component } from 'vue-property-decorator'import Loading from "@/components/Loading.vue";@Component({  components: { Loading }})export default class Project extends Vue { $refs!: {    loading: Loading;    inputRef: HTMLInputElement;  }; public mounted() {    this.$refs.loading.showLoading();    // (this.$refs.loading as Loading).showLoading();    this.$refs.inputRef.focus();  }}&lt;/script&gt;</code></pre><h1 id="6-路由"><a href="#6-路由" class="headerlink" title="6 路由"></a>6 路由</h1><h2 id="路由创建"><a href="#路由创建" class="headerlink" title="路由创建"></a>路由创建</h2><pre><code>import Vue from 'vue';import VueRouter, { RouteConfig } from 'vue-router';import Home from '@/pages/home/Home.vue';Vue.use(VueRouter);const routes: Array&lt;RouteConfig&gt; = [  {    path: '/',    name: 'home',    component: Home  },  {    path: '/about',    name: 'about',    component: () =&gt; import(/* webpackChunkName: "about" */ '@/pages/about/About.vue')  }];const router = new VueRouter({  routes});export default router;</code></pre><h2 id="组件中监听路由"><a href="#组件中监听路由" class="headerlink" title="组件中监听路由"></a>组件中监听路由</h2><pre><code>&lt;script lang="ts"&gt;import { Component, Vue, Watch } from 'vue-property-decorator';import { Route } from 'vue-router';@Componentexport default class About extends Vue {  @Watch('$route', { immediate: true })  private changeRouter(route: Route) {    console.log('route', route);  }}</code></pre><h2 id="组件中使用路由勾子函数"><a href="#组件中使用路由勾子函数" class="headerlink" title="组件中使用路由勾子函数"></a>组件中使用路由勾子函数</h2><p>main.ts中：</p><pre><code>import { Component } from 'vue-property-decorator';Component.registerHooks([  'beforeRouteEnter',  'beforeRouteLeave',  'beforeRouteUpdate']);</code></pre><p>组件中：</p><pre><code>&lt;script lang="ts"&gt;import { Component, Vue, Watch } from 'vue-property-decorator';import { Route } from 'vue-router';@Componentexport default class About extends Vue {  private beforeRouteEnter(to: Route, from: Route, next: () =&gt; void): void {    console.log('beforeRouteEnter', to, from, next);    next();   }  private beforeRouteUpdate(to: Route, from: Route, next: () =&gt; void): void {    console.log('beforeRouteUpdate'); // 暂时不生效，版本问题    next();  }  private beforeRouteLeave(to: Route, from: Route, next: () =&gt; void): void {    console.log('beforeRouteLeave');    next();  }}</code></pre><h1 id="7-数据请求"><a href="#7-数据请求" class="headerlink" title="7 数据请求"></a>7 数据请求</h1><p>对返回值和入参做类型约束：</p><pre><code>// global.d.ts declare interface ResponseBody&lt;T&gt; {  data: T;  code: number;  total: number;}declare interface ResponseStatus {  loading: boolean;  error: boolean;}declare interface Response&lt;T&gt; extends ResponseStatus {  res: IResponseBody&lt;T&gt;;}declare interface ResponseNotPage&lt;T&gt; extends ResponseStatus {  data: T;}declare interface PageParams {  page: number;  pageSize: number;}declare interface RequsetParams extends PageParams {  search: string;}// src/service/demo.tsexport const getInfo = (id: number) =&gt;  request&lt;ResponseBody&lt;{ id: number; address?: string; time?: string }&gt;&gt;(    Api.GET_LAST_TRACE_INFO,    {      router: { id }    }  );</code></pre><h1 id="8-全局状态管理"><a href="#8-全局状态管理" class="headerlink" title="8 全局状态管理"></a>8 全局状态管理</h1><h2 id="8-1-开始使用"><a href="#8-1-开始使用" class="headerlink" title="8.1 开始使用"></a>8.1 开始使用</h2><p>安装依赖</p><pre><code>npm install vuex-module-decorators --save-dev</code></pre><p>如果想通过名字空间的形式来使用module, 需在@Module装饰器中添加额外的参数. 例如, 以下示例代码中添加一个namespaced为home的module</p><pre><code>// src\store\module\home.tsimport { VuexModule, Module, Mutation, Action, getModule } from 'vuex-module-decorators';import store from '@/store';@Module({ namespaced: true, dynamic: true, name: 'home', store })export default class Home extends VuexModule {  public name: string = '';  public message: string = '';  get getMessage() {    return `当前时间${new Date()}：${this.message}`;  }  @Mutation  private SET_NAME(newName: string): void {    this.name = newName;  }  @Mutation  private SET_MESSAGE(message: string) {    this.message = message;  }  @Action  public updateMessage(newName: string): void {    this.SET_NAME(newName);    this.SET_MESSAGE('欢迎您,');  }}export const HomeModule = getModule(Home);</code></pre><p>与ts等效的js代码如下</p><pre><code>const UserModule = {    state: {        name: '',        message: ''    },    getters: {         getMessage: state =&gt; `当前时间${new Date()}：${state.user.message}`    },    mutations: {         SET_NAME: (state, name) =&gt; {            state.name = name        },        SET_MESSAGE: (state, message) =&gt; {            state.message = message        }    },    actions: {         updateMessage({commit}, newName){            commit("SET_NAME", newName);            commit("SET_MESSAGE", "欢迎您,");        }    },}</code></pre><p>dynamic模式下的store</p><pre><code>// \src\store\index.tsimport Vue from 'vue';import Vuex from 'vuex';Vue.use(Vuex);// Declare empty store first, dynamically register all modules later.export default new Vuex.Store({});</code></pre><p>组件中使用：</p><pre><code>// \src\pages\home\Home.vue&lt;template&gt;  &lt;div class="home"&gt;    &lt;img alt="Vue logo" src="../../assets/logo.png" /&gt;    &lt;hello-world msg="vue.js" /&gt;    {{ $store.state.home.name }}    &lt;br/&gt;    {{ info }}    &lt;button @click="handleClick"&gt;点击&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script lang="ts"&gt;import { Component, Vue } from 'vue-property-decorator';import HelloWorld from '@/components/HelloWorld.vue';import { HomeModule } from '@/store/modules/home';@Component({  components: {    HelloWorld  }})export default class Home extends Vue {  get info() {    return HomeModule.getMessage;  }  private handleClick() {    HomeModule.updateMessage('liwu');  }}&lt;/script&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> VUE专题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>当CORS遇到SameSite</title>
      <link href="2020/09/11/dang-cors-yu-dao-samesite-md/"/>
      <url>2020/09/11/dang-cors-yu-dao-samesite-md/</url>
      
        <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><blockquote><p>A cookie associated with a cross-site resource at <a href="http://a.com/">http://a.com/</a> was set without the ‘SameSite’ attribute. A future release of Chrome will only deliver cookies with cross-site requests if they are set with ‘SameSite=None’ and ‘Secure’. You can review cookies in developer tools under Application&gt;Storage&gt;Cookies and see more details at <a href="https://www.chromestatus.com/feature/5088147346030592">https://www.chromestatus.com/feature/5088147346030592</a> and <a href="https://www.chromestatus.com/feature/5633521622188032">https://www.chromestatus.com/feature/5633521622188032</a>.</p></blockquote><p>于是发现是 Chrome 升级 80 导致未设置 SameSite 的 Cookie 默认值是Lax。</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="1-紧急处理"><a href="#1-紧急处理" class="headerlink" title="1.紧急处理"></a>1.紧急处理</h2><p>其实是在服务方解决问题之前让用户先稍微兼容一下。方案很简单：</p><p>换个浏览器<br>or</p><p>打开 chrome://flags/#same-site-by-default-cookies，关掉 SameSite by default cookies 然后重启浏览器</p><h2 id="2-方法一：跨域-Set-Cookie"><a href="#2-方法一：跨域-Set-Cookie" class="headerlink" title="2. 方法一：跨域 + Set-Cookie"></a>2. 方法一：跨域 + Set-Cookie</h2><p>首先就是报错信息里提到的，让服务端同学在 Set-Cookie 的时候加上 SameSite=None; Secure。但是我们的后台系统都是对内使用的，很多域名都没有申请证书。而 “Secure” 属性却表示 Cookie 只能随 HTTPS 请求发送。<br>这就很尴尬。<br>要不申请证书，要不换域名。<br>但是长远来看，https是大趋势，趁着这个机会升级成 HTTPS 也是可取的。<br>然而有些版本的浏览器并不识别 SameSite=None，需要特殊处理。</p><h2 id="3-方法二：改成同域请求"><a href="#3-方法二：改成同域请求" class="headerlink" title="3. 方法二：改成同域请求"></a>3. 方法二：改成同域请求</h2><p>既然 SameSite=Lax 限制的是跨域 Cookie 携带，那么改成同域自然没有问题了。<br>但因为现在项目都是前后端分离部署的，所以请运维同学配了一下匹配到 ^/api/ 开头的请求都转发到服务端的地址。前端请求接口时直接用相对路径请求。<br>问题解决</p>]]></content>
      
      
      <categories>
          
          <category> 项目总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BFC原理及应用</title>
      <link href="2020/08/30/bfc-yuan-li-ji-ying-yong/"/>
      <url>2020/08/30/bfc-yuan-li-ji-ying-yong/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/css.png"></p><h1 id="一、常见定位方案"><a href="#一、常见定位方案" class="headerlink" title="一、常见定位方案"></a>一、常见定位方案</h1><p>在讲 BFC 之前，我们先来了解一下常见的定位方案，定位方案是控制元素的布局，有三种常见方案:</p><ul><li>普通流 (normal flow)<br>在普通流中，元素按照其在 HTML 中的先后位置至上而下布局，在这个过程中，行内元素水平排列，直到当行被占满然后换行，块级元素则会被渲染为完整的一个新行，除非另外指定，否则所有元素默认都是普通流定位，也可以说，普通流中元素的位置由该元素在 HTML 文档中的位置决定。</li><li>浮动 (float)<br>在浮动布局中，元素首先按照普通流的位置出现，然后根据浮动的方向尽可能的向左边或右边偏移，其效果与印刷排版中的文本环绕相似。</li><li>绝对定位 (absolute positioning)<br>在绝对定位布局中，元素会整体脱离普通流，因此绝对定位元素不会对其兄弟元素造成影响，而元素具体的位置由绝对定位的坐标决定。</li></ul><h1 id="二、BFC-概念"><a href="#二、BFC-概念" class="headerlink" title="二、BFC 概念"></a>二、BFC 概念</h1><blockquote><p>Formatting context(格式化上下文) 是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。</p></blockquote><p>那么 BFC 是什么呢？</p><p>BFC 即 Block Formatting Contexts (块级格式化上下文)，它属于上述定位方案的普通流。<br>具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。<br>通俗一点来讲，可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。</p><h1 id="三、触发-BFC"><a href="#三、触发-BFC" class="headerlink" title="三、触发 BFC"></a>三、触发 BFC</h1><p>只要元素满足下面任一条件即可触发 BFC 特性：</p><ul><li>body 根元素</li><li>浮动元素：float 除 none 以外的值</li><li>绝对定位元素：position (absolute、fixed)</li><li>display 为 inline-block、table-cells、flex</li><li>overflow 除了 visible 以外的值 (hidden、auto、scroll)</li></ul><h1 id="四、BFC-特性及应用"><a href="#四、BFC-特性及应用" class="headerlink" title="四、BFC 特性及应用"></a>四、BFC 特性及应用</h1><h2 id="1-同一个-BFC-下外边距会发生折叠"><a href="#1-同一个-BFC-下外边距会发生折叠" class="headerlink" title="1. 同一个 BFC 下外边距会发生折叠"></a>1. 同一个 BFC 下外边距会发生折叠</h2><pre><code>&lt;head&gt;div{    width: 100px;    height: 100px;    background: lightblue;    margin: 100px;}&lt;/head&gt;&lt;body&gt;    &lt;div&gt;&lt;/div&gt;    &lt;div&gt;&lt;/div&gt;&lt;/body&gt;</code></pre><p>从效果上看，因为两个 div 元素都处于同一个 BFC 容器下 (这里指 body 元素) 所以第一个 div 的下边距和第二个 div 的上边距发生了重叠，所以两个盒子之间距离只有 100px，而不是 200px。<br><img src="https://7.dusays.com/2020/11/02/0afee71e5de5e.png"></p><p>首先这不是 CSS 的 bug，我们可以理解为一种规范，如果想要避免外边距的重叠，可以将其放在不同的 BFC 容器中。</p><pre><code>&lt;div class="container"&gt;    &lt;p&gt;&lt;/p&gt;&lt;/div&gt;&lt;div class="container"&gt;    &lt;p&gt;&lt;/p&gt;&lt;/div&gt;.container {    overflow: hidden;}p {    width: 100px;    height: 100px;    background: lightblue;    margin: 100px;}</code></pre><p>这时候，两个盒子边距就变成了 200px </p><p><img src="https://7.dusays.com/2020/11/02/0e302d5bce868.png"></p><h2 id="2-BFC-可以包含浮动的元素（清除浮动）"><a href="#2-BFC-可以包含浮动的元素（清除浮动）" class="headerlink" title="2. BFC 可以包含浮动的元素（清除浮动）"></a>2. BFC 可以包含浮动的元素（清除浮动）</h2><p>我们都知道，浮动的元素会脱离普通文档流，来看下下面一个例子</p><pre><code>&lt;div style="border: 1px solid #000;"&gt;    &lt;div style="width: 100px;height: 100px;background: #eee;float: left;"&gt;&lt;/div&gt;&lt;/div&gt;</code></pre><p><img src="https://7.dusays.com/2020/11/02/f461d5e0dbd0f.png"></p><p>由于容器内元素浮动，脱离了文档流，所以容器只剩下 2px 的边距高度。如果使触发容器的 BFC，那么容器将会包裹着浮动元素。</p><pre><code>&lt;div style="border: 1px solid #000;overflow: hidden"&gt;    &lt;div style="width: 100px;height: 100px;background: #eee;float: left;"&gt;&lt;/div&gt;&lt;/div&gt;</code></pre><p>效果如图：</p><p><img src="https://7.dusays.com/2020/11/02/b90051e64945c.png"></p><h2 id="3-BFC-可以阻止元素被浮动元素覆盖"><a href="#3-BFC-可以阻止元素被浮动元素覆盖" class="headerlink" title="3. BFC 可以阻止元素被浮动元素覆盖"></a>3. BFC 可以阻止元素被浮动元素覆盖</h2><p>先来看一个文字环绕效果：</p><pre><code>&lt;div style="height: 100px;width: 100px;float: left;background: lightblue"&gt;    我是一个左浮动的元素&lt;/div&gt;&lt;div style="width: 200px; height: 200px;background: #eee"&gt;    我是一个没有设置浮动, 也没有触发 BFC 元素, width: 200px; height:200px; background: #eee;&lt;/div&gt;</code></pre><p><img src="https://7.dusays.com/2020/11/02/aaf4c0ab57032.png"></p><p>这时候其实第二个元素有部分被浮动元素所覆盖，(但是文本信息不会被浮动元素所覆盖) 如果想避免元素被覆盖，可触第二个元素的 BFC 特性，在第二个元素中加入 overflow: hidden，就会变成：</p><p><img src="https://7.dusays.com/2020/11/02/4a7759227aae9.png"></p><p>这个方法可以用来实现两列自适应布局，效果不错，这时候左边的宽度固定，右边的内容自适应宽度(去掉上面右边内容的宽度)。</p>]]></content>
      
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hooks入门教程</title>
      <link href="2019/09/16/hooks-ru-men-jiao-cheng/"/>
      <url>2019/09/16/hooks-ru-men-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<p><img src="https://7.dusays.com/2020/11/02/d812bf44ed5ef.png" alt="react"></p><h1 id="Hooks的含义"><a href="#Hooks的含义" class="headerlink" title="Hooks的含义:"></a>Hooks的含义:</h1><p>React Hooks 的意思是，组件尽量写成<strong>纯函数</strong>，如果需要外部功能和副作用，就用钩子把外部代码”钩”进来。 React Hooks 就是那些钩子。</p><p>React默认提供了一些常用的钩子函数，你也可以自己定义钩子函数。</p><p>React 团队希望，组件不要变成复杂的容器，最好只是数据流的管道。开发者根据需要，组合管道即可。 <strong>组件的最佳写法应该是函数</strong>，而不是类。</p><p>React 约定，钩子一律使用<strong>use</strong>前缀命名，便于识别。</p><h1 id="常见的钩子函数"><a href="#常见的钩子函数" class="headerlink" title="常见的钩子函数"></a>常见的钩子函数</h1><h2 id="1-useState-状态钩子"><a href="#1-useState-状态钩子" class="headerlink" title="1. useState():状态钩子"></a>1. useState():状态钩子</h2><pre><code>useState用于为函数组件引入状态（state）。纯函数不能有状态，所以把状态放在钩子里面useState()这个函数接受状态的初始值，作为参数，返回一个数组，数组第一个成员是一个变量，指向状态的当前值。第二个成员是函数，用来更新状态，约定用set前缀加上状态的变量名。const [buttonText, setButtonText] = useState("Click me, please");</code></pre><h2 id="2-useContext-共享状态钩子"><a href="#2-useContext-共享状态钩子" class="headerlink" title="2. useContext()共享状态钩子"></a>2. useContext()共享状态钩子</h2><pre><code>如果组件之间需要共享状态，可以使用useContext()。&lt;div className="App"&gt;  &lt;Navbar/&gt;  &lt;Messages/&gt;&lt;/div&gt;如果Navbar跟Messages实现通信，第一步在组件外部建立一个context:const AppContext = React.creatContext({})组件封装的代码如下：&lt;AppContext.Provider value={{  username: 'superawesome'}}&gt;  &lt;div className="App"&gt;    &lt;Navbar/&gt;    &lt;Messages/&gt;  &lt;/div&gt;&lt;/AppContext.Provider&gt;在组件中的使用如下：const Navbar = () =&gt; {  const { username } = useContext(AppContext);  return (    &lt;div className="navbar"&gt;      &lt;p&gt;AwesomeSite&lt;/p&gt;      &lt;p&gt;{username}&lt;/p&gt;    &lt;/div&gt;  );}</code></pre><h2 id="3-useReducer-action钩子"><a href="#3-useReducer-action钩子" class="headerlink" title="3. useReducer():action钩子"></a>3. useReducer():action钩子</h2><pre><code>React 本身不提供状态管理功能，通常需要使用外部库。这方面最常用的库是 Redux。Redux 的核心概念是，组件发出 action 与状态管理器通信。状态管理器收到 action 以后，使用 Reducer 函数算出新的状态，Reducer 函数的形式是(state, action) =&gt; newState。useReducers()钩子用来引入 Reducer 功能。const [state, dispatch] = useReducer(reducer, initialState);</code></pre><h2 id="4-useEffect-副作用钩子"><a href="#4-useEffect-副作用钩子" class="headerlink" title="4. useEffect():副作用钩子"></a>4. useEffect():副作用钩子</h2><pre><code>useEffect()用来引入具有副作用的操作，最常见的就是向服务器请求数据。以前，放在componentDidMount里面的代码，现在可以放在useEffect()。useEffect()的用法如下。useEffect(()  =&gt;  {  // Async Action}, [dependencies])useEffect()接受两个参数。第一个参数是函数，异步操作的代码放里面，第二个参数是一个数组，用于给出Effect的依赖，只要这个数组发生变化，useEffect()就会执行。第二个参数可以省略，这时每次组件渲染时，就会执行useEffect()。</code></pre><p>React首次渲染和之后的每次渲染都会调用一遍useEffect函数，而之前我们要用两个生命周期函数分别表示首次渲染(componentDidMonut)和更新导致的重新渲染(componentDidUpdate)。</p><p>useEffect中定义的函数的执行不会阻碍浏览器更新视图，也就是说这些函数时异步执行的，而componentDidMonut和componentDidUpdate中的代码都是同步执行的。个人认为这个有好处也有坏处吧，比如我们要根据页面的大小，然后绘制当前弹出窗口的大小，如果时异步的就不好操作了。</p>]]></content>
      
      
      <categories>
          
          <category> 新鲜技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
            <tag> hooks </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单的在线数据mock</title>
      <link href="2019/08/30/jian-dan-de-zai-xian-shu-ju-mock/"/>
      <url>2019/08/30/jian-dan-de-zai-xian-shu-ju-mock/</url>
      
        <content type="html"><![CDATA[<h1 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h1><p>在接口调试前，前端根据定义好的接口文档，模拟数据，发起请求，编写完整的页面逻辑，等真正开始调试的时候，将请求地址更换即可。</p><p>本文只介绍在线 mock 数据的方式，在线 mock 跟本地 mock 比较，可以省去安装配置，运行服务，多人协作数据不通的多种问题。</p><h1 id="一个简单的列子"><a href="#一个简单的列子" class="headerlink" title="一个简单的列子"></a>一个简单的列子</h1><p><img src="https://7.dusays.com/2020/11/02/98aaa2c403dd1.png"></p><p>返回结果：</p><p><img src="https://7.dusays.com/2020/11/02/a2df1d69cadcf.png"></p><h1 id="Mock-语法简介"><a href="#Mock-语法简介" class="headerlink" title="Mock 语法简介"></a>Mock 语法简介</h1><h2 id="base"><a href="#base" class="headerlink" title="base"></a>base</h2><pre><code>{    "base": {    "range": "@range(3, 7)",    "string": "@string(7, 20)",    "character": "@character(\"abcde\")",    "float": "@float(60, 100)",    "integer": "@integer(60, 100)",    "natural": "@natural(60, 100)",    "boolean": "@boolean"  },}</code></pre><p>预览：</p><pre><code>"base": {    "range": [3,4,5,6],    "string": "qg3)zBWiLlbrsisX",    "character": "c",    "float": 66.87535733306,    "integer": 66,    "natural": 71,    "boolean": false  },</code></pre><h2 id="date"><a href="#date" class="headerlink" title="date"></a>date</h2><pre><code>"date": {    "date": "@date",    "time": "@time",    "datetime": "@datetime",    "now": "@now"  },</code></pre><p>预览：</p><pre><code>"date": {    "date": "1971-10-18",    "time": "02:04:17",    "datetime": "1985-03-10 22:47:49",    "now": "2019-09-25 13:56:44"    }</code></pre><h2 id="image"><a href="#image" class="headerlink" title="image"></a>image</h2><pre><code> "image": {    "image": "@image(\"200x200\", \"#50B347\", \"#FFF\", \"FastMock\")"  },</code></pre><p>预览：</p><pre><code>"image": {    "image": "http://dummyimage.com/200x200/50B347/FFF&amp;text=FastMock"  },</code></pre><h2 id="text"><a href="#text" class="headerlink" title="text"></a>text</h2><pre><code>"text": {    "paragraph": "@paragraph(1, 3)",    "sentence": "@sentence(3, 5)",    "word": "@word(3, 5)",    "title": "@title(3, 5)",    "cparagraph": "@cparagraph(1, 3)",    "csentence": "@csentence(3, 5)",    "cword": "@cword(\"零一二三四五六七八九十\", 5, 7)",    "ctitle": "@ctitle(3, 5)"  },</code></pre><p>预览：</p><pre><code> "text": {    "paragraph": "Gifp ifnk hrreyi foajbgielv doijqrd ffaooi hlwstfcfw nrgsioum wtgashcoiy sintskl hnjk ebcsec. Bhlhghu embjvvs bckwkibqhs qgqz psu mjsodprwf exidxyqnq cdyqoatr xkezagaqu ijrcqrj vvxwdwgq ivv jxcpeybpus sojcn cscdlnmi kopzvuqfin.",    "sentence": "Xuqxp qvek ttgiq.",    "word": "ynug",    "title": "Cdnsxa Yjhrlbb Rmofrixln Jubgpxm Gjpdujgryi",    "cparagraph": "装增克体都月每手物即用周几想军点程。将角权响金华生候社根利情也龙。化必去边织众东位史回际平马至。",    "csentence": "存断实。",    "cword": "三七九六六",    "ctitle": "油眼采小"  },</code></pre><h2 id="name"><a href="#name" class="headerlink" title="name"></a>name</h2><pre><code>"name": {    "first": "@first",    "last": "@last",    "name": "@name",    "cfirst": "@cfirst",    "clast": "@clast",    "cname": "@cname"  },</code></pre><p>预览：</p><pre><code>"name": {    "first": "Jennifer",    "last": "Anderson",    "name": "Laura Moore",    "cfirst": "胡",    "clast": "秀兰",    "cname": "姜敏"  },</code></pre><h2 id="web"><a href="#web" class="headerlink" title="web"></a>web</h2><pre><code>"web": {    "url": "@url",    "domain": "@domain",    "protocol": "@protocol",    "tld": "@tld",    "email": "@email",    "ip": "@ip"  },</code></pre><p>预览：</p><pre><code>"web": {    "url": "mid://nypjj.kr/mizdvfhl",    "domain": "jbgmh.cn",    "protocol": "ftp",    "tld": "fj",    "email": "r.bdwejkiuy@ltatgpp.an",    "ip": "175.52.62.226"  },</code></pre><h2 id="address"><a href="#address" class="headerlink" title="address"></a>address</h2><pre><code>"address": {    "region": "@region",    "province": "@province",    "city": "@city(true)",    "county": "@county(true)",    "zip": "@zip"  },</code></pre><p>预览：</p><pre><code>"address": {    "region": "华中",    "province": "云南省",    "city": "天津 天津市",    "county": "台湾 金门县 金宁乡",    "zip": "539375"  },</code></pre><h2 id="miscellaneous"><a href="#miscellaneous" class="headerlink" title="miscellaneous"></a>miscellaneous</h2><pre><code> "miscellaneous": {    "id": "@id",    "guid": "@guid",    "increment": "@increment(1000)"  }</code></pre><p>预览：</p><pre><code> "miscellaneous": {    "id": "370000201504299208",    "guid": "6E6155c0-f5b5-F3F6-5F0D-23EB44C21313",    "increment": 253109  }</code></pre><h1 id="Mock-高阶用法"><a href="#Mock-高阶用法" class="headerlink" title="Mock 高阶用法"></a>Mock 高阶用法</h1><blockquote><p>Mock 能支持 function，function 中不能用上面的@XX,用 Mock.mock(“@xxx”)替代。function 中还能获取全部请求头和参数。</p></blockquote><table><thead><tr><th>对象</th><th>描述</th></tr></thead><tbody><tr><td>Mock</td><td>Mock 对象</td></tr><tr><td>_req.url</td><td>获得请求 url 地址</td></tr><tr><td>_req.method</td><td>获取请求方法</td></tr><tr><td>_req.params</td><td>获取 url 参数对象</td></tr><tr><td>_req.querystring</td><td>获取查询参数字符串(url 中?后面的部分)，不包含 ?</td></tr><tr><td>_req.query</td><td>将查询参数字符串进行解析并以对象的形式返回，如果没有查询参数字字符串则返回一个空对象</td></tr><tr><td>_req.body</td><td>当 post 请求以 x-www-form-urlencoded 方式提交时，我们可以拿到请求的参数对象</td></tr></tbody></table><h2 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h2><pre><code>{  code: function({    _req  }) {    const userName = _req.query.userName;    return userName ? 0 : -1;  },  data: function({    _req,    Mock  }) {    const userName = _req.query.userName;    return userName ? {      token: Mock.mock("@guid()"),      userId: Mock.mock("@id(5)"),      name: userName,      avatar: Mock.mock("@image(200x100, #FF6600)"),      message: "登录成功"    } : {      message: "登录失败"    }  }}</code></pre><p>预览：</p><p><img src="https://note.youdao.com/yws/public/resource/633e9bc706a3a274d9926f95b1806671/xmlnote/1C6017CB352F41DD9B758D064EBCFD4B/15016" alt="image"></p><h1 id="常用的在线-mock-工具"><a href="#常用的在线-mock-工具" class="headerlink" title="常用的在线 mock 工具"></a>常用的在线 mock 工具</h1><ul><li><p>💛 <a href="https://www.fastmock.site/">fast-mock</a></p></li><li><p>💗 <a href="https://easy-mock.com/">easy-mock</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue组件编码规范</title>
      <link href="2019/08/13/vue-zu-jian-bian-ma-gui-fan/"/>
      <url>2019/08/13/vue-zu-jian-bian-ma-gui-fan/</url>
      
        <content type="html"><![CDATA[<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><blockquote><p>本规范提供了一种统一的编码规范来编写 Vue.js 代码。这使得代码具有如下的特性：</p></blockquote><ul><li>其它开发者或是团队成员更容易阅读和理解。</li><li>IDEs 更容易理解代码，从而提供高亮、格式化等辅助功能</li><li>更容易使用现有的工具</li><li>更容易实现缓存以及代码包的分拆</li></ul><h1 id="基于模块开发"><a href="#基于模块开发" class="headerlink" title="基于模块开发"></a>基于模块开发</h1><p>始终基于模块的方式来构建你的 app，每一个子模块只做一件事情。</p><p>Vue.js 的设计初衷就是帮助开发者更好的开发界面模块。一个模块是应用程序中独立的一个部分。</p><h2 id="怎么做？"><a href="#怎么做？" class="headerlink" title="怎么做？"></a>怎么做？</h2><blockquote><p>每一个 Vue 组件（等同于模块）首先必须专注于解决一个单一的问题，独立的、可复用的、微小的 和 可测试的。</p></blockquote><p>如果你的组件做了太多的事或是变得臃肿，请将其拆分成更小的组件并保持单一的原则。一般来说，尽量保证每一个文件的代码行数不要超过 100 行。也请保证组件可独立的运行。</p><h1 id="vue-组件命名"><a href="#vue-组件命名" class="headerlink" title="vue 组件命名"></a>vue 组件命名</h1><p>组件的命名需遵从以下原则：</p><ul><li><p><strong>有意义的</strong>: 不过于具体，也不过于抽象</p></li><li><p><strong>简短</strong>: 2 到 3 个单词</p></li><li><p><strong>具有可读性</strong>: 以便于沟通交流<br>同时还需要注意：</p></li><li><p>必须符合<strong>自定义元素规范</strong>: 使用连字符分隔单词，切勿使用保留字。</p></li><li><p>app- 前缀作为命名空间:</p></li></ul><p>如果非常通用的话可使用一个单词来命名，这样可以方便于其它项目里复用。</p><h2 id="为什么？"><a href="#为什么？" class="headerlink" title="为什么？"></a>为什么？</h2><ul><li>组件是通过组件名来调用的。所以组件名必须简短、富有含义并且具有可读性。</li></ul><h2 id="如何做？"><a href="#如何做？" class="headerlink" title="如何做？"></a>如何做？</h2><pre><code>!-- 推荐 --&gt;&lt;app-header&gt;&lt;/app-header&gt;&lt;user-list&gt;&lt;/user-list&gt;&lt;range-slider&gt;&lt;/range-slider&gt;&lt;!-- 避免 --&gt;&lt;btn-group&gt;&lt;/btn-group&gt; &lt;!-- 虽然简短但是可读性差. 使用 `button-group` 替代 --&gt;&lt;ui-slider&gt;&lt;/ui-slider&gt; &lt;!-- ui 前缀太过于宽泛，在这里意义不明确 --&gt;&lt;slider&gt;&lt;/slider&gt; &lt;!-- 与自定义元素规范不兼容 --&gt;</code></pre><h1 id="组件表达式简单化"><a href="#组件表达式简单化" class="headerlink" title="组件表达式简单化"></a>组件表达式简单化</h1><p>Vue.js 的表达式是 100% 的 Javascript 表达式。这使得其功能性很强大，但也带来潜在的复杂性。因此，你应该尽量保持表达式的简单化。</p><h2 id="为什么？-1"><a href="#为什么？-1" class="headerlink" title="为什么？"></a>为什么？</h2><ul><li>复杂的行内表达式难以阅读。</li><li>行内表达式是不能够通用的，这可能会导致重复编码的问题。</li><li>IDE 基本上不能识别行内表达式语法，所以使用行内表达式 IDE 不能提供自动补全和语法校验功能。</li></ul><h2 id="怎么做？-1"><a href="#怎么做？-1" class="headerlink" title="怎么做？"></a>怎么做？</h2><p>如果你发现写了太多复杂并难以阅读的行内表达式，那么可以使用 method 或是 computed 属性来替代其功能。</p><pre><code>&lt;!-- 推荐 --&gt;&lt;template&gt;  &lt;h1&gt;    {{ `${year}-${month}` }}  &lt;/h1&gt;&lt;/template&gt;&lt;script type="text/javascript"&gt;  export default {    computed: {      month() {        return this.twoDigits((new Date()).getUTCMonth() + 1);      },      year() {        return (new Date()).getUTCFullYear();      }    },    methods: {      twoDigits(num) {        return ('0' + num).slice(-2);      }    },  };&lt;/script&gt;&lt;!-- 避免 --&gt;&lt;template&gt;  &lt;h1&gt;    {{ `${(new Date()).getUTCFullYear()}-${('0' + ((new Date()).getUTCMonth()+1)).slice(-2)}` }}  &lt;/h1&gt;&lt;/template&gt;</code></pre><h1 id="组件-props-原子化"><a href="#组件-props-原子化" class="headerlink" title="组件 props 原子化"></a>组件 props 原子化</h1><p>虽然 Vue.js 支持传递复杂的 JavaScript 对象通过 props 属性，但是你应该尽可能的使用原始类型的数据。尽量只使用 JavaScript 原始类型（字符串、数字、布尔值）和函数。尽量避免复杂的对象。</p><h2 id="为什么？-2"><a href="#为什么？-2" class="headerlink" title="为什么？"></a>为什么？</h2><ul><li>使得组件 API 清晰直观。</li><li>只使用原始类型和函数作为 props 使得组件的 API 更接近于 HTML(5) 原生元素。</li><li>其它开发者更好的理解每一个 prop 的含义、作用。</li><li>传递过于复杂的对象使得我们不能够清楚的知道哪些属性或方法被自定义组件使用，这使得代码难以重构和维护。</li></ul><h2 id="怎么做？-2"><a href="#怎么做？-2" class="headerlink" title="怎么做？"></a>怎么做？</h2><p>组件的每一个属性单独使用一个 props，并且使用函数或是原始类型的值。</p><pre><code>&lt;!-- 推荐 --&gt;&lt;range-slider  :values="[10, 20]"  :min="0"  :max="100"  :step="5"  @on-slide="updateInputs"  @on-end="updateResults"&gt;&lt;/range-slider&gt;&lt;!-- 避免 --&gt;&lt;range-slider :config="complexConfigObject"&gt;&lt;/range-slider&gt;</code></pre><h1 id="验证组件的-props"><a href="#验证组件的-props" class="headerlink" title="验证组件的 props"></a>验证组件的 props</h1><p>在 Vue.js 中，组件的 props 即 API，一个稳定并可预测的 API 会使得你的组件更容易被其他开发者使用。</p><p>组件 props 通过自定义标签的属性来传递。属性的值可以是 Vue.js 字符串(:attr=”value” 或 v-bind:attr=”value”)或是不传。你需要保证组件的 props 能应对不同的情况。</p><h2 id="为什么？-3"><a href="#为什么？-3" class="headerlink" title="为什么？"></a>为什么？</h2><p>验证组件 props 可以保证你的组件永远是可用的（防御性编程）。即使其他开发者并未按照你预想的方法使用时也不会出错。</p><h2 id="怎么做？-3"><a href="#怎么做？-3" class="headerlink" title="怎么做？"></a>怎么做？</h2><ul><li>提供默认值。</li><li>使用 type 属性校验类型。</li><li>使用 props 之前先检查该 prop 是否存在。</li></ul><pre><code>&lt;template&gt;  &lt;input type="range" v-model="value" :max="max" :min="min"&gt;&lt;/template&gt;&lt;script type="text/javascript"&gt;  export default {    props: {      max: {        type: Number, // 这里添加了数字类型的校验        default() { return 10; },      },      min: {        type: Number,        default() { return 0; },      },      value: {        type: Number,        default() { return 4; },      },    },  };&lt;/script&gt;</code></pre><h1 id="将-this-赋值给-component-变量"><a href="#将-this-赋值给-component-变量" class="headerlink" title="将 this 赋值给 component 变量"></a>将 this 赋值给 component 变量</h1><p>在 Vue.js 组件上下文中，this指向了组件实例。因此当你切换到了不同的上下文时，要确保 this 指向一个可用的 component 变量。</p><p>换句话说，如果你正在使用 ES6 的话，就不要再编写 var self = this; 这样的代码了，您可以安全地使用 Vue 组件。</p><h2 id="为什么？-4"><a href="#为什么？-4" class="headerlink" title="为什么？"></a>为什么？</h2><ul><li>使用 ES6，就不再需要将 this 保存到一个变量中了。</li><li>一般来说，当你使用箭头函数时，会保留 this 的作用域。（译者注：箭头函数没有它自己的 this 值，箭头函数内的 this 值继承自外围作用域。）</li><li>如果你没有使用 ES6，当然也就不会使用 箭头函数 啦，那你必须将 “this” 保存到到某个变量中。这是唯一的例外。</li></ul><h2 id="怎么做？-4"><a href="#怎么做？-4" class="headerlink" title="怎么做？"></a>怎么做？</h2><pre><code>&lt;script type="text/javascript"&gt;export default {  methods: {    hello() {      return 'hello';    },    printHello() {      console.log(this.hello());    },  },};&lt;/script&gt;&lt;!-- 避免 --&gt;&lt;script type="text/javascript"&gt;export default {  methods: {    hello() {      return 'hello';    },    printHello() {      const self = this; // 没有必要      console.log(self.hello());    },  },};&lt;/script&gt;</code></pre><h1 id="组件结构化"><a href="#组件结构化" class="headerlink" title="组件结构化"></a>组件结构化</h1><p>按照一定的结构组织，使得组件便于理解。</p><h2 id="为什么？-5"><a href="#为什么？-5" class="headerlink" title="为什么？"></a>为什么？</h2><ul><li>导出一个清晰、组织有序的组件，使得代码易于阅读和理解。同时也便于标准化。</li><li>按首字母排序 properties、data、computed、watches 和 methods 使得这些对象内的属性便于查找。</li><li>合理组织，使得组件易于阅读。（name; extends; props, data 和 computed; components; watch 和 methods; lifecycle methods 等）。</li><li>使用 name 属性。借助于 vue devtools 可以让你更方便的测试。</li><li>合理的 CSS 结构，如 BEM 或 rscss - 详情？。</li><li>使用单文件 .vue 文件格式来组件代码。</li></ul><h2 id="怎么做？-5"><a href="#怎么做？-5" class="headerlink" title="怎么做？"></a>怎么做？</h2><p>组件结构化</p><pre><code>&lt;template lang="html"&gt;  &lt;div class="Ranger__Wrapper"&gt;    &lt;!-- ... --&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script type="text/javascript"&gt;  export default {    // 不要忘记了 name 属性    name: 'RangeSlider',    // 使用组件 mixins 共享通用功能    mixins: [],    // 组成新的组件    extends: {},    // 组件属性、变量    props: {      bar: {}, // 按字母顺序      foo: {},      fooBar: {},    },    // 变量    data() {},    computed: {},    // 使用其它组件    components: {},    // 方法    watch: {},    methods: {},    // 生命周期函数    beforeCreate() {},    mounted() {},  };&lt;/script&gt;&lt;style scoped&gt;  .Ranger__Wrapper { /* ... */ }&lt;/style&gt;</code></pre><h1 id="避免-this-parent"><a href="#避免-this-parent" class="headerlink" title="避免 this.$parent"></a>避免 this.$parent</h1><p>Vue.js 支持组件嵌套，并且子组件可访问父组件的上下文。访问组件之外的上下文违反了基于模块开发的第一原则。因此你应该尽量避免使用 this.$parent。</p><h2 id="为什么？-6"><a href="#为什么？-6" class="headerlink" title="为什么？"></a>为什么？</h2><ul><li>组件必须相互保持独立，Vue 组件也是。如果组件需要访问其父层的上下文就违反了该原则。</li><li>如果一个组件需要访问其父组件的上下文，那么该组件将不能在其它上下文中复用。</li></ul><h2 id="怎么做？-6"><a href="#怎么做？-6" class="headerlink" title="怎么做？"></a>怎么做？</h2><ul><li>通过 props 将值传递给子组件。</li><li>通过 props 传递回调函数给子组件来达到调用父组件方法的目的。</li><li>通过在子组件触发事件来通知父组件。</li></ul><h1 id="谨慎使用-this-refs"><a href="#谨慎使用-this-refs" class="headerlink" title="谨慎使用 this.$refs"></a>谨慎使用 this.$refs</h1><p>Vue.js 支持通过 ref 属性来访问其它组件和 HTML 元素。并通过 this.$refs 可以得到组件或 HTML 元素的上下文。在大多数情况下，通过 this.$refs来访问其它组件的上下文是可以避免的。在使用的的时候你需要注意避免调用了不恰当的组件 API，所以应该尽量避免使用 this.$refs。</p><h2 id="为什么？-7"><a href="#为什么？-7" class="headerlink" title="为什么？"></a>为什么？</h2><ul><li>组件必须是保持独立的，如果一个组件的 API 不能够提供所需的功能，那么这个组件在设计、实现上是有问题的。</li><li>组件的属性和事件必须足够的给大多数的组件使用。</li></ul><h2 id="怎么做？-7"><a href="#怎么做？-7" class="headerlink" title="怎么做？"></a>怎么做？</h2><ul><li>提供良好的组件 API。</li><li>总是关注于组件本身的目的。</li><li>拒绝定制代码。如果你在一个通用的组件内部编写特定需求的代码，那么代表这个组件的 API 不够通用，或者你可能需要一个新的组件来应对该需求。</li><li>检查所有的 props 是否有缺失的，如果有提一个 issue 或是完善这个组件。</li><li>检查所有的事件。子组件向父组件通信一般是通过事件来实现的，但是大多数的开发者更多的关注于 props 从忽视了这点。</li><li>Props向下传递，事件向上传递！。以此为目标升级你的组件，提供良好的 API 和 独立性。</li><li>当遇到 props 和 events 难以实现的功能时，通过 this.$refs来实现。</li><li>当需要操作 DOM 无法通过指令来做的时候可使用 this.$ref 而不是 JQuery、document.getElement*、document.queryElement。</li></ul><pre><code>&lt;!-- 推荐，并未使用 this.$refs --&gt;&lt;range :max="max"  :min="min"  @current-value="currentValue"  :step="1"&gt;&lt;/range&gt;</code></pre><pre><code>&lt;!-- 使用 this.$refs 的适用情况--&gt;&lt;modal ref="basicModal"&gt;  &lt;h4&gt;Basic Modal&lt;/h4&gt;  &lt;button class="primary" @click="$refs.basicModal.hide()"&gt;Close&lt;/button&gt;&lt;/modal&gt;&lt;button @click="$refs.basicModal.open()"&gt;Open modal&lt;/button&gt;&lt;!-- Modal component --&gt;&lt;template&gt;  &lt;div v-show="active"&gt;    &lt;!-- ... --&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  export default {    // ...    data() {      return {        active: false,      };    },    methods: {      open() {        this.active = true;      },      hide() {        this.active = false;      },    },    // ...  };&lt;/script&gt;</code></pre><pre><code>&lt;!-- 如果可通过 emited 来做则避免通过 this.$refs 直接访问 --&gt;&lt;template&gt;  &lt;range :max="max"    :min="min"    ref="range"    :step="1"&gt;&lt;/range&gt;&lt;/template&gt;&lt;script&gt;  export default {    // ...    methods: {      getRangeCurrentValue() {        return this.$refs.range.currentValue;      },    },    // ...  };&lt;/script&gt;</code></pre><h1 id="使用组件名作为样式作用域空间"><a href="#使用组件名作为样式作用域空间" class="headerlink" title="使用组件名作为样式作用域空间"></a>使用组件名作为样式作用域空间</h1><p>Vue.js 的组件是自定义元素，这非常适合用来作为样式的根作用域空间。可以将组件名作为 CSS 类的命名空间。</p><h2 id="为什么？-8"><a href="#为什么？-8" class="headerlink" title="为什么？"></a>为什么？</h2><ul><li>给样式加上作用域空间可以避免组件样式影响外部的样式。</li><li>保持模块名、目录名、样式根作用域名一样，可以很好的将其关联起来，便于开发者理解。</li></ul><h2 id="怎么做？-8"><a href="#怎么做？-8" class="headerlink" title="怎么做？"></a>怎么做？</h2><p>使用组件名作为样式命名的前缀，可基于 BEM 或 OOCSS 范式。同时给 style 标签加上 scoped 属性。加上 scoped 属性编译后会给组件的 class 自动加上唯一的前缀从而避免样式的冲突。</p><pre><code>&lt;style scoped&gt;  /* 推荐 */  .MyExample { }  .MyExample li { }  .MyExample__item { }  /* 避免 */  .My-Example { } /* 没有用组件名或模块名限制作用域, 不符合 BEM 规范 */&lt;/style&gt;</code></pre><h1 id="尽可能使用-mixins"><a href="#尽可能使用-mixins" class="headerlink" title="尽可能使用 mixins"></a>尽可能使用 mixins</h1><h2 id="为什么"><a href="#为什么" class="headerlink" title="为什么?"></a>为什么?</h2><p>Mixins 封装可重用的代码，避免了重复。如果两个组件共享有相同的功能，则可以使用 mixin。通过 mixin，你可以专注于单个组件的任务和抽象的通用代码。这有助于更好地维护你的应用程序。</p><h2 id="怎么做"><a href="#怎么做" class="headerlink" title="怎么做?"></a>怎么做?</h2><p>假设你有一个移动端和桌面端的菜单组件，它们共享一些功能。我们可以抽象出这两个组件的核心功能到一个 mixin 中，例如：</p><pre><code>const MenuMixin = {  data () {    return {      language: 'EN'    }  },  methods: {    changeLanguage () {      if (this.language === 'DE') this.$set(this, 'language', 'EN')      if (this.language === 'EN') this.$set(this, 'language', 'DE')    }  }}export default MenuMixin</code></pre><p>要使用 mixin，只需将其导入到两个组件中（我只展示移动组件）。</p><pre><code>&lt;template&gt;  &lt;ul class="mobile"&gt;    &lt;li @click="changeLanguage"&gt;Change language&lt;/li&gt;  &lt;/ul&gt;&lt;/template&gt;&lt;script&gt;  import MenuMixin from './MenuMixin'  export default {    mixins: [MenuMixin]  }&lt;/script&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> VUE专题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端规范 </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端命名规范</title>
      <link href="2019/08/13/qian-duan-ming-ming-gui-fan/"/>
      <url>2019/08/13/qian-duan-ming-ming-gui-fan/</url>
      
        <content type="html"><![CDATA[<h1 id="驼峰式命名法介绍"><a href="#驼峰式命名法介绍" class="headerlink" title="驼峰式命名法介绍"></a>驼峰式命名法介绍</h1><ul><li>Pascal Case 大驼峰式命名法：首字母大写。eg：StudentInfo、UserInfo、ProductInfo</li><li>Camel Case 小驼峰式命名法：首字母小写。eg：studentInfo、userInfo、productInfo</li></ul><h1 id="文件资源命名"><a href="#文件资源命名" class="headerlink" title="文件资源命名"></a>文件资源命名</h1><ul><li>文件名不得含有空格</li><li>文件名建议只使用小写字母，不使用大写字母。( 为了醒目，某些说明文件的文件名，可以使用大写字母，比如README、LICENSE。 )</li><li>文件名包含多个单词时，单词之间建议使用半角的连词线 ( - ) 分隔。</li><li>引入资源使用相对路径，不要指定资源所带的具体协议 ( http:,https: ) ，除非这两者协议都不可用。</li></ul><h1 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h1><ul><li>命名方式 : 小驼峰式命名方法</li><li>命名规范 : 类型+对象描述的方式，如果没有明确的类型，就可以使前缀为名词</li></ul><table><thead><tr><th>类型</th><th>小写字母</th></tr></thead><tbody><tr><td>array</td><td>a</td></tr><tr><td>boolean</td><td>b</td></tr><tr><td>function</td><td>fn</td></tr><tr><td>int</td><td>i</td></tr><tr><td>object</td><td>o</td></tr><tr><td>string</td><td>s</td></tr></tbody></table><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><ul><li>命名方式 : 小驼峰方式 ( 构造函数使用大驼峰命名法 )</li><li>命名规则 : 前缀为动词</li></ul><table><thead><tr><th>动词</th><th>含义</th><th>返回值</th></tr></thead><tbody><tr><td>can</td><td>判断是否可执行某个动作 ( 权限 )</td><td>函数返回一个布尔值。true：可执行；false：不可执行</td></tr><tr><td>has</td><td>判断是否含有某个值</td><td>函数返回一个布尔值。true：含有此值；false：不含有此值</td></tr><tr><td>is</td><td>判断是否为某个值</td><td>函数返回一个布尔值。true：为某个值；false：不为某个值</td></tr><tr><td>get</td><td>获取某个值</td><td>函数返回一个非布尔值</td></tr><tr><td>set</td><td>设置某个值</td><td>无返回值、返回是否设置成功或者返回链式对象</td></tr></tbody></table><h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><ul><li>命名方法 : 全部大写</li><li>命名规范 : 使用大写字母和下划线来组合命名，下划线用以分割单词。<br>推荐：</li></ul><pre><code> var MAX_COUNT = 10; var URL = 'http://www.baidu.com';</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端规范 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css编写规范</title>
      <link href="2019/08/13/css-bian-xie-gui-fan/"/>
      <url>2019/08/13/css-bian-xie-gui-fan/</url>
      
        <content type="html"><![CDATA[<h1 id="id和class的命名"><a href="#id和class的命名" class="headerlink" title="id和class的命名"></a>id和class的命名</h1><p>ID和class的名称总是使用可以反应元素目的和用途的名称，或其他通用的名称，代替表象和晦涩难懂的名称</p><p>不推荐 :</p><pre><code>.fw-800 {  font-weight: 800;}.red {  color: red;}</code></pre><p>推荐 :</p><pre><code>.heavy {  font-weight: 800;}.important {  color: red;}</code></pre><h1 id="合理的使用ID"><a href="#合理的使用ID" class="headerlink" title="合理的使用ID"></a>合理的使用ID</h1><p>一般情况下ID不应该被用于样式，并且ID的权重很高，所以不使用ID解决样式的问题，而是使用class</p><p>不推荐：</p><pre><code>#content .title {  font-size: 2em;}</code></pre><p>推荐：</p><pre><code>.content .title {  font-size: 2em;}</code></pre><h1 id="css选择器中避免使用标签名"><a href="#css选择器中避免使用标签名" class="headerlink" title="css选择器中避免使用标签名"></a>css选择器中避免使用标签名</h1><p>从结构、表现、行为分离的原则来看，应该尽量避免css中出现HTML标签，并且在css选择器中出现标签名会存在潜在的问题。</p><h1 id="使用子选择器"><a href="#使用子选择器" class="headerlink" title="使用子选择器"></a>使用子选择器</h1><p>很多前端开发人员写选择器链的时候不使用 直接子选择器（注：直接子选择器和后代选择器的区别）。<br>有时，这可能会导致疼痛的设计问题并且有时候可能会很耗性能。然而，在任何情况下，这是一个非常不好的做法。<br>如果你不写很通用的，需要匹配到DOM末端的选择器， 你应该总是考虑直接子选择器。不推荐:</p><pre><code>.content .title {  font-size: 2rem;}</code></pre><p>推荐</p><pre><code>.content &gt; .title {  font-size: 2rem;}</code></pre><h1 id="尽量使用缩写属性"><a href="#尽量使用缩写属性" class="headerlink" title="尽量使用缩写属性"></a>尽量使用缩写属性</h1><p>尽量使用缩写属性对于代码效率和可读性是很有用的，比如font属性。不推荐：</p><pre><code>border-top-style: none;font-family: palatino, georgia, serif;font-size: 100%;line-height: 1.6;padding-bottom: 2em;padding-left: 1em;padding-right: 1em;padding-top: 0;</code></pre><p>推荐：</p><pre><code>border-top: 0;font: 100%/1.6 palatino, georgia, serif;padding: 0 1em 2em;</code></pre><h1 id="0后面不带单位"><a href="#0后面不带单位" class="headerlink" title="0后面不带单位"></a>0后面不带单位</h1><p>省略0后面的单位，</p><p>不推荐：</p><pre><code>padding-bottom: 0px;margin: 0em;</code></pre><p>推荐：</p><pre><code>padding-bottom: 0;margin: 0;</code></pre><h1 id="属性格式"><a href="#属性格式" class="headerlink" title="属性格式"></a>属性格式</h1><ul><li>为了保证一致性和可扩展性，每个声明应该用分号结束，每个声明换行。</li><li>属性名的冒号后使用一个空格。出于一致性的原因，属性和值（但属性和冒号之间没有空格）的之间始终使用一个空格。</li><li>每个选择器和属性声明总是使用新的一行。</li><li>属性选择器或属性值用双引号（””），而不是单引号（”）括起来。</li><li>URL值（url()）不要使用引号。</li></ul><p>作为最佳实践，我们应该遵循以下顺序（应该按照下表的顺序）：<br>结构性属性：</p><ul><li>display</li><li>position, left, top, right etc.</li><li>overflow, float, clear etc.</li><li>margin, padding</li></ul><p>表现性属性：</p><ul><li>background, border etc.</li><li>font, text</li></ul><p>不推荐：</p><pre><code> .box {  font-family: 'Arial', sans-serif;  border: 3px solid #ddd;  left: 30%;  position: absolute;  text-transform: uppercase;  background-color: #eee;  right: 30%;  isplay: block;  font-size: 1.5rem;  overflow: hidden;  padding: 1em;  margin: 1em;}</code></pre><p>推荐：</p><pre><code>.box {  display: block;  position: absolute;  left: 30%;  right: 30%;  overflow: hidden;  margin: 1em;  padding: 1em;  background-color: #eee;  border: 3px solid #ddd;  font-family: 'Arial', sans-serif;  font-size: 1.5rem;  text-transform: uppercase;}</code></pre><h1 id="ID-和-Class（类）-名的分隔符"><a href="#ID-和-Class（类）-名的分隔符" class="headerlink" title="ID 和 Class（类） 名的分隔符"></a>ID 和 Class（类） 名的分隔符</h1><p>使用连字符（中划线）分隔ID和Class（类）名中的单词。为了增强课理解性，在选择器中不要使用除了连字符（中划线）以为的任何字符（包括没有）来连接单词和缩写。</p><p>另外，作为该标准，预设属性选择器能识别连字符（中划线）作为单词[attribute|=value]的分隔符，<br>所以最好的坚持使用连字符作为分隔符。</p><p>不推荐</p><pre><code>.demoimage {}.error_status {}</code></pre><p>推荐</p><pre><code>#video-id {}.ads-sample {}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
            <tag> 前端规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端请求方式：xhr、ajax、axios与fetch的区别比较</title>
      <link href="2017/06/13/qian-duan-qing-qiu-fang-shi-xhr-ajax-axios-yu-fetch-de-qu-bie-bi-jiao/"/>
      <url>2017/06/13/qian-duan-qing-qiu-fang-shi-xhr-ajax-axios-yu-fetch-de-qu-bie-bi-jiao/</url>
      
        <content type="html"><![CDATA[<p>这些都是异步请求数据的方法。在不重新刷新页面的情况下与服务器通信，交换数据，或更新页面。</p><h1 id="XMLHttpRequest对象"><a href="#XMLHttpRequest对象" class="headerlink" title="XMLHttpRequest对象"></a>XMLHttpRequest对象</h1><p>优点：</p><ul><li>不重新加载页面的情况下更新网页</li><li>在页面已加载后从服务器请求/接收数据</li><li>在后台向服务器发送数据</li></ul><p>缺点：</p><ul><li>使用起来也比较繁琐，需要设置很多值。</li><li>早期的IE浏览器有自己的实现，这样需要写兼容代码。</li></ul><p>示例：</p><pre><code>if (window.XMLHttpRequest) { // model browser  xhr = new XMLHttpRequest()} else if (window.ActiveXObject) { // IE 6 and older  xhr = new ActiveXObject('Microsoft.XMLHTTP')}xhr.open('POST', url, true)xhr.send(data)xhr.onreadystatechange = function () {if (request.readyState === 4) { // 成功完成        // 判断响应状态码        if (request.status === 200) {            // 成功，通过responseText拿到响应的文本:            return success(request.responseText);        } else {            // 失败，根据响应码判断失败原因:            return fail(request.status);        }    } else {        // HTTP请求还在继续...    }}</code></pre><h1 id="jQuery-ajax"><a href="#jQuery-ajax" class="headerlink" title="jQuery ajax"></a>jQuery ajax</h1><p>AJAX请求也兼容了各浏览器，对XMLHttpRequest对象的封装。</p><p>优点：</p><ul><li>对原生XHR的封装，做了兼容处理，简化了使用。</li><li>增加了对JSONP的支持，可以简单处理部分跨域。</li></ul><p>缺点：</p><ul><li>如果有多个请求，并且有依赖关系的话，容易形成回调地狱。</li><li>本身是针对MVC的编程，不符合现在前端MVVM的浪潮。</li><li>ajax是jQuery中的一个方法。如果只是要使用ajax却要引入整个jQuery非常的不合理。</li></ul><p>示例：</p><pre><code>$.ajax({  type: 'POST',  url: url,   data: data,  dataType: dataType,  success: function () {},  error: function () {}})</code></pre><h1 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h1><p>Axios是一个基于promise的HTTP库，可以用在浏览器和 node.js 中。它本质也是对原生XMLHttpRequest的封装，只不过它是Promise的实现版本，符合最新的ES规范。</p><p>优点：</p><ul><li>从浏览器中创建XMLHttpRequests</li><li>从 node.js 创建 http 请求</li><li>支持 Promise API</li><li>拦截请求和响应</li><li>转换请求数据和响应数据</li><li>取消请求</li><li>自动转换 JSON 数据</li><li>客户端支持防御 XSRF</li></ul><p>缺点：</p><ul><li>只持现代代浏览器。</li></ul><pre><code>axios({    method: 'post',    url: '/user/12345',    data: {      firstName: 'liu',      lastName: 'weiqin'    }  })  .then(res =&gt; console.log(res))  .catch(err =&gt; console.log(err))</code></pre><h1 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h1><p>优点：</p><ul><li>语法简洁，更加语义化</li><li>基于标准 Promise 实现，支持 async/await</li></ul><p>缺点：</p><ul><li>Fetch 请求默认是不带 cookie 的，需要设置 fetch(url, {credentials: ‘include’})</li><li>服务器返回 400，500 错误码时并不会 reject，只有网络错误这些导致请求不能完成时，fetch 才会被 reject。</li></ul><p>示例：</p><pre><code>fetch('http://example.com/movies.json')  .then(function(response) {    return response.json();  })  .then(function(myJson) {    console.log(myJson);  });</code></pre><p>ts对fetch简单封装下：</p><pre><code>import _ from 'lodash';import 'whatwg-fetch';interface ReqInit extends RequestInit {  headers?: Record&lt;string, string&gt;;  /** eg. ?a=1 */  params?: { [key: string]: any };  /** eg. /:id/.. */  router?: { [key: string]: any };  /** 超时时间，默认3000 */  timeout?: number;}async function request&lt;T = any&gt;(path: string, init: ReqInit = {}): Promise&lt;T&gt; {  const mergeInit = {    ...request.default,    ...init,    headers: { ...request.default.headers, ...init.headers },  };  const { params, router, body, timeout, headers } = mergeInit;  let url = path;  if (router) {    url = path.replace(/:([A-Za-z]+)/g, (substring, p1: string) =&gt; router[p1]);  }  if (params) {    url += _(      _.reduce(params, (prev, val, key) =&gt; `${prev}${key}=${val}&amp;`, '?'),    ).trimEnd('&amp;');  }  if (!Reflect.get(headers, 'Content-Type')) {    if (typeof body === 'string') {      Reflect.set(headers, 'Content-Type', 'application/json');    }  }  try {    const response: Response = await Promise.race([      fetch(url, mergeInit),      new Promise&lt;any&gt;((resolve, reject) =&gt; {        setTimeout(          () =&gt; reject({ status: 408, statusText: 'TIME_OUT_ERR', url }),          timeout,        );      }),    ]);    if (response.ok) {      if (request.interceptors.response) {        return await request.interceptors.response(response);      }      return await response.json();    }    throw response;  } catch (error) {    if (request.interceptors.catch) {      request.interceptors.catch(error);    }    throw error;  }}request.default = {  method: 'GET',  headers: {    Accept: '*/*',  },  mode: 'cors',  timeout: 3000,  // credentials: 'include' // send cookies} as ReqInit;request.interceptors = {  response: null,  catch: null,} as {  response: ((response: Response) =&gt; Promise&lt;any&gt;) | null;  catch: ((error: Partial&lt;Response&gt;) =&gt; void) | null;};export default request;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据请求 </tag>
            
            <tag> 前端基础 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
