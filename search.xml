<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>前端权限管理</title>
      <link href="2021/01/05/qian-duan-quan-xian-guan-li/"/>
      <url>2021/01/05/qian-duan-quan-xian-guan-li/</url>
      
        <content type="html"><![CDATA[<h2 id="接口权限"><a href="#接口权限" class="headerlink" title="接口权限"></a>接口权限</h2><blockquote><p>接口权限目前一般采用==jwt==的形式来验证，没有通过的话一般返回401，跳转到登录页面重新进行登录。</p></blockquote><p>登录完拿到token，将token存起来，通过axios请求拦截器进行拦截，每次请求的时候头部携带token。</p><pre><code>axios.interceptors.request.use(config =&gt; {    config.headers['token'] = cookie.get('token')    return config})axios.interceptors.response.use(res=&gt;{},{response}=&gt;{    if (response.data.code === 40099 || response.data.code === 40098) { //token过期或者错误        router.push('/login')    }})</code></pre><h2 id="路由权限控制"><a href="#路由权限控制" class="headerlink" title="路由权限控制"></a>路由权限控制</h2><blockquote><p>用户登录后只能看到自己有权访问的导航菜单，也只能访问自己有权访问的路由地址，否则将跳转 4xx 提示页</p></blockquote><p>初始化即挂载全部路由，并且在路由上标记相应的权限信息，每次路由跳转前做校验。</p><pre><code>const routerMap = [  {    path: '/permission',    component: Layout,    redirect: '/permission/index',    alwaysShow: true, // will always show the root menu    meta: {      title: 'permission',      icon: 'lock',      roles: ['admin', 'editor'] // you can set roles in root nav    },    children: [{      path: 'page',      component: () =&gt; import('@/views/permission/page'),      name: 'pagePermission',      meta: {        title: 'pagePermission',        roles: ['admin'] // or you can only set roles in sub nav      }    }, {      path: 'directive',      component: () =&gt; import('@/views/permission/directive'),      name: 'directivePermission',      meta: {        title: 'directivePermission'        // if do not set roles, means: this page does not require permission      }    }]  }]</code></pre><p>登录后，获取用户的权限信息，然后筛选有权限访问的路由，在全局路由守卫里进行调用==addRoutes==添加路由</p><pre><code>import router from './router'import store from './store'import { Message } from 'element-ui'import NProgress from 'nprogress' // progress barimport 'nprogress/nprogress.css'// progress bar styleimport { getToken } from '@/utils/auth' // getToken from cookieNProgress.configure({ showSpinner: false })// NProgress Configuration// permission judge functionfunction hasPermission(roles, permissionRoles) {  if (roles.indexOf('admin') &gt;= 0) return true // admin permission passed directly  if (!permissionRoles) return true  return roles.some(role =&gt; permissionRoles.indexOf(role) &gt;= 0)}const whiteList = ['/login', '/authredirect']// no redirect whitelistrouter.beforeEach((to, from, next) =&gt; {  NProgress.start() // start progress bar  if (getToken()) { // determine if there has token    /* has token*/    if (to.path === '/login') {      next({ path: '/' })      NProgress.done() // if current page is dashboard will not trigger afterEach hook, so manually handle it    } else {      if (store.getters.roles.length === 0) { // 判断当前用户是否已拉取完user_info信息        store.dispatch('GetUserInfo').then(res =&gt; { // 拉取user_info          const roles = res.data.roles // note: roles must be a array! such as: ['editor','develop']          store.dispatch('GenerateRoutes', { roles }).then(() =&gt; { // 根据roles权限生成可访问的路由表            router.addRoutes(store.getters.addRouters) // 动态添加可访问路由表            next({ ...to, replace: true }) // hack方法 确保addRoutes已完成 ,set the replace: true so the navigation will not leave a history record          })        }).catch((err) =&gt; {          store.dispatch('FedLogOut').then(() =&gt; {            Message.error(err || 'Verification failed, please login again')            next({ path: '/' })          })        })      } else {        // 没有动态改变权限的需求可直接next() 删除下方权限判断 ↓        if (hasPermission(store.getters.roles, to.meta.roles)) {          next()//        } else {          next({ path: '/401', replace: true, query: { noGoBack: true }})        }        // 可删 ↑      }    }  } else {    /* has no token*/    if (whiteList.indexOf(to.path) !== -1) { // 在免登录白名单，直接进入      next()    } else {      next('/login') // 否则全部重定向到登录页      NProgress.done() // if current page is login will not trigger afterEach hook, so manually handle it    }  }})router.afterEach(() =&gt; {  NProgress.done() // finish progress bar})</code></pre><p>按需挂载，路由就需要知道用户的路由权限，也就是在用户登录进来的时候就要知道当前用户拥有哪些路由权限</p><p>这种方式也存在了以下的缺点：</p><ul><li>全局路由守卫里，每次路由跳转都要做判断</li><li>菜单信息写死在前端，要改个显示文字或权限信息，需要重新编译</li><li>菜单跟路由耦合在一起，定义路由的时候还有添加菜单显示标题，图标之类的信息，而且路由不一定作为菜单显示，还要多加字段进行标识</li></ul><h2 id="菜单权限"><a href="#菜单权限" class="headerlink" title="菜单权限"></a>菜单权限</h2><p>菜单权限可以理解成将页面与路由进行解耦</p><h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h3><p>菜单与路由分离，菜单由后端返回<br>前端定义路由信息</p><pre><code>{    name: "login",    path: "/login",    component: () =&gt; import("@/pages/Login.vue")}</code></pre><p>name字段都不为空，需要根据此字段与后端返回菜单做关联，后端返回的菜单信息中必须要有name对应的字段，并且做唯一性校验</p><p>全局路由守卫里做判断</p><pre><code>function hasPermission(router, accessMenu) {  if (whiteList.indexOf(router.path) !== -1) {    return true;  }  let menu = Util.getMenuByName(router.name, accessMenu);  if (menu.name) {    return true;  }  return false;}Router.beforeEach(async (to, from, next) =&gt; {  if (getToken()) {    let userInfo = store.state.user.userInfo;    if (!userInfo.name) {      try {        await store.dispatch("GetUserInfo")        await store.dispatch('updateAccessMenu')        if (to.path === '/login') {          next({ name: 'home_index' })        } else {          //Util.toDefaultPage([...routers], to.name, router, next);          next({ ...to, replace: true })//菜单权限更新完成,重新进一次当前路由        }      }        catch (e) {        if (whiteList.indexOf(to.path) !== -1) { // 在免登录白名单，直接进入          next()        } else {          next('/login')        }      }    } else {      if (to.path === '/login') {        next({ name: 'home_index' })      } else {        if (hasPermission(to, store.getters.accessMenu)) {          Util.toDefaultPage(store.getters.accessMenu,to, routes, next);        } else {          next({ path: '/403',replace:true })        }      }    }  } else {    if (whiteList.indexOf(to.path) !== -1) { // 在免登录白名单，直接进入      next()    } else {      next('/login')    }  }  let menu = Util.getMenuByName(to.name, store.getters.accessMenu);  Util.title(menu.title);});Router.afterEach((to) =&gt; {  window.scrollTo(0, 0);});</code></pre><p>每次路由跳转的时候都要判断权限，这里的判断也很简单，因为菜单的name与路由的name是一一对应的，而后端返回的菜单就已经是经过权限过滤的。</p><p>如果根据路由name找不到对应的菜单，就表示用户有没权限访问。</p><p>如果路由很多，可以在应用初始化的时候，只挂载不需要权限控制的路由。取得后端返回的菜单后，根据菜单与路由的对应关系，筛选出可访问的路由，通过==addRoutes==动态挂载。</p><p>这种方式的缺点：</p><ul><li>菜单需要与路由做一一对应，前端添加了新功能，需要通过菜单管理功能添加新的菜单，如果菜单配置的不对会导致应用不能正常使用</li><li>全局路由守卫里，每次路由跳转都要做判断</li></ul><h3 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h3><p>菜单和路由都由后端返回，<br>前端统一定义路由组件。</p><pre><code>const Home = () =&gt; import("../pages/Home.vue");const UserInfo = () =&gt; import("../pages/UserInfo.vue");export default {    home: Home,    userInfo: UserInfo};</code></pre><p>后端路由组件返回以下格式</p><pre><code>[    {        name: "home",        path: "/",        component: "home"    },    {        name: "home",        path: "/userinfo",        component: "userInfo"    }]</code></pre><p>在将后端返回路由通过addRoutes动态挂载之间，需要将数据处理一下，将component字段换为真正的组件<br>如果有嵌套路由，后端功能设计的时候，要注意添加相应的字段，前端拿到数据也要做相应的处理。</p><p>这种方法也会存在缺点：</p><ul><li>全局路由守卫里，每次路由跳转都要做判断</li><li>前后端的配合要求更高</li></ul><h2 id="按钮权限"><a href="#按钮权限" class="headerlink" title="按钮权限"></a>按钮权限</h2><h3 id="方案一-1"><a href="#方案一-1" class="headerlink" title="方案一"></a>方案一</h3><p>按钮权限也可以用v-if判断<br>但是如果页面过多，每个页面页面都要获取用户权限role和路由表里的meta.btnPermissions，然后再做判断<br>这种方式就不展开举例了</p><h3 id="方案二-1"><a href="#方案二-1" class="headerlink" title="方案二"></a>方案二</h3><blockquote><p>通过自定义指令进行按钮权限的判断</p></blockquote><p>首先配置路由</p><pre><code>{    path: '/permission',    component: Layout,    name: '权限测试',    meta: {        btnPermissions: ['admin', 'supper', 'normal']    },    //页面需要的权限    children: [{        path: 'supper',        component: _import('system/supper'),        name: '权限测试页',        meta: {            btnPermissions: ['admin', 'supper']        } //页面需要的权限    },    {        path: 'normal',        component: _import('system/normal'),        name: '权限测试页',        meta: {            btnPermissions: ['admin']        } //页面需要的权限    }]}</code></pre><p>自定义权限鉴定指令</p><pre><code>import Vue from 'vue'/**权限指令**/const has = Vue.directive('has', {    bind: function (el, binding, vnode) {        // 获取页面按钮权限        let btnPermissionsArr = [];        if(binding.value){            // 如果指令传值，获取指令参数，根据指令参数和当前登录人按钮权限做比较。            btnPermissionsArr = Array.of(binding.value);        }else{            // 否则获取路由中的参数，根据路由的btnPermissionsArr和当前登录人按钮权限做比较。            btnPermissionsArr = vnode.context.$route.meta.btnPermissions;        }        if (!Vue.prototype.$_has(btnPermissionsArr)) {            el.parentNode.removeChild(el);        }    }});// 权限检查方法Vue.prototype.$_has = function (value) {    let isExist = false;    // 获取用户按钮权限    let btnPermissionsStr = sessionStorage.getItem("btnPermissions");    if (btnPermissionsStr == undefined || btnPermissionsStr == null) {        return false;    }    if (value.indexOf(btnPermissionsStr) &gt; -1) {        isExist = true;    }    return isExist;};export {has}</code></pre><p>在使用的按钮中只需要引用v-has指令</p><pre><code>&lt;el-button @click='editClick' type="primary" v-has&gt;编辑&lt;/el-button&gt;</code></pre><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>关于权限如何选择哪种合适的方案，可以根据自己项目的方案项目，如考虑路由与菜单是否分离<br>权限需要前后端结合，前端尽可能的去控制，更多的需要后台判断</p>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> 项目总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx超时设置</title>
      <link href="2020/12/16/nginx-chao-shi-she-zhi/"/>
      <url>2020/12/16/nginx-chao-shi-she-zhi/</url>
      
        <content type="html"><![CDATA[<p>nginx访问出现504 Gateway Time-out，一般是由于程序执行时间过长导致响应超时，例如程序需要执行90秒，而nginx最大响应等待时间为30秒，这样就会出现超时。</p><h2 id="导致超时的场景"><a href="#导致超时的场景" class="headerlink" title="导致超时的场景"></a>导致超时的场景</h2><ol><li>程序在处理大量数据，导致等待超时。</li><li>程序中调用外部请求，而外部请求响应超时。</li><li>连接数据库失败而没有停止，死循环重新连。</li></ol><h2 id="nginx常用的超时配置说明"><a href="#nginx常用的超时配置说明" class="headerlink" title="nginx常用的超时配置说明"></a>nginx常用的超时配置说明</h2><h3 id="client-header-timeout"><a href="#client-header-timeout" class="headerlink" title="client_header_timeout"></a>client_header_timeout</h3><p>语法 client_header_timeout time<br>默认值 60s<br>上下文 http server<br>说明 指定等待client发送一个请求头的超时时间（例如：GET / HTTP/1.1）.仅当在一次read中，没有收到请求头，才会算成超时。如果在超时时间内，client没发送任何东西，nginx返回HTTP状态码408(“Request timed out”)</p><h3 id="client-body-timeout"><a href="#client-body-timeout" class="headerlink" title="client_body_timeout"></a>client_body_timeout</h3><p>语法 client_body_timeout time<br>默认值 60s<br>上下文 http server location<br>说明 该指令设置请求体（request body）的读超时时间。仅当在一次readstep中，没有得到请求体，就会设为超时。超时后，nginx返回HTTP状态码408(“Request timed out”)</p><h3 id="keepalive-timeout"><a href="#keepalive-timeout" class="headerlink" title="keepalive_timeout"></a>keepalive_timeout</h3><p>语法 keepalive_timeout timeout [ header_timeout ]<br>默认值 75s<br>上下文 http server location<br>说明 第一个参数指定了与client的keep-alive连接超时时间。服务器将会在这个时间后关闭连接。可选的第二个参数指定了在响应头Keep-Alive: timeout=time中的time值。这个头能够让一些浏览器主动关闭连接，这样服务器就不必要去关闭连接了。没有这个参数，nginx不会发送Keep-Alive响应头（尽管并不是由这个头来决定连接是否“keep-alive”）<br>两个参数的值可并不相同</p><p>注意不同浏览器怎么处理“keep-alive”头<br>MSIE和Opera忽略掉”Keep-Alive: timeout=<n>“ header.<br>MSIE保持连接大约60-65秒，然后发送TCP RST<br>Opera永久保持长连接<br>Mozilla keeps the connection alive for N plus about 1-10 seconds.<br>Konqueror保持长连接N秒</n></p><h3 id="lingering-timeout"><a href="#lingering-timeout" class="headerlink" title="lingering_timeout"></a>lingering_timeout</h3><p>语法 lingering_timeout time<br>默认值 5s<br>上下文 http server location<br>说明 lingering_close生效后，在关闭连接前，会检测是否有用户发送的数据到达服务器，如果超过lingering_timeout时间后还没有数据可读，就直接关闭连接；否则，必须在读取完连接缓冲区上的数据并丢弃掉后才会关闭连接。</p><h3 id="resolver-timeout"><a href="#resolver-timeout" class="headerlink" title="resolver_timeout"></a>resolver_timeout</h3><p>语法 resolver_timeout time<br>默认值 30s<br>上下文 http server location<br>说明 该指令设置DNS解析超时时间</p><h3 id="proxy-connect-timeout"><a href="#proxy-connect-timeout" class="headerlink" title="proxy_connect_timeout"></a>proxy_connect_timeout</h3><p>语法 proxy_connect_timeout time<br>默认值 60s<br>上下文 http server location<br>说明 该指令设置与upstream server的连接超时时间，有必要记住，这个超时不能超过75秒。<br>这个不是等待后端返回页面的时间，那是由proxy_read_timeout声明的。如果你的upstream服务器起来了，但是hanging住了（例如，没有足够的线程处理请求，所以把你的请求放到请求池里稍后处理），那么这个声明是没有用的，由于与upstream服务器的连接已经建立了。</p><h3 id="proxy-read-timeout"><a href="#proxy-read-timeout" class="headerlink" title="proxy_read_timeout"></a>proxy_read_timeout</h3><p>语法 proxy_read_timeout time<br>默认值 60s<br>上下文 http server location<br>说明 该指令设置与代理服务器的读超时时间。它决定了nginx会等待多长时间来获得请求的响应。这个时间不是获得整个response的时间，而是两次reading操作的时间。</p><h3 id="proxy-send-timeout"><a href="#proxy-send-timeout" class="headerlink" title="proxy_send_timeout"></a>proxy_send_timeout</h3><p>语法 proxy_send_timeout time<br>默认值 60s<br>上下文 http server location<br>说明 这个指定设置了发送请求给upstream服务器的超时时间。超时设置不是为了整个发送期间，而是在两次write操作期间。如果超时后，upstream没有收到新的数据，nginx会关闭连接</p><h3 id="proxy-upstream-fail-timeout（fail-timeout）"><a href="#proxy-upstream-fail-timeout（fail-timeout）" class="headerlink" title="proxy_upstream_fail_timeout（fail_timeout）"></a>proxy_upstream_fail_timeout（fail_timeout）</h3><p>语法 server address [fail_timeout=30s]<br>默认值 10s<br>上下文 upstream<br>说明 Upstream模块下 server指令的参数，设置了某一个upstream后端失败了指定次数（max_fails）后，该后端不可操作的时间，默认为10秒</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="请求超时"><a href="#请求超时" class="headerlink" title="请求超时"></a>请求超时</h3><pre><code>http {    include       mime.types;    server_names_hash_bucket_size  512;         default_type  application/octet-stream;    sendfile        on;    keepalive_timeout  65;  #保持    tcp_nodelay on;    client_header_timeout 15;    client_body_timeout 15;    send_timeout 25;    include vhosts/*.conf;}</code></pre><h3 id="后端服务器处理请求的时间设置"><a href="#后端服务器处理请求的时间设置" class="headerlink" title="后端服务器处理请求的时间设置"></a>后端服务器处理请求的时间设置</h3><p>如果只集成了一台nginx机器不用设置</p><pre><code>location / {        ...        proxy_read_timeout 150;  # 秒        ...    }</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack基础04-文件指纹策略</title>
      <link href="2020/12/11/webpack-ji-chu-04-wen-jian-zhi-wen-ce-lue/"/>
      <url>2020/12/11/webpack-ji-chu-04-wen-jian-zhi-wen-ce-lue/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>webpack的指纹策略是通过给文件加上hash后缀，做到当代码有修改时打包出来的文件后缀也会修改，从而可以把静态资源开启持久缓存，这样每次有更新的代码打包后生成的都是新的问题件，从而最大程度上使用缓存。</p><h2 id="文件指纹类型"><a href="#文件指纹类型" class="headerlink" title="文件指纹类型"></a>文件指纹类型</h2><p>webpack提供了三种hash类似</p><h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><p>和整个项目构建相关，只要一个文件有修改，整个项目的hash值就会改变。<br>例如</p><pre><code>// webpack.prod.jsentry: {    index: "./src/index",        search: "./src/search"},output: {    path: path.join(__dirname, "dist"),    filename: "[name]_[hash:8].js",    publicPath: "./dist"}</code></pre><p>它的问题是当项目有多入口或者使用code spliting，只要有一个文件修改打包的生成的js代码hash都会改变。不利于缓存。</p><h3 id="chunkhash"><a href="#chunkhash" class="headerlink" title="chunkhash"></a>chunkhash</h3><p>模块的hash，根据模块的修改才改变对应的hash值。<br>根据不同的入口文件(Entry)进行依赖文件解析、构建对应的chunk，生成对应的哈希值。我们在生产环境里把一些公共库和程序入口文件区分开，单独打包构建，接着我们采用chunkhash的方式生成哈希值，那么只要我们不改动公共库的代码，就可以保证其哈希值不会受影响</p><pre><code>output: {    path: path.resolve(__dirname, 'dist'),    filename: '[name]_[chunkhash:8].js'},</code></pre><h3 id="contenthash"><a href="#contenthash" class="headerlink" title="contenthash"></a>contenthash</h3><p>据文件内容来定义 hash ，文件内容不变，则 contenthash 不变。</p><p>某个页面既有js资源，又有css资源。如果css资源也使用Chunkhash。如果修改了js。由于css资源使用了Chunkhash，就会导致css内容没有变化，发布上线的文件却发生了变化。因此，通常对css资源使用Contenthash。这个时候可以使用mini-css-extract-plugin里的contenthash值，保证即使css文件所处的模块里就算其他文件内容改变，只要css文件内容不变，那么不会重复构建</p><pre><code>module.exports = {    entry: {        app: './src/app.js',        search: './src/search.js'    },    output: {        filename: '[name][chunkhash:8].js',        path: __dirname + '/dist'    },    plugins: [        new MiniCssExtractPlugin({            filename: `[name][contenthash:8].css`        }),    ]};</code></pre><h3 id="图片，字体文件的文件指纹设置"><a href="#图片，字体文件的文件指纹设置" class="headerlink" title="图片，字体文件的文件指纹设置"></a>图片，字体文件的文件指纹设置</h3><p>设置 file-loader（或url-loader） 的 name，使用 [hash]<br>图片，字体文件的hash和css/js资源的hash概念不一样，图片，字体文件的hash是由内容决定的</p><pre><code>{    test: /\.(png|svg|jpg|gif)$/,    use: [{        loader: 'file-loader',        options: {            name: 'img/[name][hash:8].[ext] '        }    }]}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack基础03-文件监听</title>
      <link href="2020/12/10/webpack-ji-chu-03-wen-jian-jian-ting/"/>
      <url>2020/12/10/webpack-ji-chu-03-wen-jian-jian-ting/</url>
      
        <content type="html"><![CDATA[<p>文件监听是指发现源码改变，自动重新构建出新的输出文件。</p><h2 id="webpack文件监听方式"><a href="#webpack文件监听方式" class="headerlink" title="webpack文件监听方式"></a>webpack文件监听方式</h2><p>webpack开启文件监听的方式有两种：</p><ol><li>启动webpack时带上 –watch参数,但是需要手动刷新浏览器</li></ol><pre><code>"scripts": {    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1",    "build": "webpack",    "watch": "webpack --watch"  },</code></pre><p>唯一缺点需要手动刷新浏览器。</p><ol start="2"><li>在配置webpack.config.js中设置watch:true</li></ol><pre><code>module.export = {        // 默认false也就是不开启        watch: true，        watchOptions: {            // 监听到数据变化后延迟600毫秒            aggregateTimeout: 600,            // 监听大量文件会导致大量的 CPU 或内存占用。可以使用正则排除            ignored: /node_modules/,            // 指定毫秒为单位进行轮询,每一秒检查一次变动            poll:1000        }    }</code></pre><h2 id="文件监听原理分析"><a href="#文件监听原理分析" class="headerlink" title="文件监听原理分析"></a>文件监听原理分析</h2><p>在webpack中监听一个文件发生变化的原理是定时的去获取这个文件的最后编辑时间，每次都存下最新的最后编辑时间，如果发现当前获取的和最后一次保存的最后编辑时间不一致，就认为该文件发生了变化。配置项中的watchOptions.poll就是用于控制定时检查的周期，具体含义是检查多少次。</p><p>当发现某个文件发生了变化，并不会立刻告诉监听者，而是先换成起来，收集一段时间的变化后，再一次性告诉监听者，配置项中的watchOptions.aggregateTimeout就是用于配置这个等待时间。这样做的目的是因为我们在编辑代码的过程中可能会高频的输入文字导致文件变化的事件高频的发生，如果每次都重新执行构建就会让构建卡死。</p><h2 id="热更新方式和原因"><a href="#热更新方式和原因" class="headerlink" title="热更新方式和原因"></a>热更新方式和原因</h2><h3 id="热更新的两种方式"><a href="#热更新的两种方式" class="headerlink" title="热更新的两种方式"></a>热更新的两种方式</h3><ol><li>webpack-dev-server</li></ol><p>wds 通常与 HotModuleReplacementPlugin插件一起使用，wds的一个比较大的优势是，它没有磁盘的io,输出完之后放到内存中，而不是输出为文件，所以构建速度会有一个较大的优势。</p><pre><code>const webpack = require('webpack')module.exports = {  devServer: {    // 开启 HMR 特性    hot: true  },  plugins: [    // HMR 特性所需要的插件    new webpack.HotModuleReplacementPlugin()  ]}</code></pre><ol start="2"><li>webpack-dev-middleware</li></ol><p>WDM 将 webpack 输出的文件传输给服务器,使用于灵活的定制场景。</p><pre><code>const express = require('express');const webpack = require('webpack');const webpackDevMiddleware = require('webpack-dev-middleware');const app = express();const config = require('./webpack.config.js');const compiler = webpack(config);app.use(webpackDevMiddleware(compiler,{    publicPath: config.output.publicPath}));app.listen(3000,function(){    console.log('Example app listening on post 3000\n')})</code></pre><h3 id="热更新原理"><a href="#热更新原理" class="headerlink" title="热更新原理"></a>热更新原理</h3><ul><li>Webpack Compile: 将JS编译成Bundle</li><li>HMR Server： 将热更新的文件输出给HMR Runtime</li><li>Bundle server: 提供文件在浏览器的访问</li><li>HMR Runtime: 会被注入到浏览器，更新文件的变化</li><li>bundle.js 构建输出的文件</li></ul><p><img src="https://7.dusays.com/2020/12/11/04a511854b09e.png"></p>]]></content>
      
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack基础02-静态资源处理</title>
      <link href="2020/12/08/webpack-ji-chu-02-jing-tai-zi-yuan-chu-li/"/>
      <url>2020/12/08/webpack-ji-chu-02-jing-tai-zi-yuan-chu-li/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文主要讲述样式文件，图片和字体资源的解析，html,css,js的压缩</p></blockquote><h2 id="解析css-sass-less"><a href="#解析css-sass-less" class="headerlink" title="解析css,sass,less"></a>解析css,sass,less</h2><p>css-loader: 用于加载.css文件，并且转换成commomjs对象<br>style-loader: 将样式通过<style>标签插入到head中<br>less-loader:将less转换成css</p><pre><code>module: &#123;        rules: [            &#123;                 test: /\.css$/,                 use: [                    &#39;style-loader&#39;,                    &#39;css-loader&#39;                ]            &#125;,            &#123;                 test: /\.less$/,                 use: [                    &#39;style-loader&#39;,                    &#39;css-loader&#39;,                    &#39;less-loader&#39;                ]            &#125;        ]    &#125;</code></pre><h2 id="图片和字体资源解析"><a href="#图片和字体资源解析" class="headerlink" title="图片和字体资源解析"></a>图片和字体资源解析</h2><p>file-loader: 用于处理图片和字体</p><pre><code>module: &#123;        rules: [            &#123;                 test: /\.(png|svg|jpg|gif)$/,                 use: [                    &#39;file-loader&#39;                ]            &#125;,            &#123;                 test: /\.(woff|woff2|eot|otf)$/,                 use: [                    &#39;file-loader&#39;                ]            &#125;        ]    &#125;</code></pre><p>url-loader： 也可以处理图片和字体，可以设置较小资源自动base64。</p><pre><code>module: &#123;        rules: [            &#123;                 test: /\.(png|svg|jpg|gif)$/,                 use: [&#123;                        loader: &#39;url-loader&#39;,                        options: &#123;                            limit: 10240                        &#125;                    &#125;]            &#125;        ]    &#125;</code></pre><h2 id="html压缩"><a href="#html压缩" class="headerlink" title="html压缩"></a>html压缩</h2><p>html的压缩用’html-webpack-plugin’这个插件。</p><pre><code>const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);module.exports = &#123;    ...    plugins: [        new HtmlWebpackPlugin(&#123;        title: &#39;Custom template&#39;,        template: &#39;./src/index.html&#39;, //指定要打包的html路径和文件名        filename:&#39;../index.html&#39; //指定输出路径和文件名      &#125;),    ]</code></pre><h2 id="js文件压缩、"><a href="#js文件压缩、" class="headerlink" title="js文件压缩、"></a>js文件压缩、</h2><p>webpack 4之前的版本是通过webpack.optimize.CommonsChunkPlugin来压缩js，webpack 4版本之后被移除了，<br>webpack4内置了uglifyjs-webpack-plugin这个插件，所以默认打包后js已经压缩了。</p><pre><code>var UglifyJsPlugin = require(&#39;uglifyjs-webpack-plugin&#39;)var OptimizeCssAssetsPlugin = require(&#39;optimize-css-assets-webpack-plugin&#39;)module.exports = &#123;  optimization: &#123;    minimizer: [      // 自定义js优化配置，将会覆盖默认配置      new UglifyJsPlugin(&#123;        exclude: /\.min\.js$/, // 过滤掉以&quot;.min.js&quot;结尾的文件，我们认为这个后缀本身就是已经压缩好的代码，没必要进行二次压缩        cache: true,        parallel: true, // 开启并行压缩，充分利用cpu        sourceMap: false,        extractComments: false, // 移除注释        uglifyOptions: &#123;          compress: &#123;            unused: true,            warnings: false,            drop_debugger: true          &#125;,          output: &#123;            comments: false          &#125;        &#125;      &#125;),      // 用于优化css文件      new OptimizeCssAssetsPlugin(&#123;        assetNameRegExp: /\.css$/g,        cssProcessorOptions: &#123;          safe: true,          autoprefixer: &#123; disable: true &#125;,           discardComments: &#123;            removeAll: true // 移除注释          &#125;        &#125;,        canPrint: true      &#125;)    ]  &#125;&#125;</code></pre><h2 id="css压缩"><a href="#css压缩" class="headerlink" title="css压缩"></a>css压缩</h2><p>css-loader在1.0以上版本没有了压缩配置，webpage4常用css压缩插件是’optimize-css-assets-webpack-plugin’，<br>需要配合安装css处理器’cssnano’。</p><pre><code>const optimizeCss = require(&#39;optimize-css-assets-webpack-plugin&#39;);module.exports = &#123;    .....,    //    plugins: [        new optimizeCss(&#123;            assetNameRegExp: /\.style\.css$/g,            cssProcessor: require(&#39;cssnano&#39;),            cssProcessorOptions: &#123; discardComments: &#123; removeAll: true &#125; &#125;,            canPrint: true        &#125;),    ],&#125;</code></pre><h2 id="补齐css3前缀"><a href="#补齐css3前缀" class="headerlink" title="补齐css3前缀"></a>补齐css3前缀</h2><p>利用postcss-loader和autoperfixer这两个插件</p><pre><code>&#123;  test: /\.css$/,  use: [    &#39;style-loader&#39;,    &#39;css-loader&#39;,    &#123;      loader: &#39;postcss-loader&#39;,      options: &#123;        plugins: [          require(&#39;autoprefixer&#39;)        ]      &#125;    &#125;  ]&#125;</code></pre><h2 id="移动端中rem转换"><a href="#移动端中rem转换" class="headerlink" title="移动端中rem转换"></a>移动端中rem转换</h2><p>使用px2rem-loader + lib-flexiable</p><pre><code>&#123;  test: /\.css$/,  use: [    &#39;style-loader&#39;,    &#39;css-loader&#39;,    &#39;less-loader&#39;,    &#123;      loader: &#39;px2rem-loader&#39;,      options: &#123;        remUnit: 75,//这是rem适配的配置  注意： remUnit在这里要根据lib-flexible的规则来配制，如果您的设计稿是750px的，用75就刚刚好。        remPrecision: 8      &#125;    &#125;  ]&#125;</code></pre></style></p>]]></content>
      
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack基础01-核心概念</title>
      <link href="2020/12/06/webpack-ji-chu-01-he-xin-gai-nian/"/>
      <url>2020/12/06/webpack-ji-chu-01-he-xin-gai-nian/</url>
      
        <content type="html"><![CDATA[<h1 id="默认安装"><a href="#默认安装" class="headerlink" title="默认安装"></a>默认安装</h1><p>npm init -y</p><h2 id="安装webpack相关"><a href="#安装webpack相关" class="headerlink" title="安装webpack相关"></a>安装webpack相关</h2><p>npm install webpack webpack-cli –save-dev</p><h2 id="检查webpack版本-cd-node-modules-bin"><a href="#检查webpack版本-cd-node-modules-bin" class="headerlink" title="检查webpack版本 cd node_modules/.bin"></a>检查webpack版本 cd node_modules/.bin</h2><p>webpack -v</p><h2 id="通过npm-stript运行webpack-否则只能在-bin下面执行"><a href="#通过npm-stript运行webpack-否则只能在-bin下面执行" class="headerlink" title="通过npm stript运行webpack,否则只能在.bin下面执行"></a>通过npm stript运行webpack,否则只能在.bin下面执行</h2><pre><code>package.json中添加 **build": "webpack"**</code></pre><h1 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h1><h2 id="entry"><a href="#entry" class="headerlink" title="entry"></a>entry</h2><p>entry是webpack打包文件的入口。入口可以设置多个，比如多页面应用。两者的写法有差异，但入口接收一个字符串，多入口写成对象的形式。</p><h3 id="单入口写法"><a href="#单入口写法" class="headerlink" title="单入口写法"></a>单入口写法</h3><pre><code>module.exports = {    entry: "./path/to/my/entry/file.js"}</code></pre><h3 id="多入口写法"><a href="#多入口写法" class="headerlink" title="多入口写法"></a>多入口写法</h3><pre><code>module.exports = {    entry: {        app: './src/app.js',        adminApp: './src/adminApp.js'    }}</code></pre><h2 id="output"><a href="#output" class="headerlink" title="output"></a>output</h2><p>output用来指定打包输出。多个文件的时候通过占位符做区分 ，比如[name]。</p><pre><code>module.exports = {    output: {        filename: '[name].js',        path: __dirname + '/dist/    }}</code></pre><h2 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h2><p>webpack原生只支持js,json两种文件类型，通过loader去支持其他文件类型并把他们转化成有效的模块，并添加到依赖图中。</p><p>本身是一个函数，接受源文件作为参数，返回转换的结果。</p><h3 id="常见的loader"><a href="#常见的loader" class="headerlink" title="常见的loader"></a>常见的loader</h3><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>babel-loader</td><td>转换ES6等新特性语法</td></tr><tr><td>css-loader</td><td>.css文件的加载和解析</td></tr><tr><td>less-loader</td><td>将less文件转为css</td></tr><tr><td>ts-loader</td><td>将TS转为js</td></tr><tr><td>file-loader</td><td>进行字体，图片的打包</td></tr><tr><td>raw-loader</td><td>将文件以字符串的形式导入</td></tr><tr><td>thread-loader</td><td>多线程打包css，js</td></tr></tbody></table><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>放在module中，test用来指定匹配规则，use指定使用的loader名称</p><pre><code>module: {        rules: [            { test: /\.txt$/, use: 'raw-loader'}        ]    }</code></pre><h2 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h2><p>插件用于bundle文件的优化，资源管理，环境变量的注入，作用于整个构建过程。loader没法做的事情，都是plugins来完成。</p><h3 id="常见的plugins"><a href="#常见的plugins" class="headerlink" title="常见的plugins"></a>常见的plugins</h3><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>html-webpack-plugin</td><td>创建html文件去承载输出的bundle</td></tr><tr><td>clean-webpack-plugin</td><td>用于在打包前清理上一次项目生成的 bundle 文件</td></tr><tr><td>splitChunks</td><td>提取被重复引入的文件，单独生成一个或多个文件，这样避免在多入口重复打包文件（替换CommonsChunkPlugin）</td></tr><tr><td>copy-webpack-plugin</td><td>将文件或文件夹拷贝到构建的输出目录</td></tr><tr><td>extract-text-webpack-plugin</td><td>抽离 css 样式,防止将样式打包在 js 中引起页面样式加载错乱的现象</td></tr><tr><td>UglifyJsPlugin</td><td>压缩js</td></tr><tr><td>ZipWebpackPlugin</td><td>将打包的出的资源生成一个zip包</td></tr><tr><td>MiniCssExtractPlugin</td><td>提取 JS 中引入的 CSS 打包到单独文件中，然后通过标签 <link>添加到头部</td></tr></tbody></table><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><p>放在plugins数组中：</p><pre><code>plugins: [        //moment这个库中，如果引用了./locale/目录的内容，就忽略掉，不会打包进去        new Webpack.IgnorePlugin(/\.\/locale/, /moment/),    ]</code></pre><h2 id="mode"><a href="#mode" class="headerlink" title="mode"></a>mode</h2><p>用来指定当前node的构建环境，有三种类型的值:production,development,none。(webpack4)<br>可用webpack内置函数来设置。</p><h3 id="选项描述"><a href="#选项描述" class="headerlink" title="选项描述"></a>选项描述</h3><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>development</td><td>会将 DefinePlugin 中 process.env.NODE_ENV 的值设置为 development。启用 NamedChunksPlugin 和 NamedModulesPlugin</td></tr><tr><td>production</td><td>会将 DefinePlugin 中 process.env.NODE_ENV 的值设置为 production。启用 FlagDependencyUsagePlugin, FlagIncludedChunksPlugin, ModuleConcatenationPlugin, NoEmitOnErrorsPlugin, OccurrenceOrderPlugin, SideEffectsFlagPlugin 和 TerserPlugin。</td></tr><tr><td>none</td><td>不开启任何优化选项</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>this指向</title>
      <link href="2020/11/25/this-zhi-xiang/"/>
      <url>2020/11/25/this-zhi-xiang/</url>
      
        <content type="html"><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p><code>this</code> 既不指向函数自身也不指向函数的作用域，在函数真正被调用执行的时候确定的，函数定义的时候确定不了。</p><ol><li><code>this</code>的指向，<strong>是在函数被调用的时候确定的</strong>，也就是执行上下文被创建时确定的；</li><li><code>this</code> 的指向和函数声明的位置没有任何关系，只取决于函数的调用位置（也即由谁、在什么地方调用这个函数）；</li><li>正因为在执行上下文的创建阶段<code>this</code>的指向就已经被确定了，在执行阶段<code>this</code>指向不可再被更改。</li></ol><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>    a<span class="token punctuation">:</span> <span class="token string">"1891"</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span> <span class="token operator">=</span> obj<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//报错，因为在执行阶段试图修改this的指向</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h1 id="this的指向规则"><a href="#this的指向规则" class="headerlink" title="this的指向规则"></a>this的指向规则</h1><h2 id="默认指向"><a href="#默认指向" class="headerlink" title="默认指向"></a>默认指向</h2><h3 id="独立函数调用"><a href="#独立函数调用" class="headerlink" title="独立函数调用"></a>独立函数调用</h3><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// this指向全局对象</span><span class="token punctuation">}</span><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//>> 2</span></code></pre><p>对于<strong>默认指向</strong>来说，决定<code>this</code>指向对象的并不是<strong>调用位置</strong>是否处于严格模式，而是函数体是否处于严格模式。如果函数体处于严格模式，<code>this</code>会指向<code>undefined</code>，否则<code>this</code>会指向全局对象。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token string">"use strict"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//函数体处于严格模式下，this指向undefined</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token string">"1891"</span><span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//>> 报错</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token string">"1891"</span><span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token string">"use strict"</span><span class="token punctuation">;</span>  <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//>> 1891</span>  <span class="token comment" spellcheck="true">//这里输出 1891 而不是报错，是因为严格模式下，this的指向与func的调用位置无关</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="SetTimeout或SetInterval中的this指向"><a href="#SetTimeout或SetInterval中的this指向" class="headerlink" title="SetTimeout或SetInterval中的this指向"></a>SetTimeout或SetInterval中的this指向</h3><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Obj</span> <span class="token punctuation">{</span>    <span class="token function">constructor</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>num <span class="token operator">=</span> num<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"setTimeout:"</span><span class="token operator">+</span><span class="token keyword">this</span><span class="token punctuation">.</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token function">func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Obj</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>obj<span class="token punctuation">.</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//>> 1　             输出的是obj.num</span>obj<span class="token punctuation">.</span><span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//>> setTimeout:0　  输出的是window.num</span>obj<span class="token punctuation">.</span><span class="token function">func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//>> 0 0 0 0 ……　    输出的是window.num</span></code></pre><p>可以发现在setInterval和setTimeout中传入函数时，函数中的this会指向window对象。</p><h2 id="隐式指向"><a href="#隐式指向" class="headerlink" title="隐式指向"></a>隐式指向</h2><ol><li><p>如果一个函数中有this，这个函数有被上一级的对象所调用，那么this指向的就是上一级的对象。</p></li><li><p>如果一个函数中有this，这个函数中包含多个对象，尽管这个函数是被最外层的对象所调用，this指向的也只是它上一级的对象。</p></li></ol><pre class=" language-javaScript"><code class="language-javaScript">var o = {    a:10,    b:{        // a:12,        fn:function(){            console.log(this.a); //undefined        }    }}o.b.fn();</code></pre><p>尽管对象b中没有属性a，这个this指向的也是对象b，因为this只会指向它的上一级对象，不管这个对象中有没有this要的东西。</p><h2 id="隐式丢失"><a href="#隐式丢失" class="headerlink" title="隐式丢失"></a>隐式丢失</h2><pre class=" language-javaScript"><code class="language-javaScript">var o = {    a:10,    b:{        a:12,        fn:function(){            console.log(this.a); //undefined            console.log(this); //window        }    }}var j = o.b.fn;j();   //this指向window</code></pre><p>这里this指向的是window,this永远指向的是最后调用它的对象。</p><p><strong>隐式丢失最容易在赋值时发生</strong>；隐式丢失发生时，调用这个函数会应用<strong>默认指向规则</strong>。下面再举一段更具迷惑性的例子：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token keyword">var</span> o <span class="token operator">=</span> <span class="token punctuation">{</span> a<span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">,</span> func<span class="token punctuation">:</span> func <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">var</span> p <span class="token operator">=</span> <span class="token punctuation">{</span> a<span class="token punctuation">:</span> <span class="token number">4</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>o<span class="token punctuation">.</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//>> 3</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>func <span class="token operator">=</span> o<span class="token punctuation">.</span>func<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//>> 2</span><span class="token comment" spellcheck="true">// 赋值表达式 p.func=o.func 的返回值是目标函数的引用，也就是 func 函数的引用</span><span class="token comment" spellcheck="true">// 因此调用位置是 func() 而不是 p.func() 或者 o.func()</span></code></pre><h2 id="显式指向"><a href="#显式指向" class="headerlink" title="显式指向"></a>显式指向</h2><p>JavaScript内置对象<code>Function</code>的三个原型方法<code>call()</code>、<code>apply()</code>和<code>bind()</code>，它们的第一个参数是一个对象，它们会把这个对象绑定到<code>this</code>，接着在调用函数时让<code>this</code>指向这个对象。</p><h3 id="call-apply-改变this的指向"><a href="#call-apply-改变this的指向" class="headerlink" title="call(),apply()改变this的指向"></a>call(),apply()改变this的指向</h3><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token string">"makai"</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>    a<span class="token punctuation">:</span><span class="token string">"coffe1891"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>func<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//>> coffe1891</span><span class="token comment" spellcheck="true">// 在调用 func 时强制把它的 this 绑定到 obj 上</span></code></pre><p>通过在call方法，给第一个参数添加要把b添加到哪个环境中，简单来说，this就会指向那个对象。</p><p>call方法除了第一个参数以外还可以添加多个参数，如下：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>    user<span class="token punctuation">:</span><span class="token string">"追梦子"</span><span class="token punctuation">,</span>    fn<span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span>ee<span class="token punctuation">)</span><span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//追梦子</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token operator">+</span>ee<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//3</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">var</span> b <span class="token operator">=</span> a<span class="token punctuation">.</span>fn<span class="token punctuation">;</span>b<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>注意如果call和apply的第一个参数写的是null，那么this指向的是window对象.</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>    user<span class="token punctuation">:</span><span class="token string">"追梦子"</span><span class="token punctuation">,</span>    fn<span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//Window {external: Object, chrome: Object, document: document, a: Object, speechSynthesis: SpeechSynthesis…}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">var</span> b <span class="token operator">=</span> a<span class="token punctuation">.</span>fn<span class="token punctuation">;</span>b<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="bind-改变this的指向"><a href="#bind-改变this的指向" class="headerlink" title="bind()改变this的指向"></a>bind()改变this的指向</h3><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>    user<span class="token punctuation">:</span><span class="token string">"追梦子"</span><span class="token punctuation">,</span>    fn<span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">var</span> b <span class="token operator">=</span> a<span class="token punctuation">.</span>fn<span class="token punctuation">;</span>b<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>我们发现代码没有被打印，对，这就是bind和call、apply方法的不同，实际上bind方法返回的是一个修改过后的函数。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>    user<span class="token punctuation">:</span><span class="token string">"追梦子"</span><span class="token punctuation">,</span>    fn<span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">var</span> b <span class="token operator">=</span> a<span class="token punctuation">.</span>fn<span class="token punctuation">;</span><span class="token keyword">var</span> c <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//function() { [native code] }</span></code></pre><p>那么我们现在执行一下函数c看看，能不能打印出对象a里面的user。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>    user<span class="token punctuation">:</span><span class="token string">"追梦子"</span><span class="token punctuation">,</span>    fn<span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//追梦子</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">var</span> b <span class="token operator">=</span> a<span class="token punctuation">.</span>fn<span class="token punctuation">;</span><span class="token keyword">var</span> c <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>同样bind也可以有多个参数，并且参数可以执行的时候再次添加，但是要注意的是，参数是按照形参的顺序进行的,且绑定在函数表达式上。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>    user<span class="token punctuation">:</span><span class="token string">"追梦子"</span><span class="token punctuation">,</span>    fn<span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span>d<span class="token punctuation">,</span>f<span class="token punctuation">)</span><span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//追梦子</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span>d<span class="token punctuation">,</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//10 1 2</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">var</span> b <span class="token operator">=</span> a<span class="token punctuation">.</span>fn<span class="token punctuation">;</span><span class="token keyword">var</span> c <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">c</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>另外，使用<code>bind</code>可以修正SetTimeout和SetInterval的this指向:</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Obj</span> <span class="token punctuation">{</span>    <span class="token function">constructor</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>num <span class="token operator">=</span> num<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"setTimeout:"</span><span class="token operator">+</span><span class="token keyword">this</span><span class="token punctuation">.</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//bind</span>    <span class="token punctuation">}</span>    <span class="token function">func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//bind</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Obj</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>obj<span class="token punctuation">.</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//>> 1　             输出的是obj.num</span>obj<span class="token punctuation">.</span><span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//>> setTimeout:1　  输出的是obj.num</span>obj<span class="token punctuation">.</span><span class="token function">func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//>> 1 1 1 1 ……　    输出的是obj.num</span></code></pre><p>总结：call和apply都是改变上下文中的this并立即执行这个函数，bind方法可以让对应的函数想什么时候调就什么时候调用，并且可以将参数在执行的时候添加，这是它们的区别，根据自己的实际情况来选择使用。</p><h2 id="“new”操作符指向"><a href="#“new”操作符指向" class="headerlink" title="“new”操作符指向"></a>“new”操作符指向</h2><p>在JavaScript 中，<strong>构造函数</strong>只是一些<strong>使用<code>new</code>操作符时被调用的函数</strong>。它们并不会属于某个类，也不会实例化一个类。实际上，它们甚至都不能算是一种特殊的类型（class），它们<strong>只是被<code>new</code>操作符调用的普通函数而已</strong>。</p><p>使用<code>new</code> 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作：</p><ol><li>创建（或者说构造）一个全新的对象；</li><li>将构造函数的作用域赋给新对象（因此<code>this</code>就指向了这个新对象）；</li><li>执行构造函数中的代码（为这个新对象添加属性、方法等）；</li><li>如果函数没有返回其他对象，那么返回这个新对象。</li></ol><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>user <span class="token operator">=</span> <span class="token string">"Caraxiong"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//Caraxiong</span></code></pre><p>这里之所以对象a可以点出函数Fn里面的user是因为new关键字可以改变this的指向，将这个this指向对象a.调用这个函数Fn的是对象a，那么this指向的自然是对象a，那么为什么对象Fn中会有user，因为你已经复制了一份Fn函数到对象a中，用了new关键字就等同于复制了一份。</p><h2 id="箭头函数的this"><a href="#箭头函数的this" class="headerlink" title="箭头函数的this"></a>箭头函数的this</h2><p>箭头函数内部的this是语法作用域，由上下文确定，有了箭头函数，可以修复this的指向，this总是指向语法作用域，也就是外层调用者。即箭头函数的this指向是<strong>根据函数定义时的作用域来决定 <code>this</code> 的指向</strong>。何谓“定义时的作用域”？就是你定义这个箭头函数的时候，该箭头函数在哪个函数里，那么箭头函数体内的this就是它父函数的this。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 返回一个箭头函数</span>  <span class="token keyword">return</span> a <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//this 继承自 func()</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> obj1 <span class="token operator">=</span> <span class="token punctuation">{</span>  a<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">var</span> obj2 <span class="token operator">=</span> <span class="token punctuation">{</span>  a<span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">var</span> bar <span class="token operator">=</span> func<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj1<span class="token punctuation">)</span><span class="token punctuation">;</span>bar<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//>> 2         不是 3 ！</span><span class="token comment" spellcheck="true">// func() 内部创建的箭头函数会捕获调用时 func() 的 this。</span><span class="token comment" spellcheck="true">// 由于 func() 的 this 绑定到 obj1， bar（引用箭头函数）的 this 也会绑定到 obj1，</span><span class="token comment" spellcheck="true">// this一旦被确定，就不可更改，所以箭头函数的绑定无法被修改。（new 也不行！）</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>执行上下文相关概念</title>
      <link href="2020/11/16/zhi-xing-shang-xia-wen/"/>
      <url>2020/11/16/zhi-xing-shang-xia-wen/</url>
      
        <content type="html"><![CDATA[<h1 id="执行上下文（Execution-Context）"><a href="#执行上下文（Execution-Context）" class="headerlink" title="执行上下文（Execution Context）"></a>执行上下文（Execution Context）</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>执行上下文就是当前 JavaScript 代码被解析和执行时所在的环境，也叫作执行环境。</p><p>它是一个抽象概念，JavaScript 中运行任何的代码都是在执行上下文中运行，在该执行上下文的创建阶段，变量对象（Variable Object，本文接下来会详述）、作用域链、this指向会分别被确定。</p><p><img src="https://7.dusays.com/2020/11/16/9349c5ea172d6.png"></p><h2 id="执行上下文类型"><a href="#执行上下文类型" class="headerlink" title="执行上下文类型"></a>执行上下文类型</h2><p>执行上下文总共有三种类型：</p><ul><li><strong>全局执行上下文</strong>：这是默认的、最基础的执行上下文。不在任何函数中的代码都位于全局执行上下文中。它做了两件事：</li></ul><ol><li>创建一个全局对象，在浏览器中这个全局对象就是 window 对象；</li><li>将 this 指针指向这个全局对象。一个程序中只能存在一个全局执行上下文。</li></ol><ul><li><strong>函数执行上下文</strong>：每次调用函数时，都会为该函数创建一个新的执行上下文。每个函数都拥有自己的执行上下文，但是只有在函数被调用的时候才会被创建。一个程序中可以存在任意数量的函数执行上下文。每当一个新的执行上下文被创建，它都会按照特定的顺序执行一系列步骤，具体过程将在本文后面讨论。</li><li>eval执行上下文：运行在 eval 函数中的代码也获得了自己的执行上下文，ES6 之后不再推荐使用 eval 函数，所以本书出于面试实用考虑，不会深入讨论eval。</li></ul><h2 id="执行上下文的生命周期"><a href="#执行上下文的生命周期" class="headerlink" title="执行上下文的生命周期"></a>执行上下文的生命周期</h2><p>执行上下文的生命周期包括三个阶段：创建阶段 → 执行阶段 → 回收阶段，本文重点介绍创建阶段。</p><h3 id="a-创建阶段"><a href="#a-创建阶段" class="headerlink" title="a. 创建阶段"></a>a. 创建阶段</h3><p>当函数被调用，但未执行任何其内部代码之前，会做以下三件事：</p><ul><li>创建变量对象：首先初始化函数的参数 arguments，提升函数声明和变量声明（变量的<strong>声明提前</strong>有赖于<code>var</code>关键字）。</li><li>创建作用域链：在执行期上下文的创建阶段，作用域链是在变量对象之后创建的。作用域链本身包含变量对象。作用域链用于解析变量。当被要求解析变量时，JavaScript 始终从代码嵌套的最内层开始，如果最内层没有找到变量，就会跳转到上一层父作用域中查找，直到找到该变量。</li><li>确定 this 指向。</li></ul><h3 id="b-执行阶段"><a href="#b-执行阶段" class="headerlink" title="b. 执行阶段"></a>b. 执行阶段</h3><p>创建完成之后，就会开始执行代码，在这个阶段，会完成变量赋值、函数引用、以及执行其他代码。</p><h3 id="c-回收阶段"><a href="#c-回收阶段" class="headerlink" title="c. 回收阶段"></a>c. 回收阶段</h3><p>函数调用完毕后，函数出栈，对应的执行上下文也出栈，等待垃圾回收器回收执行上下文。</p><p><img src="https://7.dusays.com/2020/11/16/d7d64d01245e3.png"></p><h2 id="执行上下文栈"><a href="#执行上下文栈" class="headerlink" title="执行上下文栈"></a>执行上下文栈</h2><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token string">"coffe"</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//1.进入全局执行上下文</span><span class="token keyword">function</span> <span class="token function">out</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token string">"18"</span><span class="token punctuation">;</span>    <span class="token keyword">function</span> <span class="token function">inner</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token string">"91"</span><span class="token punctuation">;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token operator">+</span>b<span class="token operator">+</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">inner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//3.进入inner函数的执行上下文</span><span class="token punctuation">}</span><span class="token function">out</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//2.进入out函数的执行上下文</span></code></pre><p> 在代码开始执行时，首先会产生一个<strong>全局执行上下文</strong>，调用函数时，会产生<strong>函数执行上下文</strong>，函数调用完成后，它的执行上下文以及其中的数据都会被销毁，重新回到全局执行环境，网页关闭后全局执行环境也会销毁。其实这是一个入栈出栈的过程，<strong>全局上下文永远在栈底，而当前正在函数执行上下文在栈顶</strong>。以上代码的执行会经历以下过程：</p><ol><li>当代码开始执行时就<strong>创建全局执行上下文，全局执行上下文入栈</strong>。</li><li>全局执行上下文入栈后，其中的代码开始执行，进行赋值、函数调用等操作，执行到<code>out()</code>时，<strong>激活函数<code>out</code>创建自己的执行上下文，<code>out</code>函数执行上下文入栈</strong>。</li><li><code>out</code>函数执行上下文入栈后，其中的代码开始执行，进行赋值、函数调用等操作，执行到<code>inner()</code>时，<strong>激活函数<code>inner</code>创建自己的执行上下文，<code>inner</code>函数执行上下文入栈</strong>。</li><li><code>inner</code>函数上下文入栈后，其中的代码开始执行，进行赋值、函数调用、打印等操作，由于里面没有可以生成其他执行上下文的需要，所有代码执行完毕后，**<code>inner</code>函数上下文出栈**。</li><li><code>inner</code>函数执行上下文出栈，又回到了<code>out</code>函数执行上下文环境，接着执行<code>out</code>函数中后面剩下的代码，由于后面没有可以生成其他执行上下文的需要，所有代码执行完毕后，**<code>out</code>函数执行上下文出栈**。</li><li><code>out</code>函数执行上下文出栈后，又回到了全局执行上下文环境，直到浏览器窗口关闭，<strong>全局执行上下文出栈</strong>。</li></ol><p><img src="https://7.dusays.com/2020/11/16/55431837a2be8.png"></p><p>我们可以发现：</p><ol><li>全局执行上下文在代码开始执行时就创建，有且只有一个，永远在执行上下文栈的栈底，浏览器窗口关闭时它才出栈。</li><li>函数被调用的时候创建函数的执行上下文环境，并且入栈。</li><li>只有栈顶的执行上下文才是处于活动状态的，也即只有栈顶的变量对象才会变成活动对象。</li></ol><h1 id="变量对象（Variable-Object，VO"><a href="#变量对象（Variable-Object，VO" class="headerlink" title="变量对象（Variable Object，VO)"></a>变量对象（Variable Object，VO)</h1><p>变量对象（VO）是一个类似于容器的对象，与作用域链、执行上下文息息相关。</p><h2 id="变量对象的创建过程的三条规则："><a href="#变量对象的创建过程的三条规则：" class="headerlink" title="变量对象的创建过程的三条规则："></a>变量对象的创建过程的三条规则：</h2><ol><li><strong>建立<code>arguments</code>对象</strong>。检查当前执行上下文中的参数，建立该对象下的属性与属性值。</li><li><strong>检查当前执行上下文的函数声明，也就是使用<code>function</code>关键字声明的函数</strong>。在变量对象中以函数名建立一个属性，属性值为指向该函数所在内存地址的引用。如果该属性之前已经存在，那么该属性将会被新的引用所覆盖。</li><li><strong>检查当前执行上下文中的变量声明，每找到一个变量声明，就在变量对象中以变量名建立一个属性，属性值为<code>undefined</code>**。</strong>如果该变量名的属性已经存在，为了防止同名的函数被修改为<code>undefined</code>，则会直接跳过，原属性值不会被修改**。</li></ol><p><img src="https://7.dusays.com/2020/11/16/7fad446d8076c.png"></p><p>可以用以下伪代码来表示变量对象：</p><pre class=" language-javascript"><code class="language-javascript">VO<span class="token operator">=</span><span class="token punctuation">{</span>    Arguments<span class="token punctuation">:</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//实参</span>    Param_Variable<span class="token punctuation">:</span>具体值<span class="token punctuation">,</span><span class="token comment" spellcheck="true">//形参</span>    Function<span class="token punctuation">:</span><span class="token operator">&lt;</span><span class="token keyword">function</span> reference<span class="token operator">></span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//函数的引用</span>    Variable<span class="token punctuation">:</span>undefined<span class="token comment" spellcheck="true">//其他变量</span><span class="token punctuation">}</span></code></pre><p>当执行上下文进入执行阶段后，变量对象会变为<strong>活动对象</strong>（Active Object，AO）。此时原先声明的变量会被赋值。<strong>变量对象和活动对象都是指同一个对象，只是处于执行上下文的不同阶段</strong>。</p><p>我们可以通过以下伪代码来表示活动对象：</p><pre class=" language-javascript"><code class="language-javascript">AO<span class="token operator">=</span><span class="token punctuation">{</span>    Arguments<span class="token punctuation">:</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//实参</span>    Param_Variable<span class="token punctuation">:</span>具体值<span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">//形参</span>    Function<span class="token punctuation">:</span><span class="token operator">&lt;</span><span class="token keyword">function</span> reference<span class="token operator">></span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//函数的引用</span>    Variable<span class="token punctuation">:</span>具体值<span class="token comment" spellcheck="true">//注意，这里已经赋值了喔</span><span class="token punctuation">}</span></code></pre><p>未进入执行上下文的执行阶段之前，变量对象中的属性都不能访问。但是<strong>进入执行阶段之后，变量对象转变为了活动对象（被激活了）</strong>，里面的属性可以被访问了，然后开始进行执行阶段的操作。</p><h2 id="全局执行上下文的变量对象"><a href="#全局执行上下文的变量对象" class="headerlink" title="全局执行上下文的变量对象"></a>全局执行上下文的变量对象</h2><p>全局执行上下文的变量对象是<code>window</code>对象，而这个特殊，在<code>this</code>指向上也同样适用，<code>this</code>也是指向<code>window</code>。</p><p>除此之外，全局执行上下文的生命周期，与程序的生命周期一致，只要程序运行不结束（比如关掉浏览器窗口），全局执行上下文就会一直存在。其他所有的执行上下文，都能直接访问全局执行上下文里的内容。</p><h2 id="再看一段代码，留意注释"><a href="#再看一段代码，留意注释" class="headerlink" title="再看一段代码，留意注释"></a>再看一段代码，留意注释</h2><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'function func'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> func <span class="token operator">=</span> <span class="token string">"coffe"</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//>> coffe</span><span class="token comment" spellcheck="true">// 以上代码中，按三条规则，变量声明的 func 遇到函数声明的 func 应该会跳过，</span><span class="token comment" spellcheck="true">// 可是为什么最后 func 的输出结果仍然是被覆盖了显示"coffe"呢？</span><span class="token comment" spellcheck="true">// 那是因为三条规则仅仅适用于变量对象的创建阶段，也即执行上下文的创建阶段。</span><span class="token comment" spellcheck="true">// 而 func="coffe" 是在执行上下文的执行阶段中运行的，输出结果自然会是"coffe"。</span></code></pre><p>这种现象很容易让人费解，其实也是因为<code>var</code>声明的变量允许重名导致的，若使用关键字<code>let</code>来声明变量，就可以避免这种令人费解的情况发生。</p><h1 id="作用域链（Scope-Chain）"><a href="#作用域链（Scope-Chain）" class="headerlink" title="作用域链（Scope Chain）"></a>作用域链（Scope Chain）</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p><strong>多个作用域对应的变量对象串联起来组成的链表就是作用域链，</strong>这个链表是以引用的形式保持对变量对象的访问<strong>。</strong>作用域链保证了当前执行上下文对符合访问权限的变量和函数的有序访问。</p><p><img src="https://7.dusays.com/2020/11/16/867543641bca6.png" alt="作用域链的图示"></p><p>作用域链的最顶端一定是当前作用域（local scope）对应的变量对象，最底端一定是全局作用域对应的变量对象（全局VO）。</p><p>作用域链可以形象地比如为一个蒸笼。</p><p><img src="https://7.dusays.com/2020/11/16/8dc21cd5da203.png" alt="蒸笼"></p><p>最底下的一屉，相当于是全局作用域，它里面的蒸汽（变量和函数的可见性）可以渗透到整个蒸笼，底层之上的其他屉相当于局部作用域，这些上面屉的蒸汽只能影响更上面的屉。</p><p>作用域链可以理解为下面这种伪代码格式：</p><pre class=" language-text"><code class="language-text">{    Scope: [        { //当前作用域对应的VO            实参,            形参,            变量,            函数        },         { //第二个作用域对应的VO            实参,            形参,            变量,            函数        },        ...         { //全局作用域对应的VO            变量,            函数        }    ]}</code></pre><h2 id="变量-函数的查找机制"><a href="#变量-函数的查找机制" class="headerlink" title="变量/函数的查找机制"></a>变量/函数的查找机制</h2><p>  查找变量/函数时JS引擎是从里离它最近作用域开始的查找的，也即从离它最近的变量对象（VO）开始查找。</p><p>如果在当前的变量对象里面找不到目标变量/函数，就在上一级作用域的变量对象里面查找。若这时找到了目标变量/函数，则停止查找；若找不到，一直回溯到全局作用域的变量对象里查找，若仍找不到目标变量/函数，停止查找。</p>]]></content>
      
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从es7到es12</title>
      <link href="2020/11/10/cong-es7-dao-es12/"/>
      <url>2020/11/10/cong-es7-dao-es12/</url>
      
        <content type="html"><![CDATA[<h1 id="本篇导读"><a href="#本篇导读" class="headerlink" title="本篇导读"></a>本篇导读</h1><p>JavaScript是一门支持多种编程范式的语言，灵活性很高，功能也十分强大。因为灵活性，JavaScript有很多种使用方式，被应用到浏览器、客户端软件、嵌入式硬件等多种场景下。在面向对象（OOP）这种编程范式大行其道的今天，这种变化多端的语言因其编程范式多样，每种场景下使用形态各异，使用者之间思维差别大，见解又各不相同，因此也就被误解得极深。正是由于这种相对的复杂性，前端工程师们有必要更系统、深入地对这门语言进行学习和研究。</p><p>现在，JavaScript在TC39（TC39由包括浏览器厂商在内的各方组成，他们开会推动JavaScript特性的提案沿着一条严格的流程推进）的推动下正加速地迭代更新，每年都会有一些新特性出现。前端工程师们有必要了解一下这些新特性，以便更好地在一线互联网企业发挥出自己的能量。</p><h1 id="JavaScript-和-ECMAScript-6-的关系"><a href="#JavaScript-和-ECMAScript-6-的关系" class="headerlink" title="JavaScript 和 ECMAScript 6 的关系"></a>JavaScript 和 ECMAScript 6 的关系</h1><p>JavaScript起源于1995年Netscape为自家游览器创造的脚本语言LiveScript。后来因为Sun公司的Java语言兴起，Netscape为了沾热度将LiveScript改名为JavaScript，但其实Java和JavaScript没有一点关系。</p><p>1997年Netscape将JavaScript规范提交到 Ecma International（<a href="https://www.ecma-international.org/">www.ecma-international.org</a>，简称EI），诞生了ECMAScript （简称“ES”）第1个版本。</p><p>随后在1999年诞生了十分稳定的ES 3，也就是2009年12月之前前端工程师们最广泛使用的版本。</p><p>在2009年12月诞生了ES 5。你可能会问ES 4 呢，抱歉，版本4因为太激进，EI委员会成员之间的意见不一，最后胎死腹中，改由更加平滑温和的版本5继承版本4的一些新特性和功能。</p><p>EI于2015年6月发布了ES 6，也就是我们今天广泛使用的版本。这之后每年6月发布一个极小更新的ES版本。</p><p>综上可见，<strong>JavaScript是ECMAScript规范的一种实现</strong>。为方便读者理解交流，而且由于ECAMScript 6 之后变化并不是特别大，如果没有特别说明，本书后面讲述的JavaScript对应的规范默认为 ES 6。</p><p>本文下面会介绍ES 7~12的新特性。</p><h1 id="ES-7-新特性"><a href="#ES-7-新特性" class="headerlink" title="ES 7 新特性"></a>ES 7 新特性</h1><table><thead><tr><th align="left">新特性</th><th align="left">中文说明</th></tr></thead><tbody><tr><td align="left"><code>Array.prototype.includes</code></td><td align="left"></td></tr><tr><td align="left">Exponentiation operator</td><td align="left">指数函数的中缀表示法</td></tr></tbody></table><h2 id="Array-prototype-includes"><a href="#Array-prototype-includes" class="headerlink" title="Array.prototype.includes"></a>Array.prototype.includes</h2><p>includes是一个Array上很有用的方法，用于快速查找数组中是否包含某个元素，包括NaN（所以和indexOf不一样)。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">NaN</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//查找2是否存在于arr数组中</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"找到了!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//>> 找到了！</span>  <span class="token punctuation">}</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>arr<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//第二个参数3表示数组下标为3的项，也即第4项开始查找</span>    console<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">"不存在!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//>> 不存在！</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//下面两句说明incluedes和indexOf的区别</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span><span class="token number">NaN</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//true</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token number">NaN</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//false</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="指数函数的中缀表示法"><a href="#指数函数的中缀表示法" class="headerlink" title="指数函数的中缀表示法"></a>指数函数的中缀表示法</h2><p>这个是与<code>Math.pow</code>有关的特性，还记得<code>i++</code>,<code>x += x</code>这种写法吗，指数函数的中缀表示法与之类似。与python语言一样，JavaScript也采用两个星符号<code>**</code>来表示<code>Math.pow</code>。好处有两个：<br>a. 中缀表示法比函数表示法更简洁，这使它更可取。<br>b. 方便数学、物理、机器人学等领域的计算。</p><p>用法示例如下：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//用法一：x ** y</span><span class="token keyword">let</span> squared <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">**</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//等同于: 2 * 2</span><span class="token keyword">let</span> cubed <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">**</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//等同于: 2 * 2 * 2</span></code></pre><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//用法二：x **= y</span><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>a <span class="token operator">**</span><span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//等同于: a = a * a;</span><span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>b <span class="token operator">**</span><span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//等同于: b = b * b * b;</span></code></pre><h1 id="ES-8-新特性"><a href="#ES-8-新特性" class="headerlink" title="ES 8 新特性"></a>ES 8 新特性</h1><table><thead><tr><th align="left">新特性</th><th align="left">中文说明</th></tr></thead><tbody><tr><td align="left"><code>Object.values</code> / <code>Object.entries</code></td><td align="left"></td></tr><tr><td align="left">String padding</td><td align="left">字符串追加</td></tr><tr><td align="left"><code>Object.getOwnPropertyDescriptors</code></td><td align="left"></td></tr><tr><td align="left">Trailing commas in function parameter lists and calls</td><td align="left">结尾允许逗号</td></tr><tr><td align="left">Async functions</td><td align="left">异步函数</td></tr><tr><td align="left">Shared memory and atomics</td><td align="left">共享内存和 Atomics 对象</td></tr></tbody></table><h2 id="Object-values-Object-entries"><a href="#Object-values-Object-entries" class="headerlink" title="Object.values() / Object.entries"></a>Object.values() / Object.entries</h2><p>定义是<code>Object.values(obj)</code>，<code>obj</code> 参数是对目标对象的操作，它可以是一个对象或者数组。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token string">'xxx'</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>Object<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ['xxx', 1]</span><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'e'</span><span class="token punctuation">,</span> <span class="token string">'s'</span><span class="token punctuation">,</span> <span class="token string">'8'</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 等同于 { 0: 'e', 1: 's', 2: '8' };</span>Object<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ['e', 's', '8']</span><span class="token comment" spellcheck="true">//当把数字对象的当键的时候，返回的数组以键的值升序排序</span><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">10</span><span class="token punctuation">:</span> <span class="token string">'xxx'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">:</span> <span class="token string">'yyy'</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">:</span> <span class="token string">'zzz'</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>Object<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ['yyy', 'zzz', 'xxx']</span>Object<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token string">'es8'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ['e', 's', '8']</span></code></pre><p><code>Object.entries</code>方法返回一个给定对象可枚举属性值的数组[key, value]，与<code>Object.values</code>类似。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token string">'xxx'</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>Object<span class="token punctuation">.</span><span class="token function">entries</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [['x', 'xxx'], ['y', 1]]</span><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'e'</span><span class="token punctuation">,</span> <span class="token string">'s'</span><span class="token punctuation">,</span> <span class="token string">'8'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>Object<span class="token punctuation">.</span><span class="token function">entries</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [['0', 'e'], ['1', 's'], ['2', '8']]</span><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">10</span><span class="token punctuation">:</span> <span class="token string">'xxx'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">:</span> <span class="token string">'yyy'</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">:</span> <span class="token string">'zzz'</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>Object<span class="token punctuation">.</span><span class="token function">entries</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [['1', 'yyy'], ['3', 'zzz'], ['10', 'xxx']]</span>Object<span class="token punctuation">.</span><span class="token function">entries</span><span class="token punctuation">(</span><span class="token string">'es8'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [['0', 'e'], ['1', 's'], ['2', '8']]</span></code></pre><h2 id="字符串追加"><a href="#字符串追加" class="headerlink" title="字符串追加"></a>字符串追加</h2><p>在 ES 8 中String新增了两个实例函数<code>String.prototype.padStart</code>和<code>String.prototype.padEnd</code>，允许将空字符串或其他字符串添加到原始字符串的开头或结尾。</p><ul><li><p><code>String.padStart(targetLength,[padString])</code><br>_targetLength：_当前字符串需要填充到的目标长度。如果这个数值小于当前字符串的长度，则返回当前字符串本身。</p><p>_padString：_(可选)填充字符串。如果字符串太长，使填充后的字符串长度超过了目标长度，则只保留最左侧的部分，其他部分会被截断，此参数的缺省值为空格。</p></li><li><p><code>String.padEnd(targetLength,padString])</code> 参数释义同上。</p></li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token string">'es8'</span><span class="token punctuation">.</span><span class="token function">padStart</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 'es8'</span><span class="token string">'es8'</span><span class="token punctuation">.</span><span class="token function">padStart</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// '  es8'</span><span class="token string">'es8'</span><span class="token punctuation">.</span><span class="token function">padStart</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token string">'1891'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// '189es8'</span><span class="token string">'es8'</span><span class="token punctuation">.</span><span class="token function">padStart</span><span class="token punctuation">(</span><span class="token number">14</span><span class="token punctuation">,</span> <span class="token string">'coffe'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 'coffecoffeces8'</span><span class="token string">'es8'</span><span class="token punctuation">.</span><span class="token function">padStart</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token string">'0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// '0000es8'</span><span class="token string">'es8'</span><span class="token punctuation">.</span><span class="token function">padEnd</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 'es8'</span><span class="token string">'es8'</span><span class="token punctuation">.</span><span class="token function">padEnd</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 'es8  '</span><span class="token string">'es8'</span><span class="token punctuation">.</span><span class="token function">padEnd</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token string">'1891'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 'es8189'</span><span class="token string">'es8'</span><span class="token punctuation">.</span><span class="token function">padEnd</span><span class="token punctuation">(</span><span class="token number">14</span><span class="token punctuation">,</span> <span class="token string">'coffe'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 'es8coffecoffec'</span><span class="token string">'es8'</span><span class="token punctuation">.</span><span class="token function">padEnd</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token string">'9'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 'es89999'</span></code></pre><h2 id="Object-getOwnPropertyDescriptors"><a href="#Object-getOwnPropertyDescriptors" class="headerlink" title="Object.getOwnPropertyDescriptors"></a>Object.getOwnPropertyDescriptors</h2><p><code>getOwnPropertyDescriptors</code>方法返回一指定对象自己所有的属性内容，并且属性内容只是自身直接定义的，而不是从object的原型继承而来的。<br>定义是：<code>Object.getOwnPropertyDescriptors(obj)</code>，<code>obj</code> 是指目标对象，这个方法返回的值可能是 configurable、enumerable、writable、get、set 和 value。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>   <span class="token keyword">get</span> <span class="token function">es7</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token number">7</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token keyword">get</span> <span class="token function">es8</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token number">8</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>Object<span class="token punctuation">.</span><span class="token function">getOwnPropertyDescriptors</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// {</span><span class="token comment" spellcheck="true">//   es7: {</span><span class="token comment" spellcheck="true">//     configurable: true,</span><span class="token comment" spellcheck="true">//     enumerable: true,</span><span class="token comment" spellcheck="true">//     get: function es7(){}, //the getter function</span><span class="token comment" spellcheck="true">//     set: undefined</span><span class="token comment" spellcheck="true">//   },</span><span class="token comment" spellcheck="true">//   es8: {</span><span class="token comment" spellcheck="true">//     configurable: true,</span><span class="token comment" spellcheck="true">//     enumerable: true,</span><span class="token comment" spellcheck="true">//     get: function es8(){}, //the getter function</span><span class="token comment" spellcheck="true">//     set: undefined</span><span class="token comment" spellcheck="true">//   }</span><span class="token comment" spellcheck="true">// }</span></code></pre><h2 id="结尾允许逗号"><a href="#结尾允许逗号" class="headerlink" title="结尾允许逗号"></a>结尾允许逗号</h2><p>用法示例如下：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//定义参数时</span><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>    param1<span class="token punctuation">,</span>    param2<span class="token punctuation">,</span><span class="token comment" spellcheck="true">//结尾逗号</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//传参时</span><span class="token function">foo</span><span class="token punctuation">(</span>    <span class="token string">'coffe'</span><span class="token punctuation">,</span>    <span class="token string">'1891'</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//结尾逗号</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//对象中</span><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token string">"a"</span><span class="token punctuation">:</span> <span class="token string">'coffe'</span><span class="token punctuation">,</span>    <span class="token string">"b"</span><span class="token punctuation">:</span> <span class="token string">'1891'</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//结尾逗号</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//数组中</span><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span>    <span class="token string">'coffe'</span><span class="token punctuation">,</span>    <span class="token string">'1891'</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//结尾逗号</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre><p>这样改动的好处有两点：</p><ul><li>重新排列项目更简单，因为如果最后一项更改其位置，则不必添加和删除逗号。</li><li>可以帮助git等版本控制系统跟踪实际发生的变化，在查看代码改动、合并代码的时候，少报一些无用信息。例如，从</li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token punctuation">[</span>    <span class="token string">'coffe'</span><span class="token punctuation">]</span></code></pre><p>变更为</p><pre class=" language-javascript"><code class="language-javascript"><span class="token punctuation">[</span>    <span class="token string">'coffe'</span><span class="token punctuation">,</span>    <span class="token string">'1891'</span><span class="token punctuation">]</span></code></pre><p>在git里它会报同时修改了两行代码，采用结尾逗号<code>'coffe',</code>之后，就只会报仅有一行代码<code>'1891',</code>的变动，这样做代码review（代码复查）的时候就更省眼力了。</p><h2 id="异步函数"><a href="#异步函数" class="headerlink" title="异步函数"></a>异步函数</h2><p>Async Functions也就是我们常说的Async/Await，相信大家对于这个概念都已经不陌生了。Async/Await是一种用于处理JS异步操作的语法糖，可以帮助我们摆脱<strong>回调地狱</strong>（callback hell），编写更加优雅的代码。</p><p>通俗的理解，<code>async</code>关键字的作用是告诉编译器对于标定的函数要区别对待。当编译器遇到标定的函数中的<code>await</code>关键字时，要暂时停止运行，等到<code>await</code>标定的函数处理完毕后，再进行相应操作。如果该函数fulfiled了，则返回值是fulfillment value，否则得到的就是reject value。</p><p>下面通过拿普通的promise写法来对比，就很好理解了：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">asyncFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">otherAsyncFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// otherAsyncFunc()返回一个Promise对象</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 等同于:</span><span class="token keyword">function</span> <span class="token function">asyncFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">otherAsyncFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// otherAsyncFunc()返回一个Promise对象</span>    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>result <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>按顺序处理多个异步函数的时候优势更为明显：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">asyncFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> result1 <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">otherAsyncFunc1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// otherAsyncFunc1()返回一个Promise对象</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> result2 <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">otherAsyncFunc2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// otherAsyncFunc2()返回一个Promise对象</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 等同于:</span><span class="token keyword">function</span> <span class="token function">asyncFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">otherAsyncFunc1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// otherAsyncFunc1()返回一个Promise对象</span>    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>result1 <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result1<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">otherAsyncFunc2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// otherAsyncFunc2()返回一个Promise对象</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>result2 <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>并行处理多个异步函数：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">asyncFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> <span class="token punctuation">[</span>result1<span class="token punctuation">,</span> result2<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">await</span> Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token punctuation">[</span>        <span class="token function">otherAsyncFunc1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">// otherAsyncFunc1()返回一个Promise对象</span>        <span class="token function">otherAsyncFunc2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// otherAsyncFunc2()返回一个Promise对象</span>    <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result1<span class="token punctuation">,</span> result2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 等同于:</span><span class="token keyword">function</span> <span class="token function">asyncFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token punctuation">[</span>        <span class="token function">otherAsyncFunc1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">// otherAsyncFunc1()返回一个Promise对象</span>        <span class="token function">otherAsyncFunc2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// otherAsyncFunc2()返回一个Promise对象</span>    <span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">[</span>result1<span class="token punctuation">,</span> result2<span class="token punctuation">]</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result1<span class="token punctuation">,</span> result2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>处理错误：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">asyncFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">await</span> <span class="token function">otherAsyncFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// otherAsyncFunc()返回一个Promise对象</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">err</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 等同于:</span><span class="token keyword">function</span> <span class="token function">asyncFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">otherAsyncFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// otherAsyncFunc()返回一个Promise对象</span>    <span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span>err <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>Async Functions若是要展开讲可以占很大的篇幅，鉴于本篇是一篇介绍性文章，故此不再进行深入论述。</p><h2 id="共享内存和-Atomics-对象"><a href="#共享内存和-Atomics-对象" class="headerlink" title="共享内存和 Atomics 对象"></a>共享内存和 Atomics 对象</h2><p>SharedArrayBuffer 对象用来表示一个通用的，固定长度的原始二进制数据缓冲区，类似于 ArrayBuffer对象（如果之前你没有接触过ArrayBuffer相关知识的话，建议从<a href="https://hacks.mozilla.org/2017/06/a-cartoon-intro-to-arraybuffers-and-sharedarraybuffers/">内存管理速成教程系列漫画解说入门</a>） ，它们都可以用来在共享内存（shared memory）上创建视图。与 ArrayBuffer 不同的是，SharedArrayBuffer 不能被分离。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">/** *  * @param {*} length 所创建的数组缓冲区的大小，以字节(byte)为单位。   * @returns {SharedArrayBuffer} 一个大小指定的新 SharedArrayBuffer 对象。其内容被初始化为 0。 */</span><span class="token keyword">new</span> <span class="token class-name">SharedArrayBuffer</span><span class="token punctuation">(</span>length<span class="token punctuation">)</span></code></pre><p>Atomics 对象提供了一组静态方法用来对 SharedArrayBuffer 对象进行原子操作，这些原子操作属于 Atomics 模块。Atomics 不是构造函数，因此不能使用 new 操作符调用，也不能将其当作函数直接调用。Atomics 的所有属性和方法都是静态的（与 Math 对象一样）。</p><table><thead><tr><th align="left">方法名</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">Atomics.add()</td><td align="left">将指定位置上的数组元素与给定的值相加，并返回相加前该元素的值。</td></tr><tr><td align="left">Atomics.and()</td><td align="left">将指定位置上的数组元素与给定的值相与，并返回与操作前该元素的值。</td></tr><tr><td align="left">Atomics.compareExchange()</td><td align="left">如果数组中指定的元素与给定的值相等，则将其更新为新的值，并返回该元素原先的值。</td></tr><tr><td align="left">Atomics.exchange()</td><td align="left">将数组中指定的元素更新为给定的值，并返回该元素更新前的值。</td></tr><tr><td align="left">Atomics.load()</td><td align="left">返回数组中指定元素的值。</td></tr><tr><td align="left">Atomics.or()</td><td align="left">将指定位置上的数组元素与给定的值相或，并返回或操作前该元素的值。</td></tr><tr><td align="left">Atomics.store()</td><td align="left">将数组中指定的元素设置为给定的值，并返回该值。</td></tr><tr><td align="left">Atomics.sub()</td><td align="left">将指定位置上的数组元素与给定的值相减，并返回相减前该元素的值。</td></tr><tr><td align="left">Atomics.xor()</td><td align="left">将指定位置上的数组元素与给定的值相异或，并返回异或操作前该元素的值。</td></tr><tr><td align="left">Atomics.wait()</td><td align="left">检测数组中某个指定位置上的值是否仍然是给定值，是则保持挂起直到被唤醒或超时。返回值为 “ok”、”not-equal” 或 “time-out”。调用时，如果当前线程不允许阻塞，则会抛出异常（大多数浏览器都不允许在主线程中调用 wait()）。</td></tr><tr><td align="left">Atomics.wake()</td><td align="left">唤醒等待队列中正在数组指定位置的元素上等待的线程。返回值为成功唤醒的线程数量。</td></tr><tr><td align="left">Atomics.isLockFree(size)</td><td align="left">可以用来检测当前系统是否支持硬件级的原子操作。对于指定大小的数组，如果当前系统支持硬件级的原子操作，则返回 true；否则就意味着对于该数组，Atomics 对象中的各原子操作都只能用锁来实现。此静态方法面向的是技术专家。</td></tr></tbody></table><h1 id="ES-9-新特性"><a href="#ES-9-新特性" class="headerlink" title="ES 9 新特性"></a>ES 9 新特性</h1><table><thead><tr><th align="left">新特性</th><th align="left">中文说明</th></tr></thead><tbody><tr><td align="left">Asynchronous Iteration</td><td align="left">异步迭代器</td></tr><tr><td align="left"><code>Promise.prototype.finally</code></td><td align="left"></td></tr><tr><td align="left">Lifting template literal restriction</td><td align="left">重新修订了字面量的转义</td></tr><tr><td align="left">Rest/Spread Properties</td><td align="left">Rest/Spread 属性</td></tr><tr><td align="left"><code>s</code> (dotAll) flag for regular expressions</td><td align="left">正则表达式dotAll模式</td></tr><tr><td align="left">RegExp named capture groups</td><td align="left">正则表达式命名捕获组</td></tr><tr><td align="left">RegExp Lookbehind Assertions</td><td align="left">正则表达式反向断言</td></tr><tr><td align="left">RegExp Unicode Property Escapes</td><td align="left">正则表达式 Unicode 转义</td></tr></tbody></table><h2 id="异步迭代器"><a href="#异步迭代器" class="headerlink" title="异步迭代器"></a>异步迭代器</h2><p>在<code>async</code>/<code>await</code>的某些时刻，你可能尝试在同步循环中调用异步函数。例如：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">func</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token keyword">of</span> array<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">await</span> <span class="token function">someFunc</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这段代码不会达到预期目的，下面这段同样也不会：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">func</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span> <span class="token punctuation">{</span>  array<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">async</span> i <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">await</span> <span class="token function">someFunc</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>上面这段代码中，循环本身依旧保持同步，并在内部异步函数之前全部调用完成。</p><p>引入异步迭代器后，就像常规迭代器，除了<code>next()</code>方法返回一个Promise。因此<code>await</code>可以和<code>for...of</code>循环一起使用，以串行的方式运行异步操作。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">func</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">for</span> <span class="token keyword">await</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token keyword">of</span> array<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//异步迭代</span>    <span class="token function">someFunc</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally"></a>Promise.prototype.finally</h2><p>一个Promise调用链要么成功到达最后一个<code>.then()</code>，要么失败触发<code>.catch()</code>。在某些情况下，你想要在无论Promise运行成功还是失败，运行相同的代码，例如清除数组、删除对话、关闭数据库连接等，<code>.finally()</code>允许实现这样的目的。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">promiseFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//返回一个Promise对象</span>    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span>err <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token keyword">finally</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">//无论promiseFunc()运行成功还是失败，这里的代码会被调用到</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="重新修订了字面量的转义"><a href="#重新修订了字面量的转义" class="headerlink" title="重新修订了字面量的转义"></a>重新修订了字面量的转义</h2><p>ES9 之前，<code>\u</code>表示 unicode 转义，<code>\x</code>表示十六进制转义，<code>\</code>后跟一个数字表示八进制转义，这使得创建特定的字符串变得不可能，例如Windows文件路径<code>C:\uuu\xxx\111</code>。</p><p>要取消转义序列的语法限制，可在模板字符串之前使用标记函数<code>String.raw</code>。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token template-string"><span class="token string">`\u{54}`</span></span> <span class="token comment" spellcheck="true">//会转义成unicode "T"</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//>> T</span><span class="token keyword">let</span> str <span class="token operator">=</span> String<span class="token punctuation">.</span>raw<span class="token template-string"><span class="token string">`\u{54}`</span></span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//不会被转义</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//>> \u{54}</span></code></pre><h2 id="Rest-Spread"><a href="#Rest-Spread" class="headerlink" title="Rest / Spread"></a>Rest / Spread</h2><p>这个就是我们通常所说的三个点<code>...</code>，这项特性在ES6中已经引入，但是ES6中的作用对象仅限于数组。在ES9中，为对象提供了像数组一样的rest参数和扩展运算符：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>  a<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>  b<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span>  c<span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token punctuation">{</span> a<span class="token punctuation">,</span> <span class="token operator">...</span>param <span class="token punctuation">}</span> <span class="token operator">=</span> obj<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//这里...是rest</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//>> 1</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//>> {b: 2, c: 3}</span><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">{</span> a<span class="token punctuation">,</span> <span class="token operator">...</span>param <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//这里...还是rest</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//>> 1</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//>> {b: 2, c: 3}</span><span class="token punctuation">}</span><span class="token keyword">const</span> param <span class="token operator">=</span> <span class="token punctuation">{</span> b<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span> c<span class="token punctuation">:</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">{</span> a<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">...</span>param <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//此处...为spread</span></code></pre><h2 id="正则表达式dotAll模式"><a href="#正则表达式dotAll模式" class="headerlink" title="正则表达式dotAll模式"></a>正则表达式dotAll模式</h2><p>正则表达式中点<code>.</code>匹配除回车外的任何单字符，标记<code>s</code>改变这种行为，允许匹配回车换行。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token regex">/hello.world/</span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">'hello\nworld'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// false</span><span class="token operator">/</span>hello<span class="token punctuation">.</span>world<span class="token operator">/</span>s<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">'hello\nworld'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token operator">/</span>hello<span class="token punctuation">.</span>world<span class="token operator">/</span>s<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`helloworld`</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">//>> true</span></code></pre><h2 id="正则表达式命名捕获组"><a href="#正则表达式命名捕获组" class="headerlink" title="正则表达式命名捕获组"></a>正则表达式命名捕获组</h2><p>Javascript正则表达式中使用<code>exec()</code>匹配后，能够返回一个包含匹配字符串的类数组对象。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> reDate <span class="token operator">=</span> <span class="token regex">/(\d{4})-(\d{2})-(\d{2})/</span><span class="token punctuation">,</span>  match <span class="token operator">=</span> reDate<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token string">"2018-08-06"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>match<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//>> [2018-08-06, 2018, 08, 06]</span><span class="token comment" spellcheck="true">//这样就可以直接用索引来获取年月日：</span><span class="token keyword">let</span> year <span class="token operator">=</span> match<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//>> 2018</span><span class="token keyword">let</span> month <span class="token operator">=</span> match<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//>> 08</span><span class="token keyword">let</span> day <span class="token operator">=</span> match<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//>> 06</span></code></pre><p>返回数组的第0项为与正则表达式相匹配的文本，第 1 项是与 <code>reDate</code> 的第 1 个分组<code>\d{4}</code>相匹配的文本（如果有的话），第 2 项是与 <code>reDate</code> 的第 2 个分组<code>\d{2}</code>相匹配的文本（如果有的话），以此类推。正则表达式的组以<code>()</code>包起来。</p><p>上面的案例，若是日期格式变成<code>月日年</code>，那么改变正则表达式的结构后，还有可能会改变变量的赋值部分的代码。如下示例：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> reDate <span class="token operator">=</span> <span class="token regex">/(\d{2})-(\d{2})-(\d{4})/</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//表达式结构变化了</span>  match <span class="token operator">=</span> reDate<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token string">"08-06-2018"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>match<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//>> [08-06-2018, 08, 06, 2018]</span><span class="token comment" spellcheck="true">//此时年月日的赋值代码也要改了,改的地方真多啊！怎么办？</span><span class="token keyword">let</span> year <span class="token operator">=</span> match<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//>> 2018</span><span class="token keyword">let</span> month <span class="token operator">=</span> match<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//>> 08</span><span class="token keyword">let</span> day <span class="token operator">=</span> match<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//>> 06</span></code></pre><p>可以发现上面的写法改的地方太多了，有没有办法少改点代码省省事呢？有！ ES9 允许使用符号<code>?&lt;name&gt;</code>来命名<strong>捕获组</strong>（也即“匹配到的组”），示例如下：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> reDate <span class="token operator">=</span> <span class="token regex">/(?&lt;year>\d{4})-(?&lt;month>\d{2})-(?&lt;day>\d{2})/</span><span class="token punctuation">,</span>  match <span class="token operator">=</span> reDate<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token string">"2018-08-06"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>match<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//>> [2018-08-06, 08, 06, 2018, groups: {day: 06, month: 08, year: 2018}]</span><span class="token comment" spellcheck="true">//此时用groups对象来获取年月日，无论正则表达式怎么变换，这下面三行不用改了，省事！</span><span class="token keyword">let</span> year <span class="token operator">=</span> match<span class="token punctuation">.</span>groups<span class="token punctuation">.</span>year<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//>> 2018</span><span class="token keyword">let</span> month <span class="token operator">=</span> match<span class="token punctuation">.</span>groups<span class="token punctuation">.</span>month<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//>> 08</span><span class="token keyword">let</span> day <span class="token operator">=</span> match<span class="token punctuation">.</span>groups<span class="token punctuation">.</span>day<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//>> 06</span></code></pre><p>命名捕获组的写法相当于是把每个捕获组都定义了一个名字，然后存储到返回值的<code>groups</code>属性中。</p><h3 id="正则表达式后行断言"><a href="#正则表达式后行断言" class="headerlink" title="正则表达式后行断言"></a>正则表达式后行断言</h3><p>先看看正则表达式<strong>先行断言</strong>示例：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> re1 <span class="token operator">=</span> <span class="token regex">/\D(\d+)/</span><span class="token punctuation">,</span>    re2 <span class="token operator">=</span> <span class="token regex">/\D(?=\d+)/</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//"?="是正向先行断言</span>    match1 <span class="token operator">=</span> re1<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token string">"$123.45"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    match2 <span class="token operator">=</span> re2<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token string">"$123.45"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>match1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//>> $123</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>match2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//>> $</span></code></pre><blockquote><p><strong>(?=pattern)</strong> 零宽正向先行断言(zero-width positive lookahead assertion)<br>代表字符串中的一个位置，<strong>紧接该位置之后</strong>的字符序列<strong>能够匹配</strong>pattern；</p><p>(<strong>?!pattern)</strong> 零宽负向先行断言(zero-width negative lookahead assertion)<br>代表字符串中的一个位置，<strong>紧接该位置之后</strong>的字符序列<strong>不能匹配</strong>pattern；</p><p><strong>(?&lt;=pattern)</strong> 零宽正向后行断言(zero-width positive lookbehind assertion)<br>代表字符串中的一个位置，<strong>紧接该位置之前</strong>的字符序列<strong>能够匹配</strong>pattern；</p><p><strong>(?&lt;!pattern)</strong> 零宽负向后行断言(zero-width negative lookbehind assertion)<br>代表字符串中的一个位置，<strong>紧接该位置之前</strong>的字符序列<strong>不能匹配</strong>pattern。</p></blockquote><p>在ES9中，可以允许使用<code>?&lt;=</code>进行<strong>正向后行断言</strong>，可以获取货币的价格而忽略货币符号。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> re<span class="token operator">=</span> <span class="token regex">/(?&lt;=\D)[\d\.]+/</span><span class="token punctuation">,</span>    match <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token string">"$123.45"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>match<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//>> 123.45</span></code></pre><p>上面的正向后行断言，也就是说<code>\D</code>这个条件必须满足，但<code>\D</code>匹配的字符不会作为结果输出（因为<strong>先行/后行断言</strong>其实只是匹配了一个位置）。如果是下面这样：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> re<span class="token operator">=</span> <span class="token regex">/(?&lt;=\D)[\d\.]+/</span><span class="token punctuation">,</span>    match1 <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token string">"123.45"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    match2 <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token string">"12345"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>match1 <span class="token operator">&amp;&amp;</span> match1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//>> 45</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>match2 <span class="token operator">&amp;&amp;</span> match1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//>> null</span></code></pre><p>可以看到<code>match1</code>匹配到的是<code>45</code>,这是由于在<code>.</code>前面没有任何符合<code>\D</code>的匹配内容，它会一直找到符合<code>\D</code>的内容，也就是<code>.</code>然后返回后面的内容。而<code>match2</code>若是没有满足前面肯定反向断言的条件的话，则结果返回<code>null</code>。</p><h2 id="正则表达式-Unicode-转义"><a href="#正则表达式-Unicode-转义" class="headerlink" title="正则表达式 Unicode 转义"></a>正则表达式 Unicode 转义</h2><p>ES9 之前，在正则表达式中本地访问 Unicode 字符属性是不被允许的。ES9 添加了 Unicode 属性转义，形式为<code>\p{...}</code>和<code>\P{...}</code>，在正则表达式中使用标记 <code>u</code> (unicode) 设置，在<code>\p</code>的<code>{...}</code>内，可用键值对的方式设置需要匹配的属性而非具体内容。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> regex <span class="token operator">=</span> <span class="token regex">/\p{Script=Greek}/u</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//Greek为希腊语的意思</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>regex<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//>> flase</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>regex<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">'Σ'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//>> true</span></code></pre><h1 id="ES-10-新特性"><a href="#ES-10-新特性" class="headerlink" title="ES 10 新特性"></a>ES 10 新特性</h1><table><thead><tr><th align="left">新特性</th><th align="left">中文说明</th></tr></thead><tbody><tr><td align="left">Optional <code>catch</code> binding</td><td align="left">可选的 catch 变量绑定</td></tr><tr><td align="left">JSON superset</td><td align="left">JSON超集</td></tr><tr><td align="left"><code>Symbol.prototype.description</code></td><td align="left">Symbol 对象的 description 属性</td></tr><tr><td align="left"><code>Function.prototype.toString</code> revision</td><td align="left">修订<code>Function.prototype.toString</code></td></tr><tr><td align="left"><code>Object.fromEntries</code></td><td align="left"></td></tr><tr><td align="left">Well-formed <code>JSON.stringify</code></td><td align="left">更加友好的JSON.stringify</td></tr><tr><td align="left"><code>String.prototype.{trimStart,trimEnd}</code></td><td align="left"></td></tr><tr><td align="left"><code>Array.prototype.{flat,flatMap}</code></td><td align="left"></td></tr></tbody></table><h2 id="可选的-catch-变量绑定"><a href="#可选的-catch-变量绑定" class="headerlink" title="可选的 catch 变量绑定"></a>可选的 catch 变量绑定</h2><p>在 ES10 之前，我们必须通过语法为 catch 子句绑定异常变量，无论是否有必要。很多时候 catch 块是多余的，而 ES10 使我们能够简单的把变量省略掉。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//之前是</span><span class="token keyword">try</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//ES10之后可以写成，</span><span class="token keyword">try</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//省掉了变量e</span></code></pre><h2 id="JSON超集"><a href="#JSON超集" class="headerlink" title="JSON超集"></a>JSON超集</h2><p>什么是 JSON 超集？简单来说就是 JSON 是 ECMAScript 的子集，也就是说让 ECMAScript 兼容 JSON 的内容所支持的全部文本。</p><p>ECMAScript 在标准 <a href="https://tc39.es/ecma262/#sec-json.parse">JSON.parse</a> 部分阐明了 JSON 确为其一个子集，但由于 JSON 的内容可以正常包含 <code>U+2028</code> 行分隔符与 <code>U+2029</code> 段落分隔符，而 ECMAScript 却不行，所以，该草案旨在解决这一问题。在这之前，如果你使用 <code>JSON.parse()</code> 执行带如上特殊字符的字符串时，只会收到 <code>SyntaxError</code> 的错误提示。该草案同样是向后兼容的，其对用户唯一的影响是保持原样，即在暂不支持特殊字符解析的运行环境中保持报错 <code>SyntaxError</code> 。</p><h2 id="Symbol-对象的-description-属性"><a href="#Symbol-对象的-description-属性" class="headerlink" title="Symbol 对象的 description 属性"></a>Symbol 对象的 description 属性</h2><p>ES10 中为 Symbol 对象添加了只读属性 <code>description</code> ，该对象返回包含 Symbol 描述的字符串。在创建Symbol时向其添加<code>description</code> (描述)，能够直接访问<code>description</code> ，对调试是很有用的。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> sym <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//添加的描述内容为“foo”</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>sym<span class="token punctuation">.</span>description<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//>> foo</span>sym <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>sym<span class="token punctuation">.</span>description<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//>> undefined</span><span class="token comment" spellcheck="true">//和 Symbol() 不同的是，用 Symbol.for() 方法创建的的 symbol 会被放入一个全局 </span><span class="token comment" spellcheck="true">//symbol 注册表中。Symbol.for() 并不是每次都会创建一个新的 symbol，它会首先检</span><span class="token comment" spellcheck="true">//查给定的 key 是否已经在注册表中了。假如是，则会直接返回上次存储的那个。否则，它</span><span class="token comment" spellcheck="true">//会再新建一个。</span>sym <span class="token operator">=</span> Symbol<span class="token punctuation">.</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token string">'bar'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>sym<span class="token punctuation">.</span>description<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//>> bar</span></code></pre><h2 id="修订Function-prototype-toString"><a href="#修订Function-prototype-toString" class="headerlink" title="修订Function.prototype.toString"></a>修订Function.prototype.toString</h2><p>函数原型上的方法<code>toString()</code>现在返回精确字符，包括空格和注释。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token comment" spellcheck="true">/* comment */</span> foo <span class="token comment" spellcheck="true">/* another comment */</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//ES10之前不会打印注释部分</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//>> function foo(){}</span><span class="token comment" spellcheck="true">//ES10里，会把注释一同打印</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//>> function </span><span class="token comment" spellcheck="true">/* comment */</span> foo <span class="token comment" spellcheck="true">/* another comment */</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//注意：</span><span class="token comment" spellcheck="true">//箭头函数是个例外</span><span class="token keyword">const</span> bar <span class="token comment" spellcheck="true">/* comment */</span> <span class="token operator">=</span> <span class="token comment" spellcheck="true">/* another comment */</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>bar<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//>> () => {}</span></code></pre><h2 id="Object-fromEntries"><a href="#Object-fromEntries" class="headerlink" title="Object.fromEntries"></a>Object.fromEntries</h2><p>在 JavaScript 操作中，数据在各种数据结构之间的转换都是很容易的，比如 Map 到数组、Map 到 Set、对象到 Map 等等。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span><span class="token string">'bar'</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> arr <span class="token operator">=</span> Array<span class="token punctuation">.</span><span class="token keyword">from</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> <span class="token keyword">set</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> foo<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> bar<span class="token punctuation">:</span> <span class="token boolean">false</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//下一句 Object.entries() 方法返回给定对象 obj 自身可枚举属性的键值对数组,</span><span class="token comment" spellcheck="true">//形如：[["foo",true],["bar",false]]</span><span class="token keyword">let</span> newMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">entries</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>但是如果我们需要将一个键值对列表转换为对象，就要写点费劲的代码了。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span><span class="token string">"foo"</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span><span class="token string">"bar"</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> obj <span class="token operator">=</span> Array<span class="token punctuation">.</span><span class="token keyword">from</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span>acc<span class="token punctuation">,</span> <span class="token punctuation">[</span>key<span class="token punctuation">,</span> val<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span>acc<span class="token punctuation">,</span> <span class="token punctuation">{</span>    <span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">:</span> val  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>该特性的目的在于为对象添加一个新的静态方法 <code>Object.fromEntries</code>，用于将符合键值对的列表（例如 Map、数组等）转换为一个对象。上一块的代码中的转换逻辑，现在我们只需要一行代码即可搞定。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span><span class="token string">"foo"</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span><span class="token string">"bar"</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> obj <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">fromEntries</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="更加友好的-JSON-stringify"><a href="#更加友好的-JSON-stringify" class="headerlink" title="更加友好的 JSON.stringify"></a>更加友好的 JSON.stringify</h2><p>ES10 之前，当你使用 <code>JSON.stringify()</code> 处理无法用 UTF-8 编码表示的字符时（U+D800 至 U+DFFF），返回的结果会是一个乱码 Unicode 字符“�”。该特性提出用<code>JSON.stringify()</code>来安全的表示这些不正常的UTF-8字符。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> r<span class="token punctuation">;</span>r <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span><span class="token string">"❤"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//正常的UTF-8字符原样输出</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//>> "❤"</span>r <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span><span class="token string">'\u2764'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//正常的UTF-8字符编码，输出解码之后的模样</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//>> "❤"</span>r <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span><span class="token string">"\uDF06\uD834"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//不正常的UTF-8字符编码，则以unicode形式输出</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//>> "\udf06\ud834"</span>r <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span><span class="token string">"\uDEAD"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//不正常的UTF-8字符编码，则以unicode形式输出</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//>> "\udead"</span></code></pre><h2 id="String-prototype-trimStart-trimEnd"><a href="#String-prototype-trimStart-trimEnd" class="headerlink" title="String.prototype.{trimStart,trimEnd}"></a>String.prototype.{trimStart,trimEnd}</h2><p>新增了String的<code>trimStart()</code>方法和<code>trimEnd()</code>方法，这两个方法很好理解，分别去除字符串首、尾的空白字符，就不举例占篇幅了。</p><h2 id="Array-prototype-flat-flatMap"><a href="#Array-prototype-flat-flatMap" class="headerlink" title="Array.prototype.{flat,flatMap}"></a>Array.prototype.{flat,flatMap}</h2><p>这个特性新创造了两个方法，其中：</p><ul><li><code>Array.prototype.flat</code> 数组的所有项会以指定的维度降维（扁平化），然后组成新数组返回；</li><li><code>Array.prototype.flatMap</code> 首先会执行一次<code>map()</code>方法，然后再通过类似<code>flat()</code>方法<strong>扁平化</strong>数组。它等同于执行完 <code>map()</code> 后再执行一次 <code>flat()</code> 方法，所以当你执行 <code>map()</code> 返回的结果如果是个数组，然后又要将其扁平化时，这个方法会显得方便。</li></ul><p>来看几个例子解释一下，首先 <code>flat()</code> 方法支持多维数组的扁平化，其中<code>Infinity</code>可以将多维数组压扁成一维数组。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> r<span class="token punctuation">;</span>r <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">"8"</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">"9"</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">"1"</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">flat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//4维数组，默认降维1，变成3维数组</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//>> [ '1', '8', [ '9', ['1'] ] ]</span>r <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">"8"</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">"9"</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">"1"</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">flat</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//4维数组，降维2，变成2维数组</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//>> [ '1', '8', '9', ['1'] ]</span>r <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">"8"</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">"9"</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">"1"</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">flat</span><span class="token punctuation">(</span><span class="token number">Infinity</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//4维数组，最多变成1维数组</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//>> [ '1', '8', '9', '1' ]</span></code></pre><p>接着来看看<code>flatMap()</code></p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> r<span class="token punctuation">;</span>r <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"I love"</span><span class="token punctuation">,</span> <span class="token string">"coffe 1891"</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>item <span class="token operator">=</span><span class="token operator">></span> item<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//>> [ [ 'I', 'love' ], [ 'coffe', '1891' ] ]</span>r <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"I love"</span><span class="token punctuation">,</span> <span class="token string">"coffe 1891"</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">flatMap</span><span class="token punctuation">(</span>item <span class="token operator">=</span><span class="token operator">></span> item<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//>>[ 'I', 'love', 'coffe', '1891' ]</span></code></pre><h1 id="ES-2020-ES11-新特性"><a href="#ES-2020-ES11-新特性" class="headerlink" title="ES 2020 (ES11) 新特性"></a>ES 2020 (ES11) 新特性</h1><p>因为太“新”，现在若想使用ES11新特性，则需要安装babel插件</p><pre class=" language-javascript"><code class="language-javascript">plugins<span class="token punctuation">:</span> <span class="token punctuation">[</span>    <span class="token string">"@babel/plugin-proposal-nullish-coalescing-operator"</span><span class="token punctuation">,</span>    <span class="token string">"@babel/plugin-proposal-optional-chaining"</span><span class="token punctuation">,</span>    <span class="token string">"@babel/plugin-proposal-class-properties"</span><span class="token punctuation">,</span>    <span class="token string">"@babel/plugin-proposal-private-methods"</span><span class="token punctuation">,</span>    <span class="token string">"@babel/plugin-syntax-bigint"</span><span class="token punctuation">]</span></code></pre><table><thead><tr><th align="left">新特性</th><th align="left">中文说明</th></tr></thead><tbody><tr><td align="left">Optional Chaining</td><td align="left">可选链操作符</td></tr><tr><td align="left">Nullish coalescing Operator</td><td align="left">空位合并操作符</td></tr><tr><td align="left"><code>String.prototype.matchAll</code></td><td align="left"></td></tr><tr><td align="left"><code>import()</code></td><td align="left">import()函数</td></tr><tr><td align="left"><code>Promise.allSettled</code></td><td align="left"></td></tr><tr><td align="left">Bigint</td><td align="left"></td></tr><tr><td align="left">globalThis</td><td align="left">全局this</td></tr></tbody></table><h2 id="Optional-Chaining"><a href="#Optional-Chaining" class="headerlink" title="Optional Chaining"></a>Optional Chaining</h2><p><strong>可选链操作符</strong> <code>?</code> 可让我们在查询具有多个层级的对象时，不再需要进行冗余的各种前置校验。</p><p>以前要读取一个对象的属性值，需要写一些防御性的前置校验代码，比如：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> second <span class="token operator">=</span> obj <span class="token operator">&amp;&amp;</span> obj<span class="token punctuation">.</span>first <span class="token operator">&amp;&amp;</span> obj<span class="token punctuation">.</span>first<span class="token punctuation">.</span>second<span class="token punctuation">;</span></code></pre><p>在访问 obj.first.second 之前，要先确认 obj 和 obj.first 的值非 null(且不是 undefined)。有了可选链式操作符，则可以大量简化类似繁琐的前置校验操作，而且更安全：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> second <span class="token operator">=</span> obj<span class="token operator">?</span><span class="token punctuation">.</span>first<span class="token operator">?</span><span class="token punctuation">.</span>second<span class="token punctuation">;</span></code></pre><p>如果 <code>obj</code> 或<code>obj.first</code>是<code>null</code>/<code>undefined</code>，表达式将会直接返回<code>undefined</code>。</p><h2 id="Nullish-coalescing-Operator-空值处理"><a href="#Nullish-coalescing-Operator-空值处理" class="headerlink" title="Nullish coalescing Operator(空值处理)"></a>Nullish coalescing Operator(空值处理)</h2><p>以前对于如下的情况：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> v <span class="token operator">=</span> a <span class="token operator">||</span> <span class="token string">"some value"</span><span class="token punctuation">;</span><span class="token keyword">let</span> z <span class="token operator">=</span> a <span class="token operator">?</span> a <span class="token punctuation">:</span> <span class="token string">"some value"</span><span class="token punctuation">;</span></code></pre><p>如果 a 的值是 <code>0</code> 、 空字符串<code>''</code> 、<code>false</code>等可能有意义的值，但是在上面的表达式中被认为是假值，因此v 和 z 也会被赋值为 <code>some value</code>。也即：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 0、''、false可能是有意义的</span><span class="token keyword">let</span> v <span class="token operator">=</span> a <span class="token operator">||</span> <span class="token string">"some value"</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//>> some value</span></code></pre><p>为解决这种问题，诞生了<code>??</code> ，如果表达式在<code>??</code>的左侧值为<code>undefined</code>或<code>null</code>，就返回右侧默认的值。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token keyword">let</span> v <span class="token operator">=</span> a <span class="token operator">?</span><span class="token operator">?</span> <span class="token string">"some value"</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//>> 0</span><span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token keyword">let</span> z <span class="token operator">=</span> b <span class="token operator">?</span><span class="token operator">?</span> <span class="token string">"some value"</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>z<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//>> some value</span></code></pre><h2 id="String-prototype-matchAll"><a href="#String-prototype-matchAll" class="headerlink" title="String.prototype.matchAll"></a>String.prototype.matchAll</h2><p><code>matchAll()</code> 方法返回一个包含所有匹配正则表达式及分组捕获结果的迭代器（iterator）。 在 <code>matchAll</code> 出现之前，通过在循环中调用<code>Regexp.exec</code>来获取所有匹配项信息（<code>Regexp</code>需使用<code>/g</code>标志）：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> regexp <span class="token operator">=</span> <span class="token function">RegExp</span><span class="token punctuation">(</span><span class="token string">'foo*'</span><span class="token punctuation">,</span><span class="token string">'g'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> str <span class="token operator">=</span> <span class="token string">'coffe football, foosball'</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>matches <span class="token operator">=</span> regexp<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`找到 </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>matches<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">，下一轮循环从位置 </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>regexp<span class="token punctuation">.</span>lastIndex<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> 开始`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//>> 找到 foo，下一轮循环从位置 9 开始</span>  <span class="token comment" spellcheck="true">//>> 找到 foo，下一轮循环从位置 19 开始</span><span class="token punctuation">}</span></code></pre><p>如果使用<code>matchAll</code> ，就可以不必使用<code>while</code>循环加<code>exec</code>方式（且正则表达式需使用<code>/g</code>标志）。使用<code>matchAll</code> 会得到一个迭代器的返回值，配合 <code>for...of</code>，<code>array spread</code>，<code>Array.from()</code> 可以更方便实现功能。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> regexp <span class="token operator">=</span> <span class="token function">RegExp</span><span class="token punctuation">(</span><span class="token string">'foo*'</span><span class="token punctuation">,</span><span class="token string">'g'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">const</span> str <span class="token operator">=</span> <span class="token string">'coffe football, foosball'</span><span class="token punctuation">;</span><span class="token keyword">let</span> matches <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">matchAll</span><span class="token punctuation">(</span>regexp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> match <span class="token keyword">of</span> matches<span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>match<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//>> [ "foo" ]</span><span class="token comment" spellcheck="true">//>> [ "foo" ]</span><span class="token comment" spellcheck="true">//注意：</span><span class="token comment" spellcheck="true">//matches的迭代器在for..of之后已经被消耗掉了，</span><span class="token comment" spellcheck="true">//需要再次调用matchAll创建一个新的迭代器</span>matches <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">matchAll</span><span class="token punctuation">(</span>regexp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> arr <span class="token operator">=</span> Array<span class="token punctuation">.</span><span class="token keyword">from</span><span class="token punctuation">(</span>matches<span class="token punctuation">,</span> m <span class="token operator">=</span><span class="token operator">></span> m<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//>> [ "foo", "foo" ]</span></code></pre><h2 id="import-函数"><a href="#import-函数" class="headerlink" title="import()函数"></a>import()函数</h2><p>这个特性为JavaScript添加了一个类函数（function-like）的<code>import()</code>功能，以便可以像函数传参那样传入参数实现<strong>动态</strong>（没错，<code>import</code>是静态引用的）引用模块（module）。下面有个单页应用简单示例，演示了用<code>import()</code>开启懒加载。</p><pre class=" language-markup"><code class="language-markup"><span class="token doctype">&lt;!DOCTYPE html></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>nav</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>books.html<span class="token punctuation">"</span></span> <span class="token attr-name">data-entry-module</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>books<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>书籍<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>movies.html<span class="token punctuation">"</span></span> <span class="token attr-name">data-entry-module</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>movies<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>电影<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>video-games.html<span class="token punctuation">"</span></span> <span class="token attr-name">data-entry-module</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>video-games<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>电视游戏<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>nav</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>main</span><span class="token punctuation">></span></span>内容将会加载到这里！<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>main</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">  <span class="token keyword">const</span> main <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">"main"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> link <span class="token keyword">of</span> document<span class="token punctuation">.</span><span class="token function">querySelectorAll</span><span class="token punctuation">(</span><span class="token string">"nav > a"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    link<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"click"</span><span class="token punctuation">,</span> e <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      e<span class="token punctuation">.</span><span class="token function">preventDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`./section-modules/</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>link<span class="token punctuation">.</span>dataset<span class="token punctuation">.</span>entryModule<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">.js`</span></span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//动态引用</span>        <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>module <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//加载模块成功以后，该模块会当作then方法的参数</span>          module<span class="token punctuation">.</span><span class="token function">loadPageInto</span><span class="token punctuation">(</span>main<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span>err <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//捕捉异常</span>          main<span class="token punctuation">.</span>textContent <span class="token operator">=</span> err<span class="token punctuation">.</span>message<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre><p>请注意<code>import()</code>和<code>import</code>的区别：</p><ul><li>import() 可以用在script脚本区，不止是模块内；</li><li>如果在模块内使用import()，它可以在任何地方任何级别执行，而不是被提升到顶级（优先执行）；</li><li>import() 是运行时执行，也即什么时候运行到这句，就会加载参数指定的模块；参数也可以是动态可变的，不止是静态参数；</li><li>import() 不建立可静态分析的依赖关系（静态分析的情况下可以做很多优化），但是，在一些比较简单的情况下，比如<code>import（“/foo.js”）</code>中，实现仍然可以执行静态分析优化。</li></ul><p>如果模块采用<code>default</code>的形式对外暴露接口，则可用<code>default</code>属性直接获得。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'./module.js'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>module <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>module<span class="token punctuation">.</span><span class="token keyword">default</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//直接通过default属性获得模块暴露的接口</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="Promise-allSettled"><a href="#Promise-allSettled" class="headerlink" title="Promise.allSettled"></a>Promise.allSettled</h2><p>为什么要有<code>Promise.allSettled()</code>？</p><p>举例说明，比如各位用户在页面上面同时填了3个独立的表单，这三个表单分三个接口提交到后端，三个接口独立，没有顺序依赖，这个时候我们需要等到请求全部完成后给与用户提示表单提交的情况。</p><p>在多个<code>promise</code>同时进行时咱们很快会想到使用<code>Promise.all</code>来进行包装，但是由于<code>Promise.all</code>的一票否决的特性，三个提交中若前面任意一个提交失败，则后面的表单也不会进行提交了，这就与咱们需求不符合。</p><p><code>Promise.allSettled</code>跟<code>Promise.all</code>类似，其参数接受一个<code>Promise</code>的数组，返回一个新的<code>Promise</code>，唯一的不同在于，其没有一票否决的特性，也就是说当<code>Promise</code>全部处理完成后我们可以拿到每个<code>Promise</code>的状态，而不管其是否处理成功。</p><pre class=" language-javascript"><code class="language-javascript">Promise<span class="token punctuation">.</span><span class="token function">allSettled</span><span class="token punctuation">(</span><span class="token punctuation">[</span>Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">"coffe"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span><span class="token string">"1891"</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>  arr <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//>> [ { status: "fulfilled", value: "coffe"},</span>                      <span class="token comment" spellcheck="true">//>>   { status: "rejected", reason: "1891" } ]</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="Bigint"><a href="#Bigint" class="headerlink" title="Bigint"></a>Bigint</h2><p>JavasSript 在数学计算领域很糟糕的原因之一是它只能安全的表示<code>-(2^53-1)</code>至 <code>2^53-1</code> 范的值，即<code>Number.MIN_SAFE_INTEGER</code> 至<code>Number.MAX_SAFE_INTEGER</code>，超出这个范围的整数计算或者表示会丢失精度。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> num <span class="token operator">=</span> Number<span class="token punctuation">.</span>MAX_SAFE_INTEGER<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// >> 9007199254740991</span>num <span class="token operator">=</span> num <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// >> 9007199254740992</span><span class="token comment" spellcheck="true">// 再次加 +1 后无法正常运算</span>num <span class="token operator">=</span> num <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// >> 9007199254740992</span><span class="token comment" spellcheck="true">// 两个不同的值，却返回了true</span><span class="token number">9007199254740992</span> <span class="token operator">===</span> <span class="token number">9007199254740993</span>  <span class="token comment" spellcheck="true">// >> true</span></code></pre><p>于是 BigInt 诞生了，<strong>它是JavaScript的第7个原始类型</strong>，可安全地进行大数整型计算。 你可以在BigInt上使用与普通数字相同的运算符，例如 +, -, /, *, %等等。</p><p>创建 BigInt 类型的值也非常简单，只需要在数字后面加上 <code>n</code> 即可。例如，123 变为 123n。也可以使用全局方法 BigInt(value) 转化，入参 value 为数字或数字字符串。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> aNumber <span class="token operator">=</span> <span class="token number">1891</span><span class="token punctuation">;</span><span class="token keyword">const</span> aBigInt <span class="token operator">=</span> <span class="token function">BigInt</span><span class="token punctuation">(</span>aNumber<span class="token punctuation">)</span><span class="token punctuation">;</span>aBigInt <span class="token operator">===</span> 1891n <span class="token comment" spellcheck="true">// true</span><span class="token keyword">typeof</span> aBigInt <span class="token operator">===</span> <span class="token string">'bigint'</span> <span class="token comment" spellcheck="true">// true</span><span class="token keyword">typeof</span> <span class="token number">1891</span> <span class="token comment" spellcheck="true">// "number"</span><span class="token keyword">typeof</span> 1891n <span class="token comment" spellcheck="true">// "bigint"</span></code></pre><p>只要在数字末尾加上 n，就可以正确计算大数：</p><pre class=" language-javascript"><code class="language-javascript">1234567890123456789n <span class="token operator">*</span> 123n<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// -> 151851850485185185047n</span></code></pre><p>最后要注意，不能将 BigInt与Number混合使用。比较Number和 BigInt是可以的，但是不能把它们相加。</p><pre class=" language-javascript"><code class="language-javascript">1n <span class="token operator">&lt;</span> <span class="token number">2</span> <span class="token comment" spellcheck="true">// true</span>1n <span class="token operator">+</span> <span class="token number">2</span> <span class="token comment" spellcheck="true">// Uncaught TypeError: Cannot mix BigInt and other types, use explicit conversions</span></code></pre><h2 id="globalThis"><a href="#globalThis" class="headerlink" title="globalThis"></a>globalThis</h2><p>globalThis 是一个全新的标准方法用来获取全局 this 。之前开发者会通过如下的一些方法获取：</p><ul><li>全局变量 window：是一个经典的获取全局对象的方法。但是它在 Node.js 和 Web Workers 中并不能使用</li><li>全局变量 self：通常只在 Web Workers 和浏览器中生效。但是它不支持 Node.js。一些人会通过判断 self 是否存在识别代码是否运行在 Web Workers 和浏览器中</li><li>全局变量 global：只在 Node.js 中生效</li></ul><p>过去获取全局对象，可通过一个全局函数：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// ES10之前的解决方案</span><span class="token keyword">const</span> getGlobal <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> self <span class="token operator">!==</span> <span class="token string">'undefined'</span><span class="token punctuation">)</span> <span class="token keyword">return</span> self  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> window <span class="token operator">!==</span> <span class="token string">'undefined'</span><span class="token punctuation">)</span> <span class="token keyword">return</span> window  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> global <span class="token operator">!==</span> <span class="token string">'undefined'</span><span class="token punctuation">)</span> <span class="token keyword">return</span> global  <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'unable to locate global object'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// ES10内置</span>globalThis<span class="token punctuation">.</span><span class="token function">Array</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// [0,1,2]</span><span class="token comment" spellcheck="true">// 定义一个全局对象v = { value:true } ,ES10用如下方式定义</span>globalThis<span class="token punctuation">.</span>v <span class="token operator">=</span> <span class="token punctuation">{</span> value<span class="token punctuation">:</span><span class="token boolean">true</span> <span class="token punctuation">}</span></code></pre><p>而 <strong>globalThis 目的就是提供一种标准化方式访问全局对象</strong>，有了 globalThis 后，你可以在任意上下文，任意时刻都能获取到全局对象。如果您在浏览器上，globalThis将为window，如果您在Node上，globalThis则将为global。因此，不再需要考虑不同的环境问题。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// worker</span>globalThis <span class="token operator">===</span> self<span class="token comment" spellcheck="true">// node</span>globalThis <span class="token operator">===</span> global<span class="token comment" spellcheck="true">// browser</span>globalThis <span class="token operator">===</span> window</code></pre><h1 id="ES-2021-ES12-等2021年发布"><a href="#ES-2021-ES12-等2021年发布" class="headerlink" title="ES 2021 (ES12) 等2021年发布"></a>ES 2021 (ES12) 等2021年发布</h1><table><thead><tr><th align="left">新特性</th><th align="left">中文说明</th></tr></thead><tbody><tr><td align="left">String.prototype.replaceAll</td><td align="left">替换所有符合的字符串</td></tr><tr><td align="left">Promise.any</td><td align="left">返回Promise列表中第一个resolve的结果状态</td></tr><tr><td align="left">WeakRefs</td><td align="left"></td></tr><tr><td align="left">逻辑运算符和赋值表达式</td><td align="left"></td></tr><tr><td align="left">数字分隔符</td><td align="left"></td></tr></tbody></table><h2 id="replaceAll"><a href="#replaceAll" class="headerlink" title="replaceAll"></a>replaceAll</h2><p>看到replaceAll这个词，相比很容易联想到replace。在JavaScript中，replace方法只能是替换字符串中匹配到的第一个实例字符，而不能进行全局多项匹配替换，唯一的办法是通过正则表达式进行相关规则匹配替换，而replaceAll则是返回一个全新的字符串，所有符合匹配规则的字符都将被替换掉，替换规则可以是字符串或者正则表达式。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> string <span class="token operator">=</span> <span class="token string">'I like javaScript,I like css'</span><span class="token comment" spellcheck="true">//使用replace</span><span class="token keyword">let</span> replaceStr <span class="token operator">=</span> string<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">'like'</span><span class="token punctuation">,</span><span class="token string">'love'</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>replaceStr<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 'I love javaScript,I like css'</span><span class="token comment" spellcheck="true">//replace使用正则匹配所有</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>string<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex">/like/g</span><span class="token punctuation">,</span><span class="token string">'love'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 'I love javaScript,I love css'</span><span class="token comment" spellcheck="true">//使用replaceAll</span><span class="token keyword">let</span> replaceAllStr <span class="token operator">=</span> string<span class="token punctuation">.</span><span class="token function">replaceAll</span><span class="token punctuation">(</span><span class="token string">'like'</span><span class="token punctuation">,</span><span class="token string">'love'</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>replaceAllStr<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 'I love javaScript,I love css'</span></code></pre><h2 id="Promise-any"><a href="#Promise-any" class="headerlink" title="Promise.any"></a>Promise.any</h2><p>当Promise列表中的任意一个promise成功resolve则返回第一个resolve的结果状态。</p><pre class=" language-javascript"><code class="language-javascript">Promise<span class="token punctuation">.</span><span class="token function">any</span><span class="token punctuation">(</span><span class="token punctuation">[</span>  <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">setTimeout</span><span class="token punctuation">(</span>reject<span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">,</span> <span class="token string">'哎呀，我被拒绝了'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">setTimeout</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">,</span> <span class="token string">'哎呀，她接受我了'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">setTimeout</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">,</span> <span class="token string">'哎呀，她也接受我了'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>value <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`输出结果: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>value<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">err</span> <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//输出结果:哎呀，她接受我了</span></code></pre><p>如果所有的promise均reject，则抛出异常表示所有请求失败。</p><pre class=" language-javascript"><code class="language-javascript">Promise<span class="token punctuation">.</span><span class="token function">any</span><span class="token punctuation">(</span><span class="token punctuation">[</span>  Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span><span class="token string">'Error 1'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span><span class="token string">'Error 2'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span><span class="token string">'Error 3'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>value <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`请求结果: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>value<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">err</span> <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//输出</span>AggregateError<span class="token punctuation">:</span> All promises were rejected</code></pre><h2 id="WeakRefs"><a href="#WeakRefs" class="headerlink" title="WeakRefs"></a>WeakRefs</h2><p>使用WeakRefs的Class类创建对对象的弱引用(对对象的弱引用是指当该对象应该被GC回收时不会阻止GC的回收行为)</p><p>当我们通过（const、let、var）创建一个变量时，垃圾收集器GC将永远不会从内存中删除该变量，只要它的引用仍然存在可访问。WeakRef对象包含对对象的弱引用。对对象的弱引用是不会阻止垃圾收集器GC恢复该对象的引用，则GC可以在任何时候删除它。</p><p>WeakRefs在很多情况下都很有用，比如使用Map对象来实现具有很多需要大量内存的键值缓存，在这种情况下最方便的就是尽快释放键值对占用的内存。</p><p>目前，可以通过WeakMap()或者WeakSet()来使用WeakRefs。</p><h2 id="数字分隔符"><a href="#数字分隔符" class="headerlink" title="数字分隔符"></a>数字分隔符</h2><p>数字分隔符，可以在数字之间创建可视化分隔符，通过_下划线来分割数字，使数字更具可读性。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> money <span class="token operator">=</span> 1_000_000_000<span class="token comment" spellcheck="true">//等价于</span><span class="token keyword">const</span> money <span class="token operator">=</span> <span class="token number">1000000000</span><span class="token keyword">const</span> totalFee <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">.</span>12_34<span class="token comment" spellcheck="true">//等价于</span><span class="token keyword">const</span> totalFee <span class="token operator">=</span> <span class="token number">1000.1234</span></code></pre><p>该新特性同样支持在八进制数中使用</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> number <span class="token operator">=</span> 0o123_456<span class="token comment" spellcheck="true">//等价于</span><span class="token keyword">const</span> number <span class="token operator">=</span> <span class="token number">0o123456</span></code></pre><h1 id="本篇结语"><a href="#本篇结语" class="headerlink" title="本篇结语"></a>本篇结语</h1><p>很显然ECMAScript接下来会持续不断地更新，按TC39的计划是每年都会发一个新版本。虽然节奏很快，但是我们完全没必要担心跟不上节奏。除了ES6这个史无前例的版本带来了超大量的新特性外，之后每年发的版本都仅仅带有少量的增量更新，你只需要花45分钟就能搞明白这一年更新的特性。保持一颗好奇的心，你会不断进步，变得更强！</p>]]></content>
      
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spread和rest操作符</title>
      <link href="2020/11/09/spread-he-rest-cao-zuo-fu/"/>
      <url>2020/11/09/spread-he-rest-cao-zuo-fu/</url>
      
        <content type="html"><![CDATA[<h1 id="spread和rest的区别"><a href="#spread和rest的区别" class="headerlink" title="spread和rest的区别"></a>spread和rest的区别</h1><p>spread和rest运算符都是<code>...</code>+<code>变量/参数</code>的形式。是spread还是rest，要根据上下文情境来判断。</p><h2 id="1-spread"><a href="#1-spread" class="headerlink" title="1.spread"></a>1.spread</h2><p>当被用于迭代器中时，它是 spread 操作符：</p><pre class=" language-javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">...</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 1 2 3 4 5</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">...</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//[1,2,3,4,5]</span></code></pre><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">const</span> numbers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">38</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token operator">...</span>numbers<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 42</span></code></pre><p>spread主要形式是<code>...[Array]</code>，表示对数组的展开。</p><h2 id="2-rest"><a href="#2-rest" class="headerlink" title="2.rest"></a>2.rest</h2><p>当被用于定义函数的参数时，是 rest 操作符：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">...</span>items<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>items<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span><span class="token function">push</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//[4,1,2,3]</span></code></pre><p>rest主要是将函数的多个参数转化成数组，<strong>而且只能放在函数参数的最后一个位置</strong>，否则，比如<code>（array,...items,other）</code>会报错。 </p><p>而rest的出现，让已经不被推荐使用的<code>arguments</code>彻底寿终正寝了。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span> <span class="token punctuation">{</span>   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>args<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">...</span>arguments<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//spread形式的用法</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//>> 1,2,3</span><span class="token comment" spellcheck="true">//>> 1,2,3</span></code></pre><h1 id="用法示例"><a href="#用法示例" class="headerlink" title="用法示例"></a>用法示例</h1><h2 id="1-添加属性"><a href="#1-添加属性" class="headerlink" title="1.添加属性"></a>1.添加属性</h2><p>克隆一个对象，同时向(浅)拷贝对象添加附加属性。<br>在这个示例中，user 被(浅)拷贝，password 属性被添加到 userWithPass 中。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> user <span class="token operator">=</span> <span class="token punctuation">{</span> id<span class="token punctuation">:</span> <span class="token number">100</span><span class="token punctuation">,</span> name<span class="token punctuation">:</span> <span class="token string">'Howard Moon'</span><span class="token punctuation">}</span><span class="token keyword">const</span> userWithPass <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token operator">...</span>user<span class="token punctuation">,</span> password<span class="token punctuation">:</span> <span class="token string">'Password!'</span> <span class="token punctuation">}</span>user <span class="token comment" spellcheck="true">//>> { id: 100, name: 'Howard Moon' }</span>userWithPass <span class="token comment" spellcheck="true">//>> { id: 100, name: 'Howard Moon', password: 'Password!' }</span></code></pre><h2 id="2-对象合并"><a href="#2-对象合并" class="headerlink" title="2.对象合并"></a>2.对象合并</h2><p>将两个对象合并到一个新对象中。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> part1 <span class="token operator">=</span> <span class="token punctuation">{</span> id<span class="token punctuation">:</span> <span class="token number">100</span><span class="token punctuation">,</span> name<span class="token punctuation">:</span> <span class="token string">'Howard Moon'</span> <span class="token punctuation">}</span><span class="token keyword">const</span> part2 <span class="token operator">=</span> <span class="token punctuation">{</span> id<span class="token punctuation">:</span> <span class="token number">100</span><span class="token punctuation">,</span> password<span class="token punctuation">:</span> <span class="token string">'Password!'</span> <span class="token punctuation">}</span><span class="token keyword">const</span> user1 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token operator">...</span>part1<span class="token punctuation">,</span> <span class="token operator">...</span>part2 <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//>> { id: 100, name: 'Howard Moon', password: 'Password!' }</span></code></pre><p>对象也可以使用以下语法合并：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> partial <span class="token operator">=</span> <span class="token punctuation">{</span> id<span class="token punctuation">:</span> <span class="token number">100</span><span class="token punctuation">,</span> name<span class="token punctuation">:</span> <span class="token string">'Howard Moon'</span> <span class="token punctuation">}</span><span class="token keyword">const</span> user <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token operator">...</span>partial<span class="token punctuation">,</span> id<span class="token punctuation">:</span> <span class="token number">100</span><span class="token punctuation">,</span> password<span class="token punctuation">:</span> <span class="token string">'Password!'</span> <span class="token punctuation">}</span>user <span class="token comment" spellcheck="true">//>> { id: 100, name: 'Howard Moon', password: 'Password!' }</span></code></pre><h2 id="3-排除对象属性"><a href="#3-排除对象属性" class="headerlink" title="3.排除对象属性"></a>3.排除对象属性</h2><p>可以结合使用 rest 运算符删除属性。 在下面这个例子里，password 被删除 ，其余的属性作为 rest 返回。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> noPassword <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> password<span class="token punctuation">,</span> <span class="token operator">...</span>rest <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> rest<span class="token keyword">const</span> user <span class="token operator">=</span> <span class="token punctuation">{</span>  id<span class="token punctuation">:</span> <span class="token number">100</span><span class="token punctuation">,</span>  name<span class="token punctuation">:</span> <span class="token string">'coffe1891'</span><span class="token punctuation">,</span>  password<span class="token punctuation">:</span> <span class="token string">'Password!'</span><span class="token punctuation">}</span><span class="token function">noPassword</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//>> { id: 100, name: 'coffe1891' }</span></code></pre><h2 id="4-动态排除属性"><a href="#4-动态排除属性" class="headerlink" title="4.动态排除属性"></a>4.动态排除属性</h2><p>函数接受一个 prop 作为参数。使用计算对象属性名称，可以从克隆中动态地删除属性。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> user1 <span class="token operator">=</span> <span class="token punctuation">{</span>  id<span class="token punctuation">:</span> <span class="token number">100</span><span class="token punctuation">,</span>  name<span class="token punctuation">:</span> <span class="token string">'coffe1891'</span><span class="token punctuation">,</span>  password<span class="token punctuation">:</span> <span class="token string">'Password!'</span><span class="token punctuation">}</span><span class="token keyword">const</span> removeProperty <span class="token operator">=</span> prop <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token punctuation">[</span>prop<span class="token punctuation">]</span><span class="token punctuation">:</span> _<span class="token punctuation">,</span> <span class="token operator">...</span>rest <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> rest<span class="token comment" spellcheck="true">//                     ----       ------</span><span class="token comment" spellcheck="true">//                          \   /</span><span class="token comment" spellcheck="true">//                dynamic destructuring</span><span class="token keyword">const</span> removePassword <span class="token operator">=</span> <span class="token function">removeProperty</span><span class="token punctuation">(</span><span class="token string">'password'</span><span class="token punctuation">)</span><span class="token keyword">const</span> removeId <span class="token operator">=</span> <span class="token function">removeProperty</span><span class="token punctuation">(</span><span class="token string">'id'</span><span class="token punctuation">)</span><span class="token function">removePassword</span><span class="token punctuation">(</span>user1<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//>> { id: 100, name: 'coffe1891' }</span><span class="token function">removeId</span><span class="token punctuation">(</span>user1<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//>> { name: 'coffe1891', password: 'Password!' }</span></code></pre><h2 id="5-对属性进行排序"><a href="#5-对属性进行排序" class="headerlink" title="5.对属性进行排序"></a>5.对属性进行排序</h2><p>有时性质并不按照我们需要的顺序排列。 使用一些技巧，我们可以将属性推到列表的顶部，或者将它们移到底部。若要将 id 移动到第一个位置，在扩展对象之前将 <code>id: undefined</code> 添加到新的 Object 最前面。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> user3 <span class="token operator">=</span> <span class="token punctuation">{</span>  password<span class="token punctuation">:</span> <span class="token string">'Password!'</span><span class="token punctuation">,</span>  name<span class="token punctuation">:</span> <span class="token string">'Naboo'</span><span class="token punctuation">,</span>  id<span class="token punctuation">:</span> <span class="token number">300</span><span class="token punctuation">}</span><span class="token keyword">const</span> organize <span class="token operator">=</span> object <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">(</span><span class="token punctuation">{</span> id<span class="token punctuation">:</span> undefined<span class="token punctuation">,</span> <span class="token operator">...</span>object <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//                            -------------</span><span class="token comment" spellcheck="true">//                          /</span><span class="token comment" spellcheck="true">//  move id to the first property</span><span class="token function">organize</span><span class="token punctuation">(</span>user3<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//>> { id: 300, password: 'Password!', name: 'Naboo' }</span></code></pre><p>若要将 password 移到最后一个属性，请从对象中解构 password。然后在使用 Rest 操作符后重新设置 password 属性。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> user3 <span class="token operator">=</span> <span class="token punctuation">{</span>  password<span class="token punctuation">:</span> <span class="token string">'Password!'</span><span class="token punctuation">,</span>  name<span class="token punctuation">:</span> <span class="token string">'Naboo'</span><span class="token punctuation">,</span>  id<span class="token punctuation">:</span> <span class="token number">300</span><span class="token punctuation">}</span><span class="token keyword">const</span> organize <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> password<span class="token punctuation">,</span> <span class="token operator">...</span>object <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span>  <span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token operator">...</span>object<span class="token punctuation">,</span> password <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//              --------</span><span class="token comment" spellcheck="true">//             /</span><span class="token comment" spellcheck="true">// move password to last property</span><span class="token function">organize</span><span class="token punctuation">(</span>user3<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//>> { name: 'Naboo', id: 300, password: 'Password!' }</span></code></pre><h2 id="6-默认属性"><a href="#6-默认属性" class="headerlink" title="6.默认属性"></a>6.默认属性</h2><p>默认属性是仅当它们不包含在原始对象中时才设置的值。<br>在本例中，user2 不包含 quotes 属性。 setdefaults 函数确保所有对象都设置了 quotes 属性，否则它将被设置为<code>[]</code>。<br>当调用 setDefaults (user2)时，返回值将包含 quotes 属性: <code>[]</code>。<br>在调用 setDefaults (user4)时，因为 user4 已经有了 quotes 属性，所以不会修改该属性。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> user2 <span class="token operator">=</span> <span class="token punctuation">{</span>  id<span class="token punctuation">:</span> <span class="token number">200</span><span class="token punctuation">,</span>  name<span class="token punctuation">:</span> <span class="token string">'Vince Noir'</span><span class="token punctuation">}</span><span class="token keyword">const</span> user4 <span class="token operator">=</span> <span class="token punctuation">{</span>  id<span class="token punctuation">:</span> <span class="token number">400</span><span class="token punctuation">,</span>  name<span class="token punctuation">:</span> <span class="token string">'Bollo'</span><span class="token punctuation">,</span>  quotes<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"I've got a bad feeling about this..."</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token keyword">const</span> setDefaults <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> quotes <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">...</span>object<span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span>  <span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token operator">...</span>object<span class="token punctuation">,</span> quotes <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token function">setDefaults</span><span class="token punctuation">(</span>user2<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//>> { id: 200, name: 'Vince Noir', quotes: [] }</span><span class="token function">setDefaults</span><span class="token punctuation">(</span>user4<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//>> {</span><span class="token comment" spellcheck="true">//>>   id: 400,</span><span class="token comment" spellcheck="true">//>>   name: 'Bollo',</span><span class="token comment" spellcheck="true">//>>   quotes: ["I've got a bad feeling about this..."]</span><span class="token comment" spellcheck="true">//>> }</span></code></pre><p>如果你希望默认值先出现而不是后出现，也可以这样写：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> setDefaults <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token operator">...</span>object<span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">(</span><span class="token punctuation">{</span> quotes<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">...</span>object <span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><h2 id="7-属性重命名"><a href="#7-属性重命名" class="headerlink" title="7.属性重命名"></a>7.属性重命名</h2><p>通过结合上面的技术，可以创建一个函数来重命名属性。假设有一些大写 ID 的对象属性名应该是小写的 id。 首先从对象解构 ID 然后在对象 Spread 时将其作为 id 添加回去。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> renamed <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> ID<span class="token punctuation">,</span> <span class="token operator">...</span>object <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">(</span><span class="token punctuation">{</span> id<span class="token punctuation">:</span> ID<span class="token punctuation">,</span> <span class="token operator">...</span>object <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">const</span> user <span class="token operator">=</span> <span class="token punctuation">{</span>  ID<span class="token punctuation">:</span> <span class="token number">500</span><span class="token punctuation">,</span>  name<span class="token punctuation">:</span> <span class="token string">"Bob Fossil"</span><span class="token punctuation">}</span><span class="token function">renamed</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//>> { id: 500, name: 'Bob Fossil' }</span></code></pre><h2 id="8-添加条件属性"><a href="#8-添加条件属性" class="headerlink" title="8.添加条件属性"></a>8.添加条件属性</h2><p>在这个例子中，只有当 password 是真实的时候才会添加 password。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> user <span class="token operator">=</span> <span class="token punctuation">{</span> id<span class="token punctuation">:</span> <span class="token number">100</span><span class="token punctuation">,</span> name<span class="token punctuation">:</span> <span class="token string">'Howard Moon'</span> <span class="token punctuation">}</span><span class="token keyword">const</span> password <span class="token operator">=</span> <span class="token string">'Password!'</span><span class="token keyword">const</span> userWithPassword <span class="token operator">=</span> <span class="token punctuation">{</span>  <span class="token operator">...</span>user<span class="token punctuation">,</span>  id<span class="token punctuation">:</span> <span class="token number">100</span><span class="token punctuation">,</span>  <span class="token operator">...</span><span class="token punctuation">(</span>password <span class="token operator">&amp;&amp;</span> <span class="token punctuation">{</span> password <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span>userWithPassword <span class="token comment" spellcheck="true">//>> { id: 100, name: 'Howard Moon', password: 'Password!' }</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue项目性能优化方案</title>
      <link href="2020/10/30/vue-xiang-mu-xing-neng-you-hua-fang-an/"/>
      <url>2020/10/30/vue-xiang-mu-xing-neng-you-hua-fang-an/</url>
      
        <content type="html"><![CDATA[<p><img src="https://7.dusays.com/2020/11/02/3ce96e73d8ee0.jpg" alt="vue.jpg"></p><h1 id="按需使用第三方库"><a href="#按需使用第三方库" class="headerlink" title="按需使用第三方库"></a>按需使用第三方库</h1><p>项目引入过多的第三方库会增大项目体积，带来性能问题<br>。以 Bootstrap 为例，如果你只是用一下它的响应式机制，还不如自己手写相关的 CSS，也不会太复杂，完全没有必要引入整个库。moment.js，Lodash.js这些库为了普适性，提供了尽可能多的功能，但你的项目可能只用了极少部分。我们不鼓励重复造轮子，但是要按需引入。现在很多库都提供了 ES 模块化的方式，也可以做到这一点。</p><p>采用按需引入的方式引入第三方组件，减少在入口文件全局引入。</p><h1 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a>路由懒加载</h1><p>路由懒加载也可以提高入口页面的加载速度，因为很多路由页面在多数情况下并没有被访问，在打包的时候放到单独的文件里可以减少入口页的体积。路由懒加载是通过 webpack 的动态 import来实现的。</p><pre><code>// in router.jsimport Home from '@/views/Home.vue'; // 静态 importconst About = () =&gt; import('@/views/About.vue'); // 动态 importconst router = new VueRouter({  routes: [    { path: '/', component: Home },    { path: '/about', component: About }  ]})</code></pre><p>另外，这些懒加载的路由还可以分组，让相关性模块的多个路由页面打包到同一个 chunk，算是一种折中方案：既实现了按需加载，又不会过于碎片化。适用于子路由页面。</p><pre><code>// in router.jsimport Home from '@/views/Home.vue'; // traditonal importsimport User from '@/views/User.vue';const About = () =&gt;  import('@/views/About.vue'); // dynamic importconst router = new VueRouter({  routes: [    { path: '/', component: Home },    { path: '/about', component: About },    { path: '/user/:id', component: User,       children: [        {          path: '/settings',          component: () =&gt; import(/* webpackChunkName: "user" */ '@/views/UserSettings')        },        {          path: '/articles',          component: () =&gt; import(/* webpackChunkName: "user" */ '@/views/UserArticles')        }      ]    }   ]})</code></pre><p>这是通过 webpack 的注释语法/* webpackChunkName: “user” */实现的，webpackChunkName相同的路由会打进同一个 chunk文件。</p><h1 id="只做展示用数据禁用响应式"><a href="#只做展示用数据禁用响应式" class="headerlink" title="只做展示用数据禁用响应式"></a>只做展示用数据禁用响应式</h1><p>默认情况下，定义在 Vue 组件data 里的数据都是响应式的，这种机制方便了数据绑定，当数据变化时界面得到自动更新。但有时候我们只是将数据显示到界面上，之后也不会改变它。这种情况下我们根本用不上响应式机制，而实现响应式是有性能代价的，特别是对于大对象和大列表。</p><p>建议将data还有Vuex 里面只用于展示的数据通过Object.freeze()禁用对象的响应式特性。</p><h1 id="资源释放"><a href="#资源释放" class="headerlink" title="资源释放"></a>资源释放</h1><ol><li> 如果在mounted/created 钩子中使用了$on，需要在beforeDestroy 中做对应解绑($off)处理</li><li> 如果在mounted/created 钩子中绑定了DOM/BOM 对象中的事件，需要在beforeDestroy 中做对应解绑处理</li><li> 如果在mounted/created 钩子中使用了第三方库初始化，需要在beforeDestroy 中做对应销毁处理</li><li> 如果使用setTimeout setInterval需要在beforeDestroy中做对应销毁处理，（最好不用）可以使用nextTick代替</li><li> 模块形成的闭包内部变量使用完后没有置成null</li><li> 全局变量没有回收</li><li> 绑在EventBus的事件没有解绑，注册的总线事件（Bus）要在组件销毁时(beforeDestroy/destroyed)卸载</li></ol><h1 id="v-if-和-v-show-区分使用场景"><a href="#v-if-和-v-show-区分使用场景" class="headerlink" title="v-if 和 v-show 区分使用场景"></a>v-if 和 v-show 区分使用场景</h1><p>v-if&nbsp;是&nbsp;真正&nbsp;的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</p><p>v-show&nbsp;就简单得多， 不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 的 display 属性进行切换。</p><p>所以，v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景；v-show 则适用于需要非常频繁切换条件的场景。</p><h1 id="computed-和-watch-区分使用场景"><a href="#computed-和-watch-区分使用场景" class="headerlink" title="computed 和 watch &nbsp;区分使用场景"></a>computed 和 watch &nbsp;区分使用场景</h1><p>（1）computed：&nbsp;是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed &nbsp;的值；</p><p>（2） watch：&nbsp;更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；</p><p>运用场景：</p><p>当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；</p><p>当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</p><h1 id="v-for-遍历必须为-item-添加-key，且避免同时使用-v-if"><a href="#v-for-遍历必须为-item-添加-key，且避免同时使用-v-if" class="headerlink" title="v-for 遍历必须为 item 添加 key，且避免同时使用 v-if"></a>v-for 遍历必须为 item 添加 key，且避免同时使用 v-if</h1><p>（1）v-for 遍历必须为 item 添加 key</p><p>在列表数据进行遍历渲染时，需要为每一项 item 设置唯一 key 值，方便 Vue.js 内部机制精准找到该条列表数据。当 state 更新时，新的状态值和旧的状态值对比，较快地定位到 diff 。</p><p>（2）v-for 遍历避免同时使用 v-if</p><p>v-for 比 v-if 优先级高，如果每一次都需要遍历整个数组，将会影响速度，尤其是当之需要渲染很小一部分的时候，必要情况下应该替换成 computed 属性。</p><pre><code>&lt;ul&gt;  &lt;li    v-for="user in activeUsers"    :key="user.id"&gt;    {{ user.name }}  &lt;/li&gt;&lt;/ul&gt;computed: {  activeUsers: function () {    return this.users.filter(function (user) {   return user.isActive    })  }}</code></pre><h1 id="减少-ES6-转为-ES5-的冗余代码"><a href="#减少-ES6-转为-ES5-的冗余代码" class="headerlink" title="减少 ES6 转为 ES5 的冗余代码"></a>减少 ES6 转为 ES5 的冗余代码</h1><p>Babel 插件会在将 ES6 代码转换成 ES5 代码时会注入一些辅助函数，例如下面的 ES6 代码：</p><pre><code>class HelloWebpack extends Component{...}</code></pre><p>这段代码再被转换成能正常运行的 ES5 代码时需要以下两个辅助函数：</p><pre><code>babel-runtime/helpers/createClass  // 用于实现 class 语法babel-runtime/helpers/inherits  // 用于实现 extends 语法</code></pre><p>在默认情况下， Babel 会在每个输出文件中内嵌这些依赖的辅助函数代码，如果多个源代码文件都依赖这些辅助函数，那么这些辅助函数的代码将会出现很多次，造成代码冗余。为了不让这些辅助函数的代码重复出现，可以在依赖它们时通过&nbsp;require(‘babel-runtime/helpers/createClass’)&nbsp;的方式导入，这样就能做到只让它们出现一次。babel-plugin-transform-runtime&nbsp;插件就是用来实现这个作用的，将相关辅助函数进行替换成导入语句，从而减小 babel 编译出来的代码的文件大小。</p><p>首先，安装 babel-plugin-transform-runtime ：</p><pre><code>npm install babel-plugin-transform-runtime --save-dev</code></pre><p>然后，修改 .babelrc  配置文件为：</p><pre><code>"plugins": [    "transform-runtime"]</code></pre><h1 id="开启gzip压缩"><a href="#开启gzip压缩" class="headerlink" title="开启gzip压缩"></a>开启gzip压缩</h1><p>首先，修改productionGzip 为true,<br>安装 compression-webpack-plugin ：</p><pre><code> //  npm install --save-dev compression-webpack-plugin  //(此处有坑) 如果打包报错，应该是版本问题 ，先卸载之前安装的此插件 ，然后安装低版本   npm install --save-dev compression-webpack-plugin@1.1.11</code></pre><p>修改nginx的配置</p><pre><code>http {  //在 http中配置如下代码，   gzip on;   gzip_disable "msie6";    gzip_vary on;    gzip_proxied any;   gzip_comp_level 8; #压缩级别   gzip_buffers 16 8k;   #gzip_http_version 1.1;   gzip_min_length 100; #不压缩临界值   gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png; }</code></pre><h1 id="图片懒加载"><a href="#图片懒加载" class="headerlink" title="图片懒加载"></a>图片懒加载</h1><p>如果应用里需要展示大量图片，通常的做法是懒加载图片。懒加载的基本原理是提前准备好图片 URL，当图片真正进入可视范围时才去加载。可以手动实现懒加载机制，不过更方便的是直接用现成的插件，比如 [vue-lazyload]<br>安装：</p><pre><code>npm i vue-lazyload -S</code></pre><p>引入：</p><pre><code>import VueLazyload from 'vue-lazyload'Vue.use(VueLazyload)</code></pre><p>使用：</p><pre><code> &lt;ul&gt;    &lt;li v-for="img in list"&gt;      &lt;img v-lazy="img.src"&gt;    &lt;/li&gt;  &lt;/ul&gt;</code></pre><h1 id="cdn加速"><a href="#cdn加速" class="headerlink" title="cdn加速"></a>cdn加速</h1><p>采用cdn加速去从别的服务器上加载第三方库而非自己的服务器，这样就会快很多.并且能节省自己服务器的带宽。</p><p>首先，在index.html中 将你所需的第三方库的链接加载进来：</p><pre><code>&lt;script src="https://cdn.bootcdn.net/ajax/libs/vue/3.0.0-beta.18/vue.cjs.js"&gt;&lt;/script&gt;</code></pre><p>在webpack.base.conf 中添加 externals 来告诉webpack我们这些第三方库不需要打包</p><pre><code>externals:{    // key表示第三方插件名称，value是暴露出的全局变量    'vue':'Vue'}</code></pre><p>在 主文件main.js 或者其他 js 修改引用这些配置的第三方插件</p><pre><code>// import Vue from 'vue';const Vue = require('vue');</code></pre><h1 id="Webpack-对图片进行压缩"><a href="#Webpack-对图片进行压缩" class="headerlink" title="Webpack 对图片进行压缩"></a>Webpack 对图片进行压缩</h1><p>安装 image-webpack-loader ：</p><pre><code>npm install image-webpack-loader --save-dev</code></pre><p>然后，在 webpack.base.conf.js  中进行配置：</p><pre><code>{  test: /\.(png|jpe?g|gif|svg)(\?.*)?$/,  use:[     {      loader: 'url-loader',      options: {        limit: 10000 ,        name: '[path][name].[ext]?[hash:6]!./dir/file.png'      }    },    /*对图片进行压缩*/    {      loader: 'image-webpack-loader',      query: {        progressive: true,        optimizationLevel: 7,        interlaced: false,        pngquant: {          quality: '65-90',          speed: 4        }      }    }  ]}</code></pre><h1 id="pax-ui框架相关"><a href="#pax-ui框架相关" class="headerlink" title="pax-ui框架相关"></a>pax-ui框架相关</h1><p>（1） 表单组件<br>pax组件的Form表单组件会对绑定数据监听，表单组件很多的情况下页面会卡顿，在pax-form上设置局部更新，会提升一部分性能。</p><pre><code>&lt;pax-form :form="form" :selfUpdate="true"&gt;&lt;/pax-form&gt;</code></pre><p>(2) select组件<br>select大数据量情况下，会造成页面元素较多，在ie上消耗更多的内存。建议采用虚拟滚动的方式：</p><pre><code>import { RecycleScroller} from 'vue-virtual-scroller';// 在Select预留卡槽中使用详情见文档：IE浏览器select大数据问题造成输入不流畅分析处理</code></pre><p>（3）tree组件<br>pax-tree在ie上问题严重,如果兼容ie，建议用@pa/vue-org-tree,使用方法参考ztree.js</p><pre><code>npm install @pa/vue-org-tree --save-dev</code></pre>]]></content>
      
      
      <categories>
          
          <category> 新鲜技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript在vue项目中的应用</title>
      <link href="2020/10/30/ts-zai-vue-xiang-mu-zhong-de-ying-yong/"/>
      <url>2020/10/30/ts-zai-vue-xiang-mu-zhong-de-ying-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="1-引言"><a href="#1-引言" class="headerlink" title="1 引言"></a>1 引言</h1><p>TypeScript 是一种由微软开发的自由和开源的编程语言。它是 JavaScript 的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程。</p><p>TypeScript 优势：</p><ul><li>静态类型检查与代码提示</li><li>适用大型项目开发，如代码重构等</li><li>更好的协作</li><li>更强的生产力</li></ul><h1 id="2-ts语法知识"><a href="#2-ts语法知识" class="headerlink" title="2 ts语法知识"></a>2 ts语法知识</h1><h2 id="2-1类型系统"><a href="#2-1类型系统" class="headerlink" title="2.1类型系统"></a>2.1类型系统</h2><p><img src="https://7.dusays.com/2020/11/02/056c4d4f841cf.png" alt="类型注解"></p><h2 id="2-2类型保护"><a href="#2-2类型保护" class="headerlink" title="2.2类型保护"></a>2.2类型保护</h2><blockquote><p>类型保护是可执行运行时检查的一种表达式，用于确保该类型在一定的范围内。</p></blockquote><ol><li>as 操作符（类型断言）<br>当你比 ts 更确定其数据类型，你能使用 as 语法确定其类型，但需要遵守类型兼容转换。 另外一种写法：<typename>varName，但不建议使用</typename></li></ol><pre><code>function getDynamicValue(): number | string | undefined {  ...}const v = getDynamicValue(); // v:number|string|undefined，联合类型变量只允许访问所有类型共有的属性// 确定返回 string(v as string).trim();</code></pre><ol start="2"><li>typeof 操作符</li></ol><pre><code>function isNumber(val: any): val is number {  return typeof val === 'number';}const a: any = 1;if (isNumber(a)) {  // a:number}</code></pre><ol start="3"><li>instanceof 操作符</li></ol><pre><code>class Base {  ...}class A extends Base {  ...}const inst: Base = new A();if (inst instanceof A) {  // inst:A}</code></pre><ol start="4"><li>函数或变量后面添加 !</li></ol><p>当要去掉联合类型的可空类型（null | undefined）,可以使用 js if 语句或短路运算符实现类型保护，也可以使用 Typescript 2.0+ !语法</p><pre><code>const x: string | null = getDynamicValue();// if判断if (x) {  // x:string}// 短路运算符function f(sn: string | null) {  return sn || '';}// !语法x!.trim();// orconst r = [1, 2, 3, 4].find(x =&gt; x === 3)!; // r:number</code></pre><h1 id="3-开发环境准备"><a href="#3-开发环境准备" class="headerlink" title="3 开发环境准备"></a>3 开发环境准备</h1><h2 id="3-1-插件安装"><a href="#3-1-插件安装" class="headerlink" title="3.1 插件安装"></a>3.1 插件安装</h2><h3 id="3-1-1-Webpack-转译-Typescript-现有方案"><a href="#3-1-1-Webpack-转译-Typescript-现有方案" class="headerlink" title="3.1.1 Webpack 转译 Typescript 现有方案"></a>3.1.1 Webpack 转译 Typescript 现有方案</h3><h4 id="1-ts-loader-babel-loader-fork-ts-checker-webpack-plugin"><a href="#1-ts-loader-babel-loader-fork-ts-checker-webpack-plugin" class="headerlink" title="1.ts-loader + babel-loader + fork-ts-checker-webpack-plugin"></a>1.ts-loader + babel-loader + fork-ts-checker-webpack-plugin</h4><p>修改 webpack.config.js 的配置：</p><pre><code>{     test: /\.ts?$/,     loader: "ts-loader",    options: {        // .vue文件必须加        appendTsSuffixTo: [/\.vue$/]    },    exclude:/node_modules/}</code></pre><p>每次重建时，类型脚本的语义检查器必须检查所有文件,随着项目变得越来越大，编译时间线性增加。这时我们使用 fork-ts-checker-webpack-plugin 另外开一个线程来进行类型检查，安装依赖：</p><pre><code>npm install -D fork-ts-checker-webpack-plugin//使用：const ForkTsCheckerWebpackPlugin = require('fork-ts-checker-webpack-plugin');plugins:[    new ForkTsCheckerWebpackPlugin()]</code></pre><ul><li>这种方案，当 webpack 编译的时候，ts-loader 会调用 typescript（所以本地项目需要安装 typescript），然后 typescript 运行的时候会去读取本地的 tsconfig.json 文件。</li><li>默认情况下，ts-loader 会进行 转译 和 类型检查，每当文件改动时，都会重新去 转译 和 类型检查，当文件很多的时候，就会特别慢，影响开发速度。所以需要使用 fork-ts-checker-webpack-plugin ，开辟一个单独的线程去执行类型检查的任务，这样就不会影响 webpack 重新编译的速度。</li><li>fork-ts-checker-webpack-plugin  这个插件要求最低 Node.js 6.11.5，webpack 4，TypeScript 2.1 和可选的 ESLint 6（其本身要求最低 Node.js 8.10.0）。</li></ul><h4 id="2-babel-loader-babel-preset-typescript"><a href="#2-babel-loader-babel-preset-typescript" class="headerlink" title="2. babel-loader + @babel/preset-typescript"></a>2. babel-loader + @babel/preset-typescript</h4><p>修改webpack.config.js</p><pre><code>rules: [        {          test:/\.(tsx?|jsx?)$/,          // 默认会调用 @babel/core           use:'babel-loader'        }]</code></pre><p>.babelrc</p><pre><code>{    "presets": [        "@babel/env"        "@vue/babel-preset-jsx",        "@babel/preset-typescript"    ]}</code></pre><ul><li>这种方案，当 webpack 编译的时候，babel-loader 会读取 .babelrc 里的配置，不会调用 typescript（所以本地项目无需安装 typescript），不会去检查类型</li><li> 需要配置tsconfig.json的，因为需要在开发代码时，让 idea 提示错误信息</li></ul><h2 id="3-2-ts项目基本构成"><a href="#3-2-ts项目基本构成" class="headerlink" title="3.2 ts项目基本构成"></a>3.2 ts项目基本构成</h2><p>一个vue+ts项目的目录结构（<a href="https://github.com/leeycode/typeScript-vue-starter/">typeScript-vue-starter</a>）：</p><pre><code>├── /@types/                     # 全局类型声明├── /build/                      # webpack配置文件├── /src/                        # 源码目录│ ├── /assets/                   # 静态资源目录│ ├── /components/               # 公共组件目录│ ├── /constants/                # 项目constants目录│ │ ├── _const.less              # less常量│ ├── /pages/                    # UI组件目录│ ├── /services/                 # 请求服务目录│ ├── /router/                   # 路由目录│ ├── /store/                    # 存放store文件目录│ ├── /style/                    # 全局样式│ ├── /utils/                    # utils目录│ │ ├── request.ts               # 基于fetch封装的API请求工具│ │ ├── global.ts                # 公共方法库│ └── main.ts                    # 项目入口|——tsconfig.json                 # ts配置|——...</code></pre><h2 id="3-3-tsconfig-json"><a href="#3-3-tsconfig-json" class="headerlink" title="3.3 tsconfig.json"></a>3.3 tsconfig.json</h2><p>在项目根目录下，这个json文件规定了ts的编译选项，相见的编译选项配置：</p><pre><code>{  "compilerOptions": {    "baseUrl": ".",                             // 用于解析非相对模块名称的基目录    "outDir": "build/dist",                     // 指定输出目录    "module": "esnext",                         // 指定使用模块: 'commonjs', 'amd', 'system', 'umd' or 'es2015'    "target": "es5",                            // 指定 ECMAScript 目标版本:    "lib": ["dom", "esnext"],                   // 指定要包含在编译中的库文件    "sourceMap": true,                          // 生成相应的 '.map' 文件    "allowJs": true,                            // 允许编译 javascript 文件    "jsx": "preserve",                          // 指定 jsx 代码的生成: 'preserve', 'react-native'等    "moduleResolution": "node",                 // 选择模块解析策略： 'node' (Node.js) or 'classic'    "strict": true                              // 启用所有严格类型检查选项    ...  },  "include": ["src/**/*", "@types/**/*"],       // 编译包含的文件     "exclude": [                                  // 排除的文件                    "node_modules",    "build",    "scripts",    "acceptance-tests",    "webpack",    "jest",    "src/setupTests.ts",    "config"  ]}</code></pre><h2 id="3-4-声明文件"><a href="#3-4-声明文件" class="headerlink" title="3.4 声明文件"></a>3.4 声明文件</h2><h3 id="types"><a href="#types" class="headerlink" title="@types"></a>@types</h3><p>安装第三方库之前，我们可以<a href="https://microsoft.github.io/TypeSearch//">搜索DefinitelyTyped</a>，查看是否有第三方在维护类型声明。通过@types安装，就能在项目中使用它的类型声明。</p><pre><code>- Partial :把 interface 所有属性变成可选// node_modules/typescript/lib/lib.es5.d.ts,安装ts的时候生成type Partial&lt;T&gt; = {    [P in keyof T]?: T[P];};changeFilter: (filter: Partial&lt;IRequsetParams&gt;) =&gt; void;- Event// node_modules/@types/react/index.d.ts,通过@types安装react的时候生成  handleClick = (e: React.MouseEvent&lt;HTMLDivElement, MouseEvent&gt;) =&gt; {    e.stopPropagation();  };- RouteComponentProps:提供了 location、history 的类型定义// node_modules/@types/react-router/index.d.tsexport interface ILoginProps extends RouteComponentProps {  login: (values: IUser, history: H.History) =&gt; void;}</code></pre><h3 id="自定义声明文件"><a href="#自定义声明文件" class="headerlink" title="自定义声明文件"></a>自定义声明文件</h3><p>扩展名.d.ts 结尾就是项目中的声明文件。在上面的项目中，我们创建了一个名为@types的文件夹，用来维护项目中需要的变量声明。</p><ol><li>全局变量声明<pre><code>// configdeclare const config: {version: string;systemName: string;debug: boolean;...}// 约束后台返回的数据 declare interface IResponseBody&lt;T&gt; {data: T;code: number;total: number;}...</code></pre></li><li>非js资源</li></ol><pre><code>declare module '*.svg';declare module '*.png';declare module '*.jpg';declare module '*.module.css';declare module '*.module.scss' </code></pre><h1 id="4-组件编写的几种方法"><a href="#4-组件编写的几种方法" class="headerlink" title="4 组件编写的几种方法"></a>4 组件编写的几种方法</h1><h2 id="4-1-Vue-extend"><a href="#4-1-Vue-extend" class="headerlink" title="4.1 Vue.extend()"></a>4.1 Vue.extend()</h2><blockquote><p>Vue.extend():使用基础 Vue 构造器，创建一个“子类”。 这种方式最接近 Vue 的单文件组件的写法，如果一个完善 Vue 项目从 JS 改成 TS，用这种方法很快，只要加上 lang=ts和一些必要的变量类型就好了，然后用Vue.extend()包裹就好。</p></blockquote><p>main.js 改为 main.ts 内容改成：</p><pre><code>import Vue from "vue";import App from "./App.vue";new Vue({    el:"#app",    render:h=&gt;h(App)});</code></pre><p>组件写法：</p><pre><code>&lt;template&gt;    &lt;h1&gt;{{name}}&lt;/h1&gt;&lt;/template&gt;&lt;script lang="ts"&gt;//也执行tsx,也就是jsx语法import Vue from "vue";export default Vue.extend({    data(){        return {            name:'liwu'        }    }})&lt;/script&gt;&lt;style scoped&gt;h1{    color: rgb(55, 142, 230);}&lt;/style&gt;</code></pre><h2 id="4-2-vue-class-component"><a href="#4-2-vue-class-component" class="headerlink" title="4.2 vue-class-component"></a>4.2 vue-class-component</h2><blockquote><p>通常和vue-property-decorator一起搭配使用，，vue-property-decorator是在vue-class-component上扩展来的，并且提供了很多修饰器比如 @Prop和@Watch等等，使用这个可以编写类式组件。</p></blockquote><p>1.组件写法：</p><pre><code>&lt;template&gt;    &lt;h1&gt;{{name}}&lt;/h1&gt;&lt;/template&gt;&lt;script lang="ts"&gt;import Vue from "vue";import Component from 'vue-class-component';// @Component 装饰器使你的类成为Vue组件@Componentexport default class App extends Vue {    private name:string = 'liwu';}&lt;/script&gt;&lt;style scoped&gt;h1{    color: rgb(55, 142, 230);}&lt;/style&gt;</code></pre><p>修改tsconfig.js，支持装饰器语法</p><pre><code>"experimentalDecorators": true,</code></pre><h2 id="4-3-jsx"><a href="#4-3-jsx" class="headerlink" title="4.3 jsx"></a>4.3 jsx</h2><blockquote><p>JSX is an XML-like syntax extension to ECMAScript without any defined semantics. It’s NOT intended to be implemented by engines or browsers.</p></blockquote><p>1.jsx语法简介（写react的同学跳过）</p><ul><li>严格的标签闭合</li><li>组件名要大写，否则解析成html标签</li><li>变量用{}</li></ul><pre><code>let name = 'xxx';&lt;div&gt;{ name }&lt;/div&gt;</code></pre><ul><li>遍历用map</li></ul><pre><code>let list = ['李一','李二','李三'];&lt;div&gt;    {list.map((item, index) =&gt; {    return &lt;p key={index}&gt;this is {item}&lt;/p&gt;     })} &lt;/div&gt; </code></pre><ul><li>条件判断</li></ul><pre><code>&lt;div className={styles.wrapper}&gt;    {_.isEmpty(currRecord) ? null : (      &lt;Graph        graph={{ nodes, edges }}        options={this.options}        events={this.events}      /&gt;    )}&lt;/div&gt; </code></pre><ul><li>事件要用驼峰写法，传参要用bind</li></ul><pre><code>&lt;div    className={styles.content}    onMouseEnter={this.showSwitch}    onMouseLeave={this.hideSwitch}    onClick={this.handleClick.bind(this,params)}&gt;&lt;/div&gt;</code></pre><ul><li>使用domPropsInnerHTML来替代v-html</li></ul><pre><code>&lt;div    domPropsInnerHTML={this.htmlContent}&gt;&lt;/div&gt;</code></pre><p>2.组件写法</p><pre><code>import { Vue, Component } from 'vue-property-decorator';import { CreateElement } from 'vue';@Componentexport default class JSX extends Vue {  private count: number = 0;  private showInfo() {    this.count++;  }  protected render(h: CreateElement) {    return &lt;h2 onMouseenter={this.showInfo}&gt;JSX Test{this.count}&lt;/h2&gt;;  }}</code></pre><h1 id="5-class组件详细用法"><a href="#5-class组件详细用法" class="headerlink" title="5 class组件详细用法"></a>5 class组件详细用法</h1><h2 id="使用Data"><a href="#使用Data" class="headerlink" title="使用Data"></a>使用Data</h2><pre><code>@Componentexport default class HelloWorld extends Vue {  private msg: string = "welcome to my app"  private list: Array&lt;object&gt; = [    {        name: 'Melody',        age: '20'    },    {        name: 'James',        age: '20'    }  ]}</code></pre><p>与ts等效的js代码</p><pre><code>export default {  data() {    return {      msg: "welcome to my app",      list: [        {          name: 'Melody',          age: '20'        },        {          name: 'James',          age: '20'        }      ]    }}</code></pre><h2 id="使用props"><a href="#使用props" class="headerlink" title="使用props"></a>使用props</h2><p>可以添加 required, default, type 为props指定验证要求，同样也可以使用 readonly 禁止操作props</p><pre><code>import { Component, Prop, Vue } from 'vue-property-decorator'@Componentexport default class HelloWorld extends Vue {  @Prop() readonly msg!: string  @Prop({default: 'Joy Melody'}) readonly name: string  @Prop({required: true}) readonly age: number  @Prop({required: false, type: String, default: 'Developer'}) readonly job: string}</code></pre><p>与ts等效的js代码如下</p><pre><code>export default {  props: {    msg,    name: {      default: 'Joy Melody'    },    age: {      required: true,    },    address: {      type: String    },    job: {      required: false,      type: string,      default: 'Developer'    }  }}</code></pre><h2 id="Computed-属性"><a href="#Computed-属性" class="headerlink" title="Computed 属性"></a>Computed 属性</h2><pre><code>export default class HelloWorld extends Vue {  get fullName(): string {    return this.first+ ' '+ this.last  }}</code></pre><p>与ts等效的js代码如下</p><pre><code>export default {  fullName() {    return this.first + ' ' + this.last  }}</code></pre><p>复杂点的涉及到setter和getter的 computed属性，在ts中写法如下：</p><pre><code>export default class HelloWorld extends Vue {  get fullName(): string {    return this.first+ ' '+ this.last  }  set fullName(newValue: string) {    let names = newValue.split(' ')    this.first = names[0]    this.last = names[names.length - 1]  }}</code></pre><p>与ts等效的js写法如下</p><pre><code>fullName: {  get: function () {    return this.first + ' ' + this.last  },  set: function (newValue) {    let names = newValue.split(' ')    this.first = names[0]    this.last = names[names.length - 1]  }}</code></pre><h2 id="使用Watch"><a href="#使用Watch" class="headerlink" title="使用Watch"></a>使用Watch</h2><p>@Watch(path: string, options: WatchOptions = {}) </p><ul><li><p>@Watch 装饰器接收两个参数：path: string 被侦听的属性名<br>options?: WatchOptions={} options可以包含两个属性</p></li><li><p>immediate?:boolean 侦听开始之后是否立即调用该回调函数<br>deep?:boolean 被侦听的对象的属性被改变时，是否调用该回调函数</p></li></ul><pre><code>@Watch('child')onChildChanged (val: string, oldVal: string) {    if (val !== oldVal) {      window.console.log(val)    }}</code></pre><p>与ts等效的js代码如下</p><pre><code>watch: {    'child': {        handler: 'onChildChanged',        immediate: false,        deep: false     }},method: {    onChildChanged(val, oldVal) {        if (val !== oldVal) {          console.log(val)        }    }}</code></pre><p>也可以写成: @Watch(‘child’, { immediate: true, deep: true }), 等价于:</p><pre><code>watch: {    'child': {        handler: 'onChildChanged',        immediate: true,        deep: true     }},method: {    onChildChanged(val, oldVal) {        if (val !== oldVal) {          window.console.log(val)        }    }}</code></pre><h2 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h2><pre><code>export default class HelloWorld extends Vue {  public clickMe(): void {    console.log('clicked')    console.log(this.addNum(4, 2))  }  public addNum(num1: number, num2: number): number {    return num1 + num2  }}</code></pre><p>与ts等效的js代码如下</p><pre><code>export default {  methods: {    clickMe() {      console.log('clicked')      console.log(this.addNum(4, 2))    }    addNum(num1, num2) {      return num1 + num2    }  }}</code></pre><h2 id="Emit"><a href="#Emit" class="headerlink" title="Emit"></a>Emit</h2><p>子组件触发父组件的自定义事件并传递数据，在TypeScript中使用@Emit 装饰器</p><pre><code>import { Vue, Component, Emit } from 'vue-property-decorator'@Componentexport default class YourComponent extends Vue {  count = 0  @Emit()  addToCount(n: number) {    this.count += n  }}</code></pre><p>与ts等效的js代码如下</p><pre><code>export default {  data() {    return {      count: 0    }  },  methods: {    addToCount(n) {      this.count += n      this.$emit('add-to-count', n)    }  }}</code></pre><h2 id="Mixins"><a href="#Mixins" class="headerlink" title="Mixins"></a>Mixins</h2><p>假设当前已经有一个mixins/ProjectMixin文件 如何在其他组件里面使用方式如下</p><pre><code>&lt;template&gt;  &lt;div class="project-detail"&gt;    {{ projectDetail }}  &lt;/div&gt;&lt;/template&gt;&lt;script lang="ts"&gt;import { Component, Vue, Mixins } from 'vue-property-decorator'import ProjectMixin from '@/mixins/ProjectMixin'@Componentexport default class Project extends Mixins(ProjectMixin) {  get projectDetail(): string {    return this.projName + ' ' + 'HS'  }}&lt;/script&gt;</code></pre><p>与ts等效的js代码如下</p><pre><code>&lt;template&gt;  &lt;div class="project-detail"&gt;    {{ projectDetail }}  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import ProjectMixin from '@/mixins/ProjectMixin'export default {  mixins: [ ProjectMixin ],  computed: {    projectDetail() {      return this.projName + ' ' + 'HS'    }  }}&lt;/script&gt;</code></pre><p>多个混入的情况</p><pre><code>import { Component, Mixins } from 'vue-property-decorator'export default class Test extends Mixins(Mixin1, Mixin2) {    test() {      this.methodFromMixin2()      console.log(this.valFromMixin1)    }}</code></pre><h2 id="refs"><a href="#refs" class="headerlink" title="refs"></a>refs</h2><p>ts无法识别vue中的$refs,需要手动指定其类型：</p><pre><code>&lt;template&gt;  &lt;loading ref="loading"/&gt;  &lt;input type="text" ref="inputRef"&gt;&lt;/template&gt;&lt;script lang="ts"&gt;import { Component } from 'vue-property-decorator'import Loading from "@/components/Loading.vue";@Component({  components: { Loading }})export default class Project extends Vue { $refs!: {    loading: Loading;    inputRef: HTMLInputElement;  }; public mounted() {    this.$refs.loading.showLoading();    // (this.$refs.loading as Loading).showLoading();    this.$refs.inputRef.focus();  }}&lt;/script&gt;</code></pre><h1 id="6-路由"><a href="#6-路由" class="headerlink" title="6 路由"></a>6 路由</h1><h2 id="路由创建"><a href="#路由创建" class="headerlink" title="路由创建"></a>路由创建</h2><pre><code>import Vue from 'vue';import VueRouter, { RouteConfig } from 'vue-router';import Home from '@/pages/home/Home.vue';Vue.use(VueRouter);const routes: Array&lt;RouteConfig&gt; = [  {    path: '/',    name: 'home',    component: Home  },  {    path: '/about',    name: 'about',    component: () =&gt; import(/* webpackChunkName: "about" */ '@/pages/about/About.vue')  }];const router = new VueRouter({  routes});export default router;</code></pre><h2 id="组件中监听路由"><a href="#组件中监听路由" class="headerlink" title="组件中监听路由"></a>组件中监听路由</h2><pre><code>&lt;script lang="ts"&gt;import { Component, Vue, Watch } from 'vue-property-decorator';import { Route } from 'vue-router';@Componentexport default class About extends Vue {  @Watch('$route', { immediate: true })  private changeRouter(route: Route) {    console.log('route', route);  }}</code></pre><h2 id="组件中使用路由勾子函数"><a href="#组件中使用路由勾子函数" class="headerlink" title="组件中使用路由勾子函数"></a>组件中使用路由勾子函数</h2><p>main.ts中：</p><pre><code>import { Component } from 'vue-property-decorator';Component.registerHooks([  'beforeRouteEnter',  'beforeRouteLeave',  'beforeRouteUpdate']);</code></pre><p>组件中：</p><pre><code>&lt;script lang="ts"&gt;import { Component, Vue, Watch } from 'vue-property-decorator';import { Route } from 'vue-router';@Componentexport default class About extends Vue {  private beforeRouteEnter(to: Route, from: Route, next: () =&gt; void): void {    console.log('beforeRouteEnter', to, from, next);    next();   }  private beforeRouteUpdate(to: Route, from: Route, next: () =&gt; void): void {    console.log('beforeRouteUpdate'); // 暂时不生效，版本问题    next();  }  private beforeRouteLeave(to: Route, from: Route, next: () =&gt; void): void {    console.log('beforeRouteLeave');    next();  }}</code></pre><h1 id="7-数据请求"><a href="#7-数据请求" class="headerlink" title="7 数据请求"></a>7 数据请求</h1><p>对返回值和入参做类型约束：</p><pre><code>// global.d.ts declare interface ResponseBody&lt;T&gt; {  data: T;  code: number;  total: number;}declare interface ResponseStatus {  loading: boolean;  error: boolean;}declare interface Response&lt;T&gt; extends ResponseStatus {  res: IResponseBody&lt;T&gt;;}declare interface ResponseNotPage&lt;T&gt; extends ResponseStatus {  data: T;}declare interface PageParams {  page: number;  pageSize: number;}declare interface RequsetParams extends PageParams {  search: string;}// src/service/demo.tsexport const getInfo = (id: number) =&gt;  request&lt;ResponseBody&lt;{ id: number; address?: string; time?: string }&gt;&gt;(    Api.GET_LAST_TRACE_INFO,    {      router: { id }    }  );</code></pre><h1 id="8-全局状态管理"><a href="#8-全局状态管理" class="headerlink" title="8 全局状态管理"></a>8 全局状态管理</h1><h2 id="8-1-开始使用"><a href="#8-1-开始使用" class="headerlink" title="8.1 开始使用"></a>8.1 开始使用</h2><p>安装依赖</p><pre><code>npm install vuex-module-decorators --save-dev</code></pre><p>如果想通过名字空间的形式来使用module, 需在@Module装饰器中添加额外的参数. 例如, 以下示例代码中添加一个namespaced为home的module</p><pre><code>// src\store\module\home.tsimport { VuexModule, Module, Mutation, Action, getModule } from 'vuex-module-decorators';import store from '@/store';@Module({ namespaced: true, dynamic: true, name: 'home', store })export default class Home extends VuexModule {  public name: string = '';  public message: string = '';  get getMessage() {    return `当前时间${new Date()}：${this.message}`;  }  @Mutation  private SET_NAME(newName: string): void {    this.name = newName;  }  @Mutation  private SET_MESSAGE(message: string) {    this.message = message;  }  @Action  public updateMessage(newName: string): void {    this.SET_NAME(newName);    this.SET_MESSAGE('欢迎您,');  }}export const HomeModule = getModule(Home);</code></pre><p>与ts等效的js代码如下</p><pre><code>const UserModule = {    state: {        name: '',        message: ''    },    getters: {         getMessage: state =&gt; `当前时间${new Date()}：${state.user.message}`    },    mutations: {         SET_NAME: (state, name) =&gt; {            state.name = name        },        SET_MESSAGE: (state, message) =&gt; {            state.message = message        }    },    actions: {         updateMessage({commit}, newName){            commit("SET_NAME", newName);            commit("SET_MESSAGE", "欢迎您,");        }    },}</code></pre><p>dynamic模式下的store</p><pre><code>// \src\store\index.tsimport Vue from 'vue';import Vuex from 'vuex';Vue.use(Vuex);// Declare empty store first, dynamically register all modules later.export default new Vuex.Store({});</code></pre><p>组件中使用：</p><pre><code>// \src\pages\home\Home.vue&lt;template&gt;  &lt;div class="home"&gt;    &lt;img alt="Vue logo" src="../../assets/logo.png" /&gt;    &lt;hello-world msg="vue.js" /&gt;    {{ $store.state.home.name }}    &lt;br/&gt;    {{ info }}    &lt;button @click="handleClick"&gt;点击&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script lang="ts"&gt;import { Component, Vue } from 'vue-property-decorator';import HelloWorld from '@/components/HelloWorld.vue';import { HomeModule } from '@/store/modules/home';@Component({  components: {    HelloWorld  }})export default class Home extends Vue {  get info() {    return HomeModule.getMessage;  }  private handleClick() {    HomeModule.updateMessage('liwu');  }}&lt;/script&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 新鲜技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>当CORS遇到SameSite</title>
      <link href="2020/09/11/dang-cors-yu-dao-samesite-md/"/>
      <url>2020/09/11/dang-cors-yu-dao-samesite-md/</url>
      
        <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><blockquote><p>A cookie associated with a cross-site resource at <a href="http://a.com/">http://a.com/</a> was set without the ‘SameSite’ attribute. A future release of Chrome will only deliver cookies with cross-site requests if they are set with ‘SameSite=None’ and ‘Secure’. You can review cookies in developer tools under Application&gt;Storage&gt;Cookies and see more details at <a href="https://www.chromestatus.com/feature/5088147346030592">https://www.chromestatus.com/feature/5088147346030592</a> and <a href="https://www.chromestatus.com/feature/5633521622188032">https://www.chromestatus.com/feature/5633521622188032</a>.</p></blockquote><p>于是发现是 Chrome 升级 80 导致未设置 SameSite 的 Cookie 默认值是Lax。</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="1-紧急处理"><a href="#1-紧急处理" class="headerlink" title="1.紧急处理"></a>1.紧急处理</h2><p>其实是在服务方解决问题之前让用户先稍微兼容一下。方案很简单：</p><p>换个浏览器<br>or</p><p>打开 chrome://flags/#same-site-by-default-cookies，关掉 SameSite by default cookies 然后重启浏览器</p><h2 id="2-方法一：跨域-Set-Cookie"><a href="#2-方法一：跨域-Set-Cookie" class="headerlink" title="2. 方法一：跨域 + Set-Cookie"></a>2. 方法一：跨域 + Set-Cookie</h2><p>首先就是报错信息里提到的，让服务端同学在 Set-Cookie 的时候加上 SameSite=None; Secure。但是我们的后台系统都是对内使用的，很多域名都没有申请证书。而 “Secure” 属性却表示 Cookie 只能随 HTTPS 请求发送。<br>这就很尴尬。<br>要不申请证书，要不换域名。<br>但是长远来看，https是大趋势，趁着这个机会升级成 HTTPS 也是可取的。<br>然而有些版本的浏览器并不识别 SameSite=None，需要特殊处理。</p><h2 id="3-方法二：改成同域请求"><a href="#3-方法二：改成同域请求" class="headerlink" title="3. 方法二：改成同域请求"></a>3. 方法二：改成同域请求</h2><p>既然 SameSite=Lax 限制的是跨域 Cookie 携带，那么改成同域自然没有问题了。<br>但因为现在项目都是前后端分离部署的，所以请运维同学配了一下匹配到 ^/api/ 开头的请求都转发到服务端的地址。前端请求接口时直接用相对路径请求。<br>问题解决</p>]]></content>
      
      
      <categories>
          
          <category> 项目总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 踩的坑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BFC原理及应用</title>
      <link href="2020/08/30/bfc-yuan-li-ji-ying-yong/"/>
      <url>2020/08/30/bfc-yuan-li-ji-ying-yong/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/css.png"></p><h1 id="一、常见定位方案"><a href="#一、常见定位方案" class="headerlink" title="一、常见定位方案"></a>一、常见定位方案</h1><p>在讲 BFC 之前，我们先来了解一下常见的定位方案，定位方案是控制元素的布局，有三种常见方案:</p><ul><li>普通流 (normal flow)<br>在普通流中，元素按照其在 HTML 中的先后位置至上而下布局，在这个过程中，行内元素水平排列，直到当行被占满然后换行，块级元素则会被渲染为完整的一个新行，除非另外指定，否则所有元素默认都是普通流定位，也可以说，普通流中元素的位置由该元素在 HTML 文档中的位置决定。</li><li>浮动 (float)<br>在浮动布局中，元素首先按照普通流的位置出现，然后根据浮动的方向尽可能的向左边或右边偏移，其效果与印刷排版中的文本环绕相似。</li><li>绝对定位 (absolute positioning)<br>在绝对定位布局中，元素会整体脱离普通流，因此绝对定位元素不会对其兄弟元素造成影响，而元素具体的位置由绝对定位的坐标决定。</li></ul><h1 id="二、BFC-概念"><a href="#二、BFC-概念" class="headerlink" title="二、BFC 概念"></a>二、BFC 概念</h1><blockquote><p>Formatting context(格式化上下文) 是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。</p></blockquote><p>那么 BFC 是什么呢？</p><p>BFC 即 Block Formatting Contexts (块级格式化上下文)，它属于上述定位方案的普通流。<br>具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。<br>通俗一点来讲，可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。</p><h1 id="三、触发-BFC"><a href="#三、触发-BFC" class="headerlink" title="三、触发 BFC"></a>三、触发 BFC</h1><p>只要元素满足下面任一条件即可触发 BFC 特性：</p><ul><li>body 根元素</li><li>浮动元素：float 除 none 以外的值</li><li>绝对定位元素：position (absolute、fixed)</li><li>display 为 inline-block、table-cells、flex</li><li>overflow 除了 visible 以外的值 (hidden、auto、scroll)</li></ul><h1 id="四、BFC-特性及应用"><a href="#四、BFC-特性及应用" class="headerlink" title="四、BFC 特性及应用"></a>四、BFC 特性及应用</h1><h2 id="1-同一个-BFC-下外边距会发生折叠"><a href="#1-同一个-BFC-下外边距会发生折叠" class="headerlink" title="1. 同一个 BFC 下外边距会发生折叠"></a>1. 同一个 BFC 下外边距会发生折叠</h2><pre><code>&lt;head&gt;div{    width: 100px;    height: 100px;    background: lightblue;    margin: 100px;}&lt;/head&gt;&lt;body&gt;    &lt;div&gt;&lt;/div&gt;    &lt;div&gt;&lt;/div&gt;&lt;/body&gt;</code></pre><p>从效果上看，因为两个 div 元素都处于同一个 BFC 容器下 (这里指 body 元素) 所以第一个 div 的下边距和第二个 div 的上边距发生了重叠，所以两个盒子之间距离只有 100px，而不是 200px。<br><img src="https://7.dusays.com/2020/11/02/0afee71e5de5e.png"></p><p>首先这不是 CSS 的 bug，我们可以理解为一种规范，如果想要避免外边距的重叠，可以将其放在不同的 BFC 容器中。</p><pre><code>&lt;div class="container"&gt;    &lt;p&gt;&lt;/p&gt;&lt;/div&gt;&lt;div class="container"&gt;    &lt;p&gt;&lt;/p&gt;&lt;/div&gt;.container {    overflow: hidden;}p {    width: 100px;    height: 100px;    background: lightblue;    margin: 100px;}</code></pre><p>这时候，两个盒子边距就变成了 200px </p><p><img src="https://7.dusays.com/2020/11/02/0e302d5bce868.png"></p><h2 id="2-BFC-可以包含浮动的元素（清除浮动）"><a href="#2-BFC-可以包含浮动的元素（清除浮动）" class="headerlink" title="2. BFC 可以包含浮动的元素（清除浮动）"></a>2. BFC 可以包含浮动的元素（清除浮动）</h2><p>我们都知道，浮动的元素会脱离普通文档流，来看下下面一个例子</p><pre><code>&lt;div style="border: 1px solid #000;"&gt;    &lt;div style="width: 100px;height: 100px;background: #eee;float: left;"&gt;&lt;/div&gt;&lt;/div&gt;</code></pre><p><img src="https://7.dusays.com/2020/11/02/f461d5e0dbd0f.png"></p><p>由于容器内元素浮动，脱离了文档流，所以容器只剩下 2px 的边距高度。如果使触发容器的 BFC，那么容器将会包裹着浮动元素。</p><pre><code>&lt;div style="border: 1px solid #000;overflow: hidden"&gt;    &lt;div style="width: 100px;height: 100px;background: #eee;float: left;"&gt;&lt;/div&gt;&lt;/div&gt;</code></pre><p>效果如图：</p><p><img src="https://7.dusays.com/2020/11/02/b90051e64945c.png"></p><h2 id="3-BFC-可以阻止元素被浮动元素覆盖"><a href="#3-BFC-可以阻止元素被浮动元素覆盖" class="headerlink" title="3. BFC 可以阻止元素被浮动元素覆盖"></a>3. BFC 可以阻止元素被浮动元素覆盖</h2><p>先来看一个文字环绕效果：</p><pre><code>&lt;div style="height: 100px;width: 100px;float: left;background: lightblue"&gt;    我是一个左浮动的元素&lt;/div&gt;&lt;div style="width: 200px; height: 200px;background: #eee"&gt;    我是一个没有设置浮动, 也没有触发 BFC 元素, width: 200px; height:200px; background: #eee;&lt;/div&gt;</code></pre><p><img src="https://7.dusays.com/2020/11/02/aaf4c0ab57032.png"></p><p>这时候其实第二个元素有部分被浮动元素所覆盖，(但是文本信息不会被浮动元素所覆盖) 如果想避免元素被覆盖，可触第二个元素的 BFC 特性，在第二个元素中加入 overflow: hidden，就会变成：</p><p><img src="https://7.dusays.com/2020/11/02/4a7759227aae9.png"></p><p>这个方法可以用来实现两列自适应布局，效果不错，这时候左边的宽度固定，右边的内容自适应宽度(去掉上面右边内容的宽度)。</p>]]></content>
      
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hooks入门教程</title>
      <link href="2019/09/16/hooks-ru-men-jiao-cheng/"/>
      <url>2019/09/16/hooks-ru-men-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<p><img src="https://7.dusays.com/2020/11/02/d812bf44ed5ef.png" alt="react"></p><h1 id="Hooks的含义"><a href="#Hooks的含义" class="headerlink" title="Hooks的含义:"></a>Hooks的含义:</h1><p>React Hooks 的意思是，组件尽量写成<strong>纯函数</strong>，如果需要外部功能和副作用，就用钩子把外部代码”钩”进来。 React Hooks 就是那些钩子。</p><p>React默认提供了一些常用的钩子函数，你也可以自己定义钩子函数。</p><p>React 团队希望，组件不要变成复杂的容器，最好只是数据流的管道。开发者根据需要，组合管道即可。 <strong>组件的最佳写法应该是函数</strong>，而不是类。</p><p>React 约定，钩子一律使用<strong>use</strong>前缀命名，便于识别。</p><h1 id="常见的钩子函数"><a href="#常见的钩子函数" class="headerlink" title="常见的钩子函数"></a>常见的钩子函数</h1><h2 id="1-useState-状态钩子"><a href="#1-useState-状态钩子" class="headerlink" title="1. useState():状态钩子"></a>1. useState():状态钩子</h2><pre><code>useState用于为函数组件引入状态（state）。纯函数不能有状态，所以把状态放在钩子里面useState()这个函数接受状态的初始值，作为参数，返回一个数组，数组第一个成员是一个变量，指向状态的当前值。第二个成员是函数，用来更新状态，约定用set前缀加上状态的变量名。const [buttonText, setButtonText] = useState("Click me, please");</code></pre><h2 id="2-useContext-共享状态钩子"><a href="#2-useContext-共享状态钩子" class="headerlink" title="2. useContext()共享状态钩子"></a>2. useContext()共享状态钩子</h2><pre><code>如果组件之间需要共享状态，可以使用useContext()。&lt;div className="App"&gt;  &lt;Navbar/&gt;  &lt;Messages/&gt;&lt;/div&gt;如果Navbar跟Messages实现通信，第一步在组件外部建立一个context:const AppContext = React.creatContext({})组件封装的代码如下：&lt;AppContext.Provider value={{  username: 'superawesome'}}&gt;  &lt;div className="App"&gt;    &lt;Navbar/&gt;    &lt;Messages/&gt;  &lt;/div&gt;&lt;/AppContext.Provider&gt;在组件中的使用如下：const Navbar = () =&gt; {  const { username } = useContext(AppContext);  return (    &lt;div className="navbar"&gt;      &lt;p&gt;AwesomeSite&lt;/p&gt;      &lt;p&gt;{username}&lt;/p&gt;    &lt;/div&gt;  );}</code></pre><h2 id="3-useReducer-action钩子"><a href="#3-useReducer-action钩子" class="headerlink" title="3. useReducer():action钩子"></a>3. useReducer():action钩子</h2><pre><code>React 本身不提供状态管理功能，通常需要使用外部库。这方面最常用的库是 Redux。Redux 的核心概念是，组件发出 action 与状态管理器通信。状态管理器收到 action 以后，使用 Reducer 函数算出新的状态，Reducer 函数的形式是(state, action) =&gt; newState。useReducers()钩子用来引入 Reducer 功能。const [state, dispatch] = useReducer(reducer, initialState);</code></pre><h2 id="4-useEffect-副作用钩子"><a href="#4-useEffect-副作用钩子" class="headerlink" title="4. useEffect():副作用钩子"></a>4. useEffect():副作用钩子</h2><pre><code>useEffect()用来引入具有副作用的操作，最常见的就是向服务器请求数据。以前，放在componentDidMount里面的代码，现在可以放在useEffect()。useEffect()的用法如下。useEffect(()  =&gt;  {  // Async Action}, [dependencies])useEffect()接受两个参数。第一个参数是函数，异步操作的代码放里面，第二个参数是一个数组，用于给出Effect的依赖，只要这个数组发生变化，useEffect()就会执行。第二个参数可以省略，这时每次组件渲染时，就会执行useEffect()。</code></pre><p>React首次渲染和之后的每次渲染都会调用一遍useEffect函数，而之前我们要用两个生命周期函数分别表示首次渲染(componentDidMonut)和更新导致的重新渲染(componentDidUpdate)。</p><p>useEffect中定义的函数的执行不会阻碍浏览器更新视图，也就是说这些函数时异步执行的，而componentDidMonut和componentDidUpdate中的代码都是同步执行的。个人认为这个有好处也有坏处吧，比如我们要根据页面的大小，然后绘制当前弹出窗口的大小，如果时异步的就不好操作了。</p>]]></content>
      
      
      <categories>
          
          <category> 新鲜技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
            <tag> hooks </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单的在线数据mock</title>
      <link href="2019/08/30/jian-dan-de-zai-xian-shu-ju-mock/"/>
      <url>2019/08/30/jian-dan-de-zai-xian-shu-ju-mock/</url>
      
        <content type="html"><![CDATA[<h1 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h1><p>在接口调试前，前端根据定义好的接口文档，模拟数据，发起请求，编写完整的页面逻辑，等真正开始调试的时候，将请求地址更换即可。</p><p>本文只介绍在线 mock 数据的方式，在线 mock 跟本地 mock 比较，可以省去安装配置，运行服务，多人协作数据不通的多种问题。</p><h1 id="一个简单的列子"><a href="#一个简单的列子" class="headerlink" title="一个简单的列子"></a>一个简单的列子</h1><p><img src="https://7.dusays.com/2020/11/02/98aaa2c403dd1.png"></p><p>返回结果：</p><p><img src="https://7.dusays.com/2020/11/02/a2df1d69cadcf.png"></p><h1 id="Mock-语法简介"><a href="#Mock-语法简介" class="headerlink" title="Mock 语法简介"></a>Mock 语法简介</h1><h2 id="base"><a href="#base" class="headerlink" title="base"></a>base</h2><pre><code>{    "base": {    "range": "@range(3, 7)",    "string": "@string(7, 20)",    "character": "@character(\"abcde\")",    "float": "@float(60, 100)",    "integer": "@integer(60, 100)",    "natural": "@natural(60, 100)",    "boolean": "@boolean"  },}</code></pre><p>预览：</p><pre><code>"base": {    "range": [3,4,5,6],    "string": "qg3)zBWiLlbrsisX",    "character": "c",    "float": 66.87535733306,    "integer": 66,    "natural": 71,    "boolean": false  },</code></pre><h2 id="date"><a href="#date" class="headerlink" title="date"></a>date</h2><pre><code>"date": {    "date": "@date",    "time": "@time",    "datetime": "@datetime",    "now": "@now"  },</code></pre><p>预览：</p><pre><code>"date": {    "date": "1971-10-18",    "time": "02:04:17",    "datetime": "1985-03-10 22:47:49",    "now": "2019-09-25 13:56:44"    }</code></pre><h2 id="image"><a href="#image" class="headerlink" title="image"></a>image</h2><pre><code> "image": {    "image": "@image(\"200x200\", \"#50B347\", \"#FFF\", \"FastMock\")"  },</code></pre><p>预览：</p><pre><code>"image": {    "image": "http://dummyimage.com/200x200/50B347/FFF&amp;text=FastMock"  },</code></pre><h2 id="text"><a href="#text" class="headerlink" title="text"></a>text</h2><pre><code>"text": {    "paragraph": "@paragraph(1, 3)",    "sentence": "@sentence(3, 5)",    "word": "@word(3, 5)",    "title": "@title(3, 5)",    "cparagraph": "@cparagraph(1, 3)",    "csentence": "@csentence(3, 5)",    "cword": "@cword(\"零一二三四五六七八九十\", 5, 7)",    "ctitle": "@ctitle(3, 5)"  },</code></pre><p>预览：</p><pre><code> "text": {    "paragraph": "Gifp ifnk hrreyi foajbgielv doijqrd ffaooi hlwstfcfw nrgsioum wtgashcoiy sintskl hnjk ebcsec. Bhlhghu embjvvs bckwkibqhs qgqz psu mjsodprwf exidxyqnq cdyqoatr xkezagaqu ijrcqrj vvxwdwgq ivv jxcpeybpus sojcn cscdlnmi kopzvuqfin.",    "sentence": "Xuqxp qvek ttgiq.",    "word": "ynug",    "title": "Cdnsxa Yjhrlbb Rmofrixln Jubgpxm Gjpdujgryi",    "cparagraph": "装增克体都月每手物即用周几想军点程。将角权响金华生候社根利情也龙。化必去边织众东位史回际平马至。",    "csentence": "存断实。",    "cword": "三七九六六",    "ctitle": "油眼采小"  },</code></pre><h2 id="name"><a href="#name" class="headerlink" title="name"></a>name</h2><pre><code>"name": {    "first": "@first",    "last": "@last",    "name": "@name",    "cfirst": "@cfirst",    "clast": "@clast",    "cname": "@cname"  },</code></pre><p>预览：</p><pre><code>"name": {    "first": "Jennifer",    "last": "Anderson",    "name": "Laura Moore",    "cfirst": "胡",    "clast": "秀兰",    "cname": "姜敏"  },</code></pre><h2 id="web"><a href="#web" class="headerlink" title="web"></a>web</h2><pre><code>"web": {    "url": "@url",    "domain": "@domain",    "protocol": "@protocol",    "tld": "@tld",    "email": "@email",    "ip": "@ip"  },</code></pre><p>预览：</p><pre><code>"web": {    "url": "mid://nypjj.kr/mizdvfhl",    "domain": "jbgmh.cn",    "protocol": "ftp",    "tld": "fj",    "email": "r.bdwejkiuy@ltatgpp.an",    "ip": "175.52.62.226"  },</code></pre><h2 id="address"><a href="#address" class="headerlink" title="address"></a>address</h2><pre><code>"address": {    "region": "@region",    "province": "@province",    "city": "@city(true)",    "county": "@county(true)",    "zip": "@zip"  },</code></pre><p>预览：</p><pre><code>"address": {    "region": "华中",    "province": "云南省",    "city": "天津 天津市",    "county": "台湾 金门县 金宁乡",    "zip": "539375"  },</code></pre><h2 id="miscellaneous"><a href="#miscellaneous" class="headerlink" title="miscellaneous"></a>miscellaneous</h2><pre><code> "miscellaneous": {    "id": "@id",    "guid": "@guid",    "increment": "@increment(1000)"  }</code></pre><p>预览：</p><pre><code> "miscellaneous": {    "id": "370000201504299208",    "guid": "6E6155c0-f5b5-F3F6-5F0D-23EB44C21313",    "increment": 253109  }</code></pre><h1 id="Mock-高阶用法"><a href="#Mock-高阶用法" class="headerlink" title="Mock 高阶用法"></a>Mock 高阶用法</h1><blockquote><p>Mock 能支持 function，function 中不能用上面的@XX,用 Mock.mock(“@xxx”)替代。function 中还能获取全部请求头和参数。</p></blockquote><table><thead><tr><th>对象</th><th>描述</th></tr></thead><tbody><tr><td>Mock</td><td>Mock 对象</td></tr><tr><td>_req.url</td><td>获得请求 url 地址</td></tr><tr><td>_req.method</td><td>获取请求方法</td></tr><tr><td>_req.params</td><td>获取 url 参数对象</td></tr><tr><td>_req.querystring</td><td>获取查询参数字符串(url 中?后面的部分)，不包含 ?</td></tr><tr><td>_req.query</td><td>将查询参数字符串进行解析并以对象的形式返回，如果没有查询参数字字符串则返回一个空对象</td></tr><tr><td>_req.body</td><td>当 post 请求以 x-www-form-urlencoded 方式提交时，我们可以拿到请求的参数对象</td></tr></tbody></table><h2 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h2><pre><code>{  code: function({    _req  }) {    const userName = _req.query.userName;    return userName ? 0 : -1;  },  data: function({    _req,    Mock  }) {    const userName = _req.query.userName;    return userName ? {      token: Mock.mock("@guid()"),      userId: Mock.mock("@id(5)"),      name: userName,      avatar: Mock.mock("@image(200x100, #FF6600)"),      message: "登录成功"    } : {      message: "登录失败"    }  }}</code></pre><p>预览：</p><p><img src="https://note.youdao.com/yws/public/resource/633e9bc706a3a274d9926f95b1806671/xmlnote/1C6017CB352F41DD9B758D064EBCFD4B/15016" alt="image"></p><h1 id="常用的在线-mock-工具"><a href="#常用的在线-mock-工具" class="headerlink" title="常用的在线 mock 工具"></a>常用的在线 mock 工具</h1><ul><li><p>💛 <a href="https://www.fastmock.site/">fast-mock</a></p></li><li><p>💗 <a href="https://easy-mock.com/">easy-mock</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue组件编码规范</title>
      <link href="2019/08/13/vue-zu-jian-bian-ma-gui-fan/"/>
      <url>2019/08/13/vue-zu-jian-bian-ma-gui-fan/</url>
      
        <content type="html"><![CDATA[<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><blockquote><p>本规范提供了一种统一的编码规范来编写 Vue.js 代码。这使得代码具有如下的特性：</p></blockquote><ul><li>其它开发者或是团队成员更容易阅读和理解。</li><li>IDEs 更容易理解代码，从而提供高亮、格式化等辅助功能</li><li>更容易使用现有的工具</li><li>更容易实现缓存以及代码包的分拆</li></ul><h1 id="基于模块开发"><a href="#基于模块开发" class="headerlink" title="基于模块开发"></a>基于模块开发</h1><p>始终基于模块的方式来构建你的 app，每一个子模块只做一件事情。</p><p>Vue.js 的设计初衷就是帮助开发者更好的开发界面模块。一个模块是应用程序中独立的一个部分。</p><h2 id="怎么做？"><a href="#怎么做？" class="headerlink" title="怎么做？"></a>怎么做？</h2><blockquote><p>每一个 Vue 组件（等同于模块）首先必须专注于解决一个单一的问题，独立的、可复用的、微小的 和 可测试的。</p></blockquote><p>如果你的组件做了太多的事或是变得臃肿，请将其拆分成更小的组件并保持单一的原则。一般来说，尽量保证每一个文件的代码行数不要超过 100 行。也请保证组件可独立的运行。</p><h1 id="vue-组件命名"><a href="#vue-组件命名" class="headerlink" title="vue 组件命名"></a>vue 组件命名</h1><p>组件的命名需遵从以下原则：</p><ul><li><p><strong>有意义的</strong>: 不过于具体，也不过于抽象</p></li><li><p><strong>简短</strong>: 2 到 3 个单词</p></li><li><p><strong>具有可读性</strong>: 以便于沟通交流<br>同时还需要注意：</p></li><li><p>必须符合<strong>自定义元素规范</strong>: 使用连字符分隔单词，切勿使用保留字。</p></li><li><p>app- 前缀作为命名空间:</p></li></ul><p>如果非常通用的话可使用一个单词来命名，这样可以方便于其它项目里复用。</p><h2 id="为什么？"><a href="#为什么？" class="headerlink" title="为什么？"></a>为什么？</h2><ul><li>组件是通过组件名来调用的。所以组件名必须简短、富有含义并且具有可读性。</li></ul><h2 id="如何做？"><a href="#如何做？" class="headerlink" title="如何做？"></a>如何做？</h2><pre><code>!-- 推荐 --&gt;&lt;app-header&gt;&lt;/app-header&gt;&lt;user-list&gt;&lt;/user-list&gt;&lt;range-slider&gt;&lt;/range-slider&gt;&lt;!-- 避免 --&gt;&lt;btn-group&gt;&lt;/btn-group&gt; &lt;!-- 虽然简短但是可读性差. 使用 `button-group` 替代 --&gt;&lt;ui-slider&gt;&lt;/ui-slider&gt; &lt;!-- ui 前缀太过于宽泛，在这里意义不明确 --&gt;&lt;slider&gt;&lt;/slider&gt; &lt;!-- 与自定义元素规范不兼容 --&gt;</code></pre><h1 id="组件表达式简单化"><a href="#组件表达式简单化" class="headerlink" title="组件表达式简单化"></a>组件表达式简单化</h1><p>Vue.js 的表达式是 100% 的 Javascript 表达式。这使得其功能性很强大，但也带来潜在的复杂性。因此，你应该尽量保持表达式的简单化。</p><h2 id="为什么？-1"><a href="#为什么？-1" class="headerlink" title="为什么？"></a>为什么？</h2><ul><li>复杂的行内表达式难以阅读。</li><li>行内表达式是不能够通用的，这可能会导致重复编码的问题。</li><li>IDE 基本上不能识别行内表达式语法，所以使用行内表达式 IDE 不能提供自动补全和语法校验功能。</li></ul><h2 id="怎么做？-1"><a href="#怎么做？-1" class="headerlink" title="怎么做？"></a>怎么做？</h2><p>如果你发现写了太多复杂并难以阅读的行内表达式，那么可以使用 method 或是 computed 属性来替代其功能。</p><pre><code>&lt;!-- 推荐 --&gt;&lt;template&gt;  &lt;h1&gt;    {{ `${year}-${month}` }}  &lt;/h1&gt;&lt;/template&gt;&lt;script type="text/javascript"&gt;  export default {    computed: {      month() {        return this.twoDigits((new Date()).getUTCMonth() + 1);      },      year() {        return (new Date()).getUTCFullYear();      }    },    methods: {      twoDigits(num) {        return ('0' + num).slice(-2);      }    },  };&lt;/script&gt;&lt;!-- 避免 --&gt;&lt;template&gt;  &lt;h1&gt;    {{ `${(new Date()).getUTCFullYear()}-${('0' + ((new Date()).getUTCMonth()+1)).slice(-2)}` }}  &lt;/h1&gt;&lt;/template&gt;</code></pre><h1 id="组件-props-原子化"><a href="#组件-props-原子化" class="headerlink" title="组件 props 原子化"></a>组件 props 原子化</h1><p>虽然 Vue.js 支持传递复杂的 JavaScript 对象通过 props 属性，但是你应该尽可能的使用原始类型的数据。尽量只使用 JavaScript 原始类型（字符串、数字、布尔值）和函数。尽量避免复杂的对象。</p><h2 id="为什么？-2"><a href="#为什么？-2" class="headerlink" title="为什么？"></a>为什么？</h2><ul><li>使得组件 API 清晰直观。</li><li>只使用原始类型和函数作为 props 使得组件的 API 更接近于 HTML(5) 原生元素。</li><li>其它开发者更好的理解每一个 prop 的含义、作用。</li><li>传递过于复杂的对象使得我们不能够清楚的知道哪些属性或方法被自定义组件使用，这使得代码难以重构和维护。</li></ul><h2 id="怎么做？-2"><a href="#怎么做？-2" class="headerlink" title="怎么做？"></a>怎么做？</h2><p>组件的每一个属性单独使用一个 props，并且使用函数或是原始类型的值。</p><pre><code>&lt;!-- 推荐 --&gt;&lt;range-slider  :values="[10, 20]"  :min="0"  :max="100"  :step="5"  @on-slide="updateInputs"  @on-end="updateResults"&gt;&lt;/range-slider&gt;&lt;!-- 避免 --&gt;&lt;range-slider :config="complexConfigObject"&gt;&lt;/range-slider&gt;</code></pre><h1 id="验证组件的-props"><a href="#验证组件的-props" class="headerlink" title="验证组件的 props"></a>验证组件的 props</h1><p>在 Vue.js 中，组件的 props 即 API，一个稳定并可预测的 API 会使得你的组件更容易被其他开发者使用。</p><p>组件 props 通过自定义标签的属性来传递。属性的值可以是 Vue.js 字符串(:attr=”value” 或 v-bind:attr=”value”)或是不传。你需要保证组件的 props 能应对不同的情况。</p><h2 id="为什么？-3"><a href="#为什么？-3" class="headerlink" title="为什么？"></a>为什么？</h2><p>验证组件 props 可以保证你的组件永远是可用的（防御性编程）。即使其他开发者并未按照你预想的方法使用时也不会出错。</p><h2 id="怎么做？-3"><a href="#怎么做？-3" class="headerlink" title="怎么做？"></a>怎么做？</h2><ul><li>提供默认值。</li><li>使用 type 属性校验类型。</li><li>使用 props 之前先检查该 prop 是否存在。</li></ul><pre><code>&lt;template&gt;  &lt;input type="range" v-model="value" :max="max" :min="min"&gt;&lt;/template&gt;&lt;script type="text/javascript"&gt;  export default {    props: {      max: {        type: Number, // 这里添加了数字类型的校验        default() { return 10; },      },      min: {        type: Number,        default() { return 0; },      },      value: {        type: Number,        default() { return 4; },      },    },  };&lt;/script&gt;</code></pre><h1 id="将-this-赋值给-component-变量"><a href="#将-this-赋值给-component-变量" class="headerlink" title="将 this 赋值给 component 变量"></a>将 this 赋值给 component 变量</h1><p>在 Vue.js 组件上下文中，this指向了组件实例。因此当你切换到了不同的上下文时，要确保 this 指向一个可用的 component 变量。</p><p>换句话说，如果你正在使用 ES6 的话，就不要再编写 var self = this; 这样的代码了，您可以安全地使用 Vue 组件。</p><h2 id="为什么？-4"><a href="#为什么？-4" class="headerlink" title="为什么？"></a>为什么？</h2><ul><li>使用 ES6，就不再需要将 this 保存到一个变量中了。</li><li>一般来说，当你使用箭头函数时，会保留 this 的作用域。（译者注：箭头函数没有它自己的 this 值，箭头函数内的 this 值继承自外围作用域。）</li><li>如果你没有使用 ES6，当然也就不会使用 箭头函数 啦，那你必须将 “this” 保存到到某个变量中。这是唯一的例外。</li></ul><h2 id="怎么做？-4"><a href="#怎么做？-4" class="headerlink" title="怎么做？"></a>怎么做？</h2><pre><code>&lt;script type="text/javascript"&gt;export default {  methods: {    hello() {      return 'hello';    },    printHello() {      console.log(this.hello());    },  },};&lt;/script&gt;&lt;!-- 避免 --&gt;&lt;script type="text/javascript"&gt;export default {  methods: {    hello() {      return 'hello';    },    printHello() {      const self = this; // 没有必要      console.log(self.hello());    },  },};&lt;/script&gt;</code></pre><h1 id="组件结构化"><a href="#组件结构化" class="headerlink" title="组件结构化"></a>组件结构化</h1><p>按照一定的结构组织，使得组件便于理解。</p><h2 id="为什么？-5"><a href="#为什么？-5" class="headerlink" title="为什么？"></a>为什么？</h2><ul><li>导出一个清晰、组织有序的组件，使得代码易于阅读和理解。同时也便于标准化。</li><li>按首字母排序 properties、data、computed、watches 和 methods 使得这些对象内的属性便于查找。</li><li>合理组织，使得组件易于阅读。（name; extends; props, data 和 computed; components; watch 和 methods; lifecycle methods 等）。</li><li>使用 name 属性。借助于 vue devtools 可以让你更方便的测试。</li><li>合理的 CSS 结构，如 BEM 或 rscss - 详情？。</li><li>使用单文件 .vue 文件格式来组件代码。</li></ul><h2 id="怎么做？-5"><a href="#怎么做？-5" class="headerlink" title="怎么做？"></a>怎么做？</h2><p>组件结构化</p><pre><code>&lt;template lang="html"&gt;  &lt;div class="Ranger__Wrapper"&gt;    &lt;!-- ... --&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script type="text/javascript"&gt;  export default {    // 不要忘记了 name 属性    name: 'RangeSlider',    // 使用组件 mixins 共享通用功能    mixins: [],    // 组成新的组件    extends: {},    // 组件属性、变量    props: {      bar: {}, // 按字母顺序      foo: {},      fooBar: {},    },    // 变量    data() {},    computed: {},    // 使用其它组件    components: {},    // 方法    watch: {},    methods: {},    // 生命周期函数    beforeCreate() {},    mounted() {},  };&lt;/script&gt;&lt;style scoped&gt;  .Ranger__Wrapper { /* ... */ }&lt;/style&gt;</code></pre><h1 id="避免-this-parent"><a href="#避免-this-parent" class="headerlink" title="避免 this.$parent"></a>避免 this.$parent</h1><p>Vue.js 支持组件嵌套，并且子组件可访问父组件的上下文。访问组件之外的上下文违反了基于模块开发的第一原则。因此你应该尽量避免使用 this.$parent。</p><h2 id="为什么？-6"><a href="#为什么？-6" class="headerlink" title="为什么？"></a>为什么？</h2><ul><li>组件必须相互保持独立，Vue 组件也是。如果组件需要访问其父层的上下文就违反了该原则。</li><li>如果一个组件需要访问其父组件的上下文，那么该组件将不能在其它上下文中复用。</li></ul><h2 id="怎么做？-6"><a href="#怎么做？-6" class="headerlink" title="怎么做？"></a>怎么做？</h2><ul><li>通过 props 将值传递给子组件。</li><li>通过 props 传递回调函数给子组件来达到调用父组件方法的目的。</li><li>通过在子组件触发事件来通知父组件。</li></ul><h1 id="谨慎使用-this-refs"><a href="#谨慎使用-this-refs" class="headerlink" title="谨慎使用 this.$refs"></a>谨慎使用 this.$refs</h1><p>Vue.js 支持通过 ref 属性来访问其它组件和 HTML 元素。并通过 this.$refs 可以得到组件或 HTML 元素的上下文。在大多数情况下，通过 this.$refs来访问其它组件的上下文是可以避免的。在使用的的时候你需要注意避免调用了不恰当的组件 API，所以应该尽量避免使用 this.$refs。</p><h2 id="为什么？-7"><a href="#为什么？-7" class="headerlink" title="为什么？"></a>为什么？</h2><ul><li>组件必须是保持独立的，如果一个组件的 API 不能够提供所需的功能，那么这个组件在设计、实现上是有问题的。</li><li>组件的属性和事件必须足够的给大多数的组件使用。</li></ul><h2 id="怎么做？-7"><a href="#怎么做？-7" class="headerlink" title="怎么做？"></a>怎么做？</h2><ul><li>提供良好的组件 API。</li><li>总是关注于组件本身的目的。</li><li>拒绝定制代码。如果你在一个通用的组件内部编写特定需求的代码，那么代表这个组件的 API 不够通用，或者你可能需要一个新的组件来应对该需求。</li><li>检查所有的 props 是否有缺失的，如果有提一个 issue 或是完善这个组件。</li><li>检查所有的事件。子组件向父组件通信一般是通过事件来实现的，但是大多数的开发者更多的关注于 props 从忽视了这点。</li><li>Props向下传递，事件向上传递！。以此为目标升级你的组件，提供良好的 API 和 独立性。</li><li>当遇到 props 和 events 难以实现的功能时，通过 this.$refs来实现。</li><li>当需要操作 DOM 无法通过指令来做的时候可使用 this.$ref 而不是 JQuery、document.getElement*、document.queryElement。</li></ul><pre><code>&lt;!-- 推荐，并未使用 this.$refs --&gt;&lt;range :max="max"  :min="min"  @current-value="currentValue"  :step="1"&gt;&lt;/range&gt;</code></pre><pre><code>&lt;!-- 使用 this.$refs 的适用情况--&gt;&lt;modal ref="basicModal"&gt;  &lt;h4&gt;Basic Modal&lt;/h4&gt;  &lt;button class="primary" @click="$refs.basicModal.hide()"&gt;Close&lt;/button&gt;&lt;/modal&gt;&lt;button @click="$refs.basicModal.open()"&gt;Open modal&lt;/button&gt;&lt;!-- Modal component --&gt;&lt;template&gt;  &lt;div v-show="active"&gt;    &lt;!-- ... --&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  export default {    // ...    data() {      return {        active: false,      };    },    methods: {      open() {        this.active = true;      },      hide() {        this.active = false;      },    },    // ...  };&lt;/script&gt;</code></pre><pre><code>&lt;!-- 如果可通过 emited 来做则避免通过 this.$refs 直接访问 --&gt;&lt;template&gt;  &lt;range :max="max"    :min="min"    ref="range"    :step="1"&gt;&lt;/range&gt;&lt;/template&gt;&lt;script&gt;  export default {    // ...    methods: {      getRangeCurrentValue() {        return this.$refs.range.currentValue;      },    },    // ...  };&lt;/script&gt;</code></pre><h1 id="使用组件名作为样式作用域空间"><a href="#使用组件名作为样式作用域空间" class="headerlink" title="使用组件名作为样式作用域空间"></a>使用组件名作为样式作用域空间</h1><p>Vue.js 的组件是自定义元素，这非常适合用来作为样式的根作用域空间。可以将组件名作为 CSS 类的命名空间。</p><h2 id="为什么？-8"><a href="#为什么？-8" class="headerlink" title="为什么？"></a>为什么？</h2><ul><li>给样式加上作用域空间可以避免组件样式影响外部的样式。</li><li>保持模块名、目录名、样式根作用域名一样，可以很好的将其关联起来，便于开发者理解。</li></ul><h2 id="怎么做？-8"><a href="#怎么做？-8" class="headerlink" title="怎么做？"></a>怎么做？</h2><p>使用组件名作为样式命名的前缀，可基于 BEM 或 OOCSS 范式。同时给 style 标签加上 scoped 属性。加上 scoped 属性编译后会给组件的 class 自动加上唯一的前缀从而避免样式的冲突。</p><pre><code>&lt;style scoped&gt;  /* 推荐 */  .MyExample { }  .MyExample li { }  .MyExample__item { }  /* 避免 */  .My-Example { } /* 没有用组件名或模块名限制作用域, 不符合 BEM 规范 */&lt;/style&gt;</code></pre><h1 id="尽可能使用-mixins"><a href="#尽可能使用-mixins" class="headerlink" title="尽可能使用 mixins"></a>尽可能使用 mixins</h1><h2 id="为什么"><a href="#为什么" class="headerlink" title="为什么?"></a>为什么?</h2><p>Mixins 封装可重用的代码，避免了重复。如果两个组件共享有相同的功能，则可以使用 mixin。通过 mixin，你可以专注于单个组件的任务和抽象的通用代码。这有助于更好地维护你的应用程序。</p><h2 id="怎么做"><a href="#怎么做" class="headerlink" title="怎么做?"></a>怎么做?</h2><p>假设你有一个移动端和桌面端的菜单组件，它们共享一些功能。我们可以抽象出这两个组件的核心功能到一个 mixin 中，例如：</p><pre><code>const MenuMixin = {  data () {    return {      language: 'EN'    }  },  methods: {    changeLanguage () {      if (this.language === 'DE') this.$set(this, 'language', 'EN')      if (this.language === 'EN') this.$set(this, 'language', 'DE')    }  }}export default MenuMixin</code></pre><p>要使用 mixin，只需将其导入到两个组件中（我只展示移动组件）。</p><pre><code>&lt;template&gt;  &lt;ul class="mobile"&gt;    &lt;li @click="changeLanguage"&gt;Change language&lt;/li&gt;  &lt;/ul&gt;&lt;/template&gt;&lt;script&gt;  import MenuMixin from './MenuMixin'  export default {    mixins: [MenuMixin]  }&lt;/script&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端规范 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端规范 </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端命名规范</title>
      <link href="2019/08/13/qian-duan-ming-ming-gui-fan/"/>
      <url>2019/08/13/qian-duan-ming-ming-gui-fan/</url>
      
        <content type="html"><![CDATA[<h1 id="驼峰式命名法介绍"><a href="#驼峰式命名法介绍" class="headerlink" title="驼峰式命名法介绍"></a>驼峰式命名法介绍</h1><ul><li>Pascal Case 大驼峰式命名法：首字母大写。eg：StudentInfo、UserInfo、ProductInfo</li><li>Camel Case 小驼峰式命名法：首字母小写。eg：studentInfo、userInfo、productInfo</li></ul><h1 id="文件资源命名"><a href="#文件资源命名" class="headerlink" title="文件资源命名"></a>文件资源命名</h1><ul><li>文件名不得含有空格</li><li>文件名建议只使用小写字母，不使用大写字母。( 为了醒目，某些说明文件的文件名，可以使用大写字母，比如README、LICENSE。 )</li><li>文件名包含多个单词时，单词之间建议使用半角的连词线 ( - ) 分隔。</li><li>引入资源使用相对路径，不要指定资源所带的具体协议 ( http:,https: ) ，除非这两者协议都不可用。</li></ul><h1 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h1><ul><li>命名方式 : 小驼峰式命名方法</li><li>命名规范 : 类型+对象描述的方式，如果没有明确的类型，就可以使前缀为名词</li></ul><table><thead><tr><th>类型</th><th>小写字母</th></tr></thead><tbody><tr><td>array</td><td>a</td></tr><tr><td>boolean</td><td>b</td></tr><tr><td>function</td><td>fn</td></tr><tr><td>int</td><td>i</td></tr><tr><td>object</td><td>o</td></tr><tr><td>string</td><td>s</td></tr></tbody></table><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><ul><li>命名方式 : 小驼峰方式 ( 构造函数使用大驼峰命名法 )</li><li>命名规则 : 前缀为动词</li></ul><table><thead><tr><th>动词</th><th>含义</th><th>返回值</th></tr></thead><tbody><tr><td>can</td><td>判断是否可执行某个动作 ( 权限 )</td><td>函数返回一个布尔值。true：可执行；false：不可执行</td></tr><tr><td>has</td><td>判断是否含有某个值</td><td>函数返回一个布尔值。true：含有此值；false：不含有此值</td></tr><tr><td>is</td><td>判断是否为某个值</td><td>函数返回一个布尔值。true：为某个值；false：不为某个值</td></tr><tr><td>get</td><td>获取某个值</td><td>函数返回一个非布尔值</td></tr><tr><td>set</td><td>设置某个值</td><td>无返回值、返回是否设置成功或者返回链式对象</td></tr></tbody></table><h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><ul><li>命名方法 : 全部大写</li><li>命名规范 : 使用大写字母和下划线来组合命名，下划线用以分割单词。<br>推荐：</li></ul><pre><code> var MAX_COUNT = 10; var URL = 'http://www.baidu.com';</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端规范 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css编写规范</title>
      <link href="2019/08/13/css-bian-xie-gui-fan/"/>
      <url>2019/08/13/css-bian-xie-gui-fan/</url>
      
        <content type="html"><![CDATA[<h1 id="id和class的命名"><a href="#id和class的命名" class="headerlink" title="id和class的命名"></a>id和class的命名</h1><p>ID和class的名称总是使用可以反应元素目的和用途的名称，或其他通用的名称，代替表象和晦涩难懂的名称</p><p>不推荐 :</p><pre><code>.fw-800 {  font-weight: 800;}.red {  color: red;}</code></pre><p>推荐 :</p><pre><code>.heavy {  font-weight: 800;}.important {  color: red;}</code></pre><h1 id="合理的使用ID"><a href="#合理的使用ID" class="headerlink" title="合理的使用ID"></a>合理的使用ID</h1><p>一般情况下ID不应该被用于样式，并且ID的权重很高，所以不使用ID解决样式的问题，而是使用class</p><p>不推荐：</p><pre><code>#content .title {  font-size: 2em;}</code></pre><p>推荐：</p><pre><code>.content .title {  font-size: 2em;}</code></pre><h1 id="css选择器中避免使用标签名"><a href="#css选择器中避免使用标签名" class="headerlink" title="css选择器中避免使用标签名"></a>css选择器中避免使用标签名</h1><p>从结构、表现、行为分离的原则来看，应该尽量避免css中出现HTML标签，并且在css选择器中出现标签名会存在潜在的问题。</p><h1 id="使用子选择器"><a href="#使用子选择器" class="headerlink" title="使用子选择器"></a>使用子选择器</h1><p>很多前端开发人员写选择器链的时候不使用 直接子选择器（注：直接子选择器和后代选择器的区别）。<br>有时，这可能会导致疼痛的设计问题并且有时候可能会很耗性能。然而，在任何情况下，这是一个非常不好的做法。<br>如果你不写很通用的，需要匹配到DOM末端的选择器， 你应该总是考虑直接子选择器。不推荐:</p><pre><code>.content .title {  font-size: 2rem;}</code></pre><p>推荐</p><pre><code>.content &gt; .title {  font-size: 2rem;}</code></pre><h1 id="尽量使用缩写属性"><a href="#尽量使用缩写属性" class="headerlink" title="尽量使用缩写属性"></a>尽量使用缩写属性</h1><p>尽量使用缩写属性对于代码效率和可读性是很有用的，比如font属性。不推荐：</p><pre><code>border-top-style: none;font-family: palatino, georgia, serif;font-size: 100%;line-height: 1.6;padding-bottom: 2em;padding-left: 1em;padding-right: 1em;padding-top: 0;</code></pre><p>推荐：</p><pre><code>border-top: 0;font: 100%/1.6 palatino, georgia, serif;padding: 0 1em 2em;</code></pre><h1 id="0后面不带单位"><a href="#0后面不带单位" class="headerlink" title="0后面不带单位"></a>0后面不带单位</h1><p>省略0后面的单位，</p><p>不推荐：</p><pre><code>padding-bottom: 0px;margin: 0em;</code></pre><p>推荐：</p><pre><code>padding-bottom: 0;margin: 0;</code></pre><h1 id="属性格式"><a href="#属性格式" class="headerlink" title="属性格式"></a>属性格式</h1><ul><li>为了保证一致性和可扩展性，每个声明应该用分号结束，每个声明换行。</li><li>属性名的冒号后使用一个空格。出于一致性的原因，属性和值（但属性和冒号之间没有空格）的之间始终使用一个空格。</li><li>每个选择器和属性声明总是使用新的一行。</li><li>属性选择器或属性值用双引号（””），而不是单引号（”）括起来。</li><li>URL值（url()）不要使用引号。</li></ul><p>作为最佳实践，我们应该遵循以下顺序（应该按照下表的顺序）：<br>结构性属性：</p><ul><li>display</li><li>position, left, top, right etc.</li><li>overflow, float, clear etc.</li><li>margin, padding</li></ul><p>表现性属性：</p><ul><li>background, border etc.</li><li>font, text</li></ul><p>不推荐：</p><pre><code> .box {  font-family: 'Arial', sans-serif;  border: 3px solid #ddd;  left: 30%;  position: absolute;  text-transform: uppercase;  background-color: #eee;  right: 30%;  isplay: block;  font-size: 1.5rem;  overflow: hidden;  padding: 1em;  margin: 1em;}</code></pre><p>推荐：</p><pre><code>.box {  display: block;  position: absolute;  left: 30%;  right: 30%;  overflow: hidden;  margin: 1em;  padding: 1em;  background-color: #eee;  border: 3px solid #ddd;  font-family: 'Arial', sans-serif;  font-size: 1.5rem;  text-transform: uppercase;}</code></pre><h1 id="ID-和-Class（类）-名的分隔符"><a href="#ID-和-Class（类）-名的分隔符" class="headerlink" title="ID 和 Class（类） 名的分隔符"></a>ID 和 Class（类） 名的分隔符</h1><p>使用连字符（中划线）分隔ID和Class（类）名中的单词。为了增强课理解性，在选择器中不要使用除了连字符（中划线）以为的任何字符（包括没有）来连接单词和缩写。</p><p>另外，作为该标准，预设属性选择器能识别连字符（中划线）作为单词[attribute|=value]的分隔符，<br>所以最好的坚持使用连字符作为分隔符。</p><p>不推荐</p><pre><code>.demoimage {}.error_status {}</code></pre><p>推荐</p><pre><code>#video-id {}.ads-sample {}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端规范 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
            <tag> 前端规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端请求方式：xhr、ajax、axios与fetch的区别比较</title>
      <link href="2017/06/13/qian-duan-qing-qiu-fang-shi-xhr-ajax-axios-yu-fetch-de-qu-bie-bi-jiao/"/>
      <url>2017/06/13/qian-duan-qing-qiu-fang-shi-xhr-ajax-axios-yu-fetch-de-qu-bie-bi-jiao/</url>
      
        <content type="html"><![CDATA[<p>这些都是异步请求数据的方法。在不重新刷新页面的情况下与服务器通信，交换数据，或更新页面。</p><h1 id="XMLHttpRequest对象"><a href="#XMLHttpRequest对象" class="headerlink" title="XMLHttpRequest对象"></a>XMLHttpRequest对象</h1><p>优点：</p><ul><li>不重新加载页面的情况下更新网页</li><li>在页面已加载后从服务器请求/接收数据</li><li>在后台向服务器发送数据</li></ul><p>缺点：</p><ul><li>使用起来也比较繁琐，需要设置很多值。</li><li>早期的IE浏览器有自己的实现，这样需要写兼容代码。</li></ul><p>示例：</p><pre><code>if (window.XMLHttpRequest) { // model browser  xhr = new XMLHttpRequest()} else if (window.ActiveXObject) { // IE 6 and older  xhr = new ActiveXObject('Microsoft.XMLHTTP')}xhr.open('POST', url, true)xhr.send(data)xhr.onreadystatechange = function () {if (request.readyState === 4) { // 成功完成        // 判断响应状态码        if (request.status === 200) {            // 成功，通过responseText拿到响应的文本:            return success(request.responseText);        } else {            // 失败，根据响应码判断失败原因:            return fail(request.status);        }    } else {        // HTTP请求还在继续...    }}</code></pre><h1 id="jQuery-ajax"><a href="#jQuery-ajax" class="headerlink" title="jQuery ajax"></a>jQuery ajax</h1><p>AJAX请求也兼容了各浏览器，对XMLHttpRequest对象的封装。</p><p>优点：</p><ul><li>对原生XHR的封装，做了兼容处理，简化了使用。</li><li>增加了对JSONP的支持，可以简单处理部分跨域。</li></ul><p>缺点：</p><ul><li>如果有多个请求，并且有依赖关系的话，容易形成回调地狱。</li><li>本身是针对MVC的编程，不符合现在前端MVVM的浪潮。</li><li>ajax是jQuery中的一个方法。如果只是要使用ajax却要引入整个jQuery非常的不合理。</li></ul><p>示例：</p><pre><code>$.ajax({  type: 'POST',  url: url,   data: data,  dataType: dataType,  success: function () {},  error: function () {}})</code></pre><h1 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h1><p>Axios是一个基于promise的HTTP库，可以用在浏览器和 node.js 中。它本质也是对原生XMLHttpRequest的封装，只不过它是Promise的实现版本，符合最新的ES规范。</p><p>优点：</p><ul><li>从浏览器中创建XMLHttpRequests</li><li>从 node.js 创建 http 请求</li><li>支持 Promise API</li><li>拦截请求和响应</li><li>转换请求数据和响应数据</li><li>取消请求</li><li>自动转换 JSON 数据</li><li>客户端支持防御 XSRF</li></ul><p>缺点：</p><ul><li>只持现代代浏览器。</li></ul><pre><code>axios({    method: 'post',    url: '/user/12345',    data: {      firstName: 'liu',      lastName: 'weiqin'    }  })  .then(res =&gt; console.log(res))  .catch(err =&gt; console.log(err))</code></pre><h1 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h1><p>优点：</p><ul><li>语法简洁，更加语义化</li><li>基于标准 Promise 实现，支持 async/await</li></ul><p>缺点：</p><ul><li>Fetch 请求默认是不带 cookie 的，需要设置 fetch(url, {credentials: ‘include’})</li><li>服务器返回 400，500 错误码时并不会 reject，只有网络错误这些导致请求不能完成时，fetch 才会被 reject。</li></ul><p>示例：</p><pre><code>fetch('http://example.com/movies.json')  .then(function(response) {    return response.json();  })  .then(function(myJson) {    console.log(myJson);  });</code></pre><p>ts对fetch简单封装下：</p><pre><code>import _ from 'lodash';import 'whatwg-fetch';interface ReqInit extends RequestInit {  headers?: Record&lt;string, string&gt;;  /** eg. ?a=1 */  params?: { [key: string]: any };  /** eg. /:id/.. */  router?: { [key: string]: any };  /** 超时时间，默认3000 */  timeout?: number;}async function request&lt;T = any&gt;(path: string, init: ReqInit = {}): Promise&lt;T&gt; {  const mergeInit = {    ...request.default,    ...init,    headers: { ...request.default.headers, ...init.headers },  };  const { params, router, body, timeout, headers } = mergeInit;  let url = path;  if (router) {    url = path.replace(/:([A-Za-z]+)/g, (substring, p1: string) =&gt; router[p1]);  }  if (params) {    url += _(      _.reduce(params, (prev, val, key) =&gt; `${prev}${key}=${val}&amp;`, '?'),    ).trimEnd('&amp;');  }  if (!Reflect.get(headers, 'Content-Type')) {    if (typeof body === 'string') {      Reflect.set(headers, 'Content-Type', 'application/json');    }  }  try {    const response: Response = await Promise.race([      fetch(url, mergeInit),      new Promise&lt;any&gt;((resolve, reject) =&gt; {        setTimeout(          () =&gt; reject({ status: 408, statusText: 'TIME_OUT_ERR', url }),          timeout,        );      }),    ]);    if (response.ok) {      if (request.interceptors.response) {        return await request.interceptors.response(response);      }      return await response.json();    }    throw response;  } catch (error) {    if (request.interceptors.catch) {      request.interceptors.catch(error);    }    throw error;  }}request.default = {  method: 'GET',  headers: {    Accept: '*/*',  },  mode: 'cors',  timeout: 3000,  // credentials: 'include' // send cookies} as ReqInit;request.interceptors = {  response: null,  catch: null,} as {  response: ((response: Response) =&gt; Promise&lt;any&gt;) | null;  catch: ((error: Partial&lt;Response&gt;) =&gt; void) | null;};export default request;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据请求 </tag>
            
            <tag> 前端基础 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
