<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>vue项目性能优化方案</title>
      <link href="2020/10/30/vue-xiang-mu-xing-neng-you-hua-fang-an/"/>
      <url>2020/10/30/vue-xiang-mu-xing-neng-you-hua-fang-an/</url>
      
        <content type="html"><![CDATA[<h1 id="按需使用第三方库"><a href="#按需使用第三方库" class="headerlink" title="按需使用第三方库"></a>按需使用第三方库</h1><p>项目引入过多的第三方库会增大项目体积，带来性能问题<br>。以 Bootstrap 为例，如果你只是用一下它的响应式机制，还不如自己手写相关的 CSS，也不会太复杂，完全没有必要引入整个库。moment.js，Lodash.js这些库为了普适性，提供了尽可能多的功能，但你的项目可能只用了极少部分。我们不鼓励重复造轮子，但是要按需引入。现在很多库都提供了 ES 模块化的方式，也可以做到这一点。</p><p>采用按需引入的方式引入第三方组件，减少在入口文件全局引入。</p><h1 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a>路由懒加载</h1><p>路由懒加载也可以提高入口页面的加载速度，因为很多路由页面在多数情况下并没有被访问，在打包的时候放到单独的文件里可以减少入口页的体积。路由懒加载是通过 webpack 的动态 import来实现的。</p><pre><code>// in router.jsimport Home from '@/views/Home.vue'; // 静态 importconst About = () =&gt; import('@/views/About.vue'); // 动态 importconst router = new VueRouter({  routes: [    { path: '/', component: Home },    { path: '/about', component: About }  ]})</code></pre><p>另外，这些懒加载的路由还可以分组，让相关性模块的多个路由页面打包到同一个 chunk，算是一种折中方案：既实现了按需加载，又不会过于碎片化。适用于子路由页面。</p><pre><code>// in router.jsimport Home from '@/views/Home.vue'; // traditonal importsimport User from '@/views/User.vue';const About = () =&gt;  import('@/views/About.vue'); // dynamic importconst router = new VueRouter({  routes: [    { path: '/', component: Home },    { path: '/about', component: About },    { path: '/user/:id', component: User,       children: [        {          path: '/settings',          component: () =&gt; import(/* webpackChunkName: "user" */ '@/views/UserSettings')        },        {          path: '/articles',          component: () =&gt; import(/* webpackChunkName: "user" */ '@/views/UserArticles')        }      ]    }   ]})</code></pre><p>这是通过 webpack 的注释语法/* webpackChunkName: “user” */实现的，webpackChunkName相同的路由会打进同一个 chunk文件。</p><h1 id="只做展示用数据禁用响应式"><a href="#只做展示用数据禁用响应式" class="headerlink" title="只做展示用数据禁用响应式"></a>只做展示用数据禁用响应式</h1><p>默认情况下，定义在 Vue 组件data 里的数据都是响应式的，这种机制方便了数据绑定，当数据变化时界面得到自动更新。但有时候我们只是将数据显示到界面上，之后也不会改变它。这种情况下我们根本用不上响应式机制，而实现响应式是有性能代价的，特别是对于大对象和大列表。</p><p>建议将data还有Vuex 里面只用于展示的数据通过Object.freeze()禁用对象的响应式特性。</p><h1 id="资源释放"><a href="#资源释放" class="headerlink" title="资源释放"></a>资源释放</h1><ol><li> 如果在mounted/created 钩子中使用了$on，需要在beforeDestroy 中做对应解绑($off)处理</li><li> 如果在mounted/created 钩子中绑定了DOM/BOM 对象中的事件，需要在beforeDestroy 中做对应解绑处理</li><li> 如果在mounted/created 钩子中使用了第三方库初始化，需要在beforeDestroy 中做对应销毁处理</li><li> 如果使用setTimeout setInterval需要在beforeDestroy中做对应销毁处理，（最好不用）可以使用nextTick代替</li><li> 模块形成的闭包内部变量使用完后没有置成null</li><li> 全局变量没有回收</li><li> 绑在EventBus的事件没有解绑，注册的总线事件（Bus）要在组件销毁时(beforeDestroy/destroyed)卸载</li></ol><h1 id="v-if-和-v-show-区分使用场景"><a href="#v-if-和-v-show-区分使用场景" class="headerlink" title="v-if 和 v-show 区分使用场景"></a>v-if 和 v-show 区分使用场景</h1><p>v-if&nbsp;是&nbsp;真正&nbsp;的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</p><p>v-show&nbsp;就简单得多， 不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 的 display 属性进行切换。</p><p>所以，v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景；v-show 则适用于需要非常频繁切换条件的场景。</p><h1 id="computed-和-watch-区分使用场景"><a href="#computed-和-watch-区分使用场景" class="headerlink" title="computed 和 watch &nbsp;区分使用场景"></a>computed 和 watch &nbsp;区分使用场景</h1><p>（1）computed：&nbsp;是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed &nbsp;的值；</p><p>（2） watch：&nbsp;更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；</p><p>运用场景：</p><p>当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；</p><p>当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</p><h1 id="v-for-遍历必须为-item-添加-key，且避免同时使用-v-if"><a href="#v-for-遍历必须为-item-添加-key，且避免同时使用-v-if" class="headerlink" title="v-for 遍历必须为 item 添加 key，且避免同时使用 v-if"></a>v-for 遍历必须为 item 添加 key，且避免同时使用 v-if</h1><p>（1）v-for 遍历必须为 item 添加 key</p><p>在列表数据进行遍历渲染时，需要为每一项 item 设置唯一 key 值，方便 Vue.js 内部机制精准找到该条列表数据。当 state 更新时，新的状态值和旧的状态值对比，较快地定位到 diff 。</p><p>（2）v-for 遍历避免同时使用 v-if</p><p>v-for 比 v-if 优先级高，如果每一次都需要遍历整个数组，将会影响速度，尤其是当之需要渲染很小一部分的时候，必要情况下应该替换成 computed 属性。</p><pre><code>&lt;ul&gt;  &lt;li    v-for="user in activeUsers"    :key="user.id"&gt;    {{ user.name }}  &lt;/li&gt;&lt;/ul&gt;computed: {  activeUsers: function () {    return this.users.filter(function (user) {   return user.isActive    })  }}</code></pre><h1 id="减少-ES6-转为-ES5-的冗余代码"><a href="#减少-ES6-转为-ES5-的冗余代码" class="headerlink" title="减少 ES6 转为 ES5 的冗余代码"></a>减少 ES6 转为 ES5 的冗余代码</h1><p>Babel 插件会在将 ES6 代码转换成 ES5 代码时会注入一些辅助函数，例如下面的 ES6 代码：</p><pre><code>class HelloWebpack extends Component{...}</code></pre><p>这段代码再被转换成能正常运行的 ES5 代码时需要以下两个辅助函数：</p><pre><code>babel-runtime/helpers/createClass  // 用于实现 class 语法babel-runtime/helpers/inherits  // 用于实现 extends 语法</code></pre><p>在默认情况下， Babel 会在每个输出文件中内嵌这些依赖的辅助函数代码，如果多个源代码文件都依赖这些辅助函数，那么这些辅助函数的代码将会出现很多次，造成代码冗余。为了不让这些辅助函数的代码重复出现，可以在依赖它们时通过&nbsp;require(‘babel-runtime/helpers/createClass’)&nbsp;的方式导入，这样就能做到只让它们出现一次。babel-plugin-transform-runtime&nbsp;插件就是用来实现这个作用的，将相关辅助函数进行替换成导入语句，从而减小 babel 编译出来的代码的文件大小。</p><p>首先，安装 babel-plugin-transform-runtime ：</p><pre><code>npm install babel-plugin-transform-runtime --save-dev</code></pre><p>然后，修改 .babelrc  配置文件为：</p><pre><code>"plugins": [    "transform-runtime"]</code></pre><h1 id="开启gzip压缩"><a href="#开启gzip压缩" class="headerlink" title="开启gzip压缩"></a>开启gzip压缩</h1><p>首先，修改productionGzip 为true,<br>安装 compression-webpack-plugin ：</p><pre><code> //  npm install --save-dev compression-webpack-plugin  //(此处有坑) 如果打包报错，应该是版本问题 ，先卸载之前安装的此插件 ，然后安装低版本   npm install --save-dev compression-webpack-plugin@1.1.11</code></pre><p>修改nginx的配置</p><pre><code>http {  //在 http中配置如下代码，   gzip on;   gzip_disable "msie6";    gzip_vary on;    gzip_proxied any;   gzip_comp_level 8; #压缩级别   gzip_buffers 16 8k;   #gzip_http_version 1.1;   gzip_min_length 100; #不压缩临界值   gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png; }</code></pre><h1 id="图片懒加载"><a href="#图片懒加载" class="headerlink" title="图片懒加载"></a>图片懒加载</h1><p>如果应用里需要展示大量图片，通常的做法是懒加载图片。懒加载的基本原理是提前准备好图片 URL，当图片真正进入可视范围时才去加载。可以手动实现懒加载机制，不过更方便的是直接用现成的插件，比如 [vue-lazyload]<br>安装：</p><pre><code>npm i vue-lazyload -S</code></pre><p>引入：</p><pre><code>import VueLazyload from 'vue-lazyload'Vue.use(VueLazyload)</code></pre><p>使用：</p><pre><code> &lt;ul&gt;    &lt;li v-for="img in list"&gt;      &lt;img v-lazy="img.src"&gt;    &lt;/li&gt;  &lt;/ul&gt;</code></pre><h1 id="cdn加速"><a href="#cdn加速" class="headerlink" title="cdn加速"></a>cdn加速</h1><p>采用cdn加速去从别的服务器上加载第三方库而非自己的服务器，这样就会快很多.并且能节省自己服务器的带宽。</p><p>首先，在index.html中 将你所需的第三方库的链接加载进来：</p><pre><code>&lt;script src="https://cdn.bootcdn.net/ajax/libs/vue/3.0.0-beta.18/vue.cjs.js"&gt;&lt;/script&gt;</code></pre><p>在webpack.base.conf 中添加 externals 来告诉webpack我们这些第三方库不需要打包</p><pre><code>externals:{    // key表示第三方插件名称，value是暴露出的全局变量    'vue':'Vue'}</code></pre><p>在 主文件main.js 或者其他 js 修改引用这些配置的第三方插件</p><pre><code>// import Vue from 'vue';const Vue = require('vue');</code></pre><h1 id="Webpack-对图片进行压缩"><a href="#Webpack-对图片进行压缩" class="headerlink" title="Webpack 对图片进行压缩"></a>Webpack 对图片进行压缩</h1><p>安装 image-webpack-loader ：</p><pre><code>npm install image-webpack-loader --save-dev</code></pre><p>然后，在 webpack.base.conf.js  中进行配置：</p><pre><code>{  test: /\.(png|jpe?g|gif|svg)(\?.*)?$/,  use:[     {      loader: 'url-loader',      options: {        limit: 10000 ,        name: '[path][name].[ext]?[hash:6]!./dir/file.png'      }    },    /*对图片进行压缩*/    {      loader: 'image-webpack-loader',      query: {        progressive: true,        optimizationLevel: 7,        interlaced: false,        pngquant: {          quality: '65-90',          speed: 4        }      }    }  ]}</code></pre><h1 id="pax-ui框架相关"><a href="#pax-ui框架相关" class="headerlink" title="pax-ui框架相关"></a>pax-ui框架相关</h1><p>（1） 表单组件<br>pax组件的Form表单组件会对绑定数据监听，表单组件很多的情况下页面会卡顿，在pax-form上设置局部更新，会提升一部分性能。</p><pre><code>&lt;pax-form :form="form" :selfUpdate="true"&gt;&lt;/pax-form&gt;</code></pre><p>(2) select组件<br>select大数据量情况下，会造成页面元素较多，在ie上消耗更多的内存。建议采用虚拟滚动的方式：</p><pre><code>import { RecycleScroller} from 'vue-virtual-scroller';// 在Select预留卡槽中使用详情见文档：IE浏览器select大数据问题造成输入不流畅分析处理</code></pre><p>（3）tree组件<br>pax-tree在ie上问题严重,如果兼容ie，建议用@pa/vue-org-tree,使用方法参考ztree.js</p><pre><code>npm install @pa/vue-org-tree --save-dev</code></pre>]]></content>
      
      
      <categories>
          
          <category> 新鲜技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript在vue项目中的应用</title>
      <link href="2020/10/30/ts-zai-vue-xiang-mu-zhong-de-ying-yong/"/>
      <url>2020/10/30/ts-zai-vue-xiang-mu-zhong-de-ying-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="1-引言"><a href="#1-引言" class="headerlink" title="1 引言"></a>1 引言</h1><p>TypeScript 是一种由微软开发的自由和开源的编程语言。它是 JavaScript 的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程。</p><p>TypeScript 优势：</p><ul><li>静态类型检查与代码提示</li><li>适用大型项目开发，如代码重构等</li><li>更好的协作</li><li>更强的生产力</li></ul><h1 id="2-ts语法知识"><a href="#2-ts语法知识" class="headerlink" title="2 ts语法知识"></a>2 ts语法知识</h1><h2 id="2-1类型系统"><a href="#2-1类型系统" class="headerlink" title="2.1类型系统"></a>2.1类型系统</h2><p><img src="http://qj245iy9p.hn-bkt.clouddn.com/%E7%B1%BB%E5%9E%8B%E6%B3%A8%E8%A7%A3.mindmap.png" alt="image"></p><h2 id="2-2类型保护"><a href="#2-2类型保护" class="headerlink" title="2.2类型保护"></a>2.2类型保护</h2><blockquote><p>类型保护是可执行运行时检查的一种表达式，用于确保该类型在一定的范围内。</p></blockquote><ol><li>as 操作符（类型断言）<br>当你比 ts 更确定其数据类型，你能使用 as 语法确定其类型，但需要遵守类型兼容转换。 另外一种写法：<typename>varName，但不建议使用</typename></li></ol><pre><code>function getDynamicValue(): number | string | undefined {  ...}const v = getDynamicValue(); // v:number|string|undefined，联合类型变量只允许访问所有类型共有的属性// 确定返回 string(v as string).trim();</code></pre><ol start="2"><li>typeof 操作符</li></ol><pre><code>function isNumber(val: any): val is number {  return typeof val === 'number';}const a: any = 1;if (isNumber(a)) {  // a:number}</code></pre><ol start="3"><li>instanceof 操作符</li></ol><pre><code>class Base {  ...}class A extends Base {  ...}const inst: Base = new A();if (inst instanceof A) {  // inst:A}</code></pre><ol start="4"><li>函数或变量后面添加 !</li></ol><p>当要去掉联合类型的可空类型（null | undefined）,可以使用 js if 语句或短路运算符实现类型保护，也可以使用 Typescript 2.0+ !语法</p><pre><code>const x: string | null = getDynamicValue();// if判断if (x) {  // x:string}// 短路运算符function f(sn: string | null) {  return sn || '';}// !语法x!.trim();// orconst r = [1, 2, 3, 4].find(x =&gt; x === 3)!; // r:number</code></pre><h1 id="3-开发环境准备"><a href="#3-开发环境准备" class="headerlink" title="3 开发环境准备"></a>3 开发环境准备</h1><h2 id="3-1-插件安装"><a href="#3-1-插件安装" class="headerlink" title="3.1 插件安装"></a>3.1 插件安装</h2><h3 id="3-1-1-Webpack-转译-Typescript-现有方案"><a href="#3-1-1-Webpack-转译-Typescript-现有方案" class="headerlink" title="3.1.1 Webpack 转译 Typescript 现有方案"></a>3.1.1 Webpack 转译 Typescript 现有方案</h3><h4 id="1-ts-loader-babel-loader-fork-ts-checker-webpack-plugin"><a href="#1-ts-loader-babel-loader-fork-ts-checker-webpack-plugin" class="headerlink" title="1.ts-loader + babel-loader + fork-ts-checker-webpack-plugin"></a>1.ts-loader + babel-loader + fork-ts-checker-webpack-plugin</h4><p>修改 webpack.config.js 的配置：</p><pre><code>{     test: /\.ts?$/,     loader: "ts-loader",    options: {        // .vue文件必须加        appendTsSuffixTo: [/\.vue$/]    },    exclude:/node_modules/}</code></pre><p>每次重建时，类型脚本的语义检查器必须检查所有文件,随着项目变得越来越大，编译时间线性增加。这时我们使用 fork-ts-checker-webpack-plugin 另外开一个线程来进行类型检查，安装依赖：</p><pre><code>npm install -D fork-ts-checker-webpack-plugin//使用：const ForkTsCheckerWebpackPlugin = require('fork-ts-checker-webpack-plugin');plugins:[    new ForkTsCheckerWebpackPlugin()]</code></pre><ul><li>这种方案，当 webpack 编译的时候，ts-loader 会调用 typescript（所以本地项目需要安装 typescript），然后 typescript 运行的时候会去读取本地的 tsconfig.json 文件。</li><li>默认情况下，ts-loader 会进行 转译 和 类型检查，每当文件改动时，都会重新去 转译 和 类型检查，当文件很多的时候，就会特别慢，影响开发速度。所以需要使用 fork-ts-checker-webpack-plugin ，开辟一个单独的线程去执行类型检查的任务，这样就不会影响 webpack 重新编译的速度。</li><li>fork-ts-checker-webpack-plugin  这个插件要求最低 Node.js 6.11.5，webpack 4，TypeScript 2.1 和可选的 ESLint 6（其本身要求最低 Node.js 8.10.0）。</li></ul><h4 id="2-babel-loader-babel-preset-typescript"><a href="#2-babel-loader-babel-preset-typescript" class="headerlink" title="2. babel-loader + @babel/preset-typescript"></a>2. babel-loader + @babel/preset-typescript</h4><p>修改webpack.config.js</p><pre><code>rules: [        {          test:/\.(tsx?|jsx?)$/,          // 默认会调用 @babel/core           use:'babel-loader'        }]</code></pre><p>.babelrc</p><pre><code>{    "presets": [        "@babel/env"        "@vue/babel-preset-jsx",        "@babel/preset-typescript"    ]}</code></pre><ul><li>这种方案，当 webpack 编译的时候，babel-loader 会读取 .babelrc 里的配置，不会调用 typescript（所以本地项目无需安装 typescript），不会去检查类型</li><li> 需要配置tsconfig.json的，因为需要在开发代码时，让 idea 提示错误信息</li></ul><h2 id="3-2-ts项目基本构成"><a href="#3-2-ts项目基本构成" class="headerlink" title="3.2 ts项目基本构成"></a>3.2 ts项目基本构成</h2><p>一个vue+ts项目的目录结构（<a href="https://github.com/leeycode/typeScript-vue-starter/">typeScript-vue-starter</a>）：</p><pre><code>├── /@types/                     # 全局类型声明├── /build/                      # webpack配置文件├── /src/                        # 源码目录│ ├── /assets/                   # 静态资源目录│ ├── /components/               # 公共组件目录│ ├── /constants/                # 项目constants目录│ │ ├── _const.less              # less常量│ ├── /pages/                    # UI组件目录│ ├── /services/                 # 请求服务目录│ ├── /router/                   # 路由目录│ ├── /store/                    # 存放store文件目录│ ├── /style/                    # 全局样式│ ├── /utils/                    # utils目录│ │ ├── request.ts               # 基于fetch封装的API请求工具│ │ ├── global.ts                # 公共方法库│ └── main.ts                    # 项目入口|——tsconfig.json                 # ts配置|——...</code></pre><h2 id="3-3-tsconfig-json"><a href="#3-3-tsconfig-json" class="headerlink" title="3.3 tsconfig.json"></a>3.3 tsconfig.json</h2><p>在项目根目录下，这个json文件规定了ts的编译选项，相见的编译选项配置：</p><pre><code>{  "compilerOptions": {    "baseUrl": ".",                             // 用于解析非相对模块名称的基目录    "outDir": "build/dist",                     // 指定输出目录    "module": "esnext",                         // 指定使用模块: 'commonjs', 'amd', 'system', 'umd' or 'es2015'    "target": "es5",                            // 指定 ECMAScript 目标版本:    "lib": ["dom", "esnext"],                   // 指定要包含在编译中的库文件    "sourceMap": true,                          // 生成相应的 '.map' 文件    "allowJs": true,                            // 允许编译 javascript 文件    "jsx": "preserve",                          // 指定 jsx 代码的生成: 'preserve', 'react-native'等    "moduleResolution": "node",                 // 选择模块解析策略： 'node' (Node.js) or 'classic'    "strict": true                              // 启用所有严格类型检查选项    ...  },  "include": ["src/**/*", "@types/**/*"],       // 编译包含的文件     "exclude": [                                  // 排除的文件                    "node_modules",    "build",    "scripts",    "acceptance-tests",    "webpack",    "jest",    "src/setupTests.ts",    "config"  ]}</code></pre><h2 id="3-4-声明文件"><a href="#3-4-声明文件" class="headerlink" title="3.4 声明文件"></a>3.4 声明文件</h2><h3 id="types"><a href="#types" class="headerlink" title="@types"></a>@types</h3><p>安装第三方库之前，我们可以<a href="https://microsoft.github.io/TypeSearch//">搜索DefinitelyTyped</a>，查看是否有第三方在维护类型声明。通过@types安装，就能在项目中使用它的类型声明。</p><pre><code>- Partial :把 interface 所有属性变成可选// node_modules/typescript/lib/lib.es5.d.ts,安装ts的时候生成type Partial&lt;T&gt; = {    [P in keyof T]?: T[P];};changeFilter: (filter: Partial&lt;IRequsetParams&gt;) =&gt; void;- Event// node_modules/@types/react/index.d.ts,通过@types安装react的时候生成  handleClick = (e: React.MouseEvent&lt;HTMLDivElement, MouseEvent&gt;) =&gt; {    e.stopPropagation();  };- RouteComponentProps:提供了 location、history 的类型定义// node_modules/@types/react-router/index.d.tsexport interface ILoginProps extends RouteComponentProps {  login: (values: IUser, history: H.History) =&gt; void;}</code></pre><h3 id="自定义声明文件"><a href="#自定义声明文件" class="headerlink" title="自定义声明文件"></a>自定义声明文件</h3><p>扩展名.d.ts 结尾就是项目中的声明文件。在上面的项目中，我们创建了一个名为@types的文件夹，用来维护项目中需要的变量声明。</p><ol><li>全局变量声明<pre><code>// configdeclare const config: {version: string;systemName: string;debug: boolean;...}// 约束后台返回的数据 declare interface IResponseBody&lt;T&gt; {data: T;code: number;total: number;}...</code></pre></li><li>非js资源</li></ol><pre><code>declare module '*.svg';declare module '*.png';declare module '*.jpg';declare module '*.module.css';declare module '*.module.scss' </code></pre><h1 id="4-组件编写的几种方法"><a href="#4-组件编写的几种方法" class="headerlink" title="4 组件编写的几种方法"></a>4 组件编写的几种方法</h1><h2 id="4-1-Vue-extend"><a href="#4-1-Vue-extend" class="headerlink" title="4.1 Vue.extend()"></a>4.1 Vue.extend()</h2><blockquote><p>Vue.extend():使用基础 Vue 构造器，创建一个“子类”。 这种方式最接近 Vue 的单文件组件的写法，如果一个完善 Vue 项目从 JS 改成 TS，用这种方法很快，只要加上 lang=ts和一些必要的变量类型就好了，然后用Vue.extend()包裹就好。</p></blockquote><p>main.js 改为 main.ts 内容改成：</p><pre><code>import Vue from "vue";import App from "./App.vue";new Vue({    el:"#app",    render:h=&gt;h(App)});</code></pre><p>组件写法：</p><pre><code>&lt;template&gt;    &lt;h1&gt;{{name}}&lt;/h1&gt;&lt;/template&gt;&lt;script lang="ts"&gt;//也执行tsx,也就是jsx语法import Vue from "vue";export default Vue.extend({    data(){        return {            name:'liwu'        }    }})&lt;/script&gt;&lt;style scoped&gt;h1{    color: rgb(55, 142, 230);}&lt;/style&gt;</code></pre><h2 id="4-2-vue-class-component"><a href="#4-2-vue-class-component" class="headerlink" title="4.2 vue-class-component"></a>4.2 vue-class-component</h2><blockquote><p>通常和vue-property-decorator一起搭配使用，，vue-property-decorator是在vue-class-component上扩展来的，并且提供了很多修饰器比如 @Prop和@Watch等等，使用这个可以编写类式组件。</p></blockquote><p>1.组件写法：</p><pre><code>&lt;template&gt;    &lt;h1&gt;{{name}}&lt;/h1&gt;&lt;/template&gt;&lt;script lang="ts"&gt;import Vue from "vue";import Component from 'vue-class-component';// @Component 装饰器使你的类成为Vue组件@Componentexport default class App extends Vue {    private name:string = 'liwu';}&lt;/script&gt;&lt;style scoped&gt;h1{    color: rgb(55, 142, 230);}&lt;/style&gt;</code></pre><p>修改tsconfig.js，支持装饰器语法</p><pre><code>"experimentalDecorators": true,</code></pre><h2 id="4-3-jsx"><a href="#4-3-jsx" class="headerlink" title="4.3 jsx"></a>4.3 jsx</h2><blockquote><p>JSX is an XML-like syntax extension to ECMAScript without any defined semantics. It’s NOT intended to be implemented by engines or browsers.</p></blockquote><p>1.jsx语法简介（写react的同学跳过）</p><ul><li>严格的标签闭合</li><li>组件名要大写，否则解析成html标签</li><li>变量用{}</li></ul><pre><code>let name = 'xxx';&lt;div&gt;{ name }&lt;/div&gt;</code></pre><ul><li>遍历用map</li></ul><pre><code>let list = ['李一','李二','李三'];&lt;div&gt;    {list.map((item, index) =&gt; {    return &lt;p key={index}&gt;this is {item}&lt;/p&gt;     })} &lt;/div&gt; </code></pre><ul><li>条件判断</li></ul><pre><code>&lt;div className={styles.wrapper}&gt;    {_.isEmpty(currRecord) ? null : (      &lt;Graph        graph={{ nodes, edges }}        options={this.options}        events={this.events}      /&gt;    )}&lt;/div&gt; </code></pre><ul><li>事件要用驼峰写法，传参要用bind</li></ul><pre><code>&lt;div    className={styles.content}    onMouseEnter={this.showSwitch}    onMouseLeave={this.hideSwitch}    onClick={this.handleClick.bind(this,params)}&gt;&lt;/div&gt;</code></pre><ul><li>使用domPropsInnerHTML来替代v-html</li></ul><pre><code>&lt;div    domPropsInnerHTML={this.htmlContent}&gt;&lt;/div&gt;</code></pre><p>2.组件写法</p><pre><code>import { Vue, Component } from 'vue-property-decorator';import { CreateElement } from 'vue';@Componentexport default class JSX extends Vue {  private count: number = 0;  private showInfo() {    this.count++;  }  protected render(h: CreateElement) {    return &lt;h2 onMouseenter={this.showInfo}&gt;JSX Test{this.count}&lt;/h2&gt;;  }}</code></pre><h1 id="5-class组件详细用法"><a href="#5-class组件详细用法" class="headerlink" title="5 class组件详细用法"></a>5 class组件详细用法</h1><h2 id="使用Data"><a href="#使用Data" class="headerlink" title="使用Data"></a>使用Data</h2><pre><code>@Componentexport default class HelloWorld extends Vue {  private msg: string = "welcome to my app"  private list: Array&lt;object&gt; = [    {        name: 'Melody',        age: '20'    },    {        name: 'James',        age: '20'    }  ]}</code></pre><p>与ts等效的js代码</p><pre><code>export default {  data() {    return {      msg: "welcome to my app",      list: [        {          name: 'Melody',          age: '20'        },        {          name: 'James',          age: '20'        }      ]    }}</code></pre><h2 id="使用props"><a href="#使用props" class="headerlink" title="使用props"></a>使用props</h2><p>可以添加 required, default, type 为props指定验证要求，同样也可以使用 readonly 禁止操作props</p><pre><code>import { Component, Prop, Vue } from 'vue-property-decorator'@Componentexport default class HelloWorld extends Vue {  @Prop() readonly msg!: string  @Prop({default: 'Joy Melody'}) readonly name: string  @Prop({required: true}) readonly age: number  @Prop({required: false, type: String, default: 'Developer'}) readonly job: string}</code></pre><p>与ts等效的js代码如下</p><pre><code>export default {  props: {    msg,    name: {      default: 'Joy Melody'    },    age: {      required: true,    },    address: {      type: String    },    job: {      required: false,      type: string,      default: 'Developer'    }  }}</code></pre><h2 id="Computed-属性"><a href="#Computed-属性" class="headerlink" title="Computed 属性"></a>Computed 属性</h2><pre><code>export default class HelloWorld extends Vue {  get fullName(): string {    return this.first+ ' '+ this.last  }}</code></pre><p>与ts等效的js代码如下</p><pre><code>export default {  fullName() {    return this.first + ' ' + this.last  }}</code></pre><p>复杂点的涉及到setter和getter的 computed属性，在ts中写法如下：</p><pre><code>export default class HelloWorld extends Vue {  get fullName(): string {    return this.first+ ' '+ this.last  }  set fullName(newValue: string) {    let names = newValue.split(' ')    this.first = names[0]    this.last = names[names.length - 1]  }}</code></pre><p>与ts等效的js写法如下</p><pre><code>fullName: {  get: function () {    return this.first + ' ' + this.last  },  set: function (newValue) {    let names = newValue.split(' ')    this.first = names[0]    this.last = names[names.length - 1]  }}</code></pre><h2 id="使用Watch"><a href="#使用Watch" class="headerlink" title="使用Watch"></a>使用Watch</h2><p>@Watch(path: string, options: WatchOptions = {}) </p><ul><li><p>@Watch 装饰器接收两个参数：path: string 被侦听的属性名<br>options?: WatchOptions={} options可以包含两个属性</p></li><li><p>immediate?:boolean 侦听开始之后是否立即调用该回调函数<br>deep?:boolean 被侦听的对象的属性被改变时，是否调用该回调函数</p></li></ul><pre><code>@Watch('child')onChildChanged (val: string, oldVal: string) {    if (val !== oldVal) {      window.console.log(val)    }}</code></pre><p>与ts等效的js代码如下</p><pre><code>watch: {    'child': {        handler: 'onChildChanged',        immediate: false,        deep: false     }},method: {    onChildChanged(val, oldVal) {        if (val !== oldVal) {          console.log(val)        }    }}</code></pre><p>也可以写成: @Watch(‘child’, { immediate: true, deep: true }), 等价于:</p><pre><code>watch: {    'child': {        handler: 'onChildChanged',        immediate: true,        deep: true     }},method: {    onChildChanged(val, oldVal) {        if (val !== oldVal) {          window.console.log(val)        }    }}</code></pre><h2 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h2><pre><code>export default class HelloWorld extends Vue {  public clickMe(): void {    console.log('clicked')    console.log(this.addNum(4, 2))  }  public addNum(num1: number, num2: number): number {    return num1 + num2  }}</code></pre><p>与ts等效的js代码如下</p><pre><code>export default {  methods: {    clickMe() {      console.log('clicked')      console.log(this.addNum(4, 2))    }    addNum(num1, num2) {      return num1 + num2    }  }}</code></pre><h2 id="Emit"><a href="#Emit" class="headerlink" title="Emit"></a>Emit</h2><p>子组件触发父组件的自定义事件并传递数据，在TypeScript中使用@Emit 装饰器</p><pre><code>import { Vue, Component, Emit } from 'vue-property-decorator'@Componentexport default class YourComponent extends Vue {  count = 0  @Emit()  addToCount(n: number) {    this.count += n  }}</code></pre><p>与ts等效的js代码如下</p><pre><code>export default {  data() {    return {      count: 0    }  },  methods: {    addToCount(n) {      this.count += n      this.$emit('add-to-count', n)    }  }}</code></pre><h2 id="Mixins"><a href="#Mixins" class="headerlink" title="Mixins"></a>Mixins</h2><p>假设当前已经有一个mixins/ProjectMixin文件 如何在其他组件里面使用方式如下</p><pre><code>&lt;template&gt;  &lt;div class="project-detail"&gt;    {{ projectDetail }}  &lt;/div&gt;&lt;/template&gt;&lt;script lang="ts"&gt;import { Component, Vue, Mixins } from 'vue-property-decorator'import ProjectMixin from '@/mixins/ProjectMixin'@Componentexport default class Project extends Mixins(ProjectMixin) {  get projectDetail(): string {    return this.projName + ' ' + 'HS'  }}&lt;/script&gt;</code></pre><p>与ts等效的js代码如下</p><pre><code>&lt;template&gt;  &lt;div class="project-detail"&gt;    {{ projectDetail }}  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import ProjectMixin from '@/mixins/ProjectMixin'export default {  mixins: [ ProjectMixin ],  computed: {    projectDetail() {      return this.projName + ' ' + 'HS'    }  }}&lt;/script&gt;</code></pre><p>多个混入的情况</p><pre><code>import { Component, Mixins } from 'vue-property-decorator'export default class Test extends Mixins(Mixin1, Mixin2) {    test() {      this.methodFromMixin2()      console.log(this.valFromMixin1)    }}</code></pre><h2 id="refs"><a href="#refs" class="headerlink" title="refs"></a>refs</h2><p>ts无法识别vue中的$refs,需要手动指定其类型：</p><pre><code>&lt;template&gt;  &lt;loading ref="loading"/&gt;  &lt;input type="text" ref="inputRef"&gt;&lt;/template&gt;&lt;script lang="ts"&gt;import { Component } from 'vue-property-decorator'import Loading from "@/components/Loading.vue";@Component({  components: { Loading }})export default class Project extends Vue { $refs!: {    loading: Loading;    inputRef: HTMLInputElement;  }; public mounted() {    this.$refs.loading.showLoading();    // (this.$refs.loading as Loading).showLoading();    this.$refs.inputRef.focus();  }}&lt;/script&gt;</code></pre><h1 id="6-路由"><a href="#6-路由" class="headerlink" title="6 路由"></a>6 路由</h1><h2 id="路由创建"><a href="#路由创建" class="headerlink" title="路由创建"></a>路由创建</h2><pre><code>import Vue from 'vue';import VueRouter, { RouteConfig } from 'vue-router';import Home from '@/pages/home/Home.vue';Vue.use(VueRouter);const routes: Array&lt;RouteConfig&gt; = [  {    path: '/',    name: 'home',    component: Home  },  {    path: '/about',    name: 'about',    component: () =&gt; import(/* webpackChunkName: "about" */ '@/pages/about/About.vue')  }];const router = new VueRouter({  routes});export default router;</code></pre><h2 id="组件中监听路由"><a href="#组件中监听路由" class="headerlink" title="组件中监听路由"></a>组件中监听路由</h2><pre><code>&lt;script lang="ts"&gt;import { Component, Vue, Watch } from 'vue-property-decorator';import { Route } from 'vue-router';@Componentexport default class About extends Vue {  @Watch('$route', { immediate: true })  private changeRouter(route: Route) {    console.log('route', route);  }}</code></pre><h2 id="组件中使用路由勾子函数"><a href="#组件中使用路由勾子函数" class="headerlink" title="组件中使用路由勾子函数"></a>组件中使用路由勾子函数</h2><p>main.ts中：</p><pre><code>import { Component } from 'vue-property-decorator';Component.registerHooks([  'beforeRouteEnter',  'beforeRouteLeave',  'beforeRouteUpdate']);</code></pre><p>组件中：</p><pre><code>&lt;script lang="ts"&gt;import { Component, Vue, Watch } from 'vue-property-decorator';import { Route } from 'vue-router';@Componentexport default class About extends Vue {  private beforeRouteEnter(to: Route, from: Route, next: () =&gt; void): void {    console.log('beforeRouteEnter', to, from, next);    next();   }  private beforeRouteUpdate(to: Route, from: Route, next: () =&gt; void): void {    console.log('beforeRouteUpdate'); // 暂时不生效，版本问题    next();  }  private beforeRouteLeave(to: Route, from: Route, next: () =&gt; void): void {    console.log('beforeRouteLeave');    next();  }}</code></pre><h1 id="7-数据请求"><a href="#7-数据请求" class="headerlink" title="7 数据请求"></a>7 数据请求</h1><p>对返回值和入参做类型约束：</p><pre><code>// global.d.ts declare interface ResponseBody&lt;T&gt; {  data: T;  code: number;  total: number;}declare interface ResponseStatus {  loading: boolean;  error: boolean;}declare interface Response&lt;T&gt; extends ResponseStatus {  res: IResponseBody&lt;T&gt;;}declare interface ResponseNotPage&lt;T&gt; extends ResponseStatus {  data: T;}declare interface PageParams {  page: number;  pageSize: number;}declare interface RequsetParams extends PageParams {  search: string;}// src/service/demo.tsexport const getInfo = (id: number) =&gt;  request&lt;ResponseBody&lt;{ id: number; address?: string; time?: string }&gt;&gt;(    Api.GET_LAST_TRACE_INFO,    {      router: { id }    }  );</code></pre><h1 id="8-全局状态管理"><a href="#8-全局状态管理" class="headerlink" title="8 全局状态管理"></a>8 全局状态管理</h1><h2 id="8-1-开始使用"><a href="#8-1-开始使用" class="headerlink" title="8.1 开始使用"></a>8.1 开始使用</h2><p>安装依赖</p><pre><code>npm install vuex-module-decorators --save-dev</code></pre><p>如果想通过名字空间的形式来使用module, 需在@Module装饰器中添加额外的参数. 例如, 以下示例代码中添加一个namespaced为home的module</p><pre><code>// src\store\module\home.tsimport { VuexModule, Module, Mutation, Action, getModule } from 'vuex-module-decorators';import store from '@/store';@Module({ namespaced: true, dynamic: true, name: 'home', store })export default class Home extends VuexModule {  public name: string = '';  public message: string = '';  get getMessage() {    return `当前时间${new Date()}：${this.message}`;  }  @Mutation  private SET_NAME(newName: string): void {    this.name = newName;  }  @Mutation  private SET_MESSAGE(message: string) {    this.message = message;  }  @Action  public updateMessage(newName: string): void {    this.SET_NAME(newName);    this.SET_MESSAGE('欢迎您,');  }}export const HomeModule = getModule(Home);</code></pre><p>与ts等效的js代码如下</p><pre><code>const UserModule = {    state: {        name: '',        message: ''    },    getters: {         getMessage: state =&gt; `当前时间${new Date()}：${state.user.message}`    },    mutations: {         SET_NAME: (state, name) =&gt; {            state.name = name        },        SET_MESSAGE: (state, message) =&gt; {            state.message = message        }    },    actions: {         updateMessage({commit}, newName){            commit("SET_NAME", newName);            commit("SET_MESSAGE", "欢迎您,");        }    },}</code></pre><p>dynamic模式下的store</p><pre><code>// \src\store\index.tsimport Vue from 'vue';import Vuex from 'vuex';Vue.use(Vuex);// Declare empty store first, dynamically register all modules later.export default new Vuex.Store({});</code></pre><p>组件中使用：</p><pre><code>// \src\pages\home\Home.vue&lt;template&gt;  &lt;div class="home"&gt;    &lt;img alt="Vue logo" src="../../assets/logo.png" /&gt;    &lt;hello-world msg="vue.js" /&gt;    {{ $store.state.home.name }}    &lt;br/&gt;    {{ info }}    &lt;button @click="handleClick"&gt;点击&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script lang="ts"&gt;import { Component, Vue } from 'vue-property-decorator';import HelloWorld from '@/components/HelloWorld.vue';import { HomeModule } from '@/store/modules/home';@Component({  components: {    HelloWorld  }})export default class Home extends Vue {  get info() {    return HomeModule.getMessage;  }  private handleClick() {    HomeModule.updateMessage('liwu');  }}&lt;/script&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 新鲜技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单的在线数据mock</title>
      <link href="2019/08/30/jian-dan-de-zai-xian-shu-ju-mock/"/>
      <url>2019/08/30/jian-dan-de-zai-xian-shu-ju-mock/</url>
      
        <content type="html"><![CDATA[<h1 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h1><p>在接口调试前，前端根据定义好的接口文档，模拟数据，发起请求，编写完整的页面逻辑，等真正开始调试的时候，将请求地址更换即可。</p><p>本文只介绍在线 mock 数据的方式，在线 mock 跟本地 mock 比较，可以省去安装配置，运行服务，多人协作数据不通的多种问题。</p><h1 id="一个简单的列子"><a href="#一个简单的列子" class="headerlink" title="一个简单的列子"></a>一个简单的列子</h1><p><img src="http://qj245iy9p.hn-bkt.clouddn.com/1569382088%281%29.png" alt="image"></p><p>返回结果：</p><p><img src="http://qj245iy9p.hn-bkt.clouddn.com/1569382282%281%29.png" alt="image"></p><h1 id="Mock-语法简介"><a href="#Mock-语法简介" class="headerlink" title="Mock 语法简介"></a>Mock 语法简介</h1><h2 id="base"><a href="#base" class="headerlink" title="base"></a>base</h2><pre><code>{    "base": {    "range": "@range(3, 7)",    "string": "@string(7, 20)",    "character": "@character(\"abcde\")",    "float": "@float(60, 100)",    "integer": "@integer(60, 100)",    "natural": "@natural(60, 100)",    "boolean": "@boolean"  },}</code></pre><p>预览：</p><pre><code>"base": {    "range": [3,4,5,6],    "string": "qg3)zBWiLlbrsisX",    "character": "c",    "float": 66.87535733306,    "integer": 66,    "natural": 71,    "boolean": false  },</code></pre><h2 id="date"><a href="#date" class="headerlink" title="date"></a>date</h2><pre><code>"date": {    "date": "@date",    "time": "@time",    "datetime": "@datetime",    "now": "@now"  },</code></pre><p>预览：</p><pre><code>"date": {    "date": "1971-10-18",    "time": "02:04:17",    "datetime": "1985-03-10 22:47:49",    "now": "2019-09-25 13:56:44"    }</code></pre><h2 id="image"><a href="#image" class="headerlink" title="image"></a>image</h2><pre><code> "image": {    "image": "@image(\"200x200\", \"#50B347\", \"#FFF\", \"FastMock\")"  },</code></pre><p>预览：</p><pre><code>"image": {    "image": "http://dummyimage.com/200x200/50B347/FFF&amp;text=FastMock"  },</code></pre><h2 id="text"><a href="#text" class="headerlink" title="text"></a>text</h2><pre><code>"text": {    "paragraph": "@paragraph(1, 3)",    "sentence": "@sentence(3, 5)",    "word": "@word(3, 5)",    "title": "@title(3, 5)",    "cparagraph": "@cparagraph(1, 3)",    "csentence": "@csentence(3, 5)",    "cword": "@cword(\"零一二三四五六七八九十\", 5, 7)",    "ctitle": "@ctitle(3, 5)"  },</code></pre><p>预览：</p><pre><code> "text": {    "paragraph": "Gifp ifnk hrreyi foajbgielv doijqrd ffaooi hlwstfcfw nrgsioum wtgashcoiy sintskl hnjk ebcsec. Bhlhghu embjvvs bckwkibqhs qgqz psu mjsodprwf exidxyqnq cdyqoatr xkezagaqu ijrcqrj vvxwdwgq ivv jxcpeybpus sojcn cscdlnmi kopzvuqfin.",    "sentence": "Xuqxp qvek ttgiq.",    "word": "ynug",    "title": "Cdnsxa Yjhrlbb Rmofrixln Jubgpxm Gjpdujgryi",    "cparagraph": "装增克体都月每手物即用周几想军点程。将角权响金华生候社根利情也龙。化必去边织众东位史回际平马至。",    "csentence": "存断实。",    "cword": "三七九六六",    "ctitle": "油眼采小"  },</code></pre><h2 id="name"><a href="#name" class="headerlink" title="name"></a>name</h2><pre><code>"name": {    "first": "@first",    "last": "@last",    "name": "@name",    "cfirst": "@cfirst",    "clast": "@clast",    "cname": "@cname"  },</code></pre><p>预览：</p><pre><code>"name": {    "first": "Jennifer",    "last": "Anderson",    "name": "Laura Moore",    "cfirst": "胡",    "clast": "秀兰",    "cname": "姜敏"  },</code></pre><h2 id="web"><a href="#web" class="headerlink" title="web"></a>web</h2><pre><code>"web": {    "url": "@url",    "domain": "@domain",    "protocol": "@protocol",    "tld": "@tld",    "email": "@email",    "ip": "@ip"  },</code></pre><p>预览：</p><pre><code>"web": {    "url": "mid://nypjj.kr/mizdvfhl",    "domain": "jbgmh.cn",    "protocol": "ftp",    "tld": "fj",    "email": "r.bdwejkiuy@ltatgpp.an",    "ip": "175.52.62.226"  },</code></pre><h2 id="address"><a href="#address" class="headerlink" title="address"></a>address</h2><pre><code>"address": {    "region": "@region",    "province": "@province",    "city": "@city(true)",    "county": "@county(true)",    "zip": "@zip"  },</code></pre><p>预览：</p><pre><code>"address": {    "region": "华中",    "province": "云南省",    "city": "天津 天津市",    "county": "台湾 金门县 金宁乡",    "zip": "539375"  },</code></pre><h2 id="miscellaneous"><a href="#miscellaneous" class="headerlink" title="miscellaneous"></a>miscellaneous</h2><pre><code> "miscellaneous": {    "id": "@id",    "guid": "@guid",    "increment": "@increment(1000)"  }</code></pre><p>预览：</p><pre><code> "miscellaneous": {    "id": "370000201504299208",    "guid": "6E6155c0-f5b5-F3F6-5F0D-23EB44C21313",    "increment": 253109  }</code></pre><h1 id="Mock-高阶用法"><a href="#Mock-高阶用法" class="headerlink" title="Mock 高阶用法"></a>Mock 高阶用法</h1><blockquote><p>Mock 能支持 function，function 中不能用上面的@XX,用 Mock.mock(“@xxx”)替代。function 中还能获取全部请求头和参数。</p></blockquote><table><thead><tr><th>对象</th><th>描述</th></tr></thead><tbody><tr><td>Mock</td><td>Mock 对象</td></tr><tr><td>_req.url</td><td>获得请求 url 地址</td></tr><tr><td>_req.method</td><td>获取请求方法</td></tr><tr><td>_req.params</td><td>获取 url 参数对象</td></tr><tr><td>_req.querystring</td><td>获取查询参数字符串(url 中?后面的部分)，不包含 ?</td></tr><tr><td>_req.query</td><td>将查询参数字符串进行解析并以对象的形式返回，如果没有查询参数字字符串则返回一个空对象</td></tr><tr><td>_req.body</td><td>当 post 请求以 x-www-form-urlencoded 方式提交时，我们可以拿到请求的参数对象</td></tr></tbody></table><h2 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h2><pre><code>{  code: function({    _req  }) {    const userName = _req.query.userName;    return userName ? 0 : -1;  },  data: function({    _req,    Mock  }) {    const userName = _req.query.userName;    return userName ? {      token: Mock.mock("@guid()"),      userId: Mock.mock("@id(5)"),      name: userName,      avatar: Mock.mock("@image(200x100, #FF6600)"),      message: "登录成功"    } : {      message: "登录失败"    }  }}</code></pre><p>预览：</p><p><img src="https://note.youdao.com/yws/public/resource/633e9bc706a3a274d9926f95b1806671/xmlnote/1C6017CB352F41DD9B758D064EBCFD4B/15016" alt="image"></p><h1 id="常用的在线-mock-工具"><a href="#常用的在线-mock-工具" class="headerlink" title="常用的在线 mock 工具"></a>常用的在线 mock 工具</h1><ul><li><p>💛 <a href="https://www.fastmock.site/">fast-mock</a></p></li><li><p>💗 <a href="https://easy-mock.com/">easy-mock</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端请求方式：xhr、ajax、axios与fetch的区别比较</title>
      <link href="2017/06/13/qian-duan-qing-qiu-fang-shi-xhr-ajax-axios-yu-fetch-de-qu-bie-bi-jiao/"/>
      <url>2017/06/13/qian-duan-qing-qiu-fang-shi-xhr-ajax-axios-yu-fetch-de-qu-bie-bi-jiao/</url>
      
        <content type="html"><![CDATA[<p>这些都是异步请求数据的方法。在不重新刷新页面的情况下与服务器通信，交换数据，或更新页面。</p><h1 id="XMLHttpRequest对象"><a href="#XMLHttpRequest对象" class="headerlink" title="XMLHttpRequest对象"></a>XMLHttpRequest对象</h1><p>优点：</p><ul><li>不重新加载页面的情况下更新网页</li><li>在页面已加载后从服务器请求/接收数据</li><li>在后台向服务器发送数据</li></ul><p>缺点：</p><ul><li>使用起来也比较繁琐，需要设置很多值。</li><li>早期的IE浏览器有自己的实现，这样需要写兼容代码。</li></ul><p>示例：</p><pre><code>if (window.XMLHttpRequest) { // model browser  xhr = new XMLHttpRequest()} else if (window.ActiveXObject) { // IE 6 and older  xhr = new ActiveXObject('Microsoft.XMLHTTP')}xhr.open('POST', url, true)xhr.send(data)xhr.onreadystatechange = function () {if (request.readyState === 4) { // 成功完成        // 判断响应状态码        if (request.status === 200) {            // 成功，通过responseText拿到响应的文本:            return success(request.responseText);        } else {            // 失败，根据响应码判断失败原因:            return fail(request.status);        }    } else {        // HTTP请求还在继续...    }}</code></pre><h1 id="jQuery-ajax"><a href="#jQuery-ajax" class="headerlink" title="jQuery ajax"></a>jQuery ajax</h1><p>AJAX请求也兼容了各浏览器，对XMLHttpRequest对象的封装。</p><p>优点：</p><ul><li>对原生XHR的封装，做了兼容处理，简化了使用。</li><li>增加了对JSONP的支持，可以简单处理部分跨域。</li></ul><p>缺点：</p><ul><li>如果有多个请求，并且有依赖关系的话，容易形成回调地狱。</li><li>本身是针对MVC的编程，不符合现在前端MVVM的浪潮。</li><li>ajax是jQuery中的一个方法。如果只是要使用ajax却要引入整个jQuery非常的不合理。</li></ul><p>示例：</p><pre><code>$.ajax({  type: 'POST',  url: url,   data: data,  dataType: dataType,  success: function () {},  error: function () {}})</code></pre><h1 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h1><p>Axios是一个基于promise的HTTP库，可以用在浏览器和 node.js 中。它本质也是对原生XMLHttpRequest的封装，只不过它是Promise的实现版本，符合最新的ES规范。</p><p>优点：</p><ul><li>从浏览器中创建XMLHttpRequests</li><li>从 node.js 创建 http 请求</li><li>支持 Promise API</li><li>拦截请求和响应</li><li>转换请求数据和响应数据</li><li>取消请求</li><li>自动转换 JSON 数据</li><li>客户端支持防御 XSRF</li></ul><p>缺点：</p><ul><li>只持现代代浏览器。</li></ul><pre><code>axios({    method: 'post',    url: '/user/12345',    data: {      firstName: 'liu',      lastName: 'weiqin'    }  })  .then(res =&gt; console.log(res))  .catch(err =&gt; console.log(err))</code></pre><h1 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h1><p>优点：</p><ul><li>语法简洁，更加语义化</li><li>基于标准 Promise 实现，支持 async/await</li></ul><p>缺点：</p><ul><li>Fetch 请求默认是不带 cookie 的，需要设置 fetch(url, {credentials: ‘include’})</li><li>服务器返回 400，500 错误码时并不会 reject，只有网络错误这些导致请求不能完成时，fetch 才会被 reject。</li></ul><p>示例：</p><pre><code>fetch('http://example.com/movies.json')  .then(function(response) {    return response.json();  })  .then(function(myJson) {    console.log(myJson);  });</code></pre><p>ts对fetch简单封装下：</p><pre><code>import _ from 'lodash';import 'whatwg-fetch';interface ReqInit extends RequestInit {  headers?: Record&lt;string, string&gt;;  /** eg. ?a=1 */  params?: { [key: string]: any };  /** eg. /:id/.. */  router?: { [key: string]: any };  /** 超时时间，默认3000 */  timeout?: number;}async function request&lt;T = any&gt;(path: string, init: ReqInit = {}): Promise&lt;T&gt; {  const mergeInit = {    ...request.default,    ...init,    headers: { ...request.default.headers, ...init.headers },  };  const { params, router, body, timeout, headers } = mergeInit;  let url = path;  if (router) {    url = path.replace(/:([A-Za-z]+)/g, (substring, p1: string) =&gt; router[p1]);  }  if (params) {    url += _(      _.reduce(params, (prev, val, key) =&gt; `${prev}${key}=${val}&amp;`, '?'),    ).trimEnd('&amp;');  }  if (!Reflect.get(headers, 'Content-Type')) {    if (typeof body === 'string') {      Reflect.set(headers, 'Content-Type', 'application/json');    }  }  try {    const response: Response = await Promise.race([      fetch(url, mergeInit),      new Promise&lt;any&gt;((resolve, reject) =&gt; {        setTimeout(          () =&gt; reject({ status: 408, statusText: 'TIME_OUT_ERR', url }),          timeout,        );      }),    ]);    if (response.ok) {      if (request.interceptors.response) {        return await request.interceptors.response(response);      }      return await response.json();    }    throw response;  } catch (error) {    if (request.interceptors.catch) {      request.interceptors.catch(error);    }    throw error;  }}request.default = {  method: 'GET',  headers: {    Accept: '*/*',  },  mode: 'cors',  timeout: 3000,  // credentials: 'include' // send cookies} as ReqInit;request.interceptors = {  response: null,  catch: null,} as {  response: ((response: Response) =&gt; Promise&lt;any&gt;) | null;  catch: ((error: Partial&lt;Response&gt;) =&gt; void) | null;};export default request;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据请求 </tag>
            
            <tag> 前端基础 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
