[{"title":"缩放带来的echarts图表模糊问题总结","slug":"缩放带来的echarts图表模糊问题总结","url":"/2023/03/26/suo-fang-dai-lai-de-echarts-tu-biao-mo-hu-wen-ti-zong-jie/","content":"\ns缩放网页或者使用了transform: scale(x,y)后致使echarts图表模糊的问题，有两个方案处理，亲测有效：\n\n解决方法：针对于echarts不清楚模糊问题的解决办法：\n1. 将canvas转换成svg; 在初始化时：\n\n```\necharts.init(dom,null,{ renderer : 'svg' });  \n```\n拉伸后图片依然清晰，但是有目前的 SVG 版中，富文本、材质功能尚未实现；（所以对于效果复杂的echarts图来说不太理想；\n2. 使用devicePixelRixelRatio: 2 ；\n\n虽然也不是很完美，但是当echarts的canvas使用的很复杂的时候，不影响属性效果的显示，使用设备像素比，是相当可以的；\n\n```\necharts.init(dom,null,{devicePixelRatio:2});\n```\n\n简单记录下，以防忘记。","tags":["踩的坑"],"categories":["项目总结"]},{"title":"异类-不一样的成功启示录","slug":"异类-不一样的成功启示录","url":"/2022/10/05/yi-lei-bu-yi-yang-de-cheng-gong-qi-shi-lu/","content":"\n![](https://note.youdao.com/yws/public/resource/3063c598a87a0294966831a6333f62a7/xmlnote/WEBRESOURCE0b8675a04ce83cb749dd0692cd8e7f14/18746)\n\n    本书作者马尔科姆·格拉德威尔，被《快公司》誉为“二十一世纪的彼得·德鲁克”，还被《时代周刊》评为最有影响力的100位人物之一。\n\n他很擅长写作，是《纽约客》的专职作家，以前还在《华盛顿邮报》做商务科学类的专栏作家。他的作品，像《引爆点》《异类》《眨眼之间》，都在图书市场上创造了销量神话。\n\n本书是格拉德威尔的代表作之一，带领我们找到了成功的根源，发现更深刻的成功契机，也为社会变革带来新的启示。\n\n# 01、异类是如何产生的\n\n\n社会上那些最有才华、最顶级的人是怎么样产生？我们的传统认知认为，一个人之所以能够出人头地，在于他本身就是非常出类拔萃的。\n\n> 比如，巴菲特这种金融巨头，像比尔·盖茨这种商业奇才，像 Beatles 摇滚明星。\n\n这些名人他们成功的背后到底有什么规律呢？作者认为，是优势的积累、外部环境、时代机遇等因素的影响。\n\n## 1、优势积累\n\n作者认为异类的产生是因为优势的积累，就是说人之所以成功，除了自身的能力以外，还需要外在因素的作用，形成指数及增长的变化。\n\n仅凭勤奋努力也很难成功，因为除了勤奋这个因素外，家庭环境、外部环境，甚至是历史条件都会极大地影响我们。\n\n举个例子：\n\n> 加拿大的冰球运动非常普及，是老百姓非常关注和热爱的一项运动，而要成为冰球职业运动员，尤其是还能打纪念杯赛的这种机会，花钱是没用的，也不是靠父母或者家族势力，只能靠自己的实力去争取。所以，你的住的再偏远也不要紧，只要你球打得好，就能够成为一流的球员。所以大多数人解释说，你看这个制度多公平，只要凭实力就能够取得成功。\n\n但是作者并不认同，怎么回事呢？他把几个最著名的冰球队花名册拿出来，查看球员资料，发现有一个特别奇怪的现象，那就是绝大多数球员的生日都是在1月、2月、3月。\n\n> 比如，老虎队，25个球员中就有17个人是在1月到3月出生的。有人解释说，这是和星座有关系，像魔羯呀、水瓶这样的星座，就比较适合冰球运动。\n\n作者说，并不是这样的。这是因为加拿大冰球队的队员是按年龄分组的，分组所依据的分界线是1月1日，即从1月1日到当年12月31日之间出生的球员将会被分在同一组。\n\n也就是说，一个1月1日出生的选手，是在跟许多年纪比他小的队友争夺晋级权—在青春期到来之前，由于有将近12个月的年龄差距，球员之间在生理成熟度上将会表现出巨大的差异。\n\n一旦进入同一个年龄组中，月份靠前的球员，因为生理发育得更早，所以他们在训练中就会有更好的表现，也就意味着有更多的上场机会，也就会带来更好的训练。\n\n而有更好的训练就会表现得更好，就能够被安排到更好的特训组，也意味着就会有更好的教练、更好的训练计划。\n\n结果，这些出生日期较早的球员，就占据了极大的优势，也就拉开了天才和非天才的距离。\n\n因此，成为顶级冰球运动员的重要因素是出生日期。如果你的生日是年底，或者是12月份左右，基本上你就没有什么机会能够成为最一流的冰球球员了。\n\n人们平日里认为，真正的天才不需要费力气就能把该做的事情做到最好，这样的说法其实是把问题简单化了。不错，能进入顶级球队的球员肯定比你我都更具备运动天赋。\n\n但是，那是因为他们起跑的时间比别人早得多，而这种领先优势，既不是他们理应得到的，也不是他们因为努力才得到的。然而最终，正是这种领先优势造就了天才们辉煌的成就。\n\n## 2、外部环境\n\n作者还说，不只是勤奋就可以啦，还需要外部环境的作用。\n\n我们常说一万小时天才定律。作者说，你个人的努力也不是最核心的因素，要达到一万个小时，还必须有外部因素来帮助你。\n\n> 比如，冰球队当中，你必须是最好的那批球员，这样才能得到那么多专业的训练机会，才能让你积累一万个小时的速度更快。一旦过了最好的运动年龄期限，即使后面积累到一万个小时也没有用了。\n\n另一个关于10000小时的有趣现象是，10000小时的确是大量时间。人们在很年轻的时候的确很难依靠自己达到这一要求。你需要获得父母的鼓励与支持。\n\n而且你不能太贫穷，因为如果你必须依靠兼职维持生计的话，你根本没法在日常生活中获得足够时间做练习。\n\n事实上，人们要想获得如此大量的练习时间，就必须依靠参加某些特定形式的训练课程，或者获得某些特定机遇得以进行训练。\n\n出生的时机、有没有条件进行一万个小时的天才训练，甚至是家庭条件，这些因素都是彼此相互紧密联系的，这些优势积累起来，就像马太效应那样，穷者愈穷，富者愈富，会进一步拉开和其他人之间的差距。\n\n## 3、时代机遇\n\n除了优势的积累、外部环境因素的影响，还有一个就是时代变革机遇的影响。时代变革往往是看不见的因素。\n\n> 比如，二十世纪四五十年代，美国律师事务所是白人精英才能进入的行业。很多犹太移民即使学业再好，毕业的学校也非常著名，可是因为不是白人精英，也没办法进入最好的律所。他们要么只能自己创业，要么在二流的小律所，接一些像打官司、恶意收购等等这类的诉讼案件。\n\n这些案件是一流律所看不上的也根本不接的，他们只接像发行债券、公司股票这些案件。然而到了20世纪70年代，人们对诉讼的厌恶情绪日渐式微。\n\n联邦管制开始放松，企业借贷变得越来越容易，市场趋向国际化，这一切导致公司收购案件的数量和规模激增。\n\n而这个时候，过去做了几十年诉讼业务的犹太律师，立刻变得炽手可热。现在纽约很多著名律师事务所的开创者，竟然都是当初干诉讼案件起家的犹太人。\n\n这些不利因素时常变为机遇。有一个律师同行说，不是这帮犹太人比其他律师更聪明，而是因为他们苦逼磨炼了多年的专业技能，因为时局一变，突然变得极有价值。\n\n所以你看，其他律师难道不勤奋吗？他们当然也勤奋，可是同样的勤奋最后取得的成就差别却很大，这就是我们说的外部条件比努力重要。\n\n因此，作者说成功者的优势，有些是与生俱来的，比如出生的日期，有些是后天养成的，比如你很勤奋，很努力，通过刻苦训练可以去争取的，可是有些真的就只是运气。\n\n要成为一个异类，顶尖的人，就得积累这些优势。所以，对于最出类拔萃的人而言，与其说成功取决于天赋，不如说成功取决于各种优势的积累，这样的模式成就了异类。\n\n\n# 02、文化传承\n\n\n\n文化传承想必大家很了解，作者认为一些成功人士除了前面我们说的这些因素以外还有另外因素，我们来看一下。\n\n## 1、文化背景\n\n作者认为，文化背景决定了成就的高低。我们是受群体文化差异的影响。\n\n> 比如，在美国南部地区的人普遍有一种“荣誉文化”。所谓荣誉文化，是指为了声誉，愿意接受来自外界的任何挑战，哪怕是最轻微的挑战。\n\n也就是别人侮辱你的时候，哪怕是动手用暴力，也一定是要捍卫自己的荣誉和尊严。那为什么会产生这种文化呢？\n\n这些地区的住民来自世界上荣誉文化最根深蒂固的地区：他们是来自苏格兰南部低地、英格兰北部各郡以及北爱尔兰阿尔斯特地区的苏格兰–爱尔兰血统移民。\n\n这些牧民和种植庄稼的农民有很大的差别，农民的生存依靠社区与他人的合作，不用担心自己的庄稼会在某天晚上被偷完。\n\n而牧民往往是在山坡上生活，很难耕种，只能靠放羊、放牛，不用互相合作，更多的是靠自己，他们总是担心牲口会被人偷走，所以要保护自己的财产，他们养成好斗的性情。\n\n因为有这样的祖先，所以就会形成这样的文化特征。\n\n作者说，文化传承是事件背后更强大的力量，它植入人性，影响长存。经过数代传承，即便产生文化的经济、社会和人口等条件已经消失，这种文化也会一直完好无损留传下来。\n\n文化直接决定了我们看待世界的方法和行为模式，其作用如此巨大，以至于没有它，我们将无法认知世界。\n\n## 2、“权力距离指数”\n\n在作者的研究当中，如果你是处于荣誉文化背景的人，当你的工作需要在复杂的人际关系环境下去沟通、协调、博弈、妥协各种利益时，可能这种文化背景就会限制你的发挥。这种看不见的影响，往往是在细微之处产生。\n\n举个例子：\n\n> 在20世纪90年代初期，韩国最大的航空公司大韩航空公司的飞机失事率特别高。大韩航空公司的飞机事故率是美国联合航空公司的17倍。当时韩国总统金大中就发表声明说，大韩航空的问题已经不仅仅是一个公司的问题了，已经成为韩国整个国家的问题了，国家信誉已经不堪一击了。随后，金大中总统把原来由大韩航空负责的总统专机转交给了大韩航空的竞争对手，韩亚航空公司。从那时起，大韩航空痛定思痛、励精图治，决心扭转自身形象。1999年以来，整个公司的安全记录是全优的，现在在安全性上，大韩航空和世界其他一流的航空公司相比都毫不逊色。\n\n为什么会产生这么严重的事故呢？他们针对针对空难进行一系列调查：听取飞机“黑匣子”录音；检查飞行记录；研究事故当时的天气状况、地面情况和机场条件；并将关岛空难和其他著名空难做比较，最后找到了原因。原来是因为韩国的文化。\n\n心理学有一个理论“权力距离指数”。权力距离是指人们对待比自己更高等级阶层的态度，特别是指对权威的重视和尊重程度。\n\n> 比如，美国人他们崇尚人人自由、平等，你就算是领导，我们俩也是平等的，只不过职权不一样。可是在亚洲国家，尤其像韩国，上飞机之前，所有机组成员听机长的指令。再比如，大韩航空的惯例是，在飞行中途逗留期间，副机长应该服侍机长，请机长吃饭或者给机长买些小礼物。\n\n这种情况下，即便副机长有问题也不敢提，如果机长决策错误，那么就只能玩完。\n\n所以，不同的文化深刻地影响着一个人的沟通交流方式、思考模式、行为模式。这种看不见的影响，也决定了我们在一些领域当中能不能取得成功。\n\n作者说，我们每个人都成长在一个文化环境之中，而文化环境又是集优点、弱点、素质和倾向等各种属性于一身的综合体。\n\n在你擅长的领域、适合的领域，它就能发挥作用，在不适合的领域，它就是一个限制作用。\n\n这也不是说这种文化的因素完全不能改变，韩国大韩航空从一个安全纪录糟糕的公司转变成世界上最好的航空公司，就是从文化入手扭转的。\n\n> 比如，改进机组成员之间的平等关系，让他们不用韩语用英语沟通，语言体系平等了，而且可以直呼其名等等。并且加上一系列的培训，把一些细微的文化因素改变了以后，大韩航空终于克服了飞行失事率高的问题。\n\n所以，文化背景也是决定我们在一个领域中能否成功，成为异类的一个重要因素。\n\n优势积累是我们通过努力、把握各种时机以后，可以往上提升的一个因素。而文化背景更像一个保障因素，就是说文化契合不代表你一定能成功，可是不契合就是一个负面的因素。\n\n\n# 最后的话：\n\n首先，作者告诉我们想要成功就必须具备天时、地利、人和。虽然有的因素我们无法控制，但这并不是说我们没有机会。\n\n> 比如，我们可以找一个高质量环境的梯队，只有在这种高质量的环境中，我们才有可能得到高质量的训练，这样会加速我们积累1万小时训练的速度。\n\n其次，我们要抓住时代的变革带给我们的红利。就像比尔盖茨那样，在大家还没有接触电脑编程的时候，人家就已经训练了1万小时了。\n\n换句话说，利用时代变革的红利时方向要对，在逆境中坚持训练1万小时。\n\n最后，等待时机，厚积薄发。机会是留给有准备之人的。","tags":["读书笔记"],"categories":["读书笔记"]},{"title":"基于 Qiankun 微前端实践-概念","slug":"基于-Qiankun-微前端实践-概念","url":"/2022/09/10/ji-yu-qiankun-wei-qian-duan-shi-jian-gai-nian/","content":"\n> 微前端就是将不同的功能按照不同的维度拆分成多个子应用。通过主应用来加载这些子应用。微前端的核心在于拆，拆完后再合！\n\n## 为什么需要微前端\n1. 使用背景\n1)在同一个页面可以使用多个前端框架(React, AngularJS, Vue 等);\n\n2)用新框架编写新代码，无需重写已有的 app;\n\n3)代码的延迟加载可以缩减初次加载时长;\n\n2. 主要解决的问题：\n1)在一个 app 中不同的模块由不同的团队维护，而每个团队所用的技术栈可能不同，而且发版周期不同。\n\n2)所使用的前端框架升级负担，新版本可能存在不兼容的更新，升级后可能对已有的业务产生 bug，造成难以升级。限制了前端框架新版本的使用。\n\n3. 导图\n![微前端导图](https://s3.bmp.ovh/imgs/2022/09/10/1f56765344a88594.png)\n\n## 什么是微前端\n![](https://s3.bmp.ovh/imgs/2022/09/10/c0df382ee16dc37e.png)\n\n微前端就是将不同的功能按照不同的维度拆分成多个子应用。通过主应用来加载这些子应用。\n### 微前端核心价值\n\n微前端架构具备以下几个核心价值：(重要)(摘自 qiankun官方文档)\n\n1)技术栈无关\n\n主框架不限制接入应用的技术栈，微应用具备完全自主权;\n\n2)独立开发、独立部署\n\n微应用仓库独立，前后端可独立开发，部署完成后主框架自动完成同步更新;\n\n3)增量升级\n\n在面对各种复杂场景时，我们通常很难对一个已经存在的系统做全量的技术栈升级或重构，而微前端是一种非常好的实施渐进式重构的手段和策略;\n\n4)独立运行时\n\n每个微应用之间状态隔离，运行时状态不共享;\n\n### 怎么落地微前端\n\n\n![](https://s3.bmp.ovh/imgs/2022/09/10/20002f8f80cd926e.png)\n\n2018年 Single-SPA 诞生了，single-spa 是一个用于前端微服务化的 JavaScript 前端解决方案(本身没有处理样式隔离，js 执行隔离)实现了路由劫持和应用加载。\n\n说明：single-spa 解决了以应用为维度的路由，应用的注册，监听，最重要的是赋予了应用生命周期和生命周期相关事件。\n\n*Single-SPA 缺陷：不够灵活，不能动态加载js文件;样式不隔离，没有js沙箱的机制。\n\n2019年 qiankun 是微前端框架，提供了更加开箱即用的 API (single-spa + sandbox + import-html-entry)，它基于 single-spa，具备 js 沙箱、样式隔离、HTML Loader、预加载 等微前端系统所需的能力。qiakun 升级 2.0 后，支持多个微应用的同时加载，有了这个特性，我们基本可以像接入 iframe 一样方便的接入微应用。\n\n*总结：子应用可以独立构建，运行时动态加载，主子应用完全解耦，技术栈无关，靠的是协议接入(子应用必须导出 bootstrap，mount，unmount方法)\n\n## 微前端核心功能实现\n\n### css 隔离方案\n\n子应用之间样式隔离：\n\nDynamic Stylesheet 动态样式表，当应用切换时移除老应用样式，添加新应用样式;\n\n主应用和子应用之间的样式隔离：\n\n1)BEM(Block Element Modifier ) 约定项目前缀;\n\n2)css-Modules 打包时生成不冲突的选择器名;\n\n3)Shadow DOM 真正意义上的隔离;\n\n4)css-in-js\n\n### 沙箱 shaowDom\n1. css 解决方法：\n\n```js\n// dom的api\n// 外界无法访问 shadow dom\nlet shadowDOM = document.getElementById('x').attachShadow({mode: 'closed'}); \nlet pElm = document.createElement('p');\npElm.innerHTML = 'hello';\nlet styleElm = document.createElement('style');\nstyleElm.textContent = `\n p{color: red}\n`\nshadowDOM.appendchild(styleElm);\nshadowDOM.appendchild(pElm);\n```\n\n2. JS 沙箱 proxy\n\n快照沙箱简单理解：1年前拍一张 在拍一张 (将区别保存起来) 在回到一年前\n\n```js\nlet sandbox = new SnapshotSandbox();\n\nclass SnapshotSandbox{\n constructor(){\n   this.proxy = window; // window属性\n    this.modifyPropsmap = {}; // 记录在window上的修改\n    this.active();\n  }\n  active() { // 激活\n   this.windowSnapshot = {}; //拍照\n    for(const prop in window) {\n     if(window.hasOwnProperty(prop)){\n       this.windowsnapshot[prop] = window[prop];\n      }\n    }\n    object.keys(this.modifyPropsMap).forEach(p=>{\n     window[p] = this.modifyPropsMap[p];\n    })\n  }\n  \n  inactive(){ // 失活\n   for(const prop in window){\n     if(window.hasOwnProperty(prop)){\n       if(window[prop] !== this.windowsnapshot[prop]){\n         this.modifyPropsMap[prop] = window[prop];\n          window[prop] = this.windowsnapshot[prop]\n        }\n      }\n    }\n  }\n}\n\n// 应用的运行 从开始到结束， 切换后不会影响全局\n((window)=> {\n window.a = 1;\n  window.b = 2;\n  console.log(window.a,window.b);\n  sandbox.inactive();\n  console.log(window.a,window.b);\n  sandbox.active();\n  console.log(window.a,window.b);\n})(sandbox.proxy); // sandbox.proxy 就是window\n// 如果是多个子应用就不能使用这种方式了，es6的proxy\n// 代理沙箱可以实现多应用沙箱。把不同的应用用不同的代理来处理\n```","tags":["qiankun"],"categories":["微前端"]},{"title":"swiper在loop为true时click失效","slug":"swiper在loop为true时click失效","url":"/2022/08/12/swiper-zai-loop-wei-true-shi-click-shi-xiao/","content":"\n最近在项目中使用swiper插件，配置loop：true无限轮播的时候，会出现第一个slide和最后一个slide点击事件失效的bug，造成这种情况的原因是：swiper的无限轮播时会自动复制第一个和最后一个页面进行轮播。但由于只复制页面没有复制点击事件，此时我们用vue写的点击事件在页面循环一周回来遇到复制的页面时，点击事件就会失效。\n\n> 解决的方法：通过swiper自己的监听点击方法来实现\n\n## 核心代码如下：\n\n```javascript\n<div class=\"swiper-wraper\">\n    <div class=\"swiper-slide\" v-for=\"(d,i) in dataList\" :key=\"i\">\n        <a data-info=\"d.info\">前往查看</a>\n    </div>\n</div>\n\n```\n使用swiper监听事件\n```js\nmounted() {\n    let that = this\n    this.swiper = new Swiper(\".swiper-container\",{\n        loop: true,\n        onClick:function(e,mouseEvent) {\n            let info = mouseEvent.target.dataset.info\n            that.handleClick(info)\n        }\n    })\n}\n```\n通过以上方式，可以解决项目中使用swiper时点击事件失效的问题。","tags":["项目总结"],"categories":["项目总结"]},{"title":"金字塔原理读后感","slug":"[读书]金字塔原理读后感","url":"/2022/08/02/du-shu-jin-zi-ta-yuan-li-du-hou-gan/","content":"\n> 我们平时表达、思考、解决问题的时候，可能会无意识地用到金字塔原理。但有时候又会忘记使用金字塔原理去思考，主要原因是没有把思考流程标准化。金字塔原理这本书，就将表达、思考、解决问题的逻辑标准化了。仔细研读，收获颇丰。\n## 金字塔原理内容概括 \n\n[![vEkAaR.png](https://s1.ax1x.com/2022/08/02/vEkAaR.png)](https://imgtu.com/i/vEkAaR)\n\n---\n\n\n## 表达的逻辑\n\n**为什么要用金字塔结构**\n\n表达的目的是让读者理解内容，而使用金字塔原理表达思想，可以提高读者的理解效率。人类大脑在理解内容的时候，会习惯性地将有共性的任何事物组织在一起。将读到的思想进行归类分组和总结概括，以便记住。金字塔原理组织的内容，正好符合读者理解和记忆思想的习惯。\n\n**金字塔内部结构**\n纵向关系：自上而下，结论先行。上一层的思想必须是下一层思想的概括总结或者是下一层思想的结论。读者先看到结论，再去阅读细节，符合读者阅读习惯。\n\n横向关系：横向各思想之间有两种关系，即演绎关系和归纳关系。演绎关系是从因到果，推理层层递进，推理的结论就是上一层级思想；归纳关系是子思想之间有共性，上一层级思想就是对子思想的概括总结，或者说可以用一个名词进行归纳。\n\n**如何构建金字塔**\n*自上而下法：*\n\n[![vEkiqJ.png](https://s1.ax1x.com/2022/08/02/vEkiqJ.png)](https://imgtu.com/i/vEkiqJ)\n\n金字塔结构 \n1. 提出主题思想 \n2. 设想受众的主要疑问\n想清楚要解决谁的什么问题。 \n3. 写序言：背景-冲突-疑问-回答\n背景是问题产生的前提条件，冲突是背景中发生了哪些能使读者产生疑问的“冲突”，疑问是我们要解决的问题，回答就是主题思想。 \n4. 与受众进行疑问、回答式对话\n疑问、回答式对话，就是自上而下的金字塔结构。从上一层思想到下一层思想。 5.对受众的新疑问，重复进行疑问/回答式对话思想慢慢开展，层级慢慢丰富。\n*自下而上法：*\n如果没有确定要讨论的主题思想，可以向下移动一个层次，从关键句层次下手。\n1. 列出你想表达的所有思想要点 \n2. 找出各要点之间的逻辑关系 \n3. 得出结论\n\n## 思考的逻辑\n构建金字塔的过程是：确定主题、回答主要疑问>>想好序言>>提出中心思想和关键句要点>>在关键句要点下展开讨论。思考的逻辑，主要解决的问题就是理清关键句下的论述逻辑。\n### 应用逻辑顺序\n金字塔原理第二条规则规定，所有列入同一组中的思想必须具有某种逻辑顺序。\n**时间顺序：**在按照时间顺序组织的思想组中，需要按照采取行动的顺序依次表述达到某一结果必须要采取的行动。当步骤较多时，还需要将步骤分组，一般超过 7 个就要进行分组。\n\n**结构顺序：**结构顺序就是当你使用示意图、地图、图画或照片想象某事务时的顺序，如组织结构图、关键成功要素示意图等。\n结构顺序中，分组后的各部分需要符合 MECE 原则：1.各部分之间相互独立，相互排斥，没有重叠；2.所有部分完全穷尽，没有遗漏。\n**程度顺序**：也称重要性顺序。是对一组因为具有某种共同特点而被聚集在一起的事务时所采用的顺序。在每组中，根据各个问题具有该特性的程度高低排序。最具有该特性的问题排在第一位，按照先重要后次要的顺序排列。\n\n### 概括各组思想\n位于金字塔结构每一个层次上的思想，都必须是对其下面一个层次思想的提炼、概括。\n如果是自下而上构建金字塔，那就需要思考概括各分组的思想。\n概括行动性思想（介绍采取的行动、行为、步骤、流程），应该要说明采取行动后取得的结果（效果、目标）\n概括描述性思想（介绍背景、信息等）时，应该说明这些思想具有“共同的含义” \n\n## 解决问题的逻辑\n解决问题的流程，主要分为以下四个步骤：\n\n[![vEkkZ9.png](https://s1.ax1x.com/2022/08/02/vEkkZ9.png)](https://imgtu.com/i/vEkkZ9)\n\n> 解决问题流程\n### 界定问题\n界定问题是解决问题的第一步，界定问题可以采用连续分析法。 \n1. 是否有/是否可能有问题（或机会）？\n判断是否有问题，需要对比期望结果和非期望结果。一般来说，如果期望结果低于非期望结果，则说明存在问题。\n2. 问题在哪里？\n寻找问题的位置，需要从背景入手。 \n3. 为什么存在？\n寻找问题的原因，寻找流程上或者结构中潜在的问题。 \n4. 我们能做什么？\n其实就是根据问题，罗列可能的解决方案。 \n5. 我们应该做什么？\n根据所有罗列的解决方案，选择一个最适合的方案去执行。\n\n### 结构化分析问题\n结构化分析问题，分为以下四个步骤\n\n[![vEkPr4.png](https://s1.ax1x.com/2022/08/02/vEkPr4.png)](https://imgtu.com/i/vEkPr4)\n\n分析问题流程\n\n分析问题的主要目的，是为了找出各种可能的原因。\n收集信息，需要在锁定的问题所涉及的背景范围内，进行收集。\n描述发现，其实是尽可能找出产生问题的原因。找出原因有三种方法：呈现有形结构、寻找因果关系、归类分组。\n**呈现有形结构：**需要画一幅系统的现况或理想状况的图，帮助决定是否要回答这些问题，并找到和分析产生问题的原因。\n**寻找因果关系**：寻找具有因果关系的要素、行为或任务，得出结果。\n**归类分组：**将所有可能的原因按相似性分类，前提是这种预先的分类有助于综合分析各种事实。\n归类分组中的要素，需要遵循相互独立，完全穷尽的原则。\n\n## 总结与感悟\n以上就是本书的主要内容，总结一下。\n1. 什么是金字塔原理呢？\n    金字塔原理就是把任何一件事情都能归纳出一个中心论点。在每个论点下面又有不超过 7 个的论据来支持。每一个论据又可以成为下一级的论点。\n2. 组织思想的方法\n    可以按照时间、空间、重要性以及逻辑演绎的顺序来组织我们的思想。\n\n3. 我们怎么样让别人对自己的观点感兴趣呢？\n    就是用 SCQ 背景、冲突、疑问的方法讲故事，吸引大家对自己的方法感兴趣。\n\n使用金字塔原理来表达，有一个明显的优势，就是别人理解起来更容易。因为大脑的工作方式就是自动将零散的信息按照逻辑归纳在一起。例如古人在仰望星空的时候记住的不是散乱的星星，而是星星组成的各种图案。去超市采购，打算买苹果、酸奶、地瓜、橘子、牛奶、土豆、葡萄、胡萝卜等等，这一大堆，到超市的时候可能一个也记不住，但如果我们换个说法，计划一共买三类东西，水果、蔬菜和奶。水果买三种，苹果、橘子和葡萄，蔬菜三种，土豆、胡萝卜和地瓜，奶买两种，牛奶和酸奶，这样会更容易记住。\n\n### 那金字塔原理具体怎么用呢？\n\n1. 自下而上的思考\n相当于建造金字塔的过程。思考问题，分三步，\n    第一步是列出所有的相关信息，就是想到什么都先写下来，\n    第二步，是从纷繁复杂的信息里找到共性和差异，然后合并同类项，简化成几个有逻辑相关的要点，\n    第三个，是以点带面得出结论。\n\n举例子，比如说有一家书店，怎么赚更多的钱？一瞬间就有很多个想法，比如说卖咖啡，卖工艺品，多营业几个小时，少雇几个人，位置偏僻一点儿，位置更好一点，装修特色一点，装修简单一点，场地对外出租。提供礼品包装服务，办签售活动，办读书俱乐部等等，这些散乱的信息毫无逻辑，甚至有一些还自相矛盾。如果把这些零散的点结构化的组织起来，效果就完全不一样。怎么结构化？这些动作可以划分成三大类，增量、开源和节流。增量就是比如说包括多营业几个小时，位置更好一点，装修特色一点，办签售活动，这几个都属于帮助增加书的销量。第二个是开源，比如说卖咖啡，卖工艺品，场地对外出租，办读书俱乐部，提供礼品包装服务，这几个都属于增加营收的类目。最后一个节流，比如说少雇几个人，位置偏僻一点，装修简单一点，这几个都属于降低成本支出。\n\n自下而上的搭建结构，有一个操作标准，叫做 MECE 法则，翻译成中文就是在分类的时候做到既不重叠又不遗漏。比如有机器猫、黑猫警长、变形金刚、一休哥这四个卡通形象，如果分成猫和机器人这两类，那机器猫就被重复出现了，一休哥就被漏掉了。所以更好的分类方法是人类和非人类，或者是来自东方和来自西方。\n\n2. 自上而下的表达\n就是跟别人描述金字塔的过程，假设工作需要你尽快安排个会议，通知王总、老张和小刘开会，半小时以后你回复说，小刘说系统出了问题，四点钟之前都不能参加，老张说他时间都 OK，最好别在十一点半之前。对了，今天的会议室都被定了，没有空的会议室了。另外呢，王总的秘书说了，王总今天晚上才能从外地回来，所以会议安排在明天可以吗？听完这一堆，同事可能无法准确理解信息。\n\n按照结论先行的方法，得先把会议得安排在明天这个结论放在第一句说，然后把原因归类分组一下，比如说有些是关于人的原因，有些是关于会议室的原因，人的原因，可以概括成王总、老张和小刘，今天都各有各的情况，但他们明天的时间都 OK。再者还要注意逻辑的递进，这几个原因要有先后顺序，比如王总，老张和小刘是不是可以按照职务的顺序来说，当你的表达有了明确的逻辑之后，听的人会更容易理解和记忆。按照结论先行归类分组，逻辑递进的原则，你可以这么回复同事，会议改到明天可以吗？因为明天王总、老张和小刘都有时间参加会议，而且会议是空着，可以预定。这样表达简洁清楚了许多。\n\n金字塔原理有两个执行方法。第一个叫做自下而上的思考，就是从最底层思考所有的可行性，一层一层的归纳提炼。第二个，叫做自上而下的表达，简单说三个词。结论先行，归类分组，逻辑递进。\n\n希望自己能在工作生活中熟练的使用金字塔原理，提高效率，节约时间。\n","tags":["读书笔记"],"categories":["读书笔记"]},{"title":"浮点数运算的精度问题","slug":"浮点数运算的精度问题","url":"/2022/01/10/fu-dian-shu-yun-suan-de-jing-du-wen-ti/","content":"\n# 前言\n在项目中涉及到商品价格的计算，经常会出现计算精度问题，引发意想不到的BUG。这是因为在 JavaScript 中整数和浮点数都属于 Number 数据类型，所有数字都是以 64 位浮点数形式储存，即便整数也是如此。 所以我们在打印 1.00 这样的浮点数的结果是 1 而非 1.00 。\n\n## 问题描述\n\n## 浮点运算的问题\n在一些特殊的数值表示中，例如金额，这样看上去有点变扭，但是至少值是正确了。然而要命的是，当浮点数做数学运算的时候，你经常会发现一些问题，举几个例子：\n\n```js\n// 加法 =====================\n// 0.1 + 0.2 = 0.30000000000000004\n// 0.7 + 0.1 = 0.7999999999999999\n// 0.2 + 0.4 = 0.6000000000000001\n// 2.22 + 0.1 = 2.3200000000000003\n \n// 减法 =====================\n// 1.5 - 1.2 = 0.30000000000000004\n// 0.3 - 0.2 = 0.09999999999999998\n \n// 乘法 =====================\n// 19.9 * 100 = 1989.9999999999998\n// 19.9 * 10 * 10 = 1990\n// 1306377.64 * 100 = 130637763.99999999\n// 1306377.64 * 10 * 10 = 130637763.99999999\n// 0.7 * 180 = 125.99999999999999\n// 9.7 * 100 = 969.9999999999999\n// 39.7 * 100 = 3970.0000000000005\n \n// 除法 =====================\n// 0.3 / 0.1 = 2.9999999999999996\n// 0.69 / 10 = 0.06899999999999999\n```\n\n\n## 整数的精度问题\n\n在 Javascript 中，整数精度同样存在问题，先来看看问题：\n\nJavaScript 代码:\n\n```js\n\nconsole.log(19571992547450991); //=> 19571992547450990\nconsole.log(19571992547450991===19571992547450992); //=> true\n```\n\n同样的原因，在 JavaScript 中 Number类型统一按浮点数处理，整数是按最大54位来算最大(253 - 1，Number.MAX_SAFE_INTEGER,9007199254740991) 和最小(-(253 - 1)，Number.MIN_SAFE_INTEGER,-9007199254740991) 安全整数范围的。所以只要超过这个范围，就会存在被舍去的精度问题。\n\n当然这个问题并不只是在 Javascript 中才会出现，几乎所有的编程语言都采用了 IEEE-745 浮点数表示法，任何使用二进制浮点数的编程语言都会有这个问题，只不过在很多其他语言中已经封装好了方法来避免精度的问题，而 JavaScript 是一门弱类型的语言，从设计思想上就没有对浮点数有个严格的数据类型，所以精度误差的问题就显得格外突出。\n\n## toFixed的问题\n\n```js\n1.35.toFixed(1) // 1.4 正确\n1.335.toFixed(2) // 1.33  错误\n1.3335.toFixed(3) // 1.333 错误\n1.33335.toFixed(4) // 1.3334 正确\n1.333335.toFixed(5)  // 1.33333 错误\n1.3333335.toFixed(6) // 1.333333 错误\n\n```\n\n# 问题的原因\n\n## 数据存储\n\nJavaScript 里的数字是采用 IEEE 754 标准的 64 位双精度浮点数。该规范定义了浮点数的格式，对于64位的浮点数在内存中的表示，最高的1位是符号位，接着的11位是指数，剩下的52位为有效数字，具体：\n\n- 第0位：符号位， s 表示 ，0表示正数，1表示负数；\n- 第1位到第11位：储存指数部分， e 表示 ；\n- 第12位到第63位：储存小数部分（即有效数字），f 表示，\n\n如图：\n![](https://bu.dusays.com/2022/01/10/4108f12333606.jpg)\n\n符号位决定了一个数的正负，指数部分决定了数值的大小，小数部分决定了数值的精度。 IEEE 754规定，有效数字第一位默认总是1，不保存在64位浮点数之中。也就是说，有效数字总是1.xx…xx的形式，其中xx..xx的部分保存在64位浮点数之中，最长可能为52位。因此，JavaScript提供的有效数字最长为53个二进制位（64位浮点的后52位+有效数字第一位的1）。\n\n## 计算过程\n\n比如在 JavaScript 中计算 0.1 + 0.2时，到底发生了什么呢？\n\n首先，十进制的0.1和0.2都会被转换成二进制，但由于浮点数用二进制表达时是无穷的，例如。\n\nJavaScript 代码:\n\n```js\n\n0.1 -> 0.0001 1001 1001 1001...(1100循环)\n0.2 -> 0.0011 0011 0011 0011...(0011循环)\n\n```\n\n IEEE 754 标准的 64 位双精度浮点数的小数部分最多支持53位二进制位，所以两者相加之后得到二进制为：\n\n```js\n0.0100110011001100110011001100110011001100110011001100 \n\n```\n\n因浮点数小数位的限制而截断的二进制数字，再转换为十进制，就成了0.30000000000000004。所以在进行算术计算时会产生误差。\n\n# 解决方案\n\n## 类库\n\n通常这种对精度要求高的计算都应该交给后端去计算和存储，因为后端有成熟的库来解决这种计算问题。前端也有几个不错的类库：\n\n### Math.js\nMath.js 是专门为 JavaScript 和 Node.js 提供的一个广泛的数学库。它具有灵活的表达式解析器，支持符号计算，配有大量内置函数和常量，并提供集成解决方案来处理不同的数据类型\n像数字，大数字(超出安全数的数字)，复数，分数，单位和矩阵。 功能强大，易于使用。\n\n官网：http://mathjs.org/\n\nGitHub：https://github.com/josdejong/mathjs\n\n### decimal.js\n为 JavaScript 提供十进制类型的任意精度数值。\n\n官网：http://mikemcl.github.io/decimal.js/\n\nGitHub：https://github.com/MikeMcl/decimal.js\n\n### big.js\n官网：http://mikemcl.github.io/big.js\n\nGitHub：https://github.com/MikeMcl/big.js/\n\n这几个类库帮我们解决很多这类问题，不过通常我们前端做这类运算通常只用于表现层，应用并不是很多。所以很多时候，一个函数能解决的问题不需要引用一个类库来解决。\n\n## 整数表示\n对于整数，我们可以通过用**String**类型的表示来取值或传值，否则会丧失精度。\n\n## 格式化数字、金额、保留几位小数等\n\n### Numeral.js\n一个用于格式化和操作数字的JavaScript库。数字可以被格式化为货币，百分比，时间，几个小数位数，千分位等等。 您也可以随时创建自定义格式。\n\n官网及文档：http://numeraljs.com/\n\nGitHub：https://github.com/adamwdraper/Numeral-js\n\n### accounting.js\n一个轻量级的JavaScript库，用于格式化数字，金额和货币等。\n\n官网及文档：http://openexchangerates.github.io/accounting.js/\n\nGitHub：https://github.com/openexchangerates/accounting.js\n\n## 解决toFixed\n\n针对toFixed的兼容性问题，我们可以把toFix重写一下来解决，代码如下：\n\n```js\n\n// toFixed兼容方法\nNumber.prototype.toFixed = function(len){\n    if(len>20 || len<0){\n        throw new RangeError('toFixed() digits argument must be between 0 and 20');\n    }\n    // .123转为0.123\n    var number = Number(this);\n    if (isNaN(number) || number >= Math.pow(10, 21)) {\n        return number.toString();\n    }\n    if (typeof (len) == 'undefined' || len == 0) {\n        return (Math.round(number)).toString();\n    }\n    var result = number.toString(),\n        numberArr = result.split('.');\n\n    if(numberArr.length<2){\n        //整数的情况\n        return padNum(result);\n    }\n    var intNum = numberArr[0], //整数部分\n        deciNum = numberArr[1],//小数部分\n        lastNum = deciNum.substr(len, 1);//最后一个数字\n    \n    if(deciNum.length == len){\n        //需要截取的长度等于当前长度\n        return result;\n    }\n    if(deciNum.length < len){\n        //需要截取的长度大于当前长度 1.3.toFixed(2)\n        return padNum(result)\n    }\n    //需要截取的长度小于当前长度，需要判断最后一位数字\n    result = intNum + '.' + deciNum.substr(0, len);\n    if(parseInt(lastNum, 10)>=5){\n        //最后一位数字大于5，要进位\n        var times = Math.pow(10, len); //需要放大的倍数\n        var changedInt = Number(result.replace('.',''));//截取后转为整数\n        changedInt++;//整数进位\n        changedInt /= times;//整数转为小数，注：有可能还是整数\n        result = padNum(changedInt+'');\n    }\n    return result;\n    //对数字末尾加0\n    function padNum(num){\n        var dotPos = num.indexOf('.');\n        if(dotPos === -1){\n            //整数的情况\n            num += '.';\n            for(var i = 0;i<len;i++){\n                num += '0';\n            }\n            return num;\n        } else {\n            //小数的情况\n            var need = len - (num.length - dotPos - 1);\n            for(var j = 0;j<need;j++){\n                num += '0';\n            }\n            return num;\n        }\n    }\n}\n\n```\n\n我们通过判断最后一位是否大于等于5来决定需不需要进位，如果需要进位先把小数乘以倍数变为整数，加1之后，再除以倍数变为小数，这样就不用一位一位的进行判断。","tags":["项目总结"],"categories":["ES语法"]},{"title":"浏览器相关知识汇总","slug":"浏览器相关知识汇总","url":"/2022/01/08/liu-lan-qi-xiang-guan-zhi-shi-hui-zong/","content":"\n\n# 浏览器如何渲染UI\n\n1. 浏览器获取HTML文件，然后对文件进行解析，形成DOM Tree\n2. 与此同时，进行CSS解析，生成Style Rules\n3. 接着将DOM Tree与Style Rules合成为 Render Tree\n4. 接着进入布局（Layout）阶段，也就是为每个节点分配一个应出现在屏幕上的确切坐标\n5. 随后调用GPU进行绘制（Paint），遍历Render Tree的节点，并将元素呈现出来\n\n![image.png](https://bu.dusays.com/2022/02/08/3d60d09942ab5.png)\n\n# 浏览器如何解析CSS\n\n浏览器会『从右往左』解析CSS选择器。\nDOM Tree与Style Rules合成为 Render Tree，实际上是需要将Style Rules附着到DOM Tree上，因此需要根据选择器提供的信息对DOM Tree进行遍历，才能将样式附着到对应的DOM元素上。\n\n```js\n.mod-nav h3 span {font-size: 16px;}\n\n```\n\n![image _1_.png](https://bu.dusays.com/2022/02/08/fb4af500748f0.png)\n\n从右至左的匹配过程是：\n1. 先找到所有的最右节点 span，对于每一个 span，向上寻找节点 h3\n2. 由 h3再向上寻找 class=mod-nav 的节点\n3. 最后找到根元素 html 则结束这个分支的遍历。\n\n# DOM Tree是如何构建的\n1. 转码: 浏览器将接收到的二进制数据按照指定编码格式转化为HTML字符串\n2. 生成Tokens: 之后开始parser，浏览器会将HTML字符串解析成Tokens\n3. 构建Nodes: 对Node添加特定的属性，通过指针确定 Node 的父、子、兄弟关系和所属 treeScope\n4. 生成DOM Tree: 通过node包含的指针确定的关系构建出DOM Tree\n\n![image _2_.png](https://bu.dusays.com/2022/02/08/541d4de2022f2.png)\n\n# 浏览器重绘与重排的区别\n\n- 重排: 部分渲染树（或者整个渲染树）需要重新分析并且节点尺寸需要重新计算，表现为重新生成布局，重新排列元素。如改变元素尺寸**边距、填充、边框、宽度和高度**等，**添加或者删除**可见的DOM元素\n- 重绘: 由于节点的几何属性发生改变或者由于样式发生改变，例如改变元素背景色时，屏幕上的部分内容需要更新，表现为某些元素的外观被改变。如\n改变元素的**color、background、box-shadow**等属性\n\n单单改变元素的外观，肯定不会引起网页重新生成布局，但当浏览器完成重排之后，将会重新绘制受到此次重排影响的部分\n\n重排和重绘代价是高昂的，它们会破坏用户体验，并且让UI展示非常迟缓，而相比之下重排的性能影响更大，在两者无法避免的情况下，一般我们宁可选择代价更小的重绘。\n\n# 如何触发重排和重绘\n任何改变用来构建渲染树的信息都会导致一次重排或重绘：\n- 添加、删除、更新DOM节点\n- 通过display: none隐藏一个DOM节点-触发重排和重绘\n- 通过visibility: hidden隐藏一个DOM节点-只触发重绘，因为没有几何变化\n- 移动或者给页面中的DOM节点添加动画\n- 添加一个样式表，调整样式属性\n- 用户行为，例如调整窗口大小，改变字号，或者滚动。\n- 查询某些属性或调用某些方法。比如说：\noffsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight\n\n# 如何避免重绘或者重排\n\n- 集中改变样式\n- 使用DocumentFragment\n- 提升为合成层\n- 缓存需要修改的DOM元素\n- 尽量只修改position：absolute或fixed元素，对其他元素影响不大\n动画开始GPU加速，translate使用3D变化\n\n![image _3_.png](https://bu.dusays.com/2022/02/08/0efbbd6b78be8.png)\n\ntransform 不重绘，不回流是因为transform属于合成属性，对合成属性进行transition/animate动画时，将会创建一个合成层。这使得动画元素在一个独立的层中进行渲染。当元素的内容没有发生改变，就没有必要进行重绘。浏览器会通过重新复合来创建动画帧。\n\n","tags":["浏览器"],"categories":["前端基础"]},{"title":"前端常见的代码问题汇总","slug":"前端常见的代码问题汇总","url":"/2022/01/05/qian-duan-chang-jian-de-dai-ma-wen-ti-hui-zong/","content":"\n代码评审中，经常发现小组成员使用\"古老\"的 es 语法，造成代码冗余臃肿，不够幽雅，特此总结下，也提醒自己不断总结，坚持学习！\n\n# 取值\n\n从 obj 中取值，经常有人喜欢用对象的点语法：\n\n```js\nconst obj = {\n  a: 1,\n  b: 2,\n  c: 3,\n  d: 4,\n  e: 5,\n};\n\nconst a = obj.a;\nconst b = obj.b;\nconst c = obj.c;\nconst d = obj.d;\nconst e = obj.e;\n```\n\n**改进**\n用 ES6 的解构赋值\n\n```js\nconst { a, b, c, d, e } = obj;\nconst f = a + d;\nconst g = c + e;\n```\n\n另外，如果对象的属性值跟自己创建的对象名不一致，可以这样写：\n\n```js\nconst { a: a1 } = obj;\nconsole.log(a1); // 1\n```\n\n**注意**\nES6 的解构赋值虽然好用。但是要注意解构的对象不能为 undefined、null。否则会报错，故要给被解构的对象一个默认值。\n\n```js\nconst { a, b, c, d, e } = obj || {};\n```\n\n# 合并数据\n\n比如合并两个数组，合并两个对象。\n\n```js\nconst a = [1, 2, 3];\nconst b = [1, 5, 6];\nconst c = a.concat(b); //[1,2,3,1,5,6]\n\nconst obj1 = {\n  a: 1,\n};\nconst obj2 = {\n  b: 1,\n};\nconst obj = Object.assign({}, obj1, obj2); //{a:1,b:1}\n```\n\n**改进**\n利用 ES6 扩展运算改进后：\n\n```js\nconst a = [1, 2, 3];\nconst b = [1, 5, 6];\nconst c = [...new Set([...a, ...b])]; //[1,2,3,5,6]\n\nconst obj1 = {\n  a: 1,\n};\nconst obj2 = {\n  b: 1,\n};\nconst obj = { ...obj1, ...obj2 }; //{a:1,b:1}\n```\n\n# 拼接字符串\n\n```js\nconst name = \"小明\";\nconst score = 59;\nlet result = \"\";\nif (score > 60) {\n  result = `${name}的考试成绩及格`;\n} else {\n  result = `${name}的考试成绩不及格`;\n}\n```\n\n**改进**\n\nES6 字符串模板在${}中可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性。\n\n```js\nconst name = \"小明\";\nconst score = 59;\nconst result = `${name}${score > 60 ? \"的考试成绩及格\" : \"的考试成绩不及格\"}`;\n```\n\n# 条件判断\n\n经常看到这样的写法：\n\n```js\nif(\n    type == 1 ||\n    type == 2 ||\n    type == 3 ||\n    type == 4 ||\n){\n   //...\n}\n\n```\n\n**改进**\nincludes 方法返回一个布尔值，表示某个数组是否包含给定的值,可以简化上面的写法：\n\n```js\nconst condition = [1, 2, 3, 4];\n\nif (condition.includes(type)) {\n  //...\n}\n```\n\n# 扁平化数组\n\n一个部门 JSON 数据中，属性名是部门 id，属性值是个部门成员 id 数组集合，现在要把有部门的成员 id 都提取到一个数组集合中。\n\n```js\nconst deps = {\n  采购部: [1, 2, 3],\n  人事部: [5, 8, 12],\n  行政部: [5, 14, 79],\n  运输部: [3, 64, 105],\n};\nlet member = [];\nfor (let item in deps) {\n  const value = deps[item];\n  if (Array.isArray(value)) {\n    member = [...member, ...value];\n  }\n}\nmember = [...new Set(member)];\n```\n\n**改进**\n\n利用`Object.values`获取对象的全部属性，然后 ES6 提供的`flat`方法来扁平化：\n\n```js\nconst deps = {\n  采购部: [1, 2, 3],\n  人事部: [5, 8, 12],\n  行政部: [5, 14, 79],\n  运输部: [3, 64, 105],\n};\nlet member = Object.values(deps).flat(Infinity);\n```\n\n# 获取对象属性\n\n业务代码中经常会遇到这样的情况，a对象有个属性b,b 也是一个对象有个属性 c,我们需要访问 c，经常会写成 a.b.c，但是如果 f 不存在时，就会出错。\n\n```js\nconst a = {\n    b: {\n        c: 123,\n    }\n}\nconsole.log(a.b.c); // 123;\nconsole.log(a.f.c); // f不存在所以会报错\n\n```\n\n**改进**\n`可选链运算符`解决该问题，通过在.之前添加一个?将键名变成可选\n\n```js\nlet person = {};\nconsole.log(person?.profile?.age ?? 18); // 18\n\n```\n\n# 空值判断\n\n在处理输入框相关业务时，往往会判断输入框未输入值的场景。\n\n```js\nif(value !== null && value !== undefined && value !== ''){\n    //...\n}\n\n```\n\n**改进**\n`空值合并运算符`与`||运算`很像，但是可以省略很多代码，可读性也增强。\n\n```js\nif((value??'') !== ''){\n  //...\n}\n```\n\n**注意**\n假设变量a不存在，我们希望给系统一个默认值，一般我们会使用||运算符。但是在javascript中空字符串，0，false都会执行||运算符，所以ECMAScript2020引入合并空运算符解决该问题，只允许在值为null或未定义时使用默认值。\n\n```js\n\nconst name = '';\n\nconsole.log(name || 'yd'); // yd;\nconsole.log(name ?? 'yd'); // '';\n\n```\n\n","tags":["项目总结","es"],"categories":["ES语法"]},{"title":"编写高性能的JavaScript","slug":"编写高性能的JavaScript","url":"/2022/01/04/bian-xie-gao-xing-neng-de-javascript/","content":"\n## 前言\n\n随着计算机硬件的不断升级，开发者越发觉得`Javascript`性能优化的好不好对网页的执行效率影响不明显，所以一些性能方面的知识被很多开发者忽视。但在某些情况下，不优化的`Javascript`代码必然会影响用户的体验。因此，即使在当前硬件性能已经大大提升的时代，在编写`Javascript`代码时，若能遵循`Javascript`规范和注意一些性能方面的知识，对于提升代码的可维护性和优化性能将大有好处。那么，接下来我们讨论几种能够提高`JavaScript性能`的方法。\n\n## 1、js文件加载和执行\n\n（1）将`<script>`标签放到`<body>`标签的底部\n\n（2）可以合并多个`js`文件，减少页面中`<script>`标签改善性能\n\n（3）使用 `defer` 属性，加载后续文档元素的过程将和` script.js `的加载并行进行，但是 `script.js` 的执行要在所有元素解析完成之后，`DOMContentLoaded `事件触发之前完成。\n\n（4）使用 `async` 属性，加载和渲染后续文档元素的过程将和` script.js `的加载与执行并行进行\n\n（5）动态加载脚本元素，无论在何时启动瞎子，文件的下载和执行过程都不会阻塞页面其它进程\n\n```\nvar script = document.createElement('script');\nscript.type = 'text/javascript';\nscript.src = 'file.js';\ndocument.getElementsByTagName('head')[0].appendChild(script);\n```\n\n## 2、标识符所在的作用域链的位置越深\n\n标识符所在的作用域链的位置越深，那么它的标识符解析的性能就越慢。所以一个好的性能提升的经验法则是：如果某个跨作用域的值在函数中被引用一次以上，那么就把它存储到局部变量里。\n\n```\nfunction fun1() {  \n// 将全局变量的引用先存储在一个局部变量中，然后使用这个局部变量代替全局变量，从而提高         \n// 性能；不然每次(3次)都要遍历整个作用域链找到\ndocument  var doc = document;   \n var bd = doc.body;  \n var links = doc.getElementsByTagName('a');  \n doc.getElementById('btn').onclick = function(){   \n console.log('btn');  \n }\n}\n```\n\n## 3、避免过长原型链继承\n\n方法或属性在原型链中存在的位置越深，搜索它的性能也就越慢，所以要避免N多层原型链的写法。\n\n## 4、对象成员嵌套过深\n\n对象的嵌套成员，对象成员嵌套越深，读取速度也就越慢。所以好的经验法则是：如果在函数中需要多次读取一个对象属性，最佳做法是将该属性值保存在局部变量中，避免多次查找带来的性能开销。\n\n```\nfunction f() { \n // 因为在以下函数中需要3次用到DOM对象属性，所以先将它存储在一个局部变量        \n // 中，然后使用这个局部变量代替它进行后续操作，从而提高性能  \nvar dom = YaHOO.util.Dom;  \nif(Dom.hasClass(element,'selected')){   \n  Dom.removeClass(elemet,'selected');  \n}else{   \n  Dom.addClass(elemet,'selected');  \n }\n}\n```\n\n## 5、DOM操作\n\n用`js`访问和操作`DOM`都会带来性能损失，可通过以下几点来减少性能损失：\n\n（1）尽可能减少`DOM`访问次数；\n\n（2）如果需要多次访问某个`DOM`节点，请使用局部变量存储它的引用；\n\n（3）小心处理`HTML`集合，因为它实时连系着底层文档；我们可以把集合的长度缓存到一个变量中，并在迭代中使用它；\n\n（4）下述情况会发生重排：\n\n- 添加或删除可见的`DOM`元素；\n- 元素位置改变；\n- 元素尺寸改变（包括：外边距、内边距、边框厚度、宽度、高度等属性）；\n- 内容改变（例如：文本改变或图片被另一个不同尺寸的图片改变）；\n- 页面渲染器初始化；\n- 浏览器窗口尺寸改变\n\n可通过以下方式减少重排：\n\n- 留意上面会导致重排的操作，尽量避免；\n- 获取布局信息的操作会导致强制渲染队列重排，应该尽量避免使用以下获取布局信息的操作方法或属性或者缓存布局信息，例如：`offsetTop,offsetLeft,offsetWidthoffsetHeight,``scrollTop,scrollLeft,scrollWidth,scrollHeight,clientTop,clientLeft,clientWidth,clientHeight,getComputedStyle()`等;\n- 批量修改样式，例如使用：\n\n```\nfunction f() {  \n  // 推荐使用以下操作  \n  var el1 = document.getElementById('mydiv');  \n  el1.style.cssText = 'border:1px;padding:2px;margin:3px';  \n  // 不推荐使用以下操作  \n  var el2 = document.getElementById('mydiv');  \n  el2.style.border = '1px';  \n  el2.style.padding = '2px';  \n  el2.style.margin = '3px';\n}\n```\n\n- 当需要批量修改`DOM`时，可以通过以下步骤减少重绘和重排的次数：\n\n- - 使元素脱离文档流（隐藏元素、拷贝元素）\n  - 对其应用多重改变；\n  - 把元素带回文档中\n\n- 使用事件委托（事件逐层冒泡并能被父级元素捕获，使用事件代理，只需给外层元素绑定一个处理器，就可以处理其子元素上触发的所用事件），因为给`DOM`元素绑定事件以及浏览器需要跟踪每个事件处理器都需要消耗性能。\n\n## 6、字符串连接\n\n```\nstr += 'one'+'two';\nstr= str+'one'+'two';\n```\n\n后者方式会比前者少在内存中创建一个临时字符串，所以性能有相应的提升，所以，所以推荐后者的写法。\n\n## 7、直接使用字面量\n\n创建对象和数组推荐使用字面量，因为这不仅是性能最优也有助于节省代码量。\n\n```\nvar obj = {   \n name:'tom',    \n age:15,    \n sex:'男'\n}\n```\n\n​    \n\n## 8、数组长度缓存\n\n如果需要遍历数组，应该先缓存数组长度，将数组长度放入局部变量中，避免多次查询数组长度。\n\n## 9、循环比较\n\n`JS`提供了三种循环：`for(;;)、while()、for(in)`。在这三种循环中 `for(in)`的效率最差，因为它需要查询Hash键，因此应尽量少用`for(in)`循环，`for(;;)、while()`循环的性能基本持平。\n\n## 10、少用eval\n\n尽量少使用`eval`，每次使用`eval`需要消耗大量时间，这时候使用`JS`所支持的闭包可以实现函数模板。\n\n## 11、字符串转换\n\n当需要将数字转换成字符时，采用如下方式：`\"\" + 1`。从性能上来看，将数字转换成字符时，有如下公式：`(\"\" +) > String() > .toString() > new String()`。`String()`属于内部函数，所以速度很快。而`.toString()`要查询原型中的函数，所以速度逊色一些，`new String()`需要重新创建一个字符串对象，速度最慢。\n\n## 12、浮点数转换整形\n\n当需要将浮点数转换成整型时，应该使用`Math.floor()`或者`Math.round()`。而不是使用`parseInt()`,该方法用于将字符串转换成数字。而且`Math`是内部对象，所以`Math.floor()`其实并没有多少查询方法和调用时间，速度是最快的。\n","tags":["项目总结"],"categories":["ES语法"]},{"title":"nginx实现灰度发布","slug":"nginx实现灰度发布","url":"/2021/08/09/nginx-shi-xian-hui-du-fa-bu/","content":"\n\n\n> 灰度发布（又名金丝雀发布，英文一般称为GrayRelease或Dark launch）是为了能够让用户逐步过渡到新功能一种发布方式。 一般是产品上线一个功能，希望在线上可以进行A/B testing，即让一部分用户继续用产品特性A，一部分用户开始用产品特性B，如果用户对B没有什么反对意见，那么逐步扩大范围，把所有用户都迁移到B上面来。\n\n优点:\n\n- 灰度发布可以保证整体系统的稳定，在初始灰度的时候就可以发现、调整问题，以保证其影响度。\n- 灰度发布可以让部分用户尽快体验到最新的功能，提高用户的积极性，进而收集用户反馈改善产品。\n\n灰度发布在谷歌和Facebook等很多公司已经使用的相当成熟，具体的分流规则也有很多，下面简单介绍下几种常见的分流规则，并分别使用nginx来配置实现。\n\n## 基于COOKIE分流\n\n使用Cookie分流的原理为：在用户首次登录时查询该用户是否是灰度用户，并为其设置标识Cookie，后续采用Cookie标识来进行分流。\n本文采用dark字段作为标识，如果cookie中dark的值true则分流到灰度环境，其他情况则分流到生产环境。\n在nginx的原生变量中，$http_cookie的值为所有Cookie以key=value的形式拼接，而$cookie_dark则只获得Cookie中dark的值。所以可以采用两种方式来判断：\n\n- 使用$http_cookie，则里面需要包含dark=true；\n- 使用$cookie_dark，则其值需要为true。\n\n最终nginx.conf文件中的核心配置如下：\n\n```js\nupstream normal {\n    server 127.0.0.1:8080;\n}\nupstream dark {\n    server 127.0.0.1:8081;\n}\nserver {\n    listen       80;\n    server_name  localhost;\n    set $group normal;\n    #或者使用 if ($cookie_dark ~* \"^true&\") 来判断\n    if ($http_cookie ~* \"dark=true\"){ \n        set $group dark;\n    }\n    \n    location / {\n        proxy_pass http://$group;\n    }\n}\n```\n\n## 基于Header分流\n\n基于Header分流的原理和用法都和Cookie类似。只有两点不同：\n\n- -- 获取灰度标识，使用的是$http_dark（即$http_header名）的写法；\nHeader不能像Cookie一样在客户端保留，所以一般是在多层网络中使用，即入口层给Header赋值，分流层再去分流。\n\n这里为了演示ngx_http_map_module的用法，使用了map替代了上面的set if判断方法。\n\n```js\nmap $http_dark $group {\n    ~*true$ dark; \n    default normal;\n}\nserver {\n    listen       80;\n    server_name  localhost;\n    location / {\n        proxy_pass http://$group;\n    }\n}\n\n```\n\n## 基于IP分流\n\n于IP分流原理：校验客户端的IP是否在我们的灰度IP列表中。\n所以关键有两点：\n\n- 如何获取客户端IP？\n- 灰度IP列表怎么保存？其实可以保存在配置文件或数据库等任意地方。\n\n假设我们有一张mysql的表存着配置的所有需要分发到灰度的IP地址，如果请求的IP在表中能够查到的话，则分流到灰度环境。我们这边最简单的创建了一个表，并插入一条IP地址。\n\n```js\nCREATE TABLE `test`.`dark_launch_ips`( `ip` VARCHAR(16) NOT NULL, PRIMARY KEY (`ip`) ); \nINSERT INTO `test`.`dark_launch_ips` (`ip`) VALUES ('1.1.1.1');\n\n```\n\n本节使用了lua脚本来判断分流，在Nginx里面使用lua需要Nginx额外增加lua-nginx-module模块，或者直接使用打包好的OpenResty。为了演示，我们依然使用了两个location，只是不再使用upstrem，而是使用content_by_lua简单返回一个字符串，目的是能够在区分分流的前提下尽量简化其他细节，以突出核心逻辑。在Nginx中连接mysql的方法参考lua-resty-mysql模块。最终Nginx的核心配置如下：\n\n```js\nlocation @normal {\n    content_by_lua 'ngx.say(\"normal\")';\n}\nlocation @dark {\n    content_by_lua 'ngx.say(\"dark\")';\n}\nlocation /test {\n    access_by_lua '\n        local mysql = require \"resty.mysql\"\n        local db, err = mysql:new()\n        if not db then\n            ngx.log(ngx.ERR, \"failed to instantiate mysql: \", err)\n            ngx.exec(\"@normal\")\n        end\n        local ok, err, errcode, sqlstate = db:connect {\n            host = \"127.0.0.1\",\n            port = 3306,\n            database = \"test\",\n            user = \"root\",\n            password = \"root\",\n            charset = \"utf8\",\n            max_packet_size = 1024 * 1024,\n        }\n        if not ok then\n            ngx.log(ngx.ERR, \"failed to connect: \", err, \": \", errcode, \" \", sqlstate)\n            ngx.exec(\"@normal\")\n        end\n        -- 以上代码是连接数据库操作，下面代码是获取IP并去数据库查询验证\n        local req_ip = ngx.var.http_x_real_ip or ngx.var.http_x_forwarded_for or ngx.var.remote_addr or \"0.0.0.0\"\n        local name = ngx.unescape_uri(req_ip)\n        local quoted_name = ngx.quote_sql_str(name) -- 防SQL注入\n        local res, err, errcode, sqlstate = db:query(\"SELECT COUNT(*) AS cnt FROM dark_launch_ips WHERE ip = \" .. quoted_name)\n        if not res then\n            ngx.log(ngx.ERR, \"bad result: \", err, \": \", errcode, \": \", sqlstate, \".\")\n            ngx.exec(\"@normal\")\n        end\n        if tonumber(res[1][\"cnt\"]) > 0 then\n            ngx.exec(\"@dark\")\n        end\n        ngx.exec(\"@normal\")\n    ';\n}\n\n```\n\n## 基于URL分流\n\n下面再介绍下URL分流，例如以下场景：如果url以dark结尾，则分流到灰度。本文继续使用一个新的模块ngx.balancer来做负载均衡。\n\n```js\nupstream balancer {\n    server 0.0.0.1;   # 这里写一个不存在的IP，作为占位填充\n    balancer_by_lua_block {\n        local balancer = require \"ngx.balancer\"\n        -- 下面一般是根据某些参数来计算要分流到哪里\n        local host = \"127.0.0.1\"\n        local port = 8080\n        local m, err = ngx.re.match(ngx.var.uri, \"dark$\")\n        if m then\n            port = 8081\n        end\n        local ok, err = balancer.set_current_peer(host, port)\n        if not ok then\n            ngx.log(ngx.ERR, \"failed to set the current peer: \", err)\n            return ngx.exit(500)\n        end\n    }\n    \n    keepalive 10;  # connection pool\n}\n```\n\n访问http://localhost/someurl-dark 访问的是灰度节点；访问http://localhost/someurl 访问的是生产节点。\n\n## 基于cookie访问不同的目录\n\n```JS\nlocation / {\n    set $rooturl /xxx/xxx/xxx/xxx;\n    if ($http_cookie ~* \"key=value\") {\n         set $rooturl /selfWorkspace/xxx/xxx/xxx;\n    }\n    root   $rooturl;\n}\n```\n\n就是加个if判断即可，重新设置root 的路径即可，注意如果404的情况下可能是目录属组或者权限问题。","tags":["nginx"],"categories":["nginx专题"]},{"title":"nginx中root&alias区别","slug":"nginx中root-alias区别","url":"/2021/08/09/nginx-zhong-root-alias-qu-bie/","content":"Nginx指定文件路径有两种方式root和alias，两种指令有不同的使用方法和作用域。\n\n- root可以配置在http、server、location、if区块中\n- alias只能配置在location区块中。\n\nroot与alias主要区别在于Nginx如何解释location后面的uri，这会使两者分别以不同的方式将请求映射到服务器文件上。\n\n## root的处理方式\n\nroot路径＋location路径，会使用url上的文件名\n\n```JS\nlocation ^~ /appImg/{\n    root /home/nginx;\n}\n```\n\n这个location相当于访问服务器上的文件路径： /home/nginx/appImg/abc.jpg\n\n## alias的处理方式\n\nalias的处理结果是：使用alias路径替换location路径\n\n```JS\nlocation ^~ /appImg/{\n    alias /home/nginx/;\n}\n```\n\n这个location相当于访问服务器上的文件目录：/home/nginx/abc.jpg(即alias不会使用location后面配置的路径)，而且如果alias 指定的是目录，后面一定要加上 /，否则会找不到文件。\n","tags":["nginx"],"categories":["nginx专题"]},{"title":"nginx的localtion配置","slug":"nginx的localtion配置","url":"/2021/05/13/nginx-de-localtion-pei-zhi/","content":"\n![nginx](https://7.dusays.com/2021/05/13/1128409d75ed2.png)\n\n## location 的作用\n\nlocation 指令的作用是根据用户请求 URI 来执行不同的应用，location 会根据用户请求网站 URL 进行匹配定位到某个 location 区块。 如果匹配成功将会处理 location 块的规则。\n\n## 语法规则\n\n```js\nlocation  =     /uri\n   ┬      ┬       ┬\n   │      │       │\n   │      │       │\n   │      │       │\n   │      │       │\n   │      │       └─────────────── 前缀|正则\n   │      └──────────────────── 可选的修饰符（用于匹配模式及优先级）\n   └───────────────────────── 必须\n\n```\n\n## 修饰符说明\n\n以下从上到下，第一个优先级最高\n\n```js\n=      |   location = /uri\n^~     |   location ^~ /uri\n~      |   location ~ pattern\n~*     |   location ~* pattern\n/uri   |   location /uri\n@      |   location @err\n```\n\n## 优先级顺序\n\n_优先级不分编辑 location 前后顺序_\n\n1. = ，精确匹配，表示严格相等\n\n```js\nlocation = /static {\n  default_type text/html;\n  return 200 \"hello world\";\n}\n\n# http://localhost/static   [成功]\n# http://localhost/Static   [失败]\n\n```\n\n2. ^~ ，匹配以 URI 开头\n\n```js\n\nlocation ^~ /static {\n  default_type text/html;\n  return 200 \"hello world\";\n}\n\n\n# http://localhost/static/1.txt    [成功]\n# http://localhost/public/1.txt    [失败]\n```\n\n3. ~ ，对大小写敏感, 使用正则 注意：某些操作系统对大小写敏感是不生效的，比如 windows 操作系统\n\n```js\nlocation ~ ^/static$ {\n  default_type text/html;\n  return 200 \"hello world\";\n}\n\n# http://localhost/static         [成功]\n# http://localhost/static?v=1     [成功] 忽略查询字符串\n# http://localhost/STATic         [失败]\n# http://localhost/static/        [失败] 多了斜杠\n\n```\n\n4. ~\\* ，与~相反，忽略大小写敏感, 使用正则\n\n```js\nlocation ~* ^/static$ {\n  default_type text/html;\n  return 200 \"hello world\";\n}\n\n# http://localhost/static         [成功]\n# http://localhost/static?v=1     [成功] 忽略查询字符串\n# http://localhost/STATic         [成功]\n# http://localhost/static/        [失败] 多了斜杠\n\n```\n\n5. /uri ，匹配以/uri 开头的地址\n\n```js\nlocation  /static {\n  default_type text/html;\n  return 200 \"hello world\";\n}\n\n# http://localhost/static              [成功]\n# http://localhost/STATIC?v=1          [成功]\n# http://localhost/static/1            [成功]\n# http://localhost/static/1.txt        [成功]\n\n```\n\n6. @ 用于定义一个 Location 块，且该块不能被外部 Client 所访问，只能被 nginx 内部配置指令所访问，比如 try_files or error_page\n\n```js\nlocation  / {\n  root   /root/;\n  error_page 404 @err;\n}\nlocation  @err {\n  # 规则\n  default_type text/html;\n  return 200 \"err\";\n}\n\n# 如果 http://localhost/1.txt 404，将会跳转到@err并输出err\n\n```\n","tags":["nginx"],"categories":["nginx专题"]},{"title":"nginx中的rewrite配置","slug":"nginx中的rewrite配置","url":"/2021/04/19/nginx-zhong-de-rewrite-pei-zhi/","content":"\n## Rewrite 规则\n\nnginx 通过 ngx_http_rewrite_module 模块支持 URI 重写、支持 if 条件判断，但不支持 else，使用 nginx 提供的全局变量或自己设置的变量，结合正则表达式和标志位实现 url 重写以及重定向。\n\nrewrite 只能放在 *server{},location{},if{}*中，并且只能对域名后边的除去传递的参数外的字符串起作用，例如 <http://seanlook.com/a/we/index.php?id=1&u=str> 只对/a/we/index.php 重写。\n\n> 语法: rewrite regex replacement [flag];\n\n如果相对域名或参数字符串起作用，可以使用全局变量匹配，也可以使用 proxy_pass 反向代理。\n\n## 指令执行顺序\n\n表明看 rewrite 和 location 功能有点像，都能实现跳转，主要区别在于 rewrite 是在同一域名内更改获取资源的路径，而 location 是对一类路径做控制访问或反向代理，可以 proxy_pass 到其他机器。很多情况下 rewrite 也会写在 location 里，它们的执行顺序是：\n\n1. 执行 server 块的 rewrite 指令\n2. 执行 location 匹配\n3. 执行选定的 location 中的 rewrite 指令\n\n如果其中某步 URI 被重写，则重新循环执行 1-3，直到找到真实存在的文件；循环超过 10 次，则返回 500 Internal Server Error 错误。\n\n## flag 标志位\n\n- last : 相当于 Apache 的[L]标记，表示完成 rewrite\n- break : 停止执行当前虚拟主机的后续 rewrite 指令集\n- redirect : 返回 302 临时重定向，地址栏会显示跳转后的地址\n- permanent : 返回 301 永久重定向，地址栏会显示跳转后的地址\n\n因为 301 和 302 不能简单的只返回状态码，还必须有重定向的 URL，这就是 return 指令无法返回 301,302 的原因了。这里 last 和 break 区别有点难以理解：\n\n1. last 一般写在 server 和 if 中，而 break 一般使用在 location 中\n2. last 不终止重写后的 url 匹配，即新的 url 会再从 server 走一遍匹配流程，而 break 终止重写后的匹配\n3. break 和 last 都能组织继续执行后面的 rewrite 指令\n\n例子：\n\n```js\n\nrewrite ^/(.*) http://www.baidu.com/$1 permanent;\n```\n\n说明：\n\n- rewrite 为固定关键字，表示开始进行 rewrite 匹配规则。\n- regex 为 ^/(.\\*)。 这是一个正则表达式，匹配完整的域名和后面的路径地址。\n- replacement 就是 <http://www.baidu.com/1这块了，其中1是取regex部分()里面的内容。如果匹配成功后跳转到的URL>。\n- flag 就是 permanent，代表永久重定向的含义，即跳转到 <http://www.baidu.com/$1> 地址上。\n\n## 理解 if 指令\n\n该指令用来支持条件判断的，并且根据条件判断结果来选择不同的 nginx 的配置，我们可以在 server 块或 location 块中配置该指令，它的语法结构为：\n\n```js\nif (condition) {\n  // ....\n}\n```\n\n比如如果用户代理是手机访问的话，直接跳转到某个页面去，也可以使用 if 判断。比如如下：\n\n```js\nif ( $http_user_agent ~* \"(Android)|(iPhone)|(Mobile)|(WAP)|(UCWEB)\" ){\n  rewrite ^/$  http://www.cnblogs.com  permanent；\n}\n```\n\nRewrite 指令可用的全局变量如下：\n\n1. $args: 该变量中存放了请求 URL 中的请求指令。比如 <http://127.0.0.1:3001?arg1=value1&arg2=value2> 中的\n   \"arg1=value1&arg2=value2\"。\n2. $content_length: 该变量中存放了请求头中的 Content-length 字段。\n3. $content_type: 该变量中存放了请求头中的 Content-type 字段。\n4. $document_root: 该变量中存放了针对当前请求的根路径。\n5. $document_uri: 该变量中存放了请求的当前 URI, 但是不包括请求指令。比如 <http://xxx.abc.com/home/1?arg1=value1>&\n   arg2=value2; 中的 \"/home/1\"\n6. $host: 变量中存放了请求的 URL 中的主机部分字段，比如<http://xxx.abc.com:8080/home>中的 xxx.abc.com.\n7. $http_host: 该变量与$host 唯一区别带有端口号：比如上面的是 xxx.abc.com:8080\n8. $http_user_agent: 变量中存放客户端的代理信息。\n9. $http_cookie, 该变量中存放客户端的 cookie 信息。\n10. $remote_addr 该变量中存放客户端的地址。\n11. $remote_port 该变量中存放了客户端与服务器建立连接的端口号。\n12. $remote_user 变量中存放客户端的用户名。\n13. $request_body_file 变量中存放了发给后端服务器的本地文件资源的名称\n14. $request_method 变量中存放了客户端的请求方式，比如 'GET'、'POST'等。\n15. $request_filename 变量中存放了当前请求的资源文件的路径名。\n16. $request_uri 变量中存放了当前请求的 URI，并且带请求指令。\n17. $query_string 和变量$args 含义一样。\n18. $scheme 变量中存放了客户端请求使用的协议，比如 'http', 'https'等。\n19. $server_protocol 变量中存放了客户端请求协议的版本, 比如 'HTTP/1.0'、'HTTP/1.1' 等。\n\n```js\n例：http://localhost:88/test1/test2/test.php\n$host：localhost\n$server_port：88\n$request_uri：http://localhost:88/test1/test2/test.php\n$document_uri：/test1/test2/test.php\n$document_root：/var/www/html\n$request_filename：/var/www/html/test1/test2/test.php\n```\n\n现在我们使用if指令来对nginx加一些判断；比如说我们访问<http://xxx.abc.com:8080/home时候，如果$host> = 'xxx.abc.com' 的时候，就做重定向跳转，nginx配置代码如下：\n\n```js\nserver {\n  listen 8088;\n  server_name xxx.abc.com;\n  location / {\n    proxy_pass http://127.0.0.1:3001;\n    if ($host = 'xxx.abc.com') {\n      rewrite ^/(.*) http://www.baidu.com redirect;\n    }\n  }\n}\n```\n\n## 常用正则\n\n- . ： 匹配除换行符以外的任意字符\n- ? ： 重复 0 次或 1 次\n- \\+ ： 重复 1 次或更多次\n- \\* ： 重复 0 次或更多次\n- \\d ：匹配数字\n- ^ ： 匹配字符串的开始\n- $ ： 匹配字符串的介绍\n- {n} ： 重复 n 次\n- {n,} ： 重复 n 次或更多次\n- [c] ： 匹配单个字符 c\n- [a-z] ： 匹配 a-z 小写字母的任意一个\n\n  小括号()之间匹配的内容，可以在后面通过$1 来引用，$2 表示的是前面第二个()里的内容。正则里面容易让人困惑的是\\转义特殊字符。\n\n### 对变量进行匹配\n\n'~' 表示匹配过程中对大小写敏感。\n'~*' 表示匹配过程中对大小写不敏感。\n'!~' 如果 '~' 匹配失败时，那么该条件就为true。\n'!~*' 如果 '~*' 匹配失败时，那么该条件就为true。\n\n比如如果用户代理是手机访问的话，直接跳转到某个页面去，也可以使用 if 判断。比如如下：\n\n```js\nif ( $http_user_agent ~* \"(Android)|(iPhone)|(Mobile)|(WAP)|(UCWEB)\" ){\n  rewrite ^/$  http://www.cnblogs.com  permanent；\n}\n```\n\n### 判断请求的文件是否存在\n\n-f' 如果请求的文件存在，那么该条件为true。\n'!-f' 如果该文件的目录存在，该文件不存在，那么返回true。如果该文件和目录都不存在，则为false。\n如果请求的目录不存在，请求的文件存在，也为false。\n\n```js\nif (-f $request_filename) {\n  // 判断请求的文件是否存在\n}\n\nif (!-f $request_filename) {\n  // 判断请求的文件是否不存在\n}\n```\n\n### 判断请求的目录是否存\n\n使用 '-d'，如果请求的目录存在，则返回true。否则返回false。\n使用 '!-d', 如果请求的目录不存在，但是该请求的上级目录存在，则返回true。如果该上级目录不存在，则返回false.... 等等其他一些语法，不多介绍。\n","tags":["nginx"],"categories":["nginx专题"]},{"title":"outlook邮箱样式问题","slug":"outlook邮箱样式问题","url":"/2021/02/22/outlook-you-xiang-yang-shi-wen-ti/","content":"\n最近项目中发送html格式的邮件到邮箱客户端，发现邮件样式千奇百怪，不堪入目。在google里面baidu了下,才发现问题严重了。因为安全原因，各大邮箱服务商及邮件客户端都会对邮件内容进行一定程度上的处理，不会按照你写的原本 HTML 展示，尤其是前端搅屎棍微软开发的OutLook，一向特立独行，使得outlook邮箱的样式成为最难写的样式。特意总结下，留给有缘人参考。\n\n## Doctype\n目前，兼容性最好的Doctype是XHTML 1.0 Strict，事实上Gmail和Hotmail会删掉你的Doctype，换上这个Doctype。使用这个Doctype，也就意味着，不能使用HTML5的语法。\n\n```js\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n\n<html xmlns=\"http://www.w3.org/1999/xhtml\">\n\n　<head>\n\n　　<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" />\n\n　　<title>HTML Email编写指南</title>\n\n　　<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"/>\n\n　</head>\n\n</html>\n\n```\n我们知道完整的 HTML 包括 DOCTYPE 声明、html 和 head 标签及其内容、body 标签，对于在一个 iframe 中显示邮件内容的邮箱还好，会保留上述结构，但是有些邮件（如 Gmail）都是在 div 中直接包含，这就对安全要求极为苛刻。安全原因邮箱会默认把上述结构做删除处理，所以写了几乎没有作用，在可能的情况下尽量把内容写到 body 内，甚至建议从 table 开写，直接放弃 DOCTYPE / html / head / body 标签。\n\n## 页面布局\n\n页面布局必须使用table，因为各个邮箱对 div + css 这一套布局的解析问题很大（如 float / position 等 CSS 都会被过滤，甚至 margin: 0 auto; 都不起作用），基本各大邮箱都会解析混乱，这就意味着 HTML 邮件中几乎只有这几个元素——table / tr / td / span / img / a，尽量避免使用 div / p 或是其他标签。\n\n而且并不是所有邮箱都支持 colspan / rowspan 属性，所以所有布局都需要使用 table 嵌套解决。\n\n使用表格布局导致的最直接的问题就是会产生多余的空白像素，所以要养成习惯给每个 table 都加上边框 border，单元格内边距 cellpadding，单元格间距 cellspacing，边框合并属性 border-collapse 这些属性：\n\n```js\n<table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" style=\"border-collapse: collapse;\">\n    <!-- ... -->\n</table>\n```\n\n## 使用内联样式\n有些版本的邮箱解析的时候会将head里面的内容直接删了，导致样式失效。html邮件也不支持外联的css,这就意味着只有內联CSS是唯一可靠的编写样式途径。\n\n\n## 属性优先\n并不是使用 style 属性就保险了，很多邮箱会对特定标签的属性做强制改造。\n\n比如在 OutLook 中，图片使用以下方式来设置宽高是无效的：\n\n```js\n<img style=\"width: 10px; height: 10px;\" src=\"*.png\" />\n```\n\n正确的设置方法：\n\n```js\n\n<img width=\"10\" height=\"10\" src=\"*.png\" />\n```\n\n所以在有属性能够实现样式效果的时候尽量使用属性，常见的可用属性有：\n\n```js\nwidth\nheight\nbgcolor\nalign\nvalign\n……\n\n```\n\n## 样式继承\n\nhtml邮件中某些属性的继承可能失效，比如 font-family，OutLook 中若想改变字体，至少每个 table 中都要指定 font-family，而在 QQ 邮箱甚至必须每个 td 都设置 font-family 才能全部生效。因此，每个标签单独写样式是很有必要的。\n\n## 背景图片\n\nstyle 内容里面 background 可以设置 color，但是 image 会被过滤，就是说不能通过 CSS 来设置背景图片了。但是有一个很有意思的元素属性，也叫 background，里面可以定义一个图片路径，但是功能有限，比如无法定位背景图片等。\n\n例如要给一个单元格加一个背景，必须这样写：\n\n```js\n<td background=\"*.png\">\n    <!-- ... -->\n</td>\n```\n\n## 字体相关\n\n在 HTML 邮件中，font-family 只支持系统字体，不支持自定义字体，也不支持 font 简写，color 尽可能也不要使用简写：\n```js\nfont: 12px / 14px Arial, sans-serif; \ncolor: #999;\n\n```\n需要写成：\n\n```js\nline-height: 14px; \nfont-size: 12px; \nfont-family: \"微软雅黑\", Arial, sans-serif; \ncolor: #999999;\n\n```\n对于加粗字体，我们可以使用 b 标签而不是 CSS 的 font-weight，前文说过，HTML 标签和属性能解决的样式决不使用 CSS 样式。\n\n## 行高\n在 OutLook 中会有个默认的行高最小值，特别是当设置 font-family 为微软雅黑时，默认的行高差不多为 Word 中的两倍行距，如果 line-height 设置的值小于默认的行高，无论你设置的是多少，则始终使用默认值，在很多情况下这是不能忍的，好在有个神奇的 mso-line-height-rule，使用行高时添加 mso-line-height-rule:exactly; 就能使行高始终等于我们所设置的值。\n```js\n\n<td style=\"mso-line-height-rule: exactly; line-height: 36px;\">\n    <!-- ... -->\n</td>\n\n```\n这只是微软的 CSS 属性，对其他客户端没影响。\n\n## 参考文献\n[HTML Email 编写指南](https://www.ruanyifeng.com/blog/2013/06/html_email.html)","tags":["踩的坑"],"categories":["项目总结"]},{"title":"前端缓存问题","slug":"前端缓存问题","url":"/2021/02/20/qian-duan-huan-cun-wen-ti/","content":"\n## 概述\n\n彻底禁止缓存，这个需求是错误的。缓存是浏览器的功能特性，又不是 Bug。但是前端知道如何处理浏览器缓存，用户并不一定了解，特别是一些静态资源的缓存，让用户一脸懵逼，因此特意总结了下。\n\n## 浏览器缓存的原理\n浏览器的缓存分为强制缓存和协商缓存。当二次打开网页时，浏览器会先对缓存发起http请求，只要请求的资源存在缓存并且该资源的请求头expires和cache-control中存在缓存的标志，那就默认读取缓存，如果缓存失效但缓存依然存在，这时有会对服务器发出http请求，通过last-modified和etag两个请求头验证是否存在协商缓存，存在协商缓存就让浏览器照样读取缓存。\n\n当然，如果你资源已经不存在了或者明确禁止缓存，那浏览器也不可能使用缓存，这也是解决缓存问题的办法\n\n![第一次发起http请求](https://7.dusays.com/2021/02/20/689c4e15f25a7.png)\n\n### 强制缓存\n设置强制缓存有两个属性expires和cache-control，cache-control优先级高于 expires,常用有5个值：\n1. public:所有内容都将被缓存（客户端和代理服务器都可缓存）\n2. private:所有内容只有客户端可以缓存\n3. no-cache: 客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定\n4. no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存 \n5. max-age=xxx (xxx is numeric)：缓存内容将在xxx秒后失效\n\n![2.png](https://7.dusays.com/2021/02/20/0bbd461ec7cf5.png)\n\n强制缓存是否生效，可以查看控制台的network选项，下面的size属性，一般就是from memory cache或者from disk cache，一个是从内存中加载缓存，一个是硬盘中加载缓存，区别就是内存要快些，一般先是读取硬盘中的缓存，要是你刷新一下，就从内存中读取，不然刷新的时候怎么那么快\n\n![3.png](https://7.dusays.com/2021/02/20/016d4a97ceaa7.png)\n\n### 协商缓存\n当强制缓存失败，浏览器就请求服务器，如果服务器觉得用缓存没问题，资源又没有更新，那么，即使缓存设了到期时间，浏览器依然会读取，此时服务器返回304，如果资源更新了，就从服务器请求更新，返回200。如何判断资源是否更新，就是靠last-modified和etag两个请求头，这里我就不多讲了\n\n但是要注意，强制缓存要优先于协商缓存，所以嘛，就算你更新了，浏览器依旧会读取缓存，\n\n## 前端解决缓存的办法\n\n### meta缓存头设置为禁止缓存\n```js\n<!-- 在入口文件index.html中，头部添加meta标签 -->\n<meta http-equiv=\"Expires\" content=\"0\">\n<meta http-equiv=\"Pragma\" content=\"no-cache\">\n<meta http-equiv=\"Cache-control\" content=\"no-cache\">\n<meta http-equiv=\"Cache\" content=\"no-cache\">\n```\n### 静态资源加上版本号\n```js\n// webpack.prod.conf.js\nconst Version = new Date().getTime();\n\noutput: {\n    path: config.build.assetsRoot,\n    filename: utils.assetsPath('js/[name].[chunkhash].'+_Version+'js'),\n    chunkFilename: utils.assetsPath('js/[id].[chunkhash].'+_Version+'js')\n}\n```\n### 服务端配置\n```js\n// nginx端配置\nlocation = /index.html {\n    add_header Cache-Control \"no-cache, no-store\";\n    # add_header Cache-Control no-store;\n    # add_header Pragma no-cache;\n}\n```\n\n## 快速清理浏览器缓存\n\n- Ctrl+shift+Del 清空浏览数据设置的快捷键，可以清除浏览数据呀，cookie呀，缓存呀，这是清除浏览器所有的缓存\n\n![](https://7.dusays.com/2021/02/20/7380544e1f4c1.png)\n\n- 控制台禁止缓存 这个隐藏在控制台network选项里的，对于开发人员很好用，默认禁止缓存\n\n![](https://7.dusays.com/2021/02/20/371f279c2667a.png)\n","tags":["踩的坑"],"categories":["项目总结"]},{"title":"nodejs从零起飞-模块","slug":"nodejs从零起飞-模块","url":"/2021/01/20/nodejs-cong-ling-qi-fei-mo-kuai/","content":"\n\n## nodejs和javascript的区别\n\nW3C 是规定 web 标准的，如 html css js-web-api 等，和 nodejs 没关系。\n\nECMA 是规范 js 语法的，例如变量，函数，class，if 语句等这些语法的，和具体 API 没关系。\n\n前端 js = ECMA + js-web-api\n\nnodejs = ECMA + node-api\n\n## commonjs\ncommonjs是nodejs默认有的模块化规范,每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。\n\nmodule,exports,require是关键词，下列示例中演示b.js引用a.js的方式，第三方库的引用方式。\n\n### module对象\n\nNode内部提供一个Module构建函数。所有模块都是Module的实例。每个模块内部，都有一个module对象，代表当前模块。\n\nmodule.exports属性表示当前模块对外输出的接口，其他文件加载该模块，实际上就是读取module.exports变量。\n\n\n\n### require命令\nNode使用CommonJS模块规范，内置的require命令用于加载模块文件。\n\nrequire命令的基本功能是，读入并执行一个JavaScript文件，然后返回该模块的exports对象。如果没有发现指定模块，会报错。\n\n### 示例：\n\n\na.js文件中\n\n```js\nfunction add(a, b) {\n    return a + b\n}\n\nfunction mul(a, b) {\n    return a * b\n}\n\n// 单个导出\n// module.exports.add = add\n\n// 全部导出\nmodule.exports = {\n    add,\n    mul\n}\n\n```\n\nb文件中\n```js\n// node 模块导出的都是对象，所以导入 node 模块就是对一个对象进行取值。\nconst { add, mul } = require('./a')\nconst _ = require('lodash')\n\nconst sum = add(10, 20)\nconst result = mul(100, 200)\n\nconsole.log(sum)\nconsole.log(result)\n\nconst arr = _.concat([1, 2], 3)\nconsole.log('arr...', arr)\n\n```\n\n## CommonJS模块的特点\n- 所有代码都运行在模块作用域，不会污染全局作用域。\n- 模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。\n- 模块加载的顺序，按照其在代码中出现的顺序。\n\n\n## ES modules\nNode.js从v13.2.0，宣布开始支持ES modules。在此之前，想要在node中使用ES modules，需要添加--experimental-module。\nv13.2.0版本后，可以直接使用ES modules了。**该特性依然是实验性的（Stability: 1），不建议在生产环境中使用该功能。**\n\n### 在node中使用ES modules\n\n想要在项目中使用ES modules，有以下两种方法：\n1. 文件后缀名使用.mjs\n\n```js\n|____component\n| |____a.mjs\n|____index.mjs\n\n```\n文件内容如下：\n\n```js\n// a.mjs\nlet a = 'Hello World';\nexport default a;\n\n// index.mjs\nimport a from './a.mjs';\nconsole.log(a);\n\n```\n\n2. 文件依然使用.js的后缀名，在项目的package.json中设置：type:module\n\n```js\n\n|____component\n| |____a.js\n|____package.json\n|____index.js\n\n```\n\n各个文件内容如下：\n\n```js\n// component/a.js\nlet a = 'This is component a';\nexport default a;\n\n// index.js\nimport a from './component/a.mjs';\nconsole.log(a);\n\n// package.json\n{\n  ...\n  \"type\": \"module\", // 必须要有这一行\n  ...\n}\n```","tags":["nodejs"],"categories":["nodeJs专栏"]},{"title":"webpack基础06-公共资源提取","slug":"webpack基础06-公共资源提取","url":"/2021/01/17/webpack-ji-chu-06-gong-gong-zi-yuan-ti-qu/","content":"\n## 基础库分离：React示例\n\n思路：将react、react-dom 基础包通过cdn引入，不打入bundle\n\n### 使用html-webpack-extends-plugin\n\n```js\nconst HtmlWebpackExternalsPlugin = require('html-webpack-externals-plugin');\nplugins: [\n    new HtmlWebpackExternalsPlugin({\n        externals: [\n          {\n            module: 'react',\n            entry: 'https://11.url.cn/now/lib/16.2.0/react.min.js',\n            global: 'React',\n          },\n          {\n            module: 'react-dom',\n            entry: 'https://11.url.cn/now/lib/16.2.0/react-dom.min.js',\n            global: 'ReactDOM',\n          },\n        ]\n    }),\n]\n\n```\n效果如图 \n\n![image](https://7.dusays.com/2021/01/18/729f3fe8cc21d.png)\n\n### 使用 SplitChunksPlugin 进行公共脚本分离\n\nwebpack4 内置的，替代 CommonsChunkPlugin（webpack3使用的多） 插件，SplitChunksPlugin介绍请参考官方文档\n\nchunks参数说明：\n\n- async: 异步引入的库进行分离（默认）\n- initial: 同步引入的库进行分离\n- all: 所以引入的库进行分离（推荐）\n\n```js\nmodule.exports = {\n  //...\n  optimization: {\n    splitChunks: {\n      chunks: 'async',\n      minSize: 30000, // 分离包体积的大小\n      maxSize: 0,\n      minChunks: 2,    // 设置最小引用次数为2次\n      maxAsyncRequests: 5,  \n      maxInitialRequests: 3,\n      automaticNameDelimiter: '~',\n      automaticNameMaxLength: 30,\n      name: true,\n      cacheGroups: {\n        vendors: {\n          test: /[\\\\/]node_modules[\\\\/]/,  // 匹配出需要分离的包\n          priority: -10\n        },\n        default: {\n          minChunks: 2,\n          priority: -20,\n          reuseExistingChunk: true\n        }\n      }\n    }\n  }\n\n  //三方库分离\n optimization:{\n        splitChunks: {\n            cacheGroups: {\n                commons: {\n                    test: /(react|react-dom)/,\n                    name: \"vendors\",\n                    chunks: \"all\"\n                }\n            }\n        }\n    }\n//公共脚本分离\n optimization:{\n        splitChunks: {\n            minSize:0,\n            cacheGroups: {\n                commons:{\n                    name:'commons',\n                    chunks:\"all\",\n                    minChunks:2 //至少引用2次，才打包出commons文件\n                }\n            }\n        }\n    }\n};\n```\n\n引入方法\n\n```js\nnew HTMLWebpackPlugin({\n  chunks:[\"vendors\",pageName]\n})\n```\n\n","tags":["webpack"],"categories":["webpack专区"]},{"title":"webpack基础05-多页面打包的方案","slug":"webpack基础05-多页面打包","url":"/2021/01/07/webpack-ji-chu-05-duo-ye-mian-da-bao/","content":"\n# 多页面（MPA）应用打包方案\n> 每次页面跳转，服务器都会返回一个新的html文档，这中类型的网站就叫多页面应用。\n\n## 多页面应用方案\n在webpack里，每个页面对应一个 entry，一个html-webpack-plugin。\n缺点：每次新增或删除页面都需要修改 webpack 配置。\n\n```javascript\nmodule.exports = {\n    entry: {\n        index: './src/index.js',\n        search: './src/search.js'\n    }\n};\n```\n1. 解决方案1：动态获取 entry 和设置 html-webpack-plugin 数量\n\n2. 解决方案2：利用 glob.sync\n\nglob库\n\n```javascript\n\nentry: glob.sync(path.join(__dirname, './src/*/index.js'))\n```\n这两个解决方案的前提是把入口文件放到 /src/*/index.js 下，所以的入口文件都叫index.js，通过二级目录来区分。\n\n```javascript\nmodule.exports = {\n    entry: {\n        index: './src/index/index.js',\n        search: './src/search/index.js'\n    }\n};\n```\n\n如果使用glob库的话，\n\n```javascript\nconst setMPA = () => {\n    const entry = {};\n    const htmlWebpackPlugins = [];\n    const entryFiles = glob.sync(path.join(__dirname, './src/*/index.js'));\n\n    Object.keys(entryFiles)\n        .map((index) => {\n            const entryFile = entryFiles[index];\n            // '/Users/cpselvis/my-project/src/index/index.js'\n\n            const match = entryFile.match(/src\\/(.*)\\/index\\.js/);\n            const pageName = match && match[1];\n\n            entry[pageName] = entryFile;\n            htmlWebpackPlugins.push(\n                new HtmlWebpackPlugin({\n                    inlineSource: '.css$',\n                    template: path.join(__dirname, `src/${pageName}/index.html`),\n                    filename: `${pageName}.html`,\n                    chunks: ['vendors', pageName],\n                    inject: true,\n                    minify: {\n                        html5: true,\n                        collapseWhitespace: true,\n                        preserveLineBreaks: false,\n                        minifyCSS: true,\n                        minifyJS: true,\n                        removeComments: false\n                    }\n                })\n            );\n        });\n\n    return {\n        entry,\n        htmlWebpackPlugins\n    }\n}\n\nconst {entry ,htmlWebpackPlugins} = setMPA();\n\nmodule.export = {\n     entry: entry,\n     plugins: [\n        new CleanWebpackPlugin()\n        ].concat(htmlWebpackPlugins)\n    }\n\n\n```","tags":["webpack"],"categories":["webpack专区"]},{"title":"前端权限管理","slug":"前端权限管理","url":"/2021/01/05/qian-duan-quan-xian-guan-li/","content":"\n## 接口权限\n> 接口权限目前一般采用==jwt==的形式来验证，没有通过的话一般返回401，跳转到登录页面重新进行登录。\n\n登录完拿到token，将token存起来，通过axios请求拦截器进行拦截，每次请求的时候头部携带token。\n\n```\naxios.interceptors.request.use(config => {\n    config.headers['token'] = cookie.get('token')\n    return config\n})\naxios.interceptors.response.use(res=>{},{response}=>{\n    if (response.data.code === 40099 || response.data.code === 40098) { //token过期或者错误\n        router.push('/login')\n    }\n})\n```\n\n## 路由权限控制\n\n> 用户登录后只能看到自己有权访问的导航菜单，也只能访问自己有权访问的路由地址，否则将跳转 4xx 提示页\n\n\n初始化即挂载全部路由，并且在路由上标记相应的权限信息，每次路由跳转前做校验。\n```\nconst routerMap = [\n  {\n    path: '/permission',\n    component: Layout,\n    redirect: '/permission/index',\n    alwaysShow: true, // will always show the root menu\n    meta: {\n      title: 'permission',\n      icon: 'lock',\n      roles: ['admin', 'editor'] // you can set roles in root nav\n    },\n    children: [{\n      path: 'page',\n      component: () => import('@/views/permission/page'),\n      name: 'pagePermission',\n      meta: {\n        title: 'pagePermission',\n        roles: ['admin'] // or you can only set roles in sub nav\n      }\n    }, {\n      path: 'directive',\n      component: () => import('@/views/permission/directive'),\n      name: 'directivePermission',\n      meta: {\n        title: 'directivePermission'\n        // if do not set roles, means: this page does not require permission\n      }\n    }]\n  }]\n```\n\n\n登录后，获取用户的权限信息，然后筛选有权限访问的路由，在全局路由守卫里进行调用==addRoutes==添加路由\n```\nimport router from './router'\nimport store from './store'\nimport { Message } from 'element-ui'\nimport NProgress from 'nprogress' // progress bar\nimport 'nprogress/nprogress.css'// progress bar style\nimport { getToken } from '@/utils/auth' // getToken from cookie\n\nNProgress.configure({ showSpinner: false })// NProgress Configuration\n\n// permission judge function\nfunction hasPermission(roles, permissionRoles) {\n  if (roles.indexOf('admin') >= 0) return true // admin permission passed directly\n  if (!permissionRoles) return true\n  return roles.some(role => permissionRoles.indexOf(role) >= 0)\n}\n\nconst whiteList = ['/login', '/authredirect']// no redirect whitelist\n\nrouter.beforeEach((to, from, next) => {\n  NProgress.start() // start progress bar\n  if (getToken()) { // determine if there has token\n    /* has token*/\n    if (to.path === '/login') {\n      next({ path: '/' })\n      NProgress.done() // if current page is dashboard will not trigger afterEach hook, so manually handle it\n    } else {\n      if (store.getters.roles.length === 0) { // 判断当前用户是否已拉取完user_info信息\n        store.dispatch('GetUserInfo').then(res => { // 拉取user_info\n          const roles = res.data.roles // note: roles must be a array! such as: ['editor','develop']\n          store.dispatch('GenerateRoutes', { roles }).then(() => { // 根据roles权限生成可访问的路由表\n            router.addRoutes(store.getters.addRouters) // 动态添加可访问路由表\n            next({ ...to, replace: true }) // hack方法 确保addRoutes已完成 ,set the replace: true so the navigation will not leave a history record\n          })\n        }).catch((err) => {\n          store.dispatch('FedLogOut').then(() => {\n            Message.error(err || 'Verification failed, please login again')\n            next({ path: '/' })\n          })\n        })\n      } else {\n        // 没有动态改变权限的需求可直接next() 删除下方权限判断 ↓\n        if (hasPermission(store.getters.roles, to.meta.roles)) {\n          next()//\n        } else {\n          next({ path: '/401', replace: true, query: { noGoBack: true }})\n        }\n        // 可删 ↑\n      }\n    }\n  } else {\n    /* has no token*/\n    if (whiteList.indexOf(to.path) !== -1) { // 在免登录白名单，直接进入\n      next()\n    } else {\n      next('/login') // 否则全部重定向到登录页\n      NProgress.done() // if current page is login will not trigger afterEach hook, so manually handle it\n    }\n  }\n})\n\nrouter.afterEach(() => {\n  NProgress.done() // finish progress bar\n})\n\n```\n按需挂载，路由就需要知道用户的路由权限，也就是在用户登录进来的时候就要知道当前用户拥有哪些路由权限\n\n这种方式也存在了以下的缺点：\n- 全局路由守卫里，每次路由跳转都要做判断\n- 菜单信息写死在前端，要改个显示文字或权限信息，需要重新编译\n- 菜单跟路由耦合在一起，定义路由的时候还有添加菜单显示标题，图标之类的信息，而且路由不一定作为菜单显示，还要多加字段进行标识\n\n## 菜单权限\n菜单权限可以理解成将页面与路由进行解耦\n### 方案一\n菜单与路由分离，菜单由后端返回\n前端定义路由信息\n```\n{\n    name: \"login\",\n    path: \"/login\",\n    component: () => import(\"@/pages/Login.vue\")\n}\n```\nname字段都不为空，需要根据此字段与后端返回菜单做关联，后端返回的菜单信息中必须要有name对应的字段，并且做唯一性校验\n\n全局路由守卫里做判断\n```\nfunction hasPermission(router, accessMenu) {\n  if (whiteList.indexOf(router.path) !== -1) {\n    return true;\n  }\n  let menu = Util.getMenuByName(router.name, accessMenu);\n  if (menu.name) {\n    return true;\n  }\n  return false;\n\n}\n\nRouter.beforeEach(async (to, from, next) => {\n  if (getToken()) {\n    let userInfo = store.state.user.userInfo;\n    if (!userInfo.name) {\n      try {\n        await store.dispatch(\"GetUserInfo\")\n        await store.dispatch('updateAccessMenu')\n        if (to.path === '/login') {\n          next({ name: 'home_index' })\n        } else {\n          //Util.toDefaultPage([...routers], to.name, router, next);\n          next({ ...to, replace: true })//菜单权限更新完成,重新进一次当前路由\n        }\n      }  \n      catch (e) {\n        if (whiteList.indexOf(to.path) !== -1) { // 在免登录白名单，直接进入\n          next()\n        } else {\n          next('/login')\n        }\n      }\n    } else {\n      if (to.path === '/login') {\n        next({ name: 'home_index' })\n      } else {\n        if (hasPermission(to, store.getters.accessMenu)) {\n          Util.toDefaultPage(store.getters.accessMenu,to, routes, next);\n        } else {\n          next({ path: '/403',replace:true })\n        }\n      }\n    }\n  } else {\n    if (whiteList.indexOf(to.path) !== -1) { // 在免登录白名单，直接进入\n      next()\n    } else {\n      next('/login')\n    }\n  }\n  let menu = Util.getMenuByName(to.name, store.getters.accessMenu);\n  Util.title(menu.title);\n});\n\nRouter.afterEach((to) => {\n  window.scrollTo(0, 0);\n});\n```\n每次路由跳转的时候都要判断权限，这里的判断也很简单，因为菜单的name与路由的name是一一对应的，而后端返回的菜单就已经是经过权限过滤的。\n\n如果根据路由name找不到对应的菜单，就表示用户有没权限访问。\n\n如果路由很多，可以在应用初始化的时候，只挂载不需要权限控制的路由。取得后端返回的菜单后，根据菜单与路由的对应关系，筛选出可访问的路由，通过==addRoutes==动态挂载。\n\n这种方式的缺点：\n- 菜单需要与路由做一一对应，前端添加了新功能，需要通过菜单管理功能添加新的菜单，如果菜单配置的不对会导致应用不能正常使用\n- 全局路由守卫里，每次路由跳转都要做判断\n\n### 方案二\n菜单和路由都由后端返回，\n前端统一定义路由组件。\n```\nconst Home = () => import(\"../pages/Home.vue\");\nconst UserInfo = () => import(\"../pages/UserInfo.vue\");\nexport default {\n    home: Home,\n    userInfo: UserInfo\n};\n```\n后端路由组件返回以下格式\n```\n[\n    {\n        name: \"home\",\n        path: \"/\",\n        component: \"home\"\n    },\n    {\n        name: \"home\",\n        path: \"/userinfo\",\n        component: \"userInfo\"\n    }\n]\n```\n在将后端返回路由通过addRoutes动态挂载之间，需要将数据处理一下，将component字段换为真正的组件\n如果有嵌套路由，后端功能设计的时候，要注意添加相应的字段，前端拿到数据也要做相应的处理。\n\n这种方法也会存在缺点：\n- 全局路由守卫里，每次路由跳转都要做判断\n- 前后端的配合要求更高\n\n## 按钮权限\n### 方案一\n按钮权限也可以用v-if判断\n但是如果页面过多，每个页面页面都要获取用户权限role和路由表里的meta.btnPermissions，然后再做判断\n这种方式就不展开举例了\n\n### 方案二\n> 通过自定义指令进行按钮权限的判断\n\n首先配置路由\n```\n{\n    path: '/permission',\n    component: Layout,\n    name: '权限测试',\n    meta: {\n        btnPermissions: ['admin', 'supper', 'normal']\n    },\n    //页面需要的权限\n    children: [{\n        path: 'supper',\n        component: _import('system/supper'),\n        name: '权限测试页',\n        meta: {\n            btnPermissions: ['admin', 'supper']\n        } //页面需要的权限\n    },\n    {\n        path: 'normal',\n        component: _import('system/normal'),\n        name: '权限测试页',\n        meta: {\n            btnPermissions: ['admin']\n        } //页面需要的权限\n    }]\n}\n```\n自定义权限鉴定指令\n```\nimport Vue from 'vue'\n/**权限指令**/\nconst has = Vue.directive('has', {\n    bind: function (el, binding, vnode) {\n        // 获取页面按钮权限\n        let btnPermissionsArr = [];\n        if(binding.value){\n            // 如果指令传值，获取指令参数，根据指令参数和当前登录人按钮权限做比较。\n            btnPermissionsArr = Array.of(binding.value);\n        }else{\n            // 否则获取路由中的参数，根据路由的btnPermissionsArr和当前登录人按钮权限做比较。\n            btnPermissionsArr = vnode.context.$route.meta.btnPermissions;\n        }\n        if (!Vue.prototype.$_has(btnPermissionsArr)) {\n            el.parentNode.removeChild(el);\n        }\n    }\n});\n// 权限检查方法\nVue.prototype.$_has = function (value) {\n    let isExist = false;\n    // 获取用户按钮权限\n    let btnPermissionsStr = sessionStorage.getItem(\"btnPermissions\");\n    if (btnPermissionsStr == undefined || btnPermissionsStr == null) {\n        return false;\n    }\n    if (value.indexOf(btnPermissionsStr) > -1) {\n        isExist = true;\n    }\n    return isExist;\n};\nexport {has}\n```\n\n在使用的按钮中只需要引用v-has指令\n```\n<el-button @click='editClick' type=\"primary\" v-has>编辑</el-button>\n```\n## 小结\n\n关于权限如何选择哪种合适的方案，可以根据自己项目的方案项目，如考虑路由与菜单是否分离\n权限需要前后端结合，前端尽可能的去控制，更多的需要后台判断\n","tags":["vue","项目总结"]},{"title":"nginx超时设置","slug":"nginx超时设置","url":"/2020/12/16/nginx-chao-shi-she-zhi/","content":"\nnginx访问出现504 Gateway Time-out，一般是由于程序执行时间过长导致响应超时，例如程序需要执行90秒，而nginx最大响应等待时间为30秒，这样就会出现超时。\n\n## 导致超时的场景\n\n1. 程序在处理大量数据，导致等待超时。\n2. 程序中调用外部请求，而外部请求响应超时。\n3. 连接数据库失败而没有停止，死循环重新连。\n\n## nginx常用的超时配置说明\n### client_header_timeout\n\n语法 client_header_timeout time\n默认值 60s\n上下文 http server\n说明 指定等待client发送一个请求头的超时时间（例如：GET / HTTP/1.1）.仅当在一次read中，没有收到请求头，才会算成超时。如果在超时时间内，client没发送任何东西，nginx返回HTTP状态码408(“Request timed out”)\n\n### client_body_timeout \n\n语法 client_body_timeout time\n默认值 60s\n上下文 http server location\n说明 该指令设置请求体（request body）的读超时时间。仅当在一次readstep中，没有得到请求体，就会设为超时。超时后，nginx返回HTTP状态码408(“Request timed out”)\n\n### keepalive_timeout \n\n语法 keepalive_timeout timeout [ header_timeout ]\n默认值 75s\n上下文 http server location\n说明 第一个参数指定了与client的keep-alive连接超时时间。服务器将会在这个时间后关闭连接。可选的第二个参数指定了在响应头Keep-Alive: timeout=time中的time值。这个头能够让一些浏览器主动关闭连接，这样服务器就不必要去关闭连接了。没有这个参数，nginx不会发送Keep-Alive响应头（尽管并不是由这个头来决定连接是否“keep-alive”）\n两个参数的值可并不相同\n\n注意不同浏览器怎么处理“keep-alive”头\nMSIE和Opera忽略掉\"Keep-Alive: timeout=<N>\" header.\nMSIE保持连接大约60-65秒，然后发送TCP RST\nOpera永久保持长连接\nMozilla keeps the connection alive for N plus about 1-10 seconds.\nKonqueror保持长连接N秒\n### lingering_timeout\n\n语法 lingering_timeout time\n默认值 5s\n上下文 http server location\n说明 lingering_close生效后，在关闭连接前，会检测是否有用户发送的数据到达服务器，如果超过lingering_timeout时间后还没有数据可读，就直接关闭连接；否则，必须在读取完连接缓冲区上的数据并丢弃掉后才会关闭连接。\n\n### resolver_timeout\n\n语法 resolver_timeout time \n默认值 30s\n上下文 http server location\n说明 该指令设置DNS解析超时时间\n\n### proxy_connect_timeout\n\n语法 proxy_connect_timeout time \n默认值 60s\n上下文 http server location\n说明 该指令设置与upstream server的连接超时时间，有必要记住，这个超时不能超过75秒。\n这个不是等待后端返回页面的时间，那是由proxy_read_timeout声明的。如果你的upstream服务器起来了，但是hanging住了（例如，没有足够的线程处理请求，所以把你的请求放到请求池里稍后处理），那么这个声明是没有用的，由于与upstream服务器的连接已经建立了。\n\n### proxy_read_timeout\n\n语法 proxy_read_timeout time \n默认值 60s\n上下文 http server location\n说明 该指令设置与代理服务器的读超时时间。它决定了nginx会等待多长时间来获得请求的响应。这个时间不是获得整个response的时间，而是两次reading操作的时间。\n\n### proxy_send_timeout\n\n语法 proxy_send_timeout time \n默认值 60s\n上下文 http server location\n说明 这个指定设置了发送请求给upstream服务器的超时时间。超时设置不是为了整个发送期间，而是在两次write操作期间。如果超时后，upstream没有收到新的数据，nginx会关闭连接\n\n### proxy_upstream_fail_timeout（fail_timeout）\n\n语法 server address [fail_timeout=30s]\n默认值 10s\n上下文 upstream\n说明 Upstream模块下 server指令的参数，设置了某一个upstream后端失败了指定次数（max_fails）后，该后端不可操作的时间，默认为10秒\n\n## 示例\n\n### 请求超时\n\n```\nhttp {\n    include       mime.types;\n    server_names_hash_bucket_size  512;     \n    default_type  application/octet-stream;\n    sendfile        on;\n    keepalive_timeout  65;  #保持\n    tcp_nodelay on;\n    client_header_timeout 15;\n    client_body_timeout 15;\n    send_timeout 25;\n    include vhosts/*.conf;\n}\n```\n\n### 后端服务器处理请求的时间设置\n\n如果只集成了一台nginx机器不用设置\n```\nlocation / {\n        ...\n        proxy_read_timeout 150;  # 秒\n        ...\n    }\n```","tags":["nginx"],"categories":["nginx专题"]},{"title":"webpack基础04-文件指纹策略","slug":"webpack基础04-文件指纹策略","url":"/2020/12/11/webpack-ji-chu-04-wen-jian-zhi-wen-ce-lue/","content":"\n## 概述\n\nwebpack的指纹策略是通过给文件加上hash后缀，做到当代码有修改时打包出来的文件后缀也会修改，从而可以把静态资源开启持久缓存，这样每次有更新的代码打包后生成的都是新的问题件，从而最大程度上使用缓存。\n\n## 文件指纹类型\nwebpack提供了三种hash类似\n\n### hash\n和整个项目构建相关，只要一个文件有修改，整个项目的hash值就会改变。\n例如\n\n```\n// webpack.prod.js\nentry: {\n    index: \"./src/index\",    \n    search: \"./src/search\"\n},\noutput: {\n    path: path.join(__dirname, \"dist\"),\n    filename: \"[name]_[hash:8].js\",\n    publicPath: \"./dist\"\n}\n\n```\n\n它的问题是当项目有多入口或者使用code spliting，只要有一个文件修改打包的生成的js代码hash都会改变。不利于缓存。\n\n### chunkhash\n\n模块的hash，根据模块的修改才改变对应的hash值。\n根据不同的入口文件(Entry)进行依赖文件解析、构建对应的chunk，生成对应的哈希值。我们在生产环境里把一些公共库和程序入口文件区分开，单独打包构建，接着我们采用chunkhash的方式生成哈希值，那么只要我们不改动公共库的代码，就可以保证其哈希值不会受影响\n\n```\noutput: {\n    path: path.resolve(__dirname, 'dist'),\n    filename: '[name]_[chunkhash:8].js'\n},\n```\n\n### contenthash\n\n据文件内容来定义 hash ，文件内容不变，则 contenthash 不变。\n\n某个页面既有js资源，又有css资源。如果css资源也使用Chunkhash。如果修改了js。由于css资源使用了Chunkhash，就会导致css内容没有变化，发布上线的文件却发生了变化。因此，通常对css资源使用Contenthash。这个时候可以使用mini-css-extract-plugin里的contenthash值，保证即使css文件所处的模块里就算其他文件内容改变，只要css文件内容不变，那么不会重复构建\n\n```\nmodule.exports = {\n    entry: {\n        app: './src/app.js',\n        search: './src/search.js'\n    },\n    output: {\n        filename: '[name][chunkhash:8].js',\n        path: __dirname + '/dist'\n    },\n    plugins: [\n        new MiniCssExtractPlugin({\n            filename: `[name][contenthash:8].css`\n        }),\n    ]\n};\n\n```\n\n### 图片，字体文件的文件指纹设置\n设置 file-loader（或url-loader） 的 name，使用 [hash]\n图片，字体文件的hash和css/js资源的hash概念不一样，图片，字体文件的hash是由内容决定的\n\n```\n{\n    test: /\\.(png|svg|jpg|gif)$/,\n    use: [{\n        loader: 'file-loader',\n        options: {\n            name: 'img/[name][hash:8].[ext] '\n        }\n    }]\n}\n\n```","tags":["webpack"],"categories":["webpack专区"]},{"title":"webpack基础03-文件监听","slug":"webpack基础03-文件监听","url":"/2020/12/10/webpack-ji-chu-03-wen-jian-jian-ting/","content":"\n\n文件监听是指发现源码改变，自动重新构建出新的输出文件。\n\n## webpack文件监听方式\nwebpack开启文件监听的方式有两种：\n1. 启动webpack时带上 --watch参数,但是需要手动刷新浏览器\n\n```\n\"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\",\n    \"build\": \"webpack\",\n    \"watch\": \"webpack --watch\"\n  },\n\n```\n唯一缺点需要手动刷新浏览器。\n\n2. 在配置webpack.config.js中设置watch:true\n\n```\nmodule.export = {\n        // 默认false也就是不开启\n        watch: true，\n        watchOptions: {\n            // 监听到数据变化后延迟600毫秒\n            aggregateTimeout: 600,\n            // 监听大量文件会导致大量的 CPU 或内存占用。可以使用正则排除\n            ignored: /node_modules/,\n            // 指定毫秒为单位进行轮询,每一秒检查一次变动\n            poll:1000\n        }\n    }\n```\n\n## 文件监听原理分析\n\n在webpack中监听一个文件发生变化的原理是定时的去获取这个文件的最后编辑时间，每次都存下最新的最后编辑时间，如果发现当前获取的和最后一次保存的最后编辑时间不一致，就认为该文件发生了变化。配置项中的watchOptions.poll就是用于控制定时检查的周期，具体含义是检查多少次。\n\n当发现某个文件发生了变化，并不会立刻告诉监听者，而是先换成起来，收集一段时间的变化后，再一次性告诉监听者，配置项中的watchOptions.aggregateTimeout就是用于配置这个等待时间。这样做的目的是因为我们在编辑代码的过程中可能会高频的输入文字导致文件变化的事件高频的发生，如果每次都重新执行构建就会让构建卡死。\n\n## 热更新方式和原理\n### 热更新的两种方式\n1. webpack-dev-server\n\nwds 通常与 HotModuleReplacementPlugin插件一起使用，wds的一个比较大的优势是，它没有磁盘的io,输出完之后放到内存中，而不是输出为文件，所以构建速度会有一个较大的优势。\n\n```\nconst webpack = require('webpack')\n \nmodule.exports = {\n  devServer: {\n    // 开启 HMR 特性\n    hot: true\n  },\n  plugins: [\n    // HMR 特性所需要的插件\n    new webpack.HotModuleReplacementPlugin()\n  ]\n}\n```\n\n2. webpack-dev-middleware\n\nWDM 将 webpack 输出的文件传输给服务器,使用于灵活的定制场景。\n\n```\nconst express = require('express');\nconst webpack = require('webpack');\nconst webpackDevMiddleware = require('webpack-dev-middleware');\n\nconst app = express();\nconst config = require('./webpack.config.js');\nconst compiler = webpack(config);\n\napp.use(webpackDevMiddleware(compiler,{\n\tpublicPath: config.output.publicPath\n}));\n\napp.listen(3000,function(){\n\tconsole.log('Example app listening on post 3000\\n')\n})\n\n```\n\n### 热更新原理\n\n\n- Webpack Compile: 将JS编译成Bundle\n- HMR Server： 将热更新的文件输出给HMR Runtime\n- Bundle server: 提供文件在浏览器的访问\n- HMR Runtime: 会被注入到浏览器，更新文件的变化\n- bundle.js 构建输出的文件\n\n![](https://7.dusays.com/2020/12/11/04a511854b09e.png)","tags":["webpack"],"categories":["webpack专区"]},{"title":"webpack基础02-静态资源处理","slug":"webpack基础02-静态资源处理","url":"/2020/12/08/webpack-ji-chu-02-jing-tai-zi-yuan-chu-li/","content":"\n> 本文主要讲述样式文件，图片和字体资源的解析，html,css,js的压缩\n\n## 解析css,sass,less\n\ncss-loader: 用于加载.css文件，并且转换成commomjs对象\nstyle-loader: 将样式通过<style>标签插入到head中 \nless-loader:将less转换成css\n\n```\nmodule: {\n        rules: [\n            { \n                test: /\\.css$/, \n                use: [\n                    'style-loader',\n                    'css-loader'\n                ]\n            },\n            { \n                test: /\\.less$/, \n                use: [\n                    'style-loader',\n                    'css-loader',\n                    'less-loader'\n                ]\n            }\n        ]\n    }\n```\n\n## 图片和字体资源解析\nfile-loader: 用于处理图片和字体\n\n```\nmodule: {\n        rules: [\n            { \n                test: /\\.(png|svg|jpg|gif)$/, \n                use: [\n                    'file-loader'\n                ]\n            },\n            { \n                test: /\\.(woff|woff2|eot|otf)$/, \n                use: [\n                    'file-loader'\n                ]\n            }\n        ]\n    }\n```\n\nurl-loader： 也可以处理图片和字体，可以设置较小资源自动base64。\n\n```\nmodule: {\n        rules: [\n            { \n                test: /\\.(png|svg|jpg|gif)$/, \n                use: [{\n                        loader: 'url-loader',\n                        options: {\n                            limit: 10240\n                        }\n                    }]\n            }\n        ]\n    }\n```\n\n## html压缩\nhtml的压缩用'html-webpack-plugin'这个插件。\n```\n\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\nmodule.exports = {\n    ...\n\n    plugins: [\n  \t  new HtmlWebpackPlugin({\n\t    title: 'Custom template',\n\t    template: './src/index.html', //指定要打包的html路径和文件名\n\t    filename:'../index.html' //指定输出路径和文件名\n\t  }),\n    ]\n\n```\n\n## js文件压缩、\nwebpack 4之前的版本是通过webpack.optimize.CommonsChunkPlugin来压缩js，webpack 4版本之后被移除了，\nwebpack4内置了uglifyjs-webpack-plugin这个插件，所以默认打包后js已经压缩了。\n\n```\n\nvar UglifyJsPlugin = require('uglifyjs-webpack-plugin')\nvar OptimizeCssAssetsPlugin = require('optimize-css-assets-webpack-plugin')\n\nmodule.exports = {\n  optimization: {\n    minimizer: [\n      // 自定义js优化配置，将会覆盖默认配置\n      new UglifyJsPlugin({\n        exclude: /\\.min\\.js$/, // 过滤掉以\".min.js\"结尾的文件，我们认为这个后缀本身就是已经压缩好的代码，没必要进行二次压缩\n        cache: true,\n        parallel: true, // 开启并行压缩，充分利用cpu\n        sourceMap: false,\n        extractComments: false, // 移除注释\n        uglifyOptions: {\n          compress: {\n            unused: true,\n            warnings: false,\n            drop_debugger: true\n          },\n          output: {\n            comments: false\n          }\n        }\n      }),\n      // 用于优化css文件\n      new OptimizeCssAssetsPlugin({\n        assetNameRegExp: /\\.css$/g,\n        cssProcessorOptions: {\n          safe: true,\n          autoprefixer: { disable: true }, \n          discardComments: {\n            removeAll: true // 移除注释\n          }\n        },\n        canPrint: true\n      })\n    ]\n  }\n}\n\n```\n\n\n\n\n## css压缩\n\ncss-loader在1.0以上版本没有了压缩配置，webpage4常用css压缩插件是'optimize-css-assets-webpack-plugin'，\n需要配合安装css处理器'cssnano'。\n\n```\nconst optimizeCss = require('optimize-css-assets-webpack-plugin');\n\nmodule.exports = {\n    \n    .....,\n    //\n    plugins: [\n        new optimizeCss({\n            assetNameRegExp: /\\.style\\.css$/g,\n            cssProcessor: require('cssnano'),\n            cssProcessorOptions: { discardComments: { removeAll: true } },\n            canPrint: true\n        }),\n    ],\n}\n```\n\n## 补齐css3前缀\n\n利用postcss-loader和autoperfixer这两个插件\n```\n{\n  test: /\\.css$/,\n  use: [\n    'style-loader',\n    'css-loader',\n    {\n      loader: 'postcss-loader',\n      options: {\n        plugins: [\n          require('autoprefixer')\n        ]\n      }\n    }\n  ]\n}\n```\n\n## 移动端中rem转换\n使用px2rem-loader + lib-flexiable\n```\n{\n  test: /\\.css$/,\n  use: [\n    'style-loader',\n    'css-loader',\n    'less-loader',\n    {\n      loader: 'px2rem-loader',\n      options: {\n        remUnit: 75,//这是rem适配的配置  注意： remUnit在这里要根据lib-flexible的规则来配制，如果您的设计稿是750px的，用75就刚刚好。\n        remPrecision: 8\n      }\n    }\n  ]\n}\n```\n\n","tags":["webpack"],"categories":["webpack专区"]},{"title":"webpack基础01-核心概念","slug":"webpack基础01-核心概念","url":"/2020/12/06/webpack-ji-chu-01-he-xin-gai-nian/","content":"\n\n# 默认安装\nnpm init -y\n\n## 安装webpack相关\nnpm install webpack webpack-cli --save-dev\n\n## 检查webpack版本 cd node_modules/.bin\nwebpack -v\n\n## 通过npm stript运行webpack,否则只能在.bin下面执行\n```\npackage.json中添加 **build\": \"webpack\"**\n```\n\n# 核心概念\n## entry\nentry是webpack打包文件的入口。入口可以设置多个，比如多页面应用。两者的写法有差异，但入口接收一个字符串，多入口写成对象的形式。\n\n### 单入口写法\n\n```\nmodule.exports = {\n    entry: \"./path/to/my/entry/file.js\"\n}\n```\n\n### 多入口写法\n```\nmodule.exports = {\n    entry: {\n        app: './src/app.js',\n        adminApp: './src/adminApp.js'\n    }\n}\n\n```\n\n## output\noutput用来指定打包输出。多个文件的时候通过占位符做区分 ，比如[name]。\n\n```\nmodule.exports = {\n    output: {\n        filename: '[name].js',\n        path: __dirname + '/dist/\n    }\n}\n\n```\n\n## loader \nwebpack原生只支持js,json两种文件类型，通过loader去支持其他文件类型并把他们转化成有效的模块，并添加到依赖图中。\n\n本身是一个函数，接受源文件作为参数，返回转换的结果。\n\n\n### 常见的loader \n\n名称        | 描述\n---|---\nbabel-loader | 转换ES6等新特性语法\ncss-loader   | .css文件的加载和解析\nless-loader  | 将less文件转为css\nts-loader    | 将TS转为js\nfile-loader  | 进行字体，图片的打包\nraw-loader   | 将文件以字符串的形式导入\nthread-loader| 多线程打包css，js\n\n### 使用\n放在module中，test用来指定匹配规则，use指定使用的loader名称\n\n```\nmodule: {\n        rules: [\n            { test: /\\.txt$/, use: 'raw-loader'}\n        ]\n    }\n```\n\n## plugins \n插件用于bundle文件的优化，资源管理，环境变量的注入，作用于整个构建过程。loader没法做的事情，都是plugins来完成。\n\n\n### 常见的plugins\n\n名称                         | 描述\n---|---\nhtml-webpack-plugin          | 创建html文件去承载输出的bundle\nclean-webpack-plugin         | 用于在打包前清理上一次项目生成的 bundle 文件\nsplitChunks                  | 提取被重复引入的文件，单独生成一个或多个文件，这样避免在多入口重复打包文件（替换CommonsChunkPlugin） \ncopy-webpack-plugin          | 将文件或文件夹拷贝到构建的输出目录\nextract-text-webpack-plugin  | 抽离 css 样式,防止将样式打包在 js 中引起页面样式加载错乱的现象\nUglifyJsPlugin               | 压缩js\nZipWebpackPlugin             | 将打包的出的资源生成一个zip包\nMiniCssExtractPlugin         | 提取 JS 中引入的 CSS 打包到单独文件中，然后通过标签 <link>添加到头部\n\n### 使用\n放在plugins数组中：\n\n```\nplugins: [\n        //moment这个库中，如果引用了./locale/目录的内容，就忽略掉，不会打包进去\n        new Webpack.IgnorePlugin(/\\.\\/locale/, /moment/),\n    ]\n\n```\n\n## mode\n用来指定当前node的构建环境，有三种类型的值:production,development,none。(webpack4)\n可用webpack内置函数来设置。\n\n\n### 选项描述\n\n名称                         | 描述\n---|---\ndevelopment\t    | 会将 DefinePlugin 中 process.env.NODE_ENV 的值设置为 development。启用 NamedChunksPlugin 和 NamedModulesPlugin\nproduction      | 会将 DefinePlugin 中 process.env.NODE_ENV 的值设置为 production。启用 FlagDependencyUsagePlugin, FlagIncludedChunksPlugin, ModuleConcatenationPlugin, NoEmitOnErrorsPlugin, OccurrenceOrderPlugin, SideEffectsFlagPlugin 和 TerserPlugin。\nnone            | 不开启任何优化选项\n","tags":["webpack"],"categories":["webpack专区"]},{"title":"this指向","slug":"this指向","url":"/2020/11/25/this-zhi-xiang/","content":"\n# 说明\n`this` 既不指向函数自身也不指向函数的作用域，在函数真正被调用执行的时候确定的，函数定义的时候确定不了。\n\n1. `this`的指向，**是在函数被调用的时候确定的**，也就是执行上下文被创建时确定的；\n2. `this` 的指向和函数声明的位置没有任何关系，只取决于函数的调用位置（也即由谁、在什么地方调用这个函数）；\n3. 正因为在执行上下文的创建阶段`this`的指向就已经被确定了，在执行阶段`this`指向不可再被更改。\n\n```javascript\nvar obj = {\n    a: \"1891\"\n}\n\nfunction func() {\n    this = obj; //报错，因为在执行阶段试图修改this的指向\n    console.log(this.a);\n}\n\nfunc();\n```\n\n# this的指向规则\n\n## 默认指向\n\n### 独立函数调用\n\n```javascript\nfunction func() {\n    console.log( this.a ); // this指向全局对象\n}\nvar a = 2;\nfunc(); //>> 2\n```\n\n对于**默认指向**来说，决定`this`指向对象的并不是**调用位置**是否处于严格模式，而是函数体是否处于严格模式。如果函数体处于严格模式，`this`会指向`undefined`，否则`this`会指向全局对象。\n\n```javascript\nfunction func() {\n  \"use strict\";//函数体处于严格模式下，this指向undefined\n  console.log(this.a);\n}\n\nvar a = \"1891\";\n(function() {\n  func(); //>> 报错\n})();\n```\n\n```javascript\nfunction func() {\n  console.log(this.a);\n}\n\nvar a = \"1891\";\n(function() {\n  \"use strict\";\n  func(); //>> 1891\n  //这里输出 1891 而不是报错，是因为严格模式下，this的指向与func的调用位置无关\n})();\n```\n\n### SetTimeout或SetInterval中的this指向\n```javascript\nvar num = 0;\nclass Obj {\n    constructor(num){\n        this.num = num;\n    }\n    func(){\n        console.log(this.num);\n    }\n    func1(){\n        setTimeout(function () {\n            console.log(\"setTimeout:\"+this.num);\n        }, 1000)\n    }\n    func2(){\n        setInterval(function () {\n            console.log(this.num);\n        }, 2000)\n    }\n}\nvar obj = new Obj(1);\nobj.func();//>> 1　             输出的是obj.num\nobj.func1()//>> setTimeout:0　  输出的是window.num\nobj.func2()//>> 0 0 0 0 ……　    输出的是window.num\n```\n可以发现在setInterval和setTimeout中传入函数时，函数中的this会指向window对象。\n\n## 隐式指向\n\n1. 如果一个函数中有this，这个函数有被上一级的对象所调用，那么this指向的就是上一级的对象。\n\n2. 如果一个函数中有this，这个函数中包含多个对象，尽管这个函数是被最外层的对象所调用，this指向的也只是它上一级的对象。\n\n```javaScript\nvar o = {\n    a:10,\n    b:{\n        // a:12,\n        fn:function(){\n            console.log(this.a); //undefined\n        }\n    }\n}\no.b.fn();\n\n```\n\n尽管对象b中没有属性a，这个this指向的也是对象b，因为this只会指向它的上一级对象，不管这个对象中有没有this要的东西。\n\n## 隐式丢失\n```javaScript\n\nvar o = {\n    a:10,\n    b:{\n        a:12,\n        fn:function(){\n            console.log(this.a); //undefined\n            console.log(this); //window\n        }\n    }\n}\nvar j = o.b.fn;\nj();   //this指向window\n\n```\n\n这里this指向的是window,this永远指向的是最后调用它的对象。\n\n**隐式丢失最容易在赋值时发生**；隐式丢失发生时，调用这个函数会应用**默认指向规则**。下面再举一段更具迷惑性的例子：\n\n```javascript\nfunction func() {\n  console.log(this.a);\n}\nvar a = 2;\nvar o = { a: 3, func: func };\nvar p = { a: 4 };\no.func(); //>> 3\n(p.func = o.func)(); //>> 2\n// 赋值表达式 p.func=o.func 的返回值是目标函数的引用，也就是 func 函数的引用\n// 因此调用位置是 func() 而不是 p.func() 或者 o.func()\n```\n\n\n## 显式指向\n\nJavaScript内置对象`Function`的三个原型方法`call()`、`apply()`和`bind()`，它们的第一个参数是一个对象，它们会把这个对象绑定到`this`，接着在调用函数时让`this`指向这个对象。\n\n### call(),apply()改变this的指向\n\n```javascript\nvar a = \"makai\";\n\nfunction func() {\n    console.log( this.a );\n}\nvar obj = {\n    a:\"coffe1891\"\n};\n\nfunc.call(obj); //>> coffe1891\n// 在调用 func 时强制把它的 this 绑定到 obj 上\n```\n通过在call方法，给第一个参数添加要把b添加到哪个环境中，简单来说，this就会指向那个对象。\n\ncall方法除了第一个参数以外还可以添加多个参数，如下：\n\n```javascript\nvar a = {\n    user:\"追梦子\",\n    fn:function(e,ee){\n        console.log(this.user); //追梦子\n        console.log(e+ee); //3\n    }\n}\nvar b = a.fn;\nb.call(a,1,2);\n```\n\n注意如果call和apply的第一个参数写的是null，那么this指向的是window对象.\n\n```javascript\nvar a = {\n    user:\"追梦子\",\n    fn:function(){\n        console.log(this); //Window {external: Object, chrome: Object, document: document, a: Object, speechSynthesis: SpeechSynthesis…}\n    }\n}\nvar b = a.fn;\nb.apply(null);\n```\n\n\n### bind()改变this的指向\n\n```javascript\nvar a = {\n    user:\"追梦子\",\n    fn:function(){\n        console.log(this.user);\n    }\n}\nvar b = a.fn;\nb.bind(a);\n\n```\n我们发现代码没有被打印，对，这就是bind和call、apply方法的不同，实际上bind方法返回的是一个修改过后的函数。\n\n```javascript\nvar a = {\n    user:\"追梦子\",\n    fn:function(){\n        console.log(this.user);\n    }\n}\nvar b = a.fn;\nvar c = b.bind(a);\nconsole.log(c); //function() { [native code] }\n\n```\n那么我们现在执行一下函数c看看，能不能打印出对象a里面的user。\n\n```javascript\nvar a = {\n    user:\"追梦子\",\n    fn:function(){\n        console.log(this.user); //追梦子\n    }\n}\nvar b = a.fn;\nvar c = b.bind(a);\nc();\n\n```\n\n同样bind也可以有多个参数，并且参数可以执行的时候再次添加，但是要注意的是，参数是按照形参的顺序进行的,且绑定在函数表达式上。\n\n```javascript\nvar a = {\n    user:\"追梦子\",\n    fn:function(e,d,f){\n        console.log(this.user); //追梦子\n        console.log(e,d,f); //10 1 2\n    }\n}\nvar b = a.fn;\nvar c = b.bind(a,10);\nc(1,2);\n\n```\n\n另外，使用`bind`可以修正SetTimeout和SetInterval的this指向:\n\n```javascript\nvar num = 0;\nclass Obj {\n    constructor(num){\n        this.num = num;\n    }\n    func(){\n        console.log(this.num);\n    }\n    func1(){\n        setTimeout(function () {\n            console.log(\"setTimeout:\"+this.num);\n        }.bind(this), 1000);//bind\n    }\n    func2(){\n        setInterval(function () {\n            console.log(this.num);\n        }.bind(this), 2000);//bind\n    }\n}\nvar obj = new Obj(1);\nobj.func();//>> 1　             输出的是obj.num\nobj.func1()//>> setTimeout:1　  输出的是obj.num\nobj.func2()//>> 1 1 1 1 ……　    输出的是obj.num\n\n```\n\n总结：call和apply都是改变上下文中的this并立即执行这个函数，bind方法可以让对应的函数想什么时候调就什么时候调用，并且可以将参数在执行的时候添加，这是它们的区别，根据自己的实际情况来选择使用。\n\n\n## “new”操作符指向\n\n在JavaScript 中，**构造函数**只是一些**使用`new`操作符时被调用的函数**。它们并不会属于某个类，也不会实例化一个类。实际上，它们甚至都不能算是一种特殊的类型（class），它们**只是被`new`操作符调用的普通函数而已**。\n\n使用`new` 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作：\n\n1. 创建（或者说构造）一个全新的对象；\n2. 将构造函数的作用域赋给新对象（因此`this`就指向了这个新对象）；\n3. 执行构造函数中的代码（为这个新对象添加属性、方法等）；\n4. 如果函数没有返回其他对象，那么返回这个新对象。\n\n```javascript\nfunction Fn(){\n    this.user = \"Caraxiong\";\n}\nvar a = new Fn();\nconsole.log(a.user); //Caraxiong\n\n```\n\n这里之所以对象a可以点出函数Fn里面的user是因为new关键字可以改变this的指向，将这个this指向对象a.调用这个函数Fn的是对象a，那么this指向的自然是对象a，那么为什么对象Fn中会有user，因为你已经复制了一份Fn函数到对象a中，用了new关键字就等同于复制了一份。\n\n## 箭头函数的this\n\n箭头函数内部的this是语法作用域，由上下文确定，有了箭头函数，可以修复this的指向，this总是指向语法作用域，也就是外层调用者。即箭头函数的this指向是**根据函数定义时的作用域来决定 `this` 的指向**。何谓“定义时的作用域”？就是你定义这个箭头函数的时候，该箭头函数在哪个函数里，那么箭头函数体内的this就是它父函数的this。\n\n\n```javascript\nfunction func() {\n  // 返回一个箭头函数\n  return a => {\n    //this 继承自 func()\n    console.log(this.a);\n  };\n}\nvar obj1 = {\n  a: 2\n};\nvar obj2 = {\n  a: 3\n};\n\nvar bar = func.call(obj1);\nbar.call(obj2); //>> 2         不是 3 ！\n\n// func() 内部创建的箭头函数会捕获调用时 func() 的 this。\n// 由于 func() 的 this 绑定到 obj1， bar（引用箭头函数）的 this 也会绑定到 obj1，\n// this一旦被确定，就不可更改，所以箭头函数的绑定无法被修改。（new 也不行！）\n```","tags":["javaScript"],"categories":["ES语法"]},{"title":"执行上下文相关概念","slug":"执行上下文","url":"/2020/11/16/zhi-xing-shang-xia-wen/","content":"\n# 执行上下文（Execution Context）\n## 定义\n\n执行上下文就是当前 JavaScript 代码被解析和执行时所在的环境，也叫作执行环境。\n\n它是一个抽象概念，JavaScript 中运行任何的代码都是在执行上下文中运行，在该执行上下文的创建阶段，变量对象（Variable Object，本文接下来会详述）、作用域链、this指向会分别被确定。\n\n![](https://7.dusays.com/2020/11/16/9349c5ea172d6.png)\n\n## 执行上下文类型\n\n执行上下文总共有三种类型：\n\n* **全局执行上下文**：这是默认的、最基础的执行上下文。不在任何函数中的代码都位于全局执行上下文中。它做了两件事：\n1. 创建一个全局对象，在浏览器中这个全局对象就是 window 对象；\n2. 将 this 指针指向这个全局对象。一个程序中只能存在一个全局执行上下文。\n* **函数执行上下文**：每次调用函数时，都会为该函数创建一个新的执行上下文。每个函数都拥有自己的执行上下文，但是只有在函数被调用的时候才会被创建。一个程序中可以存在任意数量的函数执行上下文。每当一个新的执行上下文被创建，它都会按照特定的顺序执行一系列步骤，具体过程将在本文后面讨论。\n* eval执行上下文：运行在 eval 函数中的代码也获得了自己的执行上下文，ES6 之后不再推荐使用 eval 函数，所以本书出于面试实用考虑，不会深入讨论eval。\n\n## 执行上下文的生命周期\n\n执行上下文的生命周期包括三个阶段：创建阶段 → 执行阶段 → 回收阶段，本文重点介绍创建阶段。\n\n### a. 创建阶段\n\n当函数被调用，但未执行任何其内部代码之前，会做以下三件事：\n\n* 创建变量对象：首先初始化函数的参数 arguments，提升函数声明和变量声明（变量的**声明提前**有赖于`var`关键字）。\n* 创建作用域链：在执行期上下文的创建阶段，作用域链是在变量对象之后创建的。作用域链本身包含变量对象。作用域链用于解析变量。当被要求解析变量时，JavaScript 始终从代码嵌套的最内层开始，如果最内层没有找到变量，就会跳转到上一层父作用域中查找，直到找到该变量。\n* 确定 this 指向。\n\n### b. 执行阶段\n\n创建完成之后，就会开始执行代码，在这个阶段，会完成变量赋值、函数引用、以及执行其他代码。\n\n### c. 回收阶段\n\n函数调用完毕后，函数出栈，对应的执行上下文也出栈，等待垃圾回收器回收执行上下文。\n\n![](https://7.dusays.com/2020/11/16/d7d64d01245e3.png)\n\n## 执行上下文栈\n\n```javascript\nvar a = \"coffe\"; //1.进入全局执行上下文\nfunction out() {\n    var b = \"18\";\n    function inner() {\n        var c = \"91\";\n        console.log(a+b+c);\n    }\n    inner(); //3.进入inner函数的执行上下文\n}\nout(); //2.进入out函数的执行上下文\n```\n\n 在代码开始执行时，首先会产生一个**全局执行上下文**，调用函数时，会产生**函数执行上下文**，函数调用完成后，它的执行上下文以及其中的数据都会被销毁，重新回到全局执行环境，网页关闭后全局执行环境也会销毁。其实这是一个入栈出栈的过程，**全局上下文永远在栈底，而当前正在函数执行上下文在栈顶**。以上代码的执行会经历以下过程：\n\n1. 当代码开始执行时就**创建全局执行上下文，全局执行上下文入栈**。\n2. 全局执行上下文入栈后，其中的代码开始执行，进行赋值、函数调用等操作，执行到`out()`时，**激活函数`out`创建自己的执行上下文，`out`函数执行上下文入栈**。\n3. `out`函数执行上下文入栈后，其中的代码开始执行，进行赋值、函数调用等操作，执行到`inner()`时，**激活函数`inner`创建自己的执行上下文，`inner`函数执行上下文入栈**。\n4. `inner`函数上下文入栈后，其中的代码开始执行，进行赋值、函数调用、打印等操作，由于里面没有可以生成其他执行上下文的需要，所有代码执行完毕后，**`inner`函数上下文出栈**。\n5. `inner`函数执行上下文出栈，又回到了`out`函数执行上下文环境，接着执行`out`函数中后面剩下的代码，由于后面没有可以生成其他执行上下文的需要，所有代码执行完毕后，**`out`函数执行上下文出栈**。\n6. `out`函数执行上下文出栈后，又回到了全局执行上下文环境，直到浏览器窗口关闭，**全局执行上下文出栈**。\n\n![](https://7.dusays.com/2020/11/16/55431837a2be8.png)\n\n我们可以发现：\n\n1. 全局执行上下文在代码开始执行时就创建，有且只有一个，永远在执行上下文栈的栈底，浏览器窗口关闭时它才出栈。\n2. 函数被调用的时候创建函数的执行上下文环境，并且入栈。\n3. 只有栈顶的执行上下文才是处于活动状态的，也即只有栈顶的变量对象才会变成活动对象。\n\n\n# 变量对象（Variable Object，VO)\n\n变量对象（VO）是一个类似于容器的对象，与作用域链、执行上下文息息相关。\n\n## 变量对象的创建过程的三条规则：\n\n1. **建立`arguments`对象**。检查当前执行上下文中的参数，建立该对象下的属性与属性值。\n2. **检查当前执行上下文的函数声明，也就是使用`function`关键字声明的函数**。在变量对象中以函数名建立一个属性，属性值为指向该函数所在内存地址的引用。如果该属性之前已经存在，那么该属性将会被新的引用所覆盖。\n3. **检查当前执行上下文中的变量声明，每找到一个变量声明，就在变量对象中以变量名建立一个属性，属性值为`undefined`**。**如果该变量名的属性已经存在，为了防止同名的函数被修改为`undefined`，则会直接跳过，原属性值不会被修改**。\n\n\n![](https://7.dusays.com/2020/11/16/7fad446d8076c.png)\n\n可以用以下伪代码来表示变量对象：\n\n```javascript\nVO={\n    Arguments:{},//实参\n    Param_Variable:具体值,//形参\n    Function:<function reference>,//函数的引用\n    Variable:undefined//其他变量\n}\n```\n\n当执行上下文进入执行阶段后，变量对象会变为**活动对象**（Active Object，AO）。此时原先声明的变量会被赋值。**变量对象和活动对象都是指同一个对象，只是处于执行上下文的不同阶段**。\n\n我们可以通过以下伪代码来表示活动对象：\n\n```javascript\nAO={\n    Arguments:{},//实参\n    Param_Variable:具体值,  //形参\n    Function:<function reference>,//函数的引用\n    Variable:具体值//注意，这里已经赋值了喔\n}\n```\n\n未进入执行上下文的执行阶段之前，变量对象中的属性都不能访问。但是**进入执行阶段之后，变量对象转变为了活动对象（被激活了）**，里面的属性可以被访问了，然后开始进行执行阶段的操作。\n\n## 全局执行上下文的变量对象\n\n全局执行上下文的变量对象是`window`对象，而这个特殊，在`this`指向上也同样适用，`this`也是指向`window`。\n\n除此之外，全局执行上下文的生命周期，与程序的生命周期一致，只要程序运行不结束（比如关掉浏览器窗口），全局执行上下文就会一直存在。其他所有的执行上下文，都能直接访问全局执行上下文里的内容。\n\n## 再看一段代码，留意注释\n\n```javascript\nfunction func() {\n    console.log('function func');\n}\nvar func = \"coffe\";\nconsole.log(func); //>> coffe\n// 以上代码中，按三条规则，变量声明的 func 遇到函数声明的 func 应该会跳过，\n// 可是为什么最后 func 的输出结果仍然是被覆盖了显示\"coffe\"呢？\n// 那是因为三条规则仅仅适用于变量对象的创建阶段，也即执行上下文的创建阶段。\n// 而 func=\"coffe\" 是在执行上下文的执行阶段中运行的，输出结果自然会是\"coffe\"。\n```\n\n这种现象很容易让人费解，其实也是因为`var`声明的变量允许重名导致的，若使用关键字`let`来声明变量，就可以避免这种令人费解的情况发生。\n\n# 作用域链（Scope Chain）\n\n## 定义\n\n**多个作用域对应的变量对象串联起来组成的链表就是作用域链，**这个链表是以引用的形式保持对变量对象的访问**。**作用域链保证了当前执行上下文对符合访问权限的变量和函数的有序访问。\n\n![&#x4F5C;&#x7528;&#x57DF;&#x94FE;&#x7684;&#x56FE;&#x793A;](https://7.dusays.com/2020/11/16/867543641bca6.png)\n\n作用域链的最顶端一定是当前作用域（local scope）对应的变量对象，最底端一定是全局作用域对应的变量对象（全局VO）。\n\n作用域链可以形象地比如为一个蒸笼。\n\n![&#x84B8;&#x7B3C;](https://7.dusays.com/2020/11/16/8dc21cd5da203.png)\n\n最底下的一屉，相当于是全局作用域，它里面的蒸汽（变量和函数的可见性）可以渗透到整个蒸笼，底层之上的其他屉相当于局部作用域，这些上面屉的蒸汽只能影响更上面的屉。\n\n作用域链可以理解为下面这种伪代码格式：\n\n```text\n{\n    Scope: [\n        { //当前作用域对应的VO\n            实参,\n            形参,\n            变量,\n            函数\n        }, \n        { //第二个作用域对应的VO\n            实参,\n            形参,\n            变量,\n            函数\n        },\n        ... \n        { //全局作用域对应的VO\n            变量,\n            函数\n        }\n    ]\n}\n```\n\n## 变量/函数的查找机制\n\n  查找变量/函数时JS引擎是从里离它最近作用域开始的查找的，也即从离它最近的变量对象（VO）开始查找。\n\n如果在当前的变量对象里面找不到目标变量/函数，就在上一级作用域的变量对象里面查找。若这时找到了目标变量/函数，则停止查找；若找不到，一直回溯到全局作用域的变量对象里查找，若仍找不到目标变量/函数，停止查找。\n","tags":["javaScript"],"categories":["ES语法"]},{"title":"从es7到es12","slug":"从es7到es12","url":"/2020/11/10/cong-es7-dao-es12/","content":"\n# 本篇导读\n\nJavaScript是一门支持多种编程范式的语言，灵活性很高，功能也十分强大。因为灵活性，JavaScript有很多种使用方式，被应用到浏览器、客户端软件、嵌入式硬件等多种场景下。在面向对象（OOP）这种编程范式大行其道的今天，这种变化多端的语言因其编程范式多样，每种场景下使用形态各异，使用者之间思维差别大，见解又各不相同，因此也就被误解得极深。正是由于这种相对的复杂性，前端工程师们有必要更系统、深入地对这门语言进行学习和研究。\n\n现在，JavaScript在TC39（TC39由包括浏览器厂商在内的各方组成，他们开会推动JavaScript特性的提案沿着一条严格的流程推进）的推动下正加速地迭代更新，每年都会有一些新特性出现。前端工程师们有必要了解一下这些新特性，以便更好地在一线互联网企业发挥出自己的能量。\n\n# JavaScript 和 ECMAScript 6 的关系\n\nJavaScript起源于1995年Netscape为自家游览器创造的脚本语言LiveScript。后来因为Sun公司的Java语言兴起，Netscape为了沾热度将LiveScript改名为JavaScript，但其实Java和JavaScript没有一点关系。\n\n1997年Netscape将JavaScript规范提交到 Ecma International（[www.ecma-international.org](https://www.ecma-international.org/)，简称EI），诞生了ECMAScript （简称“ES”）第1个版本。\n\n随后在1999年诞生了十分稳定的ES 3，也就是2009年12月之前前端工程师们最广泛使用的版本。\n\n在2009年12月诞生了ES 5。你可能会问ES 4 呢，抱歉，版本4因为太激进，EI委员会成员之间的意见不一，最后胎死腹中，改由更加平滑温和的版本5继承版本4的一些新特性和功能。\n\nEI于2015年6月发布了ES 6，也就是我们今天广泛使用的版本。这之后每年6月发布一个极小更新的ES版本。\n\n综上可见，**JavaScript是ECMAScript规范的一种实现**。为方便读者理解交流，而且由于ECAMScript 6 之后变化并不是特别大，如果没有特别说明，本书后面讲述的JavaScript对应的规范默认为 ES 6。\n\n本文下面会介绍ES 7~12的新特性。\n\n# ES 7 新特性\n\n| 新特性 | 中文说明 |\n| :--- | :--- |\n| `Array.prototype.includes` |  |\n| Exponentiation operator | 指数函数的中缀表示法 |\n\n## Array.prototype.includes\n\nincludes是一个Array上很有用的方法，用于快速查找数组中是否包含某个元素，包括NaN（所以和indexOf不一样\\)。\n\n```javascript\n(() => {\n  let arr = [1, 2, 3, NaN];\n\n  if (arr.includes(2)) {\n    //查找2是否存在于arr数组中\n    console.log(\"找到了!\"); //>> 找到了！\n  }\n  if (!arr.includes(2, 3)) {\n    //第二个参数3表示数组下标为3的项，也即第4项开始查找\n    console.warn(\"不存在!\"); //>> 不存在！\n  }\n\n  //下面两句说明incluedes和indexOf的区别\n  console.log(arr.includes(NaN)); //true\n  console.log(arr.indexOf(NaN) != -1); //false\n})();\n```\n\n## 指数函数的中缀表示法\n\n这个是与`Math.pow`有关的特性，还记得`i++`,`x += x`这种写法吗，指数函数的中缀表示法与之类似。与python语言一样，JavaScript也采用两个星符号`**`来表示`Math.pow`。好处有两个：  \na. 中缀表示法比函数表示法更简洁，这使它更可取。  \nb. 方便数学、物理、机器人学等领域的计算。\n\n用法示例如下：\n\n```javascript\n//用法一：x ** y\n\nlet squared = 2 ** 2;//等同于: 2 * 2\nlet cubed = 2 ** 3;//等同于: 2 * 2 * 2\n```\n\n```javascript\n//用法二：x **= y\n\nlet a = 2;\na **= 2;//等同于: a = a * a;\n\nlet b = 3;\nb **= 3;//等同于: b = b * b * b;\n```\n\n# ES 8 新特性\n\n| 新特性 | 中文说明 |\n| :--- | :--- |\n| `Object.values` / `Object.entries` |  |\n| String padding | 字符串追加 |\n| `Object.getOwnPropertyDescriptors` |  |\n| Trailing commas in function parameter lists and calls | 结尾允许逗号 |\n| Async functions | 异步函数 |\n| Shared memory and atomics | 共享内存和 Atomics 对象 |\n\n## Object.values\\(\\) / Object.entries\n\n定义是`Object.values(obj)`，`obj` 参数是对目标对象的操作，它可以是一个对象或者数组。\n\n```javascript\nconst obj = { x: 'xxx', y: 1 };\nObject.values(obj); // ['xxx', 1]\n\nconst obj = ['e', 's', '8']; // 等同于 { 0: 'e', 1: 's', 2: '8' };\nObject.values(obj); // ['e', 's', '8']\n\n//当把数字对象的当键的时候，返回的数组以键的值升序排序\nconst obj = { 10: 'xxx', 1: 'yyy', 3: 'zzz' };\nObject.values(obj); // ['yyy', 'zzz', 'xxx']\nObject.values('es8'); // ['e', 's', '8']\n```\n\n`Object.entries`方法返回一个给定对象可枚举属性值的数组\\[key, value\\]，与`Object.values`类似。\n\n```javascript\nconst obj = { x: 'xxx', y: 1 };\nObject.entries(obj); // [['x', 'xxx'], ['y', 1]]\n\nconst obj = ['e', 's', '8'];\nObject.entries(obj); // [['0', 'e'], ['1', 's'], ['2', '8']]\n\nconst obj = { 10: 'xxx', 1: 'yyy', 3: 'zzz' };\nObject.entries(obj); // [['1', 'yyy'], ['3', 'zzz'], ['10', 'xxx']]\nObject.entries('es8'); // [['0', 'e'], ['1', 's'], ['2', '8']]\n```\n\n## 字符串追加\n\n在 ES 8 中String新增了两个实例函数`String.prototype.padStart`和`String.prototype.padEnd`，允许将空字符串或其他字符串添加到原始字符串的开头或结尾。\n\n* `String.padStart(targetLength,[padString])`    \n  _targetLength：_当前字符串需要填充到的目标长度。如果这个数值小于当前字符串的长度，则返回当前字符串本身。\n\n  _padString：_\\(可选\\)填充字符串。如果字符串太长，使填充后的字符串长度超过了目标长度，则只保留最左侧的部分，其他部分会被截断，此参数的缺省值为空格。\n\n* `String.padEnd(targetLength,padString])` 参数释义同上。\n\n```javascript\n'es8'.padStart(2);          // 'es8'\n'es8'.padStart(5);          // '  es8'\n'es8'.padStart(6, '1891');  // '189es8'\n'es8'.padStart(14, 'coffe');  // 'coffecoffeces8'\n'es8'.padStart(7, '0');     // '0000es8'\n\n'es8'.padEnd(2);            // 'es8'\n'es8'.padEnd(5);            // 'es8  '\n'es8'.padEnd(6, '1891');    // 'es8189'\n'es8'.padEnd(14, 'coffe');    // 'es8coffecoffec'\n'es8'.padEnd(7, '9');       // 'es89999'\n```\n\n## Object.getOwnPropertyDescriptors\n\n`getOwnPropertyDescriptors`方法返回一指定对象自己所有的属性内容，并且属性内容只是自身直接定义的，而不是从object的原型继承而来的。  \n定义是：`Object.getOwnPropertyDescriptors(obj)`，`obj` 是指目标对象，这个方法返回的值可能是 configurable、enumerable、writable、get、set 和 value。\n\n```javascript\nconst obj = { \n  get es7() { return 7; },\n  get es8() { return 8; }\n};\nObject.getOwnPropertyDescriptors(obj);\n// {\n//   es7: {\n//     configurable: true,\n//     enumerable: true,\n//     get: function es7(){}, //the getter function\n//     set: undefined\n//   },\n//   es8: {\n//     configurable: true,\n//     enumerable: true,\n//     get: function es8(){}, //the getter function\n//     set: undefined\n//   }\n// }\n```\n\n## 结尾允许逗号\n\n用法示例如下：\n\n```javascript\n//定义参数时\nfunction foo(\n    param1,\n    param2,//结尾逗号\n) {}\n//传参时\nfoo(\n    'coffe',\n    '1891',//结尾逗号\n);\n//对象中\nlet obj = {\n    \"a\": 'coffe',\n    \"b\": '1891',//结尾逗号\n};\n//数组中\nlet arr = [\n    'coffe',\n    '1891',//结尾逗号\n];\n```\n\n这样改动的好处有两点：\n\n* 重新排列项目更简单，因为如果最后一项更改其位置，则不必添加和删除逗号。\n* 可以帮助git等版本控制系统跟踪实际发生的变化，在查看代码改动、合并代码的时候，少报一些无用信息。例如，从\n\n```javascript\n[\n    'coffe'\n]\n```\n\n变更为\n\n```javascript\n[\n    'coffe',\n    '1891'\n]\n```\n\n在git里它会报同时修改了两行代码，采用结尾逗号`'coffe',`之后，就只会报仅有一行代码`'1891',`的变动，这样做代码review（代码复查）的时候就更省眼力了。\n\n## 异步函数\n\nAsync Functions也就是我们常说的Async/Await，相信大家对于这个概念都已经不陌生了。Async/Await是一种用于处理JS异步操作的语法糖，可以帮助我们摆脱**回调地狱**（callback hell），编写更加优雅的代码。\n\n通俗的理解，`async`关键字的作用是告诉编译器对于标定的函数要区别对待。当编译器遇到标定的函数中的`await`关键字时，要暂时停止运行，等到`await`标定的函数处理完毕后，再进行相应操作。如果该函数fulfiled了，则返回值是fulfillment value，否则得到的就是reject value。\n\n下面通过拿普通的promise写法来对比，就很好理解了：\n\n```javascript\nasync function asyncFunc() {\n    const result = await otherAsyncFunc();// otherAsyncFunc()返回一个Promise对象\n    console.log(result);\n}\n\n// 等同于:\nfunction asyncFunc() {\n    return otherAsyncFunc()// otherAsyncFunc()返回一个Promise对象\n    .then(result => {\n        console.log(result);\n    });\n}\n```\n\n按顺序处理多个异步函数的时候优势更为明显：\n\n```javascript\nasync function asyncFunc() {\n    const result1 = await otherAsyncFunc1();// otherAsyncFunc1()返回一个Promise对象\n    console.log(result1);\n    const result2 = await otherAsyncFunc2();// otherAsyncFunc2()返回一个Promise对象\n    console.log(result2);\n}\n\n// 等同于:\nfunction asyncFunc() {\n    return otherAsyncFunc1()// otherAsyncFunc1()返回一个Promise对象\n    .then(result1 => {\n        console.log(result1);\n        return otherAsyncFunc2();// otherAsyncFunc2()返回一个Promise对象\n    })\n    .then(result2 => {\n        console.log(result2);\n    });\n}\n```\n\n并行处理多个异步函数：\n\n```javascript\nasync function asyncFunc() {\n    const [result1, result2] = await Promise.all([\n        otherAsyncFunc1(),// otherAsyncFunc1()返回一个Promise对象\n        otherAsyncFunc2() // otherAsyncFunc2()返回一个Promise对象\n    ]);\n    console.log(result1, result2);\n}\n\n// 等同于:\nfunction asyncFunc() {\n    return Promise.all([\n        otherAsyncFunc1(),// otherAsyncFunc1()返回一个Promise对象\n        otherAsyncFunc2() // otherAsyncFunc2()返回一个Promise对象\n    ])\n    .then([result1, result2] => {\n        console.log(result1, result2);\n    });\n}\n```\n\n处理错误：\n\n```javascript\nasync function asyncFunc() {\n    try {\n        await otherAsyncFunc();// otherAsyncFunc()返回一个Promise对象\n    } catch (err) {\n        console.error(err);\n    }\n}\n\n// 等同于:\nfunction asyncFunc() {\n    return otherAsyncFunc()// otherAsyncFunc()返回一个Promise对象\n    .catch(err => {\n        console.error(err);\n    });\n}\n```\n\nAsync Functions若是要展开讲可以占很大的篇幅，鉴于本篇是一篇介绍性文章，故此不再进行深入论述。\n\n## 共享内存和 Atomics 对象\n\nSharedArrayBuffer 对象用来表示一个通用的，固定长度的原始二进制数据缓冲区，类似于 ArrayBuffer对象（如果之前你没有接触过ArrayBuffer相关知识的话，建议从[内存管理速成教程系列漫画解说入门](https://hacks.mozilla.org/2017/06/a-cartoon-intro-to-arraybuffers-and-sharedarraybuffers/)） ，它们都可以用来在共享内存（shared memory）上创建视图。与 ArrayBuffer 不同的是，SharedArrayBuffer 不能被分离。\n\n```javascript\n/**\n * \n * @param {*} length 所创建的数组缓冲区的大小，以字节(byte)为单位。  \n * @returns {SharedArrayBuffer} 一个大小指定的新 SharedArrayBuffer 对象。其内容被初始化为 0。\n */\nnew SharedArrayBuffer(length)\n\n```\n\nAtomics 对象提供了一组静态方法用来对 SharedArrayBuffer 对象进行原子操作，这些原子操作属于 Atomics 模块。Atomics 不是构造函数，因此不能使用 new 操作符调用，也不能将其当作函数直接调用。Atomics 的所有属性和方法都是静态的（与 Math 对象一样）。\n\n| 方法名 | 说明 |\n| :--- | :--- |\n| Atomics.add\\(\\) | 将指定位置上的数组元素与给定的值相加，并返回相加前该元素的值。 |\n| Atomics.and\\(\\) | 将指定位置上的数组元素与给定的值相与，并返回与操作前该元素的值。 |\n| Atomics.compareExchange\\(\\) | 如果数组中指定的元素与给定的值相等，则将其更新为新的值，并返回该元素原先的值。 |\n| Atomics.exchange\\(\\) | 将数组中指定的元素更新为给定的值，并返回该元素更新前的值。 |\n| Atomics.load\\(\\) | 返回数组中指定元素的值。 |\n| Atomics.or\\(\\) | 将指定位置上的数组元素与给定的值相或，并返回或操作前该元素的值。 |\n| Atomics.store\\(\\) | 将数组中指定的元素设置为给定的值，并返回该值。 |\n| Atomics.sub\\(\\) | 将指定位置上的数组元素与给定的值相减，并返回相减前该元素的值。 |\n| Atomics.xor\\(\\) | 将指定位置上的数组元素与给定的值相异或，并返回异或操作前该元素的值。 |\n| Atomics.wait\\(\\) | 检测数组中某个指定位置上的值是否仍然是给定值，是则保持挂起直到被唤醒或超时。返回值为 \"ok\"、\"not-equal\" 或 \"time-out\"。调用时，如果当前线程不允许阻塞，则会抛出异常（大多数浏览器都不允许在主线程中调用 wait\\(\\)）。 |\n| Atomics.wake\\(\\) | 唤醒等待队列中正在数组指定位置的元素上等待的线程。返回值为成功唤醒的线程数量。 |\n| Atomics.isLockFree\\(size\\) | 可以用来检测当前系统是否支持硬件级的原子操作。对于指定大小的数组，如果当前系统支持硬件级的原子操作，则返回 true；否则就意味着对于该数组，Atomics 对象中的各原子操作都只能用锁来实现。此静态方法面向的是技术专家。 |\n\n# ES 9 新特性\n\n| 新特性 | 中文说明 |\n| :--- | :--- |\n| Asynchronous Iteration | 异步迭代器 |\n| `Promise.prototype.finally` |  |\n| Lifting template literal restriction | 重新修订了字面量的转义 |\n| Rest/Spread Properties | Rest/Spread 属性 |\n| `s` \\(dotAll\\) flag for regular expressions | 正则表达式dotAll模式 |\n| RegExp named capture groups | 正则表达式命名捕获组 |\n| RegExp Lookbehind Assertions | 正则表达式反向断言 |\n| RegExp Unicode Property Escapes | 正则表达式 Unicode 转义 |\n\n## 异步迭代器\n\n在`async`/`await`的某些时刻，你可能尝试在同步循环中调用异步函数。例如：\n\n```javascript\nasync function func(array) {\n  for (let i of array) {\n    await someFunc(i);\n  }\n}\n```\n\n这段代码不会达到预期目的，下面这段同样也不会：\n\n```javascript\nasync function func(array) {\n  array.forEach(async i => {\n    await someFunc(i);\n  });\n}\n```\n\n上面这段代码中，循环本身依旧保持同步，并在内部异步函数之前全部调用完成。\n\n引入异步迭代器后，就像常规迭代器，除了`next()`方法返回一个Promise。因此`await`可以和`for...of`循环一起使用，以串行的方式运行异步操作。\n\n```javascript\nasync function func(array) {\n  for await (let i of array) {//异步迭代\n    someFunc(i);\n  }\n}\n```\n\n## Promise.prototype.finally\n\n一个Promise调用链要么成功到达最后一个`.then()`，要么失败触发`.catch()`。在某些情况下，你想要在无论Promise运行成功还是失败，运行相同的代码，例如清除数组、删除对话、关闭数据库连接等，`.finally()`允许实现这样的目的。\n\n```javascript\nfunction func() {\n  promiseFunc() //返回一个Promise对象\n    .then(() => {})\n    .then(() => {})\n    .catch(err => {\n      console.log(err);\n    })\n    .finally(() => {\n      //无论promiseFunc()运行成功还是失败，这里的代码会被调用到\n    });\n}\n```\n\n## 重新修订了字面量的转义\n\nES9 之前，`\\u`表示 unicode 转义，`\\x`表示十六进制转义，`\\`后跟一个数字表示八进制转义，这使得创建特定的字符串变得不可能，例如Windows文件路径`C:\\uuu\\xxx\\111`。\n\n要取消转义序列的语法限制，可在模板字符串之前使用标记函数`String.raw`。\n\n```javascript\nlet s = `\\u{54}` //会转义成unicode \"T\"\nconsole.log(s);//>> T\n\nlet str = String.raw`\\u{54}`; //不会被转义\nconsole.log(str);//>> \\u{54}\n```\n\n## Rest / Spread\n\n这个就是我们通常所说的三个点`...`，这项特性在ES6中已经引入，但是ES6中的作用对象仅限于数组。在ES9中，为对象提供了像数组一样的rest参数和扩展运算符：\n\n```javascript\nconst obj = {\n  a: 1,\n  b: 2,\n  c: 3\n};\nconst { a, ...param } = obj; //这里...是rest\nconsole.log(a); //>> 1\nconsole.log(param); //>> {b: 2, c: 3}\n\nfunction foo({ a, ...param }) {//这里...还是rest\n  console.log(a); //>> 1\n  console.log(param); //>> {b: 2, c: 3}\n}\n\nconst param = { b: 2, c: 3 };\nfoo({ a: 1, ...param });  //此处...为spread\n```\n\n## 正则表达式dotAll模式\n\n正则表达式中点`.`匹配除回车外的任何单字符，标记`s`改变这种行为，允许匹配回车换行。\n\n```javascript\n/hello.world/.test('hello\\nworld');  // false\n/hello.world/s.test('hello\\nworld'); // true\nconsole.log(/hello.world/s.test(`hello\nworld`))   //>> true\n```\n\n## 正则表达式命名捕获组\n\nJavascript正则表达式中使用`exec()`匹配后，能够返回一个包含匹配字符串的类数组对象。\n\n```javascript\nconst reDate = /(\\d{4})-(\\d{2})-(\\d{2})/,\n  match = reDate.exec(\"2018-08-06\");\nconsole.log(match);//>> [2018-08-06, 2018, 08, 06]\n\n//这样就可以直接用索引来获取年月日：\nlet year = match[1]; //>> 2018\nlet month = match[2]; //>> 08\nlet day = match[3]; //>> 06\n```\n\n返回数组的第0项为与正则表达式相匹配的文本，第 1 项是与 `reDate` 的第 1 个分组`\\d{4}`相匹配的文本（如果有的话），第 2 项是与 `reDate` 的第 2 个分组`\\d{2}`相匹配的文本（如果有的话），以此类推。正则表达式的组以`()`包起来。\n\n上面的案例，若是日期格式变成`月日年`，那么改变正则表达式的结构后，还有可能会改变变量的赋值部分的代码。如下示例：\n\n```javascript\nconst reDate = /(\\d{2})-(\\d{2})-(\\d{4})/,//表达式结构变化了\n  match = reDate.exec(\"08-06-2018\");\nconsole.log(match);//>> [08-06-2018, 08, 06, 2018]\n\n//此时年月日的赋值代码也要改了,改的地方真多啊！怎么办？\nlet year = match[3]; //>> 2018\nlet month = match[1]; //>> 08\nlet day = match[2]; //>> 06\n```\n\n可以发现上面的写法改的地方太多了，有没有办法少改点代码省省事呢？有！ ES9 允许使用符号`?<name>`来命名**捕获组**（也即“匹配到的组”），示例如下：\n\n```javascript\nconst reDate = /(?<year>\\d{4})-(?<month>\\d{2})-(?<day>\\d{2})/,\n  match = reDate.exec(\"2018-08-06\");\nconsole.log(match);\n//>> [2018-08-06, 08, 06, 2018, groups: {day: 06, month: 08, year: 2018}]\n\n//此时用groups对象来获取年月日，无论正则表达式怎么变换，这下面三行不用改了，省事！\nlet year = match.groups.year; //>> 2018\nlet month = match.groups.month; //>> 08\nlet day = match.groups.day; //>> 06\n```\n\n命名捕获组的写法相当于是把每个捕获组都定义了一个名字，然后存储到返回值的`groups`属性中。\n\n### 正则表达式后行断言\n\n先看看正则表达式**先行断言**示例：\n\n```javascript\nconst re1 = /\\D(\\d+)/,\n    re2 = /\\D(?=\\d+)/,//\"?=\"是正向先行断言\n    match1 = re1.exec(\"$123.45\"),\n    match2 = re2.exec(\"$123.45\");\nconsole.log(match1[0]); //>> $123\nconsole.log(match2[0]); //>> $\n```\n\n> **\\(?=pattern\\)** 零宽正向先行断言\\(zero-width positive lookahead assertion\\)  \n> 代表字符串中的一个位置，**紧接该位置之后**的字符序列**能够匹配**pattern；\n>\n> \\(**?!pattern\\)** 零宽负向先行断言\\(zero-width negative lookahead assertion\\)  \n> 代表字符串中的一个位置，**紧接该位置之后**的字符序列**不能匹配**pattern；\n>\n> **\\(?&lt;=pattern\\)** 零宽正向后行断言\\(zero-width positive lookbehind assertion\\)   \n> 代表字符串中的一个位置，**紧接该位置之前**的字符序列**能够匹配**pattern；\n>\n> **\\(?&lt;!pattern\\)** 零宽负向后行断言\\(zero-width negative lookbehind assertion\\)  \n> 代表字符串中的一个位置，**紧接该位置之前**的字符序列**不能匹配**pattern。\n\n在ES9中，可以允许使用`?<=`进行**正向后行断言**，可以获取货币的价格而忽略货币符号。\n\n```javascript\nconst re= /(?<=\\D)[\\d\\.]+/,\n    match = re.exec(\"$123.45\");\nconsole.log(match[0]); //>> 123.45\n```\n\n上面的正向后行断言，也就是说`\\D`这个条件必须满足，但`\\D`匹配的字符不会作为结果输出（因为**先行/后行断言**其实只是匹配了一个位置）。如果是下面这样：\n\n```javascript\nconst re= /(?<=\\D)[\\d\\.]+/,\n    match1 = re.exec(\"123.45\"),\n    match2 = re.exec(\"12345\");\nconsole.log(match1 && match1[0]); //>> 45\nconsole.log(match2 && match1[0]); //>> null\n```\n\n可以看到`match1`匹配到的是`45`,这是由于在`.`前面没有任何符合`\\D`的匹配内容，它会一直找到符合`\\D`的内容，也就是`.`然后返回后面的内容。而`match2`若是没有满足前面肯定反向断言的条件的话，则结果返回`null`。\n\n## 正则表达式 Unicode 转义\n\nES9 之前，在正则表达式中本地访问 Unicode 字符属性是不被允许的。ES9 添加了 Unicode 属性转义，形式为`\\p{...}`和`\\P{...}`，在正则表达式中使用标记 `u` \\(unicode\\) 设置，在`\\p`的`{...}`内，可用键值对的方式设置需要匹配的属性而非具体内容。\n\n```javascript\nconst regex = /\\p{Script=Greek}/u;//Greek为希腊语的意思\nconsole.log(regex.test('a')); //>> flase\nconsole.log(regex.test('Σ')); //>> true\n```\n\n# ES 10 新特性\n\n| 新特性 | 中文说明 |\n| :--- | :--- |\n| Optional `catch` binding | 可选的 catch 变量绑定 |\n| JSON superset | JSON超集 |\n| `Symbol.prototype.description` | Symbol 对象的 description 属性 |\n| `Function.prototype.toString` revision | 修订`Function.prototype.toString` |\n| `Object.fromEntries` |  |\n| Well-formed `JSON.stringify` | 更加友好的JSON.stringify |\n| `String.prototype.{trimStart,trimEnd}` |  |\n| `Array.prototype.{flat,flatMap}` |  |\n\n## 可选的 catch 变量绑定\n\n在 ES10 之前，我们必须通过语法为 catch 子句绑定异常变量，无论是否有必要。很多时候 catch 块是多余的，而 ES10 使我们能够简单的把变量省略掉。\n\n```javascript\n//之前是\ntry {} catch(e) {}\n\n//ES10之后可以写成，\ntry {} catch {}//省掉了变量e\n```\n\n## JSON超集\n\n什么是 JSON 超集？简单来说就是 JSON 是 ECMAScript 的子集，也就是说让 ECMAScript 兼容 JSON 的内容所支持的全部文本。\n\nECMAScript 在标准 [JSON.parse](https://tc39.es/ecma262/#sec-json.parse) 部分阐明了 JSON 确为其一个子集，但由于 JSON 的内容可以正常包含 `U+2028` 行分隔符与 `U+2029` 段落分隔符，而 ECMAScript 却不行，所以，该草案旨在解决这一问题。在这之前，如果你使用 `JSON.parse()` 执行带如上特殊字符的字符串时，只会收到 `SyntaxError` 的错误提示。该草案同样是向后兼容的，其对用户唯一的影响是保持原样，即在暂不支持特殊字符解析的运行环境中保持报错 `SyntaxError` 。\n\n## Symbol 对象的 description 属性\n\nES10 中为 Symbol 对象添加了只读属性 `description` ，该对象返回包含 Symbol 描述的字符串。在创建Symbol时向其添加`description` \\(描述\\)，能够直接访问`description` ，对调试是很有用的。\n\n```javascript\nlet sym = Symbol('foo');//添加的描述内容为“foo”\nconsole.log(sym.description);//>> foo\n\nsym = Symbol();\nconsole.log(sym.description);//>> undefined\n\n//和 Symbol() 不同的是，用 Symbol.for() 方法创建的的 symbol 会被放入一个全局 \n//symbol 注册表中。Symbol.for() 并不是每次都会创建一个新的 symbol，它会首先检\n//查给定的 key 是否已经在注册表中了。假如是，则会直接返回上次存储的那个。否则，它\n//会再新建一个。\nsym = Symbol.for('bar');\nconsole.log(sym.description);//>> bar\n```\n\n## 修订Function.prototype.toString\n\n函数原型上的方法`toString()`现在返回精确字符，包括空格和注释。\n\n```javascript\nfunction /* comment */ foo /* another comment */() {}\n\n//ES10之前不会打印注释部分\nconsole.log(foo.toString()); //>> function foo(){}\n\n//ES10里，会把注释一同打印\nconsole.log(foo.toString()); //>> function /* comment */ foo /* another comment */ (){}\n\n//注意：\n//箭头函数是个例外\nconst bar /* comment */ = /* another comment */ () => {};\nconsole.log(bar.toString()); //>> () => {}\n```\n\n## Object.fromEntries\n\n在 JavaScript 操作中，数据在各种数据结构之间的转换都是很容易的，比如 Map 到数组、Map 到 Set、对象到 Map 等等。\n\n```javascript\nlet map = new Map().set('foo', true).set('bar', false);\nlet arr = Array.from(map);\nlet set = new Set(map.values());\n\nlet obj = { foo: true, bar: false };\n//下一句 Object.entries() 方法返回给定对象 obj 自身可枚举属性的键值对数组,\n//形如：[[\"foo\",true],[\"bar\",false]]\nlet newMap = new Map(Object.entries(obj));\n```\n\n但是如果我们需要将一个键值对列表转换为对象，就要写点费劲的代码了。\n\n```javascript\nlet map = new Map().set(\"foo\", true).set(\"bar\", false);\nlet obj = Array.from(map).reduce((acc, [key, val]) => {\n  return Object.assign(acc, {\n    [key]: val\n  });\n}, {});\n```\n\n该特性的目的在于为对象添加一个新的静态方法 `Object.fromEntries`，用于将符合键值对的列表（例如 Map、数组等）转换为一个对象。上一块的代码中的转换逻辑，现在我们只需要一行代码即可搞定。\n\n```javascript\nconst map = new Map().set(\"foo\", true).set(\"bar\", false);\nlet obj = Object.fromEntries(map);\n```\n\n## 更加友好的 JSON.stringify\n\nES10 之前，当你使用 `JSON.stringify()` 处理无法用 UTF-8 编码表示的字符时（U+D800 至 U+DFFF），返回的结果会是一个乱码 Unicode 字符“�”。该特性提出用`JSON.stringify()`来安全的表示这些不正常的UTF-8字符。\n\n```javascript\nlet r;\nr = JSON.stringify(\"❤\"); //正常的UTF-8字符原样输出\nconsole.log(r); //>> \"❤\"\n \nr = JSON.stringify('\\u2764'); //正常的UTF-8字符编码，输出解码之后的模样\nconsole.log(r); //>> \"❤\"\n\nr = JSON.stringify(\"\\uDF06\\uD834\"); //不正常的UTF-8字符编码，则以unicode形式输出\nconsole.log(r); //>> \"\\udf06\\ud834\"\n\nr = JSON.stringify(\"\\uDEAD\"); //不正常的UTF-8字符编码，则以unicode形式输出\nconsole.log(r); //>> \"\\udead\"\n```\n\n## String.prototype.{trimStart,trimEnd}\n\n新增了String的`trimStart()`方法和`trimEnd()`方法，这两个方法很好理解，分别去除字符串首、尾的空白字符，就不举例占篇幅了。\n\n## Array.prototype.{flat,flatMap}\n\n这个特性新创造了两个方法，其中：\n\n* `Array.prototype.flat` 数组的所有项会以指定的维度降维（扁平化），然后组成新数组返回；\n* `Array.prototype.flatMap` 首先会执行一次`map()`方法，然后再通过类似`flat()`方法**扁平化**数组。它等同于执行完 `map()` 后再执行一次 `flat()` 方法，所以当你执行 `map()` 返回的结果如果是个数组，然后又要将其扁平化时，这个方法会显得方便。\n\n来看几个例子解释一下，首先 `flat()` 方法支持多维数组的扁平化，其中`Infinity`可以将多维数组压扁成一维数组。\n\n```javascript\nlet r;\nr = [\"1\", [\"8\", [\"9\", [\"1\"]]]].flat();//4维数组，默认降维1，变成3维数组\nconsole.log(r); //>> [ '1', '8', [ '9', ['1'] ] ]\n\nr = [\"1\", [\"8\", [\"9\", [\"1\"]]]].flat(2); //4维数组，降维2，变成2维数组\nconsole.log(r); //>> [ '1', '8', '9', ['1'] ]\n\nr = [\"1\", [\"8\", [\"9\", [\"1\"]]]].flat(Infinity);//4维数组，最多变成1维数组\nconsole.log(r); //>> [ '1', '8', '9', '1' ]\n```\n\n接着来看看`flatMap()`\n\n```javascript\nlet r;\nr = [\"I love\", \"coffe 1891\"].map(item => item.split(\" \"));\nconsole.log(r); //>> [ [ 'I', 'love' ], [ 'coffe', '1891' ] ]\n\nr = [\"I love\", \"coffe 1891\"].flatMap(item => item.split(\" \"));\nconsole.log(r); //>>[ 'I', 'love', 'coffe', '1891' ]\n```\n\n# ES 2020 \\(ES11\\) 新特性\n\n因为太“新”，现在若想使用ES11新特性，则需要安装babel插件\n\n```javascript\nplugins: [\n    \"@babel/plugin-proposal-nullish-coalescing-operator\",\n    \"@babel/plugin-proposal-optional-chaining\",\n    \"@babel/plugin-proposal-class-properties\",\n    \"@babel/plugin-proposal-private-methods\",\n    \"@babel/plugin-syntax-bigint\"\n]\n```\n\n| 新特性 | 中文说明 |\n| :--- | :--- |\n| Optional Chaining | 可选链操作符 |\n| Nullish coalescing Operator | 空位合并操作符 |\n| `String.prototype.matchAll` |  |\n| `import()` | import\\(\\)函数 |\n| `Promise.allSettled` |  |\n| Bigint |  |\n| globalThis | 全局this |\n\n## Optional Chaining\n\n**可选链操作符** `?` 可让我们在查询具有多个层级的对象时，不再需要进行冗余的各种前置校验。\n\n以前要读取一个对象的属性值，需要写一些防御性的前置校验代码，比如：\n\n```javascript\nlet second = obj && obj.first && obj.first.second;\n```\n\n在访问 obj.first.second 之前，要先确认 obj 和 obj.first 的值非 null\\(且不是 undefined\\)。有了可选链式操作符，则可以大量简化类似繁琐的前置校验操作，而且更安全：\n\n```javascript\nlet second = obj?.first?.second;\n```\n\n如果 `obj` 或`obj.first`是`null`/`undefined`，表达式将会直接返回`undefined`。\n\n## Nullish coalescing Operator\\(空值处理\\)\n\n以前对于如下的情况：\n\n```javascript\nlet v = a || \"some value\";\n\nlet z = a ? a : \"some value\";\n```\n\n如果 a 的值是 `0` 、 空字符串`''` 、`false`等可能有意义的值，但是在上面的表达式中被认为是假值，因此v 和 z 也会被赋值为 `some value`。也即：\n\n```javascript\nlet a = 0; // 0、''、false可能是有意义的\nlet v = a || \"some value\";\nconsole.log(v); //>> some value\n```\n\n为解决这种问题，诞生了`??` ，如果表达式在`??`的左侧值为`undefined`或`null`，就返回右侧默认的值。\n\n```javascript\nlet a = 0; \nlet v = a ?? \"some value\";\nconsole.log(v); //>> 0\n\nlet b = null; \nlet z = b ?? \"some value\";\nconsole.log(z); //>> some value\n```\n\n## String.prototype.matchAll\n\n`matchAll()` 方法返回一个包含所有匹配正则表达式及分组捕获结果的迭代器（iterator）。 在 `matchAll` 出现之前，通过在循环中调用`Regexp.exec`来获取所有匹配项信息（`Regexp`需使用`/g`标志）：\n\n```javascript\nconst regexp = RegExp('foo*','g');\nconst str = 'coffe football, foosball';\n\nwhile ((matches = regexp.exec(str)) !== null) {\n  console.log(`找到 ${matches[0]}，下一轮循环从位置 ${regexp.lastIndex} 开始`);\n  //>> 找到 foo，下一轮循环从位置 9 开始\n  //>> 找到 foo，下一轮循环从位置 19 开始\n}\n```\n\n如果使用`matchAll` ，就可以不必使用`while`循环加`exec`方式（且正则表达式需使用`/g`标志）。使用`matchAll` 会得到一个迭代器的返回值，配合 `for...of`，`array spread`，`Array.from()` 可以更方便实现功能。\n\n```javascript\nconst regexp = RegExp('foo*','g'); \nconst str = 'coffe football, foosball';\nlet matches = str.matchAll(regexp);\n\nfor (const match of matches) {\n  console.log(match);\n}\n//>> [ \"foo\" ]\n//>> [ \"foo\" ]\n\n//注意：\n//matches的迭代器在for..of之后已经被消耗掉了，\n//需要再次调用matchAll创建一个新的迭代器\nmatches = str.matchAll(regexp);\n\nlet arr = Array.from(matches, m => m[0]);\nconsole.log(arr);\n//>> [ \"foo\", \"foo\" ]\n```\n\n## import\\(\\)函数\n\n这个特性为JavaScript添加了一个类函数（function-like）的`import()`功能，以便可以像函数传参那样传入参数实现**动态**（没错，`import`是静态引用的）引用模块（module）。下面有个单页应用简单示例，演示了用`import()`开启懒加载。\n\n```markup\n<!DOCTYPE html>\n<nav>\n  <a href=\"books.html\" data-entry-module=\"books\">书籍</a>\n  <a href=\"movies.html\" data-entry-module=\"movies\">电影</a>\n  <a href=\"video-games.html\" data-entry-module=\"video-games\">电视游戏</a>\n</nav>\n\n<main>内容将会加载到这里！</main>\n\n<script>\n  const main = document.querySelector(\"main\");\n  for (const link of document.querySelectorAll(\"nav > a\")) {\n    link.addEventListener(\"click\", e => {\n      e.preventDefault();\n\n      import(`./section-modules/${link.dataset.entryModule}.js`)//动态引用\n        .then(module => {//加载模块成功以后，该模块会当作then方法的参数\n          module.loadPageInto(main);\n        })\n        .catch(err => {//捕捉异常\n          main.textContent = err.message;\n        });\n    });\n  }\n</script>\n```\n\n请注意`import()`和`import`的区别：\n\n* import\\(\\) 可以用在script脚本区，不止是模块内；\n* 如果在模块内使用import\\(\\)，它可以在任何地方任何级别执行，而不是被提升到顶级（优先执行）；\n* import\\(\\) 是运行时执行，也即什么时候运行到这句，就会加载参数指定的模块；参数也可以是动态可变的，不止是静态参数；\n* import\\(\\) 不建立可静态分析的依赖关系（静态分析的情况下可以做很多优化），但是，在一些比较简单的情况下，比如`import（“/foo.js”）`中，实现仍然可以执行静态分析优化。\n\n如果模块采用`default`的形式对外暴露接口，则可用`default`属性直接获得。\n\n```javascript\nimport('./module.js')\n.then(module => {\n  console.log(module.default);//直接通过default属性获得模块暴露的接口\n});\n```\n\n## Promise.allSettled\n\n为什么要有`Promise.allSettled()`？\n\n举例说明，比如各位用户在页面上面同时填了3个独立的表单，这三个表单分三个接口提交到后端，三个接口独立，没有顺序依赖，这个时候我们需要等到请求全部完成后给与用户提示表单提交的情况。\n\n在多个`promise`同时进行时咱们很快会想到使用`Promise.all`来进行包装，但是由于`Promise.all`的一票否决的特性，三个提交中若前面任意一个提交失败，则后面的表单也不会进行提交了，这就与咱们需求不符合。\n\n`Promise.allSettled`跟`Promise.all`类似，其参数接受一个`Promise`的数组，返回一个新的`Promise`，唯一的不同在于，其没有一票否决的特性，也就是说当`Promise`全部处理完成后我们可以拿到每个`Promise`的状态，而不管其是否处理成功。\n\n```javascript\nPromise.allSettled([Promise.resolve(\"coffe\"), Promise.reject(\"1891\")]).then(\n  arr => {\n    console.log(arr); //>> [ { status: \"fulfilled\", value: \"coffe\"},\n                      //>>   { status: \"rejected\", reason: \"1891\" } ]\n  }\n);\n```\n\n## Bigint\n\nJavasSript 在数学计算领域很糟糕的原因之一是它只能安全的表示`-(2^53-1)`至 `2^53-1` 范的值，即`Number.MIN_SAFE_INTEGER` 至`Number.MAX_SAFE_INTEGER`，超出这个范围的整数计算或者表示会丢失精度。\n\n```javascript\nvar num = Number.MAX_SAFE_INTEGER;  // >> 9007199254740991\n\nnum = num + 1; // >> 9007199254740992\n\n// 再次加 +1 后无法正常运算\nnum = num + 1; // >> 9007199254740992\n\n// 两个不同的值，却返回了true\n9007199254740992 === 9007199254740993  // >> true\n```\n\n于是 BigInt 诞生了，**它是JavaScript的第7个原始类型**，可安全地进行大数整型计算。 你可以在BigInt上使用与普通数字相同的运算符，例如 +, -, /, \\*, %等等。\n\n创建 BigInt 类型的值也非常简单，只需要在数字后面加上 `n` 即可。例如，123 变为 123n。也可以使用全局方法 BigInt\\(value\\) 转化，入参 value 为数字或数字字符串。\n\n```javascript\nconst aNumber = 1891;\nconst aBigInt = BigInt(aNumber);\naBigInt === 1891n // true\ntypeof aBigInt === 'bigint' // true\ntypeof 1891 // \"number\"\ntypeof 1891n // \"bigint\"\n```\n\n只要在数字末尾加上 n，就可以正确计算大数：\n\n```javascript\n1234567890123456789n * 123n;\n// -> 151851850485185185047n\n```\n\n最后要注意，不能将 BigInt与Number混合使用。比较Number和 BigInt是可以的，但是不能把它们相加。\n\n```javascript\n1n < 2 // true\n\n1n + 2 // Uncaught TypeError: Cannot mix BigInt and other types, use explicit conversions\n```\n\n## globalThis\n\nglobalThis 是一个全新的标准方法用来获取全局 this 。之前开发者会通过如下的一些方法获取：\n\n* 全局变量 window：是一个经典的获取全局对象的方法。但是它在 Node.js 和 Web Workers 中并不能使用\n* 全局变量 self：通常只在 Web Workers 和浏览器中生效。但是它不支持 Node.js。一些人会通过判断 self 是否存在识别代码是否运行在 Web Workers 和浏览器中\n* 全局变量 global：只在 Node.js 中生效\n\n过去获取全局对象，可通过一个全局函数：\n\n```javascript\n// ES10之前的解决方案\nconst getGlobal = function(){\n  if(typeof self !== 'undefined') return self\n  if(typeof window !== 'undefined') return window\n  if(typeof global !== 'undefined') return global\n  throw new Error('unable to locate global object')\n}\n\n// ES10内置\nglobalThis.Array(0,1,2) // [0,1,2]\n\n// 定义一个全局对象v = { value:true } ,ES10用如下方式定义\nglobalThis.v = { value:true }\n```\n\n而 **globalThis 目的就是提供一种标准化方式访问全局对象**，有了 globalThis 后，你可以在任意上下文，任意时刻都能获取到全局对象。如果您在浏览器上，globalThis将为window，如果您在Node上，globalThis则将为global。因此，不再需要考虑不同的环境问题。\n\n```javascript\n// worker\nglobalThis === self\n// node\nglobalThis === global\n// browser\nglobalThis === window\n```\n# ES 2021 \\(ES12\\) 等2021年发布\n\n| 新特性 | 中文说明 |\n| :--- | :--- |\n| String.prototype.replaceAll | 替换所有符合的字符串 |\n| Promise.any | 返回Promise列表中第一个resolve的结果状态 |\n| WeakRefs |  |\n| 逻辑运算符和赋值表达式 |  |\n| 数字分隔符 |  |\n\n## replaceAll\n\n看到replaceAll这个词，相比很容易联想到replace。在JavaScript中，replace方法只能是替换字符串中匹配到的第一个实例字符，而不能进行全局多项匹配替换，唯一的办法是通过正则表达式进行相关规则匹配替换，而replaceAll则是返回一个全新的字符串，所有符合匹配规则的字符都将被替换掉，替换规则可以是字符串或者正则表达式。\n\n```javascript\nlet string = 'I like javaScript,I like css'\n\n//使用replace\nlet replaceStr = string.replace('like','love')\nconsole.log(replaceStr)  // 'I love javaScript,I like css'\n\n//replace使用正则匹配所有\nconsole.log(string.replace(/like/g,'love')) // 'I love javaScript,I love css'\n\n//使用replaceAll\nlet replaceAllStr = string.replaceAll('like','love')\nconsole.log(replaceAllStr) // 'I love javaScript,I love css'\n\n```\n\n## Promise.any\n\n当Promise列表中的任意一个promise成功resolve则返回第一个resolve的结果状态。\n\n```javascript\n\nPromise.any([\n  new Promise((resolve, reject) => setTimeout(reject, 500, '哎呀，我被拒绝了')),\n  new Promise((resolve, reject) => setTimeout(resolve, 1000, '哎呀，她接受我了')),\n  new Promise((resolve, reject) => setTimeout(resolve, 2000, '哎呀，她也接受我了')),\n])\n.then(value => console.log(`输出结果: ${value}`))\n.catch (err => console.log(err))\n\n//输出结果:哎呀，她接受我了\n\n```\n\n如果所有的promise均reject，则抛出异常表示所有请求失败。\n\n```javascript\nPromise.any([\n  Promise.reject('Error 1'),\n  Promise.reject('Error 2'),\n  Promise.reject('Error 3')\n])\n.then(value => console.log(`请求结果: ${value}`))\n.catch (err => console.log(err))\n\n//输出\nAggregateError: All promises were rejected\n\n```\n\n## WeakRefs\n使用WeakRefs的Class类创建对对象的弱引用(对对象的弱引用是指当该对象应该被GC回收时不会阻止GC的回收行为)\n\n当我们通过（const、let、var）创建一个变量时，垃圾收集器GC将永远不会从内存中删除该变量，只要它的引用仍然存在可访问。WeakRef对象包含对对象的弱引用。对对象的弱引用是不会阻止垃圾收集器GC恢复该对象的引用，则GC可以在任何时候删除它。\n\nWeakRefs在很多情况下都很有用，比如使用Map对象来实现具有很多需要大量内存的键值缓存，在这种情况下最方便的就是尽快释放键值对占用的内存。\n\n目前，可以通过WeakMap()或者WeakSet()来使用WeakRefs。\n\n\n## 数字分隔符\n数字分隔符，可以在数字之间创建可视化分隔符，通过_下划线来分割数字，使数字更具可读性。\n\n```javascript\nconst money = 1_000_000_000\n//等价于\nconst money = 1000000000\n\nconst totalFee = 1000.12_34\n//等价于\nconst totalFee = 1000.1234\n\n```\n\n该新特性同样支持在八进制数中使用\n\n```javascript\n\nconst number = 0o123_456\n//等价于\nconst number = 0o123456\n\n\n```\n\n# 本篇结语\n\n很显然ECMAScript接下来会持续不断地更新，按TC39的计划是每年都会发一个新版本。虽然节奏很快，但是我们完全没必要担心跟不上节奏。除了ES6这个史无前例的版本带来了超大量的新特性外，之后每年发的版本都仅仅带有少量的增量更新，你只需要花45分钟就能搞明白这一年更新的特性。保持一颗好奇的心，你会不断进步，变得更强！","tags":["es"],"categories":["ES语法"]},{"title":"spread和rest操作符","slug":"spread和rest操作符","url":"/2020/11/09/spread-he-rest-cao-zuo-fu/","content":"\n\n# spread和rest的区别\n\nspread和rest运算符都是`...`+`变量/参数`的形式。是spread还是rest，要根据上下文情境来判断。\n\n## 1.spread\n\n当被用于迭代器中时，它是 spread 操作符：\n\n```javascript\nconsole.log(1, ...[2, 3, 4], 5)\n// 1 2 3 4 5\nconsole.log([1, ...[2, 3, 4], 5])\n//[1,2,3,4,5]\n```\n\n```javascript\nfunction add(x, y) {\n  return x + y;\n}\n\nconst numbers = [4, 38];\nadd(...numbers) // 42\n```\n\nspread主要形式是`...[Array]`，表示对数组的展开。\n\n## 2.rest\n\n当被用于定义函数的参数时，是 rest 操作符：\n\n```javascript\nfunction push(...items) {\n    console.log(items);\n}\nlet a = 4;\npush(a, 1, 2, 3)\n//[4,1,2,3]\n```\n\nrest主要是将函数的多个参数转化成数组，**而且只能放在函数参数的最后一个位置**，否则，比如`（array,...items,other）`会报错。 \n\n而rest的出现，让已经不被推荐使用的`arguments`彻底寿终正寝了。\n\n```javascript\n(function fn(...args) {\n   console.log(args.join());\n   console.log([...arguments].join());//spread形式的用法\n})([1,2,3]);\n//>> 1,2,3\n//>> 1,2,3\n```\n\n# 用法示例\n\n## 1.添加属性\n\n克隆一个对象，同时向\\(浅\\)拷贝对象添加附加属性。  \n在这个示例中，user 被\\(浅\\)拷贝，password 属性被添加到 userWithPass 中。\n\n```javascript\nconst user = { id: 100, name: 'Howard Moon'}\nconst userWithPass = { ...user, password: 'Password!' }\n\nuser //>> { id: 100, name: 'Howard Moon' }\nuserWithPass //>> { id: 100, name: 'Howard Moon', password: 'Password!' }\n```\n\n## 2.对象合并\n\n将两个对象合并到一个新对象中。\n\n```javascript\nconst part1 = { id: 100, name: 'Howard Moon' }\nconst part2 = { id: 100, password: 'Password!' }\n\nconst user1 = { ...part1, ...part2 }\n//>> { id: 100, name: 'Howard Moon', password: 'Password!' }\n```\n\n对象也可以使用以下语法合并：\n\n```javascript\nconst partial = { id: 100, name: 'Howard Moon' }\nconst user = { ...partial, id: 100, password: 'Password!' }\n\nuser //>> { id: 100, name: 'Howard Moon', password: 'Password!' }\n```\n\n## 3.排除对象属性\n\n可以结合使用 rest 运算符删除属性。 在下面这个例子里，password 被删除 ，其余的属性作为 rest 返回。\n\n```javascript\nconst noPassword = ({ password, ...rest }) => rest\nconst user = {\n  id: 100,\n  name: 'coffe1891',\n  password: 'Password!'\n}\n\nnoPassword(user) //>> { id: 100, name: 'coffe1891' }\n```\n\n## 4.动态排除属性\n\n函数接受一个 prop 作为参数。使用计算对象属性名称，可以从克隆中动态地删除属性。\n\n```javascript\nconst user1 = {\n  id: 100,\n  name: 'coffe1891',\n  password: 'Password!'\n}\nconst removeProperty = prop => ({ [prop]: _, ...rest }) => rest\n//                     ----       ------\n//                          \\   /\n//                dynamic destructuring\n\nconst removePassword = removeProperty('password')\nconst removeId = removeProperty('id')\n\nremovePassword(user1) //>> { id: 100, name: 'coffe1891' }\nremoveId(user1) //>> { name: 'coffe1891', password: 'Password!' }\n```\n\n## 5.对属性进行排序\n\n有时性质并不按照我们需要的顺序排列。 使用一些技巧，我们可以将属性推到列表的顶部，或者将它们移到底部。若要将 id 移动到第一个位置，在扩展对象之前将 `id: undefined` 添加到新的 Object 最前面。\n\n```javascript\nconst user3 = {\n  password: 'Password!',\n  name: 'Naboo',\n  id: 300\n}\n\nconst organize = object => ({ id: undefined, ...object })\n//                            -------------\n//                          /\n//  move id to the first property\n\norganize(user3)\n//>> { id: 300, password: 'Password!', name: 'Naboo' }\n```\n\n若要将 password 移到最后一个属性，请从对象中解构 password。然后在使用 Rest 操作符后重新设置 password 属性。\n\n```javascript\nconst user3 = {\n  password: 'Password!',\n  name: 'Naboo',\n  id: 300\n}\n\nconst organize = ({ password, ...object }) =>\n  ({ ...object, password })\n//              --------\n//             /\n// move password to last property\n\norganize(user3)\n//>> { name: 'Naboo', id: 300, password: 'Password!' }\n```\n\n## 6.默认属性\n\n默认属性是仅当它们不包含在原始对象中时才设置的值。  \n在本例中，user2 不包含 quotes 属性。 setdefaults 函数确保所有对象都设置了 quotes 属性，否则它将被设置为`[]`。  \n当调用 setDefaults \\(user2\\)时，返回值将包含 quotes 属性: `[]`。  \n在调用 setDefaults \\(user4\\)时，因为 user4 已经有了 quotes 属性，所以不会修改该属性。\n\n```javascript\nconst user2 = {\n  id: 200,\n  name: 'Vince Noir'\n}\n\nconst user4 = {\n  id: 400,\n  name: 'Bollo',\n  quotes: [\"I've got a bad feeling about this...\"]\n}\n\nconst setDefaults = ({ quotes = [], ...object}) =>\n  ({ ...object, quotes })\n\nsetDefaults(user2)\n//>> { id: 200, name: 'Vince Noir', quotes: [] }\n\nsetDefaults(user4)\n//>> {\n//>>   id: 400,\n//>>   name: 'Bollo',\n//>>   quotes: [\"I've got a bad feeling about this...\"]\n//>> }\n```\n\n如果你希望默认值先出现而不是后出现，也可以这样写：\n\n```javascript\nconst setDefaults = ({ ...object}) => ({ quotes: [], ...object })\n```\n\n## 7.属性重命名\n\n通过结合上面的技术，可以创建一个函数来重命名属性。假设有一些大写 ID 的对象属性名应该是小写的 id。 首先从对象解构 ID 然后在对象 Spread 时将其作为 id 添加回去。\n\n```javascript\nconst renamed = ({ ID, ...object }) => ({ id: ID, ...object })\n\nconst user = {\n  ID: 500,\n  name: \"Bob Fossil\"\n}\n\nrenamed(user) //>> { id: 500, name: 'Bob Fossil' }\n```\n\n## 8.添加条件属性\n\n在这个例子中，只有当 password 是真实的时候才会添加 password。\n\n```javascript\nconst user = { id: 100, name: 'Howard Moon' }\nconst password = 'Password!'\nconst userWithPassword = {\n  ...user,\n  id: 100,\n  ...(password && { password })\n}\n\nuserWithPassword //>> { id: 100, name: 'Howard Moon', password: 'Password!' }\n```\n\n","tags":["ES语法"],"categories":["ES语法"]},{"title":"TypeScript在vue项目中的应用","slug":"ts在vue项目中的应用","url":"/2020/10/30/ts-zai-vue-xiang-mu-zhong-de-ying-yong/","content":"\n# 1 引言\n\nTypeScript 是一种由微软开发的自由和开源的编程语言。它是 JavaScript 的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程。\n\nTypeScript 优势：\n\n- 静态类型检查与代码提示\n- 适用大型项目开发，如代码重构等\n- 更好的协作\n- 更强的生产力\n\n# 2 ts语法知识\n\n## 2.1类型系统\n![类型注解](https://7.dusays.com/2020/11/02/056c4d4f841cf.png)\n\n\n## 2.2类型保护\n> 类型保护是可执行运行时检查的一种表达式，用于确保该类型在一定的范围内。\n\n1. as 操作符（类型断言）\n当你比 ts 更确定其数据类型，你能使用 as 语法确定其类型，但需要遵守类型兼容转换。 另外一种写法：<typeName>varName，但不建议使用\n\n```\nfunction getDynamicValue(): number | string | undefined {\n  ...\n}\n\nconst v = getDynamicValue(); // v:number|string|undefined，联合类型变量只允许访问所有类型共有的属性\n\n// 确定返回 string\n(v as string).trim();\n```\n\n2. typeof 操作符\n\n```\nfunction isNumber(val: any): val is number {\n  return typeof val === 'number';\n}\n\nconst a: any = 1;\n\nif (isNumber(a)) {\n  // a:number\n}\n```\n\n3. instanceof 操作符\n\n```\nclass Base {\n  ...\n}\n\nclass A extends Base {\n  ...\n}\n\nconst inst: Base = new A();\n\nif (inst instanceof A) {\n  // inst:A\n}\n```\n\n4. 函数或变量后面添加 !\n\n当要去掉联合类型的可空类型（null | undefined）,可以使用 js if 语句或短路运算符实现类型保护，也可以使用 Typescript 2.0+ !语法\n\n```\nconst x: string | null = getDynamicValue();\n\n// if判断\nif (x) {\n  // x:string\n}\n// 短路运算符\nfunction f(sn: string | null) {\n  return sn || '';\n}\n// !语法\nx!.trim();\n// or\nconst r = [1, 2, 3, 4].find(x => x === 3)!; // r:number\n\n```\n# 3 开发环境准备\n\n## 3.1 插件安装\n\n### 3.1.1 Webpack 转译 Typescript 现有方案\n#### 1.ts-loader + babel-loader + fork-ts-checker-webpack-plugin\n\n修改 webpack.config.js 的配置：\n\n\n```\n{ \n\ttest: /\\.ts?$/, \n\tloader: \"ts-loader\",\n\toptions: {\n\t\t// .vue文件必须加\n\t\tappendTsSuffixTo: [/\\.vue$/]\n\t},\n\texclude:/node_modules/\n}\n\n```\n\n每次重建时，类型脚本的语义检查器必须检查所有文件,随着项目变得越来越大，编译时间线性增加。这时我们使用 fork-ts-checker-webpack-plugin 另外开一个线程来进行类型检查，安装依赖：\n\n\n```\nnpm install -D fork-ts-checker-webpack-plugin\n//使用：\nconst ForkTsCheckerWebpackPlugin = require('fork-ts-checker-webpack-plugin');\nplugins:[\n\tnew ForkTsCheckerWebpackPlugin()\n]\n\n```\n\n\n- 这种方案，当 webpack 编译的时候，ts-loader 会调用 typescript（所以本地项目需要安装 typescript），然后 typescript 运行的时候会去读取本地的 tsconfig.json 文件。\n- 默认情况下，ts-loader 会进行 转译 和 类型检查，每当文件改动时，都会重新去 转译 和 类型检查，当文件很多的时候，就会特别慢，影响开发速度。所以需要使用 fork-ts-checker-webpack-plugin ，开辟一个单独的线程去执行类型检查的任务，这样就不会影响 webpack 重新编译的速度。\n- fork-ts-checker-webpack-plugin  这个插件要求最低 Node.js 6.11.5，webpack 4，TypeScript 2.1 和可选的 ESLint 6（其本身要求最低 Node.js 8.10.0）。\n\n\n#### 2. babel-loader + @babel/preset-typescript\n\n修改webpack.config.js\n\n\n```\nrules: [\n        {\n          test:/\\.(tsx?|jsx?)$/,\n          // 默认会调用 @babel/core \n          use:'babel-loader'\n        }\n]\n```\n\n.babelrc\n\n```\n{\n    \"presets\": [\n        \"@babel/env\"\n        \"@vue/babel-preset-jsx\",\n        \"@babel/preset-typescript\"\n    ]\n}\n```\n\n\n- 这种方案，当 webpack 编译的时候，babel-loader 会读取 .babelrc 里的配置，不会调用 typescript（所以本地项目无需安装 typescript），不会去检查类型\n-  需要配置tsconfig.json的，因为需要在开发代码时，让 idea 提示错误信息\n\n\n \n## 3.2 ts项目基本构成\n一个vue+ts项目的目录结构（[typeScript-vue-starter](https://github.com/leeycode/typeScript-vue-starter/)）：\n\n```\n├── /@types/                     # 全局类型声明\n├── /build/                      # webpack配置文件\n├── /src/                        # 源码目录\n│ ├── /assets/                   # 静态资源目录\n│ ├── /components/               # 公共组件目录\n│ ├── /constants/                # 项目constants目录\n│ │ ├── _const.less              # less常量\n│ ├── /pages/                    # UI组件目录\n│ ├── /services/                 # 请求服务目录\n│ ├── /router/                   # 路由目录\n│ ├── /store/                    # 存放store文件目录\n│ ├── /style/                    # 全局样式\n│ ├── /utils/                    # utils目录\n│ │ ├── request.ts               # 基于fetch封装的API请求工具\n│ │ ├── global.ts                # 公共方法库\n│ └── main.ts                    # 项目入口\n|——tsconfig.json                 # ts配置\n|——...\n```\n\n## 3.3 tsconfig.json\n在项目根目录下，这个json文件规定了ts的编译选项，相见的编译选项配置：\n\n```\n{\n  \"compilerOptions\": {\n    \"baseUrl\": \".\",                             // 用于解析非相对模块名称的基目录\n    \"outDir\": \"build/dist\",                     // 指定输出目录\n    \"module\": \"esnext\",                         // 指定使用模块: 'commonjs', 'amd', 'system', 'umd' or 'es2015'\n    \"target\": \"es5\",                            // 指定 ECMAScript 目标版本:\n    \"lib\": [\"dom\", \"esnext\"],                   // 指定要包含在编译中的库文件\n    \"sourceMap\": true,                          // 生成相应的 '.map' 文件\n    \"allowJs\": true,                            // 允许编译 javascript 文件\n    \"jsx\": \"preserve\",                          // 指定 jsx 代码的生成: 'preserve', 'react-native'等\n    \"moduleResolution\": \"node\",                 // 选择模块解析策略： 'node' (Node.js) or 'classic'\n    \"strict\": true                              // 启用所有严格类型检查选项\n    ...\n      \n  },\n  \"include\": [\"src/**/*\", \"@types/**/*\"],       // 编译包含的文件   \n  \"exclude\": [                                  // 排除的文件                \n    \"node_modules\",\n    \"build\",\n    \"scripts\",\n    \"acceptance-tests\",\n    \"webpack\",\n    \"jest\",\n    \"src/setupTests.ts\",\n    \"config\"\n  ]\n}\n\n```\n\n## 3.4 声明文件\n\n### @types\n\n安装第三方库之前，我们可以[搜索DefinitelyTyped](https://microsoft.github.io/TypeSearch//)，查看是否有第三方在维护类型声明。通过@types安装，就能在项目中使用它的类型声明。\n\n\n```\n- Partial :把 interface 所有属性变成可选\n// node_modules/typescript/lib/lib.es5.d.ts,安装ts的时候生成\ntype Partial<T> = {\n    [P in keyof T]?: T[P];\n};\n\nchangeFilter: (filter: Partial<IRequsetParams>) => void;\n\n- Event\n// node_modules/@types/react/index.d.ts,通过@types安装react的时候生成\n  handleClick = (e: React.MouseEvent<HTMLDivElement, MouseEvent>) => {\n    e.stopPropagation();\n  };\n\n- RouteComponentProps:提供了 location、history 的类型定义\n// node_modules/@types/react-router/index.d.ts\nexport interface ILoginProps extends RouteComponentProps {\n  login: (values: IUser, history: H.History) => void;\n}\n```\n\n### 自定义声明文件\n\n扩展名.d.ts 结尾就是项目中的声明文件。在上面的项目中，我们创建了一个名为@types的文件夹，用来维护项目中需要的变量声明。\n1. 全局变量声明\n```\n// config\ndeclare const config: {\n  version: string;\n  systemName: string;\n  debug: boolean;\n  ...\n  }\n// 约束后台返回的数据 \ndeclare interface IResponseBody<T> {\n  data: T;\n  code: number;\n  total: number;\n}\n...\n```\n2. 非js资源\n\n```\ndeclare module '*.svg';\ndeclare module '*.png';\ndeclare module '*.jpg';\n\ndeclare module '*.module.css';\ndeclare module '*.module.scss' \n```\n\n# 4 组件编写的几种方法\n## 4.1 Vue.extend()\n\n> Vue.extend():使用基础 Vue 构造器，创建一个“子类”。 这种方式最接近 Vue 的单文件组件的写法，如果一个完善 Vue 项目从 JS 改成 TS，用这种方法很快，只要加上 lang=ts和一些必要的变量类型就好了，然后用Vue.extend()包裹就好。\n\nmain.js 改为 main.ts 内容改成：\n\n```\nimport Vue from \"vue\";\nimport App from \"./App.vue\";\n\nnew Vue({\n    el:\"#app\",\n    render:h=>h(App)\n});\n\n```\n组件写法：\n```\n<template>\n    <h1>{{name}}</h1>\n</template>\n<script lang=\"ts\">\n//也执行tsx,也就是jsx语法\nimport Vue from \"vue\";\n\nexport default Vue.extend({\n    data(){\n        return {\n            name:'liwu'\n        }\n    }\n})\n</script>\n<style scoped>\nh1{\n    color: rgb(55, 142, 230);\n}\n</style>\n\n```\n## 4.2 vue-class-component\n> 通常和vue-property-decorator一起搭配使用，，vue-property-decorator是在vue-class-component上扩展来的，并且提供了很多修饰器比如 @Prop和@Watch等等，使用这个可以编写类式组件。\n\n\n1.组件写法：\n\n```\n<template>\n    <h1>{{name}}</h1>\n</template>\n<script lang=\"ts\">\n\nimport Vue from \"vue\";\nimport Component from 'vue-class-component';\n\n// @Component 装饰器使你的类成为Vue组件\n@Component\n\nexport default class App extends Vue {\n    private name:string = 'liwu';\n}\n\n</script>\n<style scoped>\nh1{\n    color: rgb(55, 142, 230);\n}\n</style>\n```\n\n修改tsconfig.js，支持装饰器语法\n\n```\n\"experimentalDecorators\": true,\n```\n\n## 4.3 jsx\n\n> JSX is an XML-like syntax extension to ECMAScript without any defined semantics. It's NOT intended to be implemented by engines or browsers.\n\n1.jsx语法简介（写react的同学跳过）\n- 严格的标签闭合\n- 组件名要大写，否则解析成html标签\n- 变量用{}\n\n```\nlet name = 'xxx';\n<div>{ name }</div>\n```\n- 遍历用map\n\n```\nlet list = ['李一','李二','李三'];\n\n<div>\n    {list.map((item, index) => {\n    return <p key={index}>this is {item}</p> \n    })} \n</div> \n```\n- 条件判断\n\n```\n<div className={styles.wrapper}>\n    {_.isEmpty(currRecord) ? null : (\n      <Graph\n        graph={{ nodes, edges }}\n        options={this.options}\n        events={this.events}\n      />\n    )}\n</div> \n```\n\n- 事件要用驼峰写法，传参要用bind\n\n```\n<div\n    className={styles.content}\n    onMouseEnter={this.showSwitch}\n    onMouseLeave={this.hideSwitch}\n    onClick={this.handleClick.bind(this,params)}\n>\n</div>\n```\n\n- 使用domPropsInnerHTML来替代v-html\n\n```\n<div\n    domPropsInnerHTML={this.htmlContent}\n>\n</div>\n```\n\n\n2.组件写法\n\n```\nimport { Vue, Component } from 'vue-property-decorator';\nimport { CreateElement } from 'vue';\n@Component\nexport default class JSX extends Vue {\n  private count: number = 0;\n  private showInfo() {\n    this.count++;\n  }\n\n  protected render(h: CreateElement) {\n    return <h2 onMouseenter={this.showInfo}>JSX Test{this.count}</h2>;\n  }\n}\n\n```\n\n# 5 class组件详细用法\n## 使用Data\n\n```\n@Component\nexport default class HelloWorld extends Vue {\n  private msg: string = \"welcome to my app\"\n  private list: Array<object> = [\n    {\n        name: 'Melody',\n        age: '20'\n    },\n    {\n        name: 'James',\n        age: '20'\n    }\n  ]\n}\n\n```\n与ts等效的js代码\n\n```\nexport default {\n  data() {\n    return {\n      msg: \"welcome to my app\",\n      list: [\n        {\n          name: 'Melody',\n          age: '20'\n        },\n        {\n          name: 'James',\n          age: '20'\n        }\n      ]\n    }\n}\n\n```\n\n## 使用props\n可以添加 required, default, type 为props指定验证要求，同样也可以使用 readonly 禁止操作props\n\n```\nimport { Component, Prop, Vue } from 'vue-property-decorator'\n@Component\nexport default class HelloWorld extends Vue {\n  @Prop() readonly msg!: string\n  @Prop({default: 'Joy Melody'}) readonly name: string\n  @Prop({required: true}) readonly age: number\n  @Prop({required: false, type: String, default: 'Developer'}) readonly job: string\n}\n\n```\n\n与ts等效的js代码如下\n\n```\nexport default {\n  props: {\n    msg,\n    name: {\n      default: 'Joy Melody'\n    },\n    age: {\n      required: true,\n    },\n    address: {\n      type: String\n    },\n    job: {\n      required: false,\n      type: string,\n      default: 'Developer'\n    }\n  }\n}\n\n\n```\n\n## Computed 属性\n\n```\nexport default class HelloWorld extends Vue {\n  get fullName(): string {\n    return this.first+ ' '+ this.last\n  }\n}\n```\n\n与ts等效的js代码如下\n\n\n```\nexport default {\n  fullName() {\n    return this.first + ' ' + this.last\n  }\n}\n\n```\n\n复杂点的涉及到setter和getter的 computed属性，在ts中写法如下：\n\n```\nexport default class HelloWorld extends Vue {\n  get fullName(): string {\n    return this.first+ ' '+ this.last\n  }\n  set fullName(newValue: string) {\n    let names = newValue.split(' ')\n    this.first = names[0]\n    this.last = names[names.length - 1]\n  }\n}\n\n```\n\n与ts等效的js写法如下\n\n\n```\nfullName: {\n  get: function () {\n    return this.first + ' ' + this.last\n  },\n  set: function (newValue) {\n    let names = newValue.split(' ')\n    this.first = names[0]\n    this.last = names[names.length - 1]\n  }\n}\n\n```\n\n## 使用Watch\n\n@Watch(path: string, options: WatchOptions = {}) \n\n- @Watch 装饰器接收两个参数：path: string 被侦听的属性名\noptions?: WatchOptions={} options可以包含两个属性\n\n- immediate?:boolean 侦听开始之后是否立即调用该回调函数\ndeep?:boolean 被侦听的对象的属性被改变时，是否调用该回调函数\n\n\n```\n@Watch('child')\nonChildChanged (val: string, oldVal: string) {\n    if (val !== oldVal) {\n      window.console.log(val)\n    }\n}\n\n```\n与ts等效的js代码如下\n\n\n```\nwatch: {\n    'child': {\n        handler: 'onChildChanged',\n        immediate: false,\n        deep: false \n    }\n},\nmethod: {\n    onChildChanged(val, oldVal) {\n        if (val !== oldVal) {\n          console.log(val)\n        }\n    }\n}\n\n\n```\n也可以写成: @Watch('child', { immediate: true, deep: true }), 等价于:\n\n\n```\nwatch: {\n    'child': {\n        handler: 'onChildChanged',\n        immediate: true,\n        deep: true \n    }\n},\nmethod: {\n    onChildChanged(val, oldVal) {\n        if (val !== oldVal) {\n          window.console.log(val)\n        }\n    }\n}\n\n\n```\n\n## Methods\n\n```\nexport default class HelloWorld extends Vue {\n  public clickMe(): void {\n    console.log('clicked')\n    console.log(this.addNum(4, 2))\n  }\n  public addNum(num1: number, num2: number): number {\n    return num1 + num2\n  }\n}\n\n```\n\n与ts等效的js代码如下\n\n\n```\nexport default {\n  methods: {\n    clickMe() {\n      console.log('clicked')\n      console.log(this.addNum(4, 2))\n    }\n    addNum(num1, num2) {\n      return num1 + num2\n    }\n  }\n}\n\n```\n\n## Emit\n\n子组件触发父组件的自定义事件并传递数据，在TypeScript中使用@Emit 装饰器\n\n```\nimport { Vue, Component, Emit } from 'vue-property-decorator'\n\n@Component\nexport default class YourComponent extends Vue {\n  count = 0\n\n  @Emit()\n  addToCount(n: number) {\n    this.count += n\n  }\n}\n\n```\n\n与ts等效的js代码如下\n\n\n```\nexport default {\n  data() {\n    return {\n      count: 0\n    }\n  },\n  methods: {\n    addToCount(n) {\n      this.count += n\n      this.$emit('add-to-count', n)\n    }\n  }\n}\n\n```\n\n## Mixins\n\n假设当前已经有一个mixins/ProjectMixin文件 如何在其他组件里面使用方式如下\n\n\n```\n<template>\n  <div class=\"project-detail\">\n    {{ projectDetail }}\n  </div>\n</template>\n<script lang=\"ts\">\nimport { Component, Vue, Mixins } from 'vue-property-decorator'\nimport ProjectMixin from '@/mixins/ProjectMixin'\n@Component\nexport default class Project extends Mixins(ProjectMixin) {\n  get projectDetail(): string {\n    return this.projName + ' ' + 'HS'\n  }\n}\n</script>\n\n```\n与ts等效的js代码如下\n\n\n```\n<template>\n  <div class=\"project-detail\">\n    {{ projectDetail }}\n  </div>\n</template>\n<script>\nimport ProjectMixin from '@/mixins/ProjectMixin'\nexport default {\n  mixins: [ ProjectMixin ],\n  computed: {\n    projectDetail() {\n      return this.projName + ' ' + 'HS'\n    }\n  }\n}\n</script>\n```\n\n多个混入的情况\n\n\n```\nimport { Component, Mixins } from 'vue-property-decorator'\n\nexport default class Test extends Mixins(Mixin1, Mixin2) {\n    test() {\n      this.methodFromMixin2()\n      console.log(this.valFromMixin1)\n    }\n}\n\n```\n\n## refs\n\nts无法识别vue中的$refs,需要手动指定其类型：\n\n```\n<template>\n  <loading ref=\"loading\"/>\n  <input type=\"text\" ref=\"inputRef\">\n</template>\n\n<script lang=\"ts\">\nimport { Component } from 'vue-property-decorator'\nimport Loading from \"@/components/Loading.vue\";\n\n@Component({\n  components: { Loading }\n})\n\nexport default class Project extends Vue {\n $refs!: {\n    loading: Loading;\n    inputRef: HTMLInputElement;\n  };\n  \n public mounted() {\n    this.$refs.loading.showLoading();\n    // (this.$refs.loading as Loading).showLoading();\n    this.$refs.inputRef.focus();\n  }\n}\n</script>\n```\n\n# 6 路由\n## 路由创建\n\n```\nimport Vue from 'vue';\nimport VueRouter, { RouteConfig } from 'vue-router';\nimport Home from '@/pages/home/Home.vue';\n\nVue.use(VueRouter);\n\nconst routes: Array<RouteConfig> = [\n  {\n    path: '/',\n    name: 'home',\n    component: Home\n  },\n  {\n    path: '/about',\n    name: 'about',\n    component: () => import(/* webpackChunkName: \"about\" */ '@/pages/about/About.vue')\n  }\n];\n\nconst router = new VueRouter({\n  routes\n});\n\nexport default router;\n\n```\n## 组件中监听路由\n\n```\n<script lang=\"ts\">\nimport { Component, Vue, Watch } from 'vue-property-decorator';\nimport { Route } from 'vue-router';\n\n@Component\nexport default class About extends Vue {\n  @Watch('$route', { immediate: true })\n  private changeRouter(route: Route) {\n    console.log('route', route);\n  }\n}\n\n```\n## 组件中使用路由勾子函数\nmain.ts中：\n\n```\nimport { Component } from 'vue-property-decorator';\n\nComponent.registerHooks([\n  'beforeRouteEnter',\n  'beforeRouteLeave',\n  'beforeRouteUpdate'\n]);\n\n```\n组件中：\n```\n<script lang=\"ts\">\nimport { Component, Vue, Watch } from 'vue-property-decorator';\nimport { Route } from 'vue-router';\n\n@Component\nexport default class About extends Vue {\n\n  private beforeRouteEnter(to: Route, from: Route, next: () => void): void {\n    console.log('beforeRouteEnter', to, from, next);\n    next(); \n  }\n\n  private beforeRouteUpdate(to: Route, from: Route, next: () => void): void {\n    console.log('beforeRouteUpdate'); // 暂时不生效，版本问题\n    next();\n  }\n\n  private beforeRouteLeave(to: Route, from: Route, next: () => void): void {\n    console.log('beforeRouteLeave');\n    next();\n  }\n}\n```\n\n\n# 7 数据请求\n\n对返回值和入参做类型约束：\n\n```\n// global.d.ts \ndeclare interface ResponseBody<T> {\n  data: T;\n  code: number;\n  total: number;\n}\ndeclare interface ResponseStatus {\n  loading: boolean;\n  error: boolean;\n}\ndeclare interface Response<T> extends ResponseStatus {\n  res: IResponseBody<T>;\n}\ndeclare interface ResponseNotPage<T> extends ResponseStatus {\n  data: T;\n}\ndeclare interface PageParams {\n  page: number;\n  pageSize: number;\n}\ndeclare interface RequsetParams extends PageParams {\n  search: string;\n}\n\n\n// src/service/demo.ts\nexport const getInfo = (id: number) =>\n  request<ResponseBody<{ id: number; address?: string; time?: string }>>(\n    Api.GET_LAST_TRACE_INFO,\n    {\n      router: { id }\n    }\n  );\n```\n\n\n\n# 8 全局状态管理\n## 8.1 开始使用\n安装依赖\n\n```\nnpm install vuex-module-decorators --save-dev\n```\n如果想通过名字空间的形式来使用module, 需在@Module装饰器中添加额外的参数. 例如, 以下示例代码中添加一个namespaced为home的module\n\n\n```\n// src\\store\\module\\home.ts\nimport { VuexModule, Module, Mutation, Action, getModule } from 'vuex-module-decorators';\nimport store from '@/store';\n\n@Module({ namespaced: true, dynamic: true, name: 'home', store })\n\nexport default class Home extends VuexModule {\n  public name: string = '';\n  public message: string = '';\n\n  get getMessage() {\n    return `当前时间${new Date()}：${this.message}`;\n  }\n\n  @Mutation\n  private SET_NAME(newName: string): void {\n    this.name = newName;\n  }\n\n  @Mutation\n  private SET_MESSAGE(message: string) {\n    this.message = message;\n  }\n\n  @Action\n  public updateMessage(newName: string): void {\n    this.SET_NAME(newName);\n    this.SET_MESSAGE('欢迎您,');\n  }\n}\n\nexport const HomeModule = getModule(Home);\n\n\n```\n\n\n与ts等效的js代码如下\n\n```\nconst UserModule = {\n    state: {\n        name: '',\n        message: ''\n    },\n    getters: { \n        getMessage: state => `当前时间${new Date()}：${state.user.message}`\n    },\n    mutations: { \n        SET_NAME: (state, name) => {\n            state.name = name\n        },\n        SET_MESSAGE: (state, message) => {\n            state.message = message\n        }\n    },\n    actions: { \n        updateMessage({commit}, newName){\n            commit(\"SET_NAME\", newName);\n            commit(\"SET_MESSAGE\", \"欢迎您,\");\n        }\n    },\n    \n}\n\n```\n\ndynamic模式下的store\n\n```\n// \\src\\store\\index.ts\nimport Vue from 'vue';\nimport Vuex from 'vuex';\n\nVue.use(Vuex);\n\n// Declare empty store first, dynamically register all modules later.\nexport default new Vuex.Store({});\n\n```\n\n\n组件中使用：\n\n```\n// \\src\\pages\\home\\Home.vue\n\n<template>\n  <div class=\"home\">\n    <img alt=\"Vue logo\" src=\"../../assets/logo.png\" />\n    <hello-world msg=\"vue.js\" />\n    {{ $store.state.home.name }}\n    <br/>\n    {{ info }}\n    <button @click=\"handleClick\">点击</button>\n  </div>\n</template>\n\n<script lang=\"ts\">\nimport { Component, Vue } from 'vue-property-decorator';\nimport HelloWorld from '@/components/HelloWorld.vue';\nimport { HomeModule } from '@/store/modules/home';\n\n@Component({\n  components: {\n    HelloWorld\n  }\n})\nexport default class Home extends Vue {\n  get info() {\n    return HomeModule.getMessage;\n  }\n\n  private handleClick() {\n    HomeModule.updateMessage('liwu');\n  }\n}\n\n</script>\n\n```\n\n","tags":["vue","TypeScript"],"categories":["VUE专题"]},{"title":"vue项目性能优化方案","slug":"vue项目性能优化方案","url":"/2020/10/30/vue-xiang-mu-xing-neng-you-hua-fang-an/","content":"\n![vue.jpg](https://7.dusays.com/2020/11/02/3ce96e73d8ee0.jpg)\n\n# 按需使用第三方库\n项目引入过多的第三方库会增大项目体积，带来性能问题\n。以 Bootstrap 为例，如果你只是用一下它的响应式机制，还不如自己手写相关的 CSS，也不会太复杂，完全没有必要引入整个库。moment.js，Lodash.js这些库为了普适性，提供了尽可能多的功能，但你的项目可能只用了极少部分。我们不鼓励重复造轮子，但是要按需引入。现在很多库都提供了 ES 模块化的方式，也可以做到这一点。\n\n采用按需引入的方式引入第三方组件，减少在入口文件全局引入。\n\n# 路由懒加载\n\n路由懒加载也可以提高入口页面的加载速度，因为很多路由页面在多数情况下并没有被访问，在打包的时候放到单独的文件里可以减少入口页的体积。路由懒加载是通过 webpack 的动态 import来实现的。\n\n\n```\n// in router.js\nimport Home from '@/views/Home.vue'; // 静态 import\nconst About = () => import('@/views/About.vue'); // 动态 import\nconst router = new VueRouter({\n  routes: [\n    { path: '/', component: Home },\n    { path: '/about', component: About }\n  ]\n})\n\n```\n另外，这些懒加载的路由还可以分组，让相关性模块的多个路由页面打包到同一个 chunk，算是一种折中方案：既实现了按需加载，又不会过于碎片化。适用于子路由页面。\n\n\n```\n// in router.js\nimport Home from '@/views/Home.vue'; // traditonal imports\nimport User from '@/views/User.vue';\nconst About = () =>  import('@/views/About.vue'); // dynamic import\nconst router = new VueRouter({\n  routes: [\n    { path: '/', component: Home },\n    { path: '/about', component: About },\n    { path: '/user/:id', component: User, \n      children: [\n        {\n          path: '/settings',\n          component: () => import(/* webpackChunkName: \"user\" */ '@/views/UserSettings')\n        },\n        {\n          path: '/articles',\n          component: () => import(/* webpackChunkName: \"user\" */ '@/views/UserArticles')\n        }\n      ]\n    } \n  ]\n})\n\n```\n这是通过 webpack 的注释语法/* webpackChunkName: \"user\" */实现的，webpackChunkName相同的路由会打进同一个 chunk文件。\n\n# 只做展示用数据禁用响应式 \n\n默认情况下，定义在 Vue 组件data 里的数据都是响应式的，这种机制方便了数据绑定，当数据变化时界面得到自动更新。但有时候我们只是将数据显示到界面上，之后也不会改变它。这种情况下我们根本用不上响应式机制，而实现响应式是有性能代价的，特别是对于大对象和大列表。\n\n建议将data还有Vuex 里面只用于展示的数据通过Object.freeze()禁用对象的响应式特性。\n\n# 资源释放\n1.  如果在mounted/created 钩子中使用了$on，需要在beforeDestroy 中做对应解绑($off)处理\n2.  如果在mounted/created 钩子中绑定了DOM/BOM 对象中的事件，需要在beforeDestroy 中做对应解绑处理\n3.  如果在mounted/created 钩子中使用了第三方库初始化，需要在beforeDestroy 中做对应销毁处理\n4.  如果使用setTimeout setInterval需要在beforeDestroy中做对应销毁处理，（最好不用）可以使用nextTick代替\n5.  模块形成的闭包内部变量使用完后没有置成null\n6.  全局变量没有回收\n7.  绑在EventBus的事件没有解绑，注册的总线事件（Bus）要在组件销毁时(beforeDestroy/destroyed)卸载\n\n# v-if 和 v-show 区分使用场景\nv-if 是 真正 的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。\n\nv-show 就简单得多， 不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 的 display 属性进行切换。\n\n所以，v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景；v-show 则适用于需要非常频繁切换条件的场景。\n\n# computed 和 watch  区分使用场景\n（1）computed： 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed  的值；\n\n（2） watch： 更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；\n\n运用场景：\n\n当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；\n\n当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。\n\n# v-for 遍历必须为 item 添加 key，且避免同时使用 v-if\n（1）v-for 遍历必须为 item 添加 key\n\n在列表数据进行遍历渲染时，需要为每一项 item 设置唯一 key 值，方便 Vue.js 内部机制精准找到该条列表数据。当 state 更新时，新的状态值和旧的状态值对比，较快地定位到 diff 。\n\n（2）v-for 遍历避免同时使用 v-if\n\nv-for 比 v-if 优先级高，如果每一次都需要遍历整个数组，将会影响速度，尤其是当之需要渲染很小一部分的时候，必要情况下应该替换成 computed 属性。\n\n\n```\n<ul>\n  <li\n    v-for=\"user in activeUsers\"\n    :key=\"user.id\">\n    {{ user.name }}\n  </li>\n</ul>\ncomputed: {\n  activeUsers: function () {\n    return this.users.filter(function (user) {\n   return user.isActive\n    })\n  }\n}\n```\n\n# 减少 ES6 转为 ES5 的冗余代码\nBabel 插件会在将 ES6 代码转换成 ES5 代码时会注入一些辅助函数，例如下面的 ES6 代码：\n\n```\nclass HelloWebpack extends Component{...}\n```\n这段代码再被转换成能正常运行的 ES5 代码时需要以下两个辅助函数：\n\n```\nbabel-runtime/helpers/createClass  // 用于实现 class 语法\nbabel-runtime/helpers/inherits  // 用于实现 extends 语法\n```\n在默认情况下， Babel 会在每个输出文件中内嵌这些依赖的辅助函数代码，如果多个源代码文件都依赖这些辅助函数，那么这些辅助函数的代码将会出现很多次，造成代码冗余。为了不让这些辅助函数的代码重复出现，可以在依赖它们时通过 require('babel-runtime/helpers/createClass') 的方式导入，这样就能做到只让它们出现一次。babel-plugin-transform-runtime 插件就是用来实现这个作用的，将相关辅助函数进行替换成导入语句，从而减小 babel 编译出来的代码的文件大小。\n\n首先，安装 babel-plugin-transform-runtime ：\n\n```\nnpm install babel-plugin-transform-runtime --save-dev\n```\n然后，修改 .babelrc  配置文件为：\n\n```\n\"plugins\": [\n    \"transform-runtime\"\n]\n```\n\n# 开启gzip压缩\n首先，修改productionGzip 为true,\n安装 compression-webpack-plugin ：\n\n```\n // \n \n npm install --save-dev compression-webpack-plugin \n //(此处有坑) 如果打包报错，应该是版本问题 ，先卸载之前安装的此插件 ，然后安装低版本 \n  npm install --save-dev compression-webpack-plugin@1.1.11\n```\n\n修改nginx的配置\n\n```\nhttp {  //在 http中配置如下代码，\n   gzip on;\n   gzip_disable \"msie6\"; \n   gzip_vary on; \n   gzip_proxied any;\n   gzip_comp_level 8; #压缩级别\n   gzip_buffers 16 8k;\n   #gzip_http_version 1.1;\n   gzip_min_length 100; #不压缩临界值\n   gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png;\n }\n```\n\n# 图片懒加载\n如果应用里需要展示大量图片，通常的做法是懒加载图片。懒加载的基本原理是提前准备好图片 URL，当图片真正进入可视范围时才去加载。可以手动实现懒加载机制，不过更方便的是直接用现成的插件，比如 [vue-lazyload]\n安装：\n\n```\nnpm i vue-lazyload -S\n```\n\n引入：\n\n```\nimport VueLazyload from 'vue-lazyload'\nVue.use(VueLazyload)\n\n```\n使用：\n\n```\n <ul>\n    <li v-for=\"img in list\">\n      <img v-lazy=\"img.src\">\n    </li>\n  </ul>\n\n```\n\n# cdn加速\n采用cdn加速去从别的服务器上加载第三方库而非自己的服务器，这样就会快很多.并且能节省自己服务器的带宽。\n\n首先，在index.html中 将你所需的第三方库的链接加载进来：\n\n```\n<script src=\"https://cdn.bootcdn.net/ajax/libs/vue/3.0.0-beta.18/vue.cjs.js\"></script>\n```\n\n在webpack.base.conf 中添加 externals 来告诉webpack我们这些第三方库不需要打包\n\n\n```\nexternals:{\n    // key表示第三方插件名称，value是暴露出的全局变量\n    'vue':'Vue'\n}\n```\n\n在 主文件main.js 或者其他 js 修改引用这些配置的第三方插件\n\n```\n// import Vue from 'vue';\n\nconst Vue = require('vue');\n```\n\n# Webpack 对图片进行压缩\n安装 image-webpack-loader ：\n\n```\nnpm install image-webpack-loader --save-dev\n```\n然后，在 webpack.base.conf.js  中进行配置：\n\n```\n{\n  test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/,\n  use:[\n     {\n      loader: 'url-loader',\n      options: {\n        limit: 10000 ,\n        name: '[path][name].[ext]?[hash:6]!./dir/file.png'\n      }\n    },\n    /*对图片进行压缩*/\n    {\n      loader: 'image-webpack-loader',\n      query: {\n        progressive: true,\n        optimizationLevel: 7,\n        interlaced: false,\n        pngquant: {\n          quality: '65-90',\n          speed: 4\n        }\n      }\n    }\n  ]\n}\n\n```\n\n# pax-ui框架相关\n（1） 表单组件\npax组件的Form表单组件会对绑定数据监听，表单组件很多的情况下页面会卡顿，在pax-form上设置局部更新，会提升一部分性能。\n\n```\n<pax-form :form=\"form\" :selfUpdate=\"true\"></pax-form>\n```\n\n\n(2) select组件\nselect大数据量情况下，会造成页面元素较多，在ie上消耗更多的内存。建议采用虚拟滚动的方式：\n\n```\nimport { RecycleScroller} from 'vue-virtual-scroller';\n\n// 在Select预留卡槽中使用\n详情见文档：IE浏览器select大数据问题造成输入不流畅分析处理\n```\n（3）tree组件\npax-tree在ie上问题严重,如果兼容ie，建议用@pa/vue-org-tree,使用方法参考ztree.js\n\n```\nnpm install @pa/vue-org-tree --save-dev\n```\n","tags":["vue"],"categories":["VUE专题"]},{"title":"当CORS遇到SameSite","slug":"当CORS遇到SameSite-md","url":"/2020/09/11/dang-cors-yu-dao-samesite-md/","content":"\n# 问题描述\n> A cookie associated with a cross-site resource at http://a.com/ was set without the 'SameSite' attribute. A future release of Chrome will only deliver cookies with cross-site requests if they are set with 'SameSite=None' and 'Secure'. You can review cookies in developer tools under Application>Storage>Cookies and see more details at https://www.chromestatus.com/feature/5088147346030592 and https://www.chromestatus.com/feature/5633521622188032.\n\n于是发现是 Chrome 升级 80 导致未设置 SameSite 的 Cookie 默认值是Lax。\n\n# 解决方案\n\n## 1.紧急处理\n其实是在服务方解决问题之前让用户先稍微兼容一下。方案很简单：\n\n\n换个浏览器\nor\n\n\n打开 chrome://flags/#same-site-by-default-cookies，关掉 SameSite by default cookies 然后重启浏览器\n\n\n## 2. 方法一：跨域 + Set-Cookie\n\n首先就是报错信息里提到的，让服务端同学在 Set-Cookie 的时候加上 SameSite=None; Secure。但是我们的后台系统都是对内使用的，很多域名都没有申请证书。而 “Secure” 属性却表示 Cookie 只能随 HTTPS 请求发送。\n这就很尴尬。\n要不申请证书，要不换域名。\n但是长远来看，https是大趋势，趁着这个机会升级成 HTTPS 也是可取的。\n然而有些版本的浏览器并不识别 SameSite=None，需要特殊处理。\n\n## 3. 方法二：改成同域请求\n既然 SameSite=Lax 限制的是跨域 Cookie 携带，那么改成同域自然没有问题了。\n但因为现在项目都是前后端分离部署的，所以请运维同学配了一下匹配到 ^/api/ 开头的请求都转发到服务端的地址。前端请求接口时直接用相对路径请求。\n问题解决\n\n","tags":["项目总结"],"categories":["项目总结"]},{"title":"BFC原理及应用","slug":"BFC原理及应用","url":"/2020/08/30/bfc-yuan-li-ji-ying-yong/","content":"\n![](/images/css.png)\n\n# 一、常见定位方案\n在讲 BFC 之前，我们先来了解一下常见的定位方案，定位方案是控制元素的布局，有三种常见方案:\n\n- 普通流 (normal flow)\n在普通流中，元素按照其在 HTML 中的先后位置至上而下布局，在这个过程中，行内元素水平排列，直到当行被占满然后换行，块级元素则会被渲染为完整的一个新行，除非另外指定，否则所有元素默认都是普通流定位，也可以说，普通流中元素的位置由该元素在 HTML 文档中的位置决定。\n- 浮动 (float)\n在浮动布局中，元素首先按照普通流的位置出现，然后根据浮动的方向尽可能的向左边或右边偏移，其效果与印刷排版中的文本环绕相似。\n- 绝对定位 (absolute positioning)\n在绝对定位布局中，元素会整体脱离普通流，因此绝对定位元素不会对其兄弟元素造成影响，而元素具体的位置由绝对定位的坐标决定。\n\n# 二、BFC 概念\n> Formatting context(格式化上下文) 是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。\n\n那么 BFC 是什么呢？\n\nBFC 即 Block Formatting Contexts (块级格式化上下文)，它属于上述定位方案的普通流。\n具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。\n通俗一点来讲，可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。\n\n# 三、触发 BFC\n只要元素满足下面任一条件即可触发 BFC 特性：\n- body 根元素\n- 浮动元素：float 除 none 以外的值\n- 绝对定位元素：position (absolute、fixed)\n- display 为 inline-block、table-cells、flex\n- overflow 除了 visible 以外的值 (hidden、auto、scroll)\n\n# 四、BFC 特性及应用\n## 1. 同一个 BFC 下外边距会发生折叠\n\n```\n<head>\ndiv{\n    width: 100px;\n    height: 100px;\n    background: lightblue;\n    margin: 100px;\n}\n</head>\n<body>\n    <div></div>\n    <div></div>\n</body>\n\n```\n从效果上看，因为两个 div 元素都处于同一个 BFC 容器下 (这里指 body 元素) 所以第一个 div 的下边距和第二个 div 的上边距发生了重叠，所以两个盒子之间距离只有 100px，而不是 200px。\n![](https://7.dusays.com/2020/11/02/0afee71e5de5e.png)\n\n首先这不是 CSS 的 bug，我们可以理解为一种规范，如果想要避免外边距的重叠，可以将其放在不同的 BFC 容器中。\n\n```\n\n<div class=\"container\">\n    <p></p>\n</div>\n<div class=\"container\">\n    <p></p>\n</div>\n\n.container {\n    overflow: hidden;\n}\np {\n    width: 100px;\n    height: 100px;\n    background: lightblue;\n    margin: 100px;\n}\n\n```\n\n这时候，两个盒子边距就变成了 200px \n\n![](https://7.dusays.com/2020/11/02/0e302d5bce868.png)\n\n\n ## 2. BFC 可以包含浮动的元素（清除浮动）\n我们都知道，浮动的元素会脱离普通文档流，来看下下面一个例子\n```\n<div style=\"border: 1px solid #000;\">\n    <div style=\"width: 100px;height: 100px;background: #eee;float: left;\"></div>\n</div>\n```\n\n![](https://7.dusays.com/2020/11/02/f461d5e0dbd0f.png)\n\n\n由于容器内元素浮动，脱离了文档流，所以容器只剩下 2px 的边距高度。如果使触发容器的 BFC，那么容器将会包裹着浮动元素。\n\n```\n<div style=\"border: 1px solid #000;overflow: hidden\">\n    <div style=\"width: 100px;height: 100px;background: #eee;float: left;\"></div>\n</div>\n```\n\n效果如图：\n\n![](https://7.dusays.com/2020/11/02/b90051e64945c.png)\n\n## 3. BFC 可以阻止元素被浮动元素覆盖\n先来看一个文字环绕效果：\n\n```\n<div style=\"height: 100px;width: 100px;float: left;background: lightblue\">\n    我是一个左浮动的元素\n</div>\n<div style=\"width: 200px; height: 200px;background: #eee\">\n    我是一个没有设置浮动, 也没有触发 BFC 元素, width: 200px; height:200px; background: #eee;\n</div>\n\n```\n![](https://7.dusays.com/2020/11/02/aaf4c0ab57032.png)\n\n这时候其实第二个元素有部分被浮动元素所覆盖，(但是文本信息不会被浮动元素所覆盖) 如果想避免元素被覆盖，可触第二个元素的 BFC 特性，在第二个元素中加入 overflow: hidden，就会变成：\n\n![](https://7.dusays.com/2020/11/02/4a7759227aae9.png)\n\n这个方法可以用来实现两列自适应布局，效果不错，这时候左边的宽度固定，右边的内容自适应宽度(去掉上面右边内容的宽度)。","tags":["css"],"categories":["前端基础"]},{"title":"Hooks入门教程","slug":"Hooks入门教程","url":"/2019/09/16/hooks-ru-men-jiao-cheng/","content":"\n![react](https://7.dusays.com/2020/11/02/d812bf44ed5ef.png)\n\n\n# Hooks的含义:\nReact Hooks 的意思是，组件尽量写成**纯函数**，如果需要外部功能和副作用，就用钩子把外部代码\"钩\"进来。 React Hooks 就是那些钩子。\n\nReact默认提供了一些常用的钩子函数，你也可以自己定义钩子函数。\n\nReact 团队希望，组件不要变成复杂的容器，最好只是数据流的管道。开发者根据需要，组合管道即可。 **组件的最佳写法应该是函数**，而不是类。\n\nReact 约定，钩子一律使用**use**前缀命名，便于识别。\n\n# 常见的钩子函数\n## 1. useState():状态钩子\n\n\n```\nuseState用于为函数组件引入状态（state）。纯函数不能有状态，所以把状态放在钩子里面\n\nuseState()这个函数接受状态的初始值，作为参数，返回一个数组，数组第一个成员是一个变量，指向状态的当前值。第二个成员是函数，用来更新状态，约定用set前缀加上状态的变量名。\n\nconst [buttonText, setButtonText] = useState(\"Click me, please\");\n```\n\n\n## 2. useContext()共享状态钩子\n\n```\n如果组件之间需要共享状态，可以使用useContext()。\n\n<div className=\"App\">\n  <Navbar/>\n  <Messages/>\n</div>\n\n如果Navbar跟Messages实现通信，第一步在组件外部建立一个context:\nconst AppContext = React.creatContext({})\n\n组件封装的代码如下：\n<AppContext.Provider value={{\n  username: 'superawesome'\n}}>\n  <div className=\"App\">\n    <Navbar/>\n    <Messages/>\n  </div>\n</AppContext.Provider>\n\n在组件中的使用如下：\nconst Navbar = () => {\n  const { username } = useContext(AppContext);\n  return (\n    <div className=\"navbar\">\n      <p>AwesomeSite</p>\n      <p>{username}</p>\n    </div>\n  );\n}\n\n```\n\n\n\n## 3. useReducer():action钩子\n\n\n```\nReact 本身不提供状态管理功能，通常需要使用外部库。这方面最常用的库是 Redux。\n\nRedux 的核心概念是，组件发出 action 与状态管理器通信。状态管理器收到 action 以后，使用 Reducer 函数算出新的状态，Reducer 函数的形式是(state, action) => newState。\n\nuseReducers()钩子用来引入 Reducer 功能。\n\nconst [state, dispatch] = useReducer(reducer, initialState);\n\n```\n\n## 4. useEffect():副作用钩子\n\n```\nuseEffect()用来引入具有副作用的操作，最常见的就是向服务器请求数据。以前，放在componentDidMount里面的代码，现在可以放在useEffect()。\n\nuseEffect()的用法如下。\n\nuseEffect(()  =>  {\n  // Async Action\n}, [dependencies])\n\nuseEffect()接受两个参数。第一个参数是函数，异步操作的代码放里面，第二个参数是一个数组，用于给出Effect的依赖，只要这个数组发生变化，useEffect()就会执行。第二个参数可以省略，这时每次组件渲染时，就会执行useEffect()。\n```\nReact首次渲染和之后的每次渲染都会调用一遍useEffect函数，而之前我们要用两个生命周期函数分别表示首次渲染(componentDidMonut)和更新导致的重新渲染(componentDidUpdate)。\n\nuseEffect中定义的函数的执行不会阻碍浏览器更新视图，也就是说这些函数时异步执行的，而componentDidMonut和componentDidUpdate中的代码都是同步执行的。个人认为这个有好处也有坏处吧，比如我们要根据页面的大小，然后绘制当前弹出窗口的大小，如果时异步的就不好操作了。\n","tags":["react","hooks"],"categories":["新鲜技能"]},{"title":"简单的在线数据mock","slug":"简单的在线数据mock","url":"/2019/08/30/jian-dan-de-zai-xian-shu-ju-mock/","content":"\n\n# 说明：\n\n在接口调试前，前端根据定义好的接口文档，模拟数据，发起请求，编写完整的页面逻辑，等真正开始调试的时候，将请求地址更换即可。\n\n本文只介绍在线 mock 数据的方式，在线 mock 跟本地 mock 比较，可以省去安装配置，运行服务，多人协作数据不通的多种问题。\n\n# 一个简单的列子\n\n![](https://7.dusays.com/2020/11/02/98aaa2c403dd1.png)\n\n返回结果：\n\n![](https://7.dusays.com/2020/11/02/a2df1d69cadcf.png)\n\n# Mock 语法简介\n\n## base\n\n```\n{\n    \"base\": {\n    \"range\": \"@range(3, 7)\",\n    \"string\": \"@string(7, 20)\",\n    \"character\": \"@character(\\\"abcde\\\")\",\n    \"float\": \"@float(60, 100)\",\n    \"integer\": \"@integer(60, 100)\",\n    \"natural\": \"@natural(60, 100)\",\n    \"boolean\": \"@boolean\"\n  },\n}\n\n```\n\n预览：\n\n```\n\"base\": {\n    \"range\": [3,4,5,6],\n    \"string\": \"qg3)zBWiLlbrsisX\",\n    \"character\": \"c\",\n    \"float\": 66.87535733306,\n    \"integer\": 66,\n    \"natural\": 71,\n    \"boolean\": false\n  },\n```\n\n## date\n\n```\n\"date\": {\n    \"date\": \"@date\",\n    \"time\": \"@time\",\n    \"datetime\": \"@datetime\",\n    \"now\": \"@now\"\n  },\n```\n\n预览：\n\n```\n\"date\": {\n    \"date\": \"1971-10-18\",\n    \"time\": \"02:04:17\",\n    \"datetime\": \"1985-03-10 22:47:49\",\n    \"now\": \"2019-09-25 13:56:44\"\n    }\n```\n\n## image\n\n```\n \"image\": {\n    \"image\": \"@image(\\\"200x200\\\", \\\"#50B347\\\", \\\"#FFF\\\", \\\"FastMock\\\")\"\n  },\n```\n\n预览：\n\n```\n\"image\": {\n    \"image\": \"http://dummyimage.com/200x200/50B347/FFF&text=FastMock\"\n  },\n```\n\n## text\n\n```\n\"text\": {\n    \"paragraph\": \"@paragraph(1, 3)\",\n    \"sentence\": \"@sentence(3, 5)\",\n    \"word\": \"@word(3, 5)\",\n    \"title\": \"@title(3, 5)\",\n    \"cparagraph\": \"@cparagraph(1, 3)\",\n    \"csentence\": \"@csentence(3, 5)\",\n    \"cword\": \"@cword(\\\"零一二三四五六七八九十\\\", 5, 7)\",\n    \"ctitle\": \"@ctitle(3, 5)\"\n  },\n\n```\n\n预览：\n\n```\n \"text\": {\n    \"paragraph\": \"Gifp ifnk hrreyi foajbgielv doijqrd ffaooi hlwstfcfw nrgsioum wtgashcoiy sintskl hnjk ebcsec. Bhlhghu embjvvs bckwkibqhs qgqz psu mjsodprwf exidxyqnq cdyqoatr xkezagaqu ijrcqrj vvxwdwgq ivv jxcpeybpus sojcn cscdlnmi kopzvuqfin.\",\n    \"sentence\": \"Xuqxp qvek ttgiq.\",\n    \"word\": \"ynug\",\n    \"title\": \"Cdnsxa Yjhrlbb Rmofrixln Jubgpxm Gjpdujgryi\",\n    \"cparagraph\": \"装增克体都月每手物即用周几想军点程。将角权响金华生候社根利情也龙。化必去边织众东位史回际平马至。\",\n    \"csentence\": \"存断实。\",\n    \"cword\": \"三七九六六\",\n    \"ctitle\": \"油眼采小\"\n  },\n```\n\n## name\n\n```\n\"name\": {\n    \"first\": \"@first\",\n    \"last\": \"@last\",\n    \"name\": \"@name\",\n    \"cfirst\": \"@cfirst\",\n    \"clast\": \"@clast\",\n    \"cname\": \"@cname\"\n  },\n```\n\n预览：\n\n```\n\"name\": {\n    \"first\": \"Jennifer\",\n    \"last\": \"Anderson\",\n    \"name\": \"Laura Moore\",\n    \"cfirst\": \"胡\",\n    \"clast\": \"秀兰\",\n    \"cname\": \"姜敏\"\n  },\n```\n\n## web\n\n```\n\"web\": {\n    \"url\": \"@url\",\n    \"domain\": \"@domain\",\n    \"protocol\": \"@protocol\",\n    \"tld\": \"@tld\",\n    \"email\": \"@email\",\n    \"ip\": \"@ip\"\n  },\n```\n\n预览：\n\n```\n\"web\": {\n    \"url\": \"mid://nypjj.kr/mizdvfhl\",\n    \"domain\": \"jbgmh.cn\",\n    \"protocol\": \"ftp\",\n    \"tld\": \"fj\",\n    \"email\": \"r.bdwejkiuy@ltatgpp.an\",\n    \"ip\": \"175.52.62.226\"\n  },\n```\n\n## address\n\n```\n\"address\": {\n    \"region\": \"@region\",\n    \"province\": \"@province\",\n    \"city\": \"@city(true)\",\n    \"county\": \"@county(true)\",\n    \"zip\": \"@zip\"\n  },\n```\n\n预览：\n\n```\n\"address\": {\n    \"region\": \"华中\",\n    \"province\": \"云南省\",\n    \"city\": \"天津 天津市\",\n    \"county\": \"台湾 金门县 金宁乡\",\n    \"zip\": \"539375\"\n  },\n```\n\n## miscellaneous\n\n```\n \"miscellaneous\": {\n    \"id\": \"@id\",\n    \"guid\": \"@guid\",\n    \"increment\": \"@increment(1000)\"\n  }\n```\n\n预览：\n\n```\n \"miscellaneous\": {\n    \"id\": \"370000201504299208\",\n    \"guid\": \"6E6155c0-f5b5-F3F6-5F0D-23EB44C21313\",\n    \"increment\": 253109\n  }\n```\n\n# Mock 高阶用法\n\n> Mock 能支持 function，function 中不能用上面的@XX,用 Mock.mock(\"@xxx\")替代。function 中还能获取全部请求头和参数。\n\n| 对象              | 描述                                                                                 |\n| ----------------- | ------------------------------------------------------------------------------------ |\n| Mock              | Mock 对象                                                                            |\n| \\_req.url         | 获得请求 url 地址                                                                    |\n| \\_req.method      | 获取请求方法                                                                         |\n| \\_req.params      | 获取 url 参数对象                                                                    |\n| \\_req.querystring | 获取查询参数字符串(url 中?后面的部分)，不包含 ?                                      |\n| \\_req.query       | 将查询参数字符串进行解析并以对象的形式返回，如果没有查询参数字字符串则返回一个空对象 |\n| \\_req.body        | 当 post 请求以 x-www-form-urlencoded 方式提交时，我们可以拿到请求的参数对象          |\n\n## 举个栗子\n\n```\n{\n  code: function({\n    _req\n  }) {\n    const userName = _req.query.userName;\n    return userName ? 0 : -1;\n  },\n  data: function({\n    _req,\n    Mock\n  }) {\n    const userName = _req.query.userName;\n    return userName ? {\n      token: Mock.mock(\"@guid()\"),\n      userId: Mock.mock(\"@id(5)\"),\n      name: userName,\n      avatar: Mock.mock(\"@image(200x100, #FF6600)\"),\n      message: \"登录成功\"\n    } : {\n      message: \"登录失败\"\n    }\n  }\n}\n```\n\n预览：\n\n![image](https://note.youdao.com/yws/public/resource/633e9bc706a3a274d9926f95b1806671/xmlnote/1C6017CB352F41DD9B758D064EBCFD4B/15016)\n\n# 常用的在线 mock 工具\n\n- 💛 [fast-mock](https://www.fastmock.site/)\n\n- 💗 [easy-mock](https://easy-mock.com/)\n","tags":["项目总结"],"categories":["开发工具"]},{"title":"Vue组件编码规范","slug":"Vue组件编码规范","url":"/2019/08/13/vue-zu-jian-bian-ma-gui-fan/","content":"\n# 目标\n\n>本规范提供了一种统一的编码规范来编写 Vue.js 代码。这使得代码具有如下的特性：\n\n- 其它开发者或是团队成员更容易阅读和理解。\n- IDEs 更容易理解代码，从而提供高亮、格式化等辅助功能\n- 更容易使用现有的工具\n- 更容易实现缓存以及代码包的分拆\n\n\n# 基于模块开发\n始终基于模块的方式来构建你的 app，每一个子模块只做一件事情。\n\nVue.js 的设计初衷就是帮助开发者更好的开发界面模块。一个模块是应用程序中独立的一个部分。\n\n## 怎么做？\n> 每一个 Vue 组件（等同于模块）首先必须专注于解决一个单一的问题，独立的、可复用的、微小的 和 可测试的。\n\n如果你的组件做了太多的事或是变得臃肿，请将其拆分成更小的组件并保持单一的原则。一般来说，尽量保证每一个文件的代码行数不要超过 100 行。也请保证组件可独立的运行。\n\n# vue 组件命名\n组件的命名需遵从以下原则：\n\n- **有意义的**: 不过于具体，也不过于抽象\n- **简短**: 2 到 3 个单词\n- **具有可读性**: 以便于沟通交流\n同时还需要注意：\n\n- 必须符合**自定义元素规范**: 使用连字符分隔单词，切勿使用保留字。\n- app- 前缀作为命名空间:\n\n如果非常通用的话可使用一个单词来命名，这样可以方便于其它项目里复用。\n\n## 为什么？\n- 组件是通过组件名来调用的。所以组件名必须简短、富有含义并且具有可读性。\n\n## 如何做？\n```\n!-- 推荐 -->\n<app-header></app-header>\n<user-list></user-list>\n<range-slider></range-slider>\n\n<!-- 避免 -->\n<btn-group></btn-group> <!-- 虽然简短但是可读性差. 使用 `button-group` 替代 -->\n<ui-slider></ui-slider> <!-- ui 前缀太过于宽泛，在这里意义不明确 -->\n<slider></slider> <!-- 与自定义元素规范不兼容 -->\n```\n\n\n# 组件表达式简单化\nVue.js 的表达式是 100% 的 Javascript 表达式。这使得其功能性很强大，但也带来潜在的复杂性。因此，你应该尽量保持表达式的简单化。\n## 为什么？\n- 复杂的行内表达式难以阅读。\n- 行内表达式是不能够通用的，这可能会导致重复编码的问题。\n- IDE 基本上不能识别行内表达式语法，所以使用行内表达式 IDE 不能提供自动补全和语法校验功能。\n\n## 怎么做？\n如果你发现写了太多复杂并难以阅读的行内表达式，那么可以使用 method 或是 computed 属性来替代其功能。\n\n```\n<!-- 推荐 -->\n<template>\n  <h1>\n    {{ `${year}-${month}` }}\n  </h1>\n</template>\n<script type=\"text/javascript\">\n  export default {\n    computed: {\n      month() {\n        return this.twoDigits((new Date()).getUTCMonth() + 1);\n      },\n      year() {\n        return (new Date()).getUTCFullYear();\n      }\n    },\n    methods: {\n      twoDigits(num) {\n        return ('0' + num).slice(-2);\n      }\n    },\n  };\n</script>\n\n<!-- 避免 -->\n<template>\n  <h1>\n    {{ `${(new Date()).getUTCFullYear()}-${('0' + ((new Date()).getUTCMonth()+1)).slice(-2)}` }}\n  </h1>\n</template>\n```\n\n# 组件 props 原子化\n\n虽然 Vue.js 支持传递复杂的 JavaScript 对象通过 props 属性，但是你应该尽可能的使用原始类型的数据。尽量只使用 JavaScript 原始类型（字符串、数字、布尔值）和函数。尽量避免复杂的对象。\n\n## 为什么？\n- 使得组件 API 清晰直观。\n- 只使用原始类型和函数作为 props 使得组件的 API 更接近于 HTML(5) 原生元素。\n- 其它开发者更好的理解每一个 prop 的含义、作用。\n- 传递过于复杂的对象使得我们不能够清楚的知道哪些属性或方法被自定义组件使用，这使得代码难以重构和维护。\n\n## 怎么做？\n组件的每一个属性单独使用一个 props，并且使用函数或是原始类型的值。\n\n\n```\n<!-- 推荐 -->\n<range-slider\n  :values=\"[10, 20]\"\n  :min=\"0\"\n  :max=\"100\"\n  :step=\"5\"\n  @on-slide=\"updateInputs\"\n  @on-end=\"updateResults\">\n</range-slider>\n\n<!-- 避免 -->\n<range-slider :config=\"complexConfigObject\"></range-slider>\n```\n\n# 验证组件的 props\n在 Vue.js 中，组件的 props 即 API，一个稳定并可预测的 API 会使得你的组件更容易被其他开发者使用。\n\n组件 props 通过自定义标签的属性来传递。属性的值可以是 Vue.js 字符串(:attr=\"value\" 或 v-bind:attr=\"value\")或是不传。你需要保证组件的 props 能应对不同的情况。\n\n## 为什么？\n验证组件 props 可以保证你的组件永远是可用的（防御性编程）。即使其他开发者并未按照你预想的方法使用时也不会出错。\n\n## 怎么做？\n- 提供默认值。\n- 使用 type 属性校验类型。\n- 使用 props 之前先检查该 prop 是否存在。\n\n\n```\n<template>\n  <input type=\"range\" v-model=\"value\" :max=\"max\" :min=\"min\">\n</template>\n<script type=\"text/javascript\">\n  export default {\n    props: {\n      max: {\n        type: Number, // 这里添加了数字类型的校验\n        default() { return 10; },\n      },\n      min: {\n        type: Number,\n        default() { return 0; },\n      },\n      value: {\n        type: Number,\n        default() { return 4; },\n      },\n    },\n  };\n</script>\n```\n\n# 将 this 赋值给 component 变量\n在 Vue.js 组件上下文中，this指向了组件实例。因此当你切换到了不同的上下文时，要确保 this 指向一个可用的 component 变量。\n\n换句话说，如果你正在使用 ES6 的话，就不要再编写 var self = this; 这样的代码了，您可以安全地使用 Vue 组件。\n\n## 为什么？\n- 使用 ES6，就不再需要将 this 保存到一个变量中了。\n- 一般来说，当你使用箭头函数时，会保留 this 的作用域。（译者注：箭头函数没有它自己的 this 值，箭头函数内的 this 值继承自外围作用域。）\n- 如果你没有使用 ES6，当然也就不会使用 箭头函数 啦，那你必须将 “this” 保存到到某个变量中。这是唯一的例外。\n\n## 怎么做？\n\n```\n<script type=\"text/javascript\">\nexport default {\n  methods: {\n    hello() {\n      return 'hello';\n    },\n    printHello() {\n      console.log(this.hello());\n    },\n  },\n};\n</script>\n\n<!-- 避免 -->\n<script type=\"text/javascript\">\nexport default {\n  methods: {\n    hello() {\n      return 'hello';\n    },\n    printHello() {\n      const self = this; // 没有必要\n      console.log(self.hello());\n    },\n  },\n};\n</script>\n```\n\n# 组件结构化\n按照一定的结构组织，使得组件便于理解。\n\n## 为什么？\n- 导出一个清晰、组织有序的组件，使得代码易于阅读和理解。同时也便于标准化。\n- 按首字母排序 properties、data、computed、watches 和 methods 使得这些对象内的属性便于查找。\n- 合理组织，使得组件易于阅读。（name; extends; props, data 和 computed; components; watch 和 methods; lifecycle methods 等）。\n- 使用 name 属性。借助于 vue devtools 可以让你更方便的测试。\n- 合理的 CSS 结构，如 BEM 或 rscss - 详情？。\n- 使用单文件 .vue 文件格式来组件代码。\n\n## 怎么做？\n组件结构化\n```\n<template lang=\"html\">\n  <div class=\"Ranger__Wrapper\">\n    <!-- ... -->\n  </div>\n</template>\n\n<script type=\"text/javascript\">\n  export default {\n    // 不要忘记了 name 属性\n    name: 'RangeSlider',\n    // 使用组件 mixins 共享通用功能\n    mixins: [],\n    // 组成新的组件\n    extends: {},\n    // 组件属性、变量\n    props: {\n      bar: {}, // 按字母顺序\n      foo: {},\n      fooBar: {},\n    },\n    // 变量\n    data() {},\n    computed: {},\n    // 使用其它组件\n    components: {},\n    // 方法\n    watch: {},\n    methods: {},\n    // 生命周期函数\n    beforeCreate() {},\n    mounted() {},\n  };\n</script>\n\n<style scoped>\n  .Ranger__Wrapper { /* ... */ }\n</style>\n```\n\n# 避免 this.$parent\nVue.js 支持组件嵌套，并且子组件可访问父组件的上下文。访问组件之外的上下文违反了基于模块开发的第一原则。因此你应该尽量避免使用 this.$parent。\n\n## 为什么？\n- 组件必须相互保持独立，Vue 组件也是。如果组件需要访问其父层的上下文就违反了该原则。\n- 如果一个组件需要访问其父组件的上下文，那么该组件将不能在其它上下文中复用。\n\n## 怎么做？\n\n- 通过 props 将值传递给子组件。\n- 通过 props 传递回调函数给子组件来达到调用父组件方法的目的。\n- 通过在子组件触发事件来通知父组件。\n\n\n# 谨慎使用 this.$refs\nVue.js 支持通过 ref 属性来访问其它组件和 HTML 元素。并通过 this.$refs 可以得到组件或 HTML 元素的上下文。在大多数情况下，通过 this.$refs来访问其它组件的上下文是可以避免的。在使用的的时候你需要注意避免调用了不恰当的组件 API，所以应该尽量避免使用 this.$refs。\n\n## 为什么？\n- 组件必须是保持独立的，如果一个组件的 API 不能够提供所需的功能，那么这个组件在设计、实现上是有问题的。\n- 组件的属性和事件必须足够的给大多数的组件使用。\n\n## 怎么做？\n- 提供良好的组件 API。\n- 总是关注于组件本身的目的。\n- 拒绝定制代码。如果你在一个通用的组件内部编写特定需求的代码，那么代表这个组件的 API 不够通用，或者你可能需要一个新的组件来应对该需求。\n- 检查所有的 props 是否有缺失的，如果有提一个 issue 或是完善这个组件。\n- 检查所有的事件。子组件向父组件通信一般是通过事件来实现的，但是大多数的开发者更多的关注于 props 从忽视了这点。\n- Props向下传递，事件向上传递！。以此为目标升级你的组件，提供良好的 API 和 独立性。\n- 当遇到 props 和 events 难以实现的功能时，通过 this.$refs来实现。\n- 当需要操作 DOM 无法通过指令来做的时候可使用 this.$ref 而不是 JQuery、document.getElement*、document.queryElement。\n\n\n```\n<!-- 推荐，并未使用 this.$refs -->\n<range :max=\"max\"\n  :min=\"min\"\n  @current-value=\"currentValue\"\n  :step=\"1\"></range>\n```\n\n\n```\n<!-- 使用 this.$refs 的适用情况-->\n<modal ref=\"basicModal\">\n  <h4>Basic Modal</h4>\n  <button class=\"primary\" @click=\"$refs.basicModal.hide()\">Close</button>\n</modal>\n<button @click=\"$refs.basicModal.open()\">Open modal</button>\n\n<!-- Modal component -->\n<template>\n  <div v-show=\"active\">\n    <!-- ... -->\n  </div>\n</template>\n\n<script>\n  export default {\n    // ...\n    data() {\n      return {\n        active: false,\n      };\n    },\n    methods: {\n      open() {\n        this.active = true;\n      },\n      hide() {\n        this.active = false;\n      },\n    },\n    // ...\n  };\n</script>\n```\n\n\n```\n<!-- 如果可通过 emited 来做则避免通过 this.$refs 直接访问 -->\n<template>\n  <range :max=\"max\"\n    :min=\"min\"\n    ref=\"range\"\n    :step=\"1\"></range>\n</template>\n\n<script>\n  export default {\n    // ...\n    methods: {\n      getRangeCurrentValue() {\n        return this.$refs.range.currentValue;\n      },\n    },\n    // ...\n  };\n</script>\n```\n\n# 使用组件名作为样式作用域空间\nVue.js 的组件是自定义元素，这非常适合用来作为样式的根作用域空间。可以将组件名作为 CSS 类的命名空间。\n\n## 为什么？\n\n- 给样式加上作用域空间可以避免组件样式影响外部的样式。\n- 保持模块名、目录名、样式根作用域名一样，可以很好的将其关联起来，便于开发者理解。\n\n## 怎么做？\n使用组件名作为样式命名的前缀，可基于 BEM 或 OOCSS 范式。同时给 style 标签加上 scoped 属性。加上 scoped 属性编译后会给组件的 class 自动加上唯一的前缀从而避免样式的冲突。\n\n\n```\n<style scoped>\n  /* 推荐 */\n  .MyExample { }\n  .MyExample li { }\n  .MyExample__item { }\n\n  /* 避免 */\n  .My-Example { } /* 没有用组件名或模块名限制作用域, 不符合 BEM 规范 */\n</style>\n```\n\n# 尽可能使用 mixins\n## 为什么?\nMixins 封装可重用的代码，避免了重复。如果两个组件共享有相同的功能，则可以使用 mixin。通过 mixin，你可以专注于单个组件的任务和抽象的通用代码。这有助于更好地维护你的应用程序。\n\n## 怎么做?\n假设你有一个移动端和桌面端的菜单组件，它们共享一些功能。我们可以抽象出这两个组件的核心功能到一个 mixin 中，例如：\n\n\n```\nconst MenuMixin = {\n  data () {\n    return {\n      language: 'EN'\n    }\n  },\n\n  methods: {\n    changeLanguage () {\n      if (this.language === 'DE') this.$set(this, 'language', 'EN')\n      if (this.language === 'EN') this.$set(this, 'language', 'DE')\n    }\n  }\n}\n\nexport default MenuMixin\n```\n\n要使用 mixin，只需将其导入到两个组件中（我只展示移动组件）。\n\n\n```\n<template>\n  <ul class=\"mobile\">\n    <li @click=\"changeLanguage\">Change language</li>\n  </ul>\n</template>\n\n<script>\n  import MenuMixin from './MenuMixin'\n\n  export default {\n    mixins: [MenuMixin]\n  }\n</script>\n```\n","tags":["前端规范","vue"],"categories":["VUE专题"]},{"title":"前端命名规范","slug":"前端命名规范","url":"/2019/08/13/qian-duan-ming-ming-gui-fan/","content":"\n# 驼峰式命名法介绍\n- Pascal Case 大驼峰式命名法：首字母大写。eg：StudentInfo、UserInfo、ProductInfo\n- Camel Case 小驼峰式命名法：首字母小写。eg：studentInfo、userInfo、productInfo\n\n# 文件资源命名\n- 文件名不得含有空格\n- 文件名建议只使用小写字母，不使用大写字母。( 为了醒目，某些说明文件的文件名，可以使用大写字母，比如README、LICENSE。 )\n- 文件名包含多个单词时，单词之间建议使用半角的连词线 ( - ) 分隔。\n- 引入资源使用相对路径，不要指定资源所带的具体协议 ( http:,https: ) ，除非这两者协议都不可用。\n\n# 变量命名\n- 命名方式 : 小驼峰式命名方法\n- 命名规范 : 类型+对象描述的方式，如果没有明确的类型，就可以使前缀为名词\n\n\n类型 | 小写字母\n---|---\narray       | a\nboolean     | b\nfunction    | fn\nint         | i\nobject      | o\nstring      | s\n\n# 函数\n- 命名方式 : 小驼峰方式 ( 构造函数使用大驼峰命名法 )\n- 命名规则 : 前缀为动词\n\n\n动词 | 含义 | 返回值\n---|---|---\ncan | 判断是否可执行某个动作 ( 权限 )|函数返回一个布尔值。true：可执行；false：不可执行\nhas |判断是否含有某个值|函数返回一个布尔值。true：含有此值；false：不含有此值\nis\t|判断是否为某个值|\t函数返回一个布尔值。true：为某个值；false：不为某个值\nget\t|获取某个值\t|函数返回一个非布尔值\nset\t|设置某个值|\t无返回值、返回是否设置成功或者返回链式对象\n\n\n# 常量\n- 命名方法 : 全部大写\n- 命名规范 : 使用大写字母和下划线来组合命名，下划线用以分割单词。\n推荐：\n\n```\n var MAX_COUNT = 10;\n var URL = 'http://www.baidu.com';\n```\n","tags":["前端规范"],"categories":["前端规范"]},{"title":"css编写规范","slug":"CSS编写规范","url":"/2019/08/13/css-bian-xie-gui-fan/","content":"\n# id和class的命名\nID和class的名称总是使用可以反应元素目的和用途的名称，或其他通用的名称，代替表象和晦涩难懂的名称\n\n不推荐 :\n\n```\n.fw-800 {\n  font-weight: 800;\n}\n\n.red {\n  color: red;\n}\n```\n推荐 :\n\n```\n.heavy {\n  font-weight: 800;\n}\n\n.important {\n  color: red;\n}\n```\n# 合理的使用ID\n一般情况下ID不应该被用于样式，并且ID的权重很高，所以不使用ID解决样式的问题，而是使用class\n\n不推荐：\n\n```\n#content .title {\n  font-size: 2em;\n}\n```\n推荐：\n\n```\n.content .title {\n  font-size: 2em;\n}\n```\n# css选择器中避免使用标签名\n从结构、表现、行为分离的原则来看，应该尽量避免css中出现HTML标签，并且在css选择器中出现标签名会存在潜在的问题。\n\n# 使用子选择器\n很多前端开发人员写选择器链的时候不使用 直接子选择器（注：直接子选择器和后代选择器的区别）。\n有时，这可能会导致疼痛的设计问题并且有时候可能会很耗性能。然而，在任何情况下，这是一个非常不好的做法。\n如果你不写很通用的，需要匹配到DOM末端的选择器， 你应该总是考虑直接子选择器。不推荐:\n\n```\n.content .title {\n  font-size: 2rem;\n}\n```\n\n推荐\n\n```\n.content > .title {\n  font-size: 2rem;\n}\n```\n# 尽量使用缩写属性\n尽量使用缩写属性对于代码效率和可读性是很有用的，比如font属性。不推荐：\n\n```\nborder-top-style: none;\nfont-family: palatino, georgia, serif;\nfont-size: 100%;\nline-height: 1.6;\npadding-bottom: 2em;\npadding-left: 1em;\npadding-right: 1em;\npadding-top: 0;\n```\n\n推荐：\n```\nborder-top: 0;\nfont: 100%/1.6 palatino, georgia, serif;\npadding: 0 1em 2em;\n```\n\n# 0后面不带单位\n省略0后面的单位，\n\n不推荐：\n\n```\npadding-bottom: 0px;\nmargin: 0em;\n```\n推荐：\n\n```\npadding-bottom: 0;\nmargin: 0;\n```\n# 属性格式\n- 为了保证一致性和可扩展性，每个声明应该用分号结束，每个声明换行。\n- 属性名的冒号后使用一个空格。出于一致性的原因，属性和值（但属性和冒号之间没有空格）的之间始终使用一个空格。\n- 每个选择器和属性声明总是使用新的一行。\n- 属性选择器或属性值用双引号（””），而不是单引号（”）括起来。\n- URL值（url()）不要使用引号。\n\n作为最佳实践，我们应该遵循以下顺序（应该按照下表的顺序）：\n结构性属性：\n\n- display\n- position, left, top, right etc.\n- overflow, float, clear etc.\n- margin, padding\n\n表现性属性：\n\n- background, border etc.\n- font, text\n\n不推荐：\n\n```\n .box {\n  font-family: 'Arial', sans-serif;\n  border: 3px solid #ddd;\n  left: 30%;\n  position: absolute;\n  text-transform: uppercase;\n  background-color: #eee;\n  right: 30%;\n  isplay: block;\n  font-size: 1.5rem;\n  overflow: hidden;\n  padding: 1em;\n  margin: 1em;\n}\n```\n\n推荐：\n\n```\n.box {\n  display: block;\n  position: absolute;\n  left: 30%;\n  right: 30%;\n  overflow: hidden;\n  margin: 1em;\n  padding: 1em;\n  background-color: #eee;\n  border: 3px solid #ddd;\n  font-family: 'Arial', sans-serif;\n  font-size: 1.5rem;\n  text-transform: uppercase;\n}\n\n```\n# ID 和 Class（类） 名的分隔符\n使用连字符（中划线）分隔ID和Class（类）名中的单词。为了增强课理解性，在选择器中不要使用除了连字符（中划线）以为的任何字符（包括没有）来连接单词和缩写。\n\n另外，作为该标准，预设属性选择器能识别连字符（中划线）作为单词[attribute|=value]的分隔符，\n所以最好的坚持使用连字符作为分隔符。\n\n不推荐\n\n```\n.demoimage {}\n.error_status {}\n```\n推荐\n\n```\n#video-id {}\n.ads-sample {}\n```\n","tags":["css","前端规范"],"categories":["前端基础"]},{"title":"前端请求方式：xhr、ajax、axios与fetch的区别比较","slug":"前端请求方式：xhr、ajax、axios与fetch的区别比较","url":"/2017/06/13/qian-duan-qing-qiu-fang-shi-xhr-ajax-axios-yu-fetch-de-qu-bie-bi-jiao/","content":"\n这些都是异步请求数据的方法。在不重新刷新页面的情况下与服务器通信，交换数据，或更新页面。\n\n# XMLHttpRequest对象\n优点：\n- 不重新加载页面的情况下更新网页\n- 在页面已加载后从服务器请求/接收数据\n- 在后台向服务器发送数据\n\n缺点：\n- 使用起来也比较繁琐，需要设置很多值。\n- 早期的IE浏览器有自己的实现，这样需要写兼容代码。\n\n\n示例：\n```\nif (window.XMLHttpRequest) { // model browser\n  xhr = new XMLHttpRequest()\n} else if (window.ActiveXObject) { // IE 6 and older\n  xhr = new ActiveXObject('Microsoft.XMLHTTP')\n}\nxhr.open('POST', url, true)\nxhr.send(data)\nxhr.onreadystatechange = function () {\nif (request.readyState === 4) { // 成功完成\n        // 判断响应状态码\n        if (request.status === 200) {\n            // 成功，通过responseText拿到响应的文本:\n            return success(request.responseText);\n        } else {\n            // 失败，根据响应码判断失败原因:\n            return fail(request.status);\n        }\n    } else {\n        // HTTP请求还在继续...\n    }\n}\n```\n\n#  jQuery ajax\nAJAX请求也兼容了各浏览器，对XMLHttpRequest对象的封装。\n\n\n优点：\n- 对原生XHR的封装，做了兼容处理，简化了使用。\n- 增加了对JSONP的支持，可以简单处理部分跨域。\n \n\n缺点：\n- 如果有多个请求，并且有依赖关系的话，容易形成回调地狱。\n- 本身是针对MVC的编程，不符合现在前端MVVM的浪潮。\n- ajax是jQuery中的一个方法。如果只是要使用ajax却要引入整个jQuery非常的不合理。\n\n示例：\n\n```\n$.ajax({\n  type: 'POST',\n  url: url, \n  data: data,\n  dataType: dataType,\n  success: function () {},\n  error: function () {}\n})\n```\n\n# axios\n\nAxios是一个基于promise的HTTP库，可以用在浏览器和 node.js 中。它本质也是对原生XMLHttpRequest的封装，只不过它是Promise的实现版本，符合最新的ES规范。\n\n\n优点：\n- 从浏览器中创建XMLHttpRequests\n- 从 node.js 创建 http 请求\n- 支持 Promise API\n- 拦截请求和响应\n- 转换请求数据和响应数据\n- 取消请求\n- 自动转换 JSON 数据\n- 客户端支持防御 XSRF\n\n\n缺点：\n- 只持现代代浏览器。\n\n```\naxios({\n    method: 'post',\n    url: '/user/12345',\n    data: {\n      firstName: 'liu',\n      lastName: 'weiqin'\n    }\n  })\n  .then(res => console.log(res))\n  .catch(err => console.log(err))\n```\n\n\n# fetch\n优点：\n- 语法简洁，更加语义化\n- 基于标准 Promise 实现，支持 async/await\n\n缺点：\n- Fetch 请求默认是不带 cookie 的，需要设置 fetch(url, {credentials: 'include'})\n- 服务器返回 400，500 错误码时并不会 reject，只有网络错误这些导致请求不能完成时，fetch 才会被 reject。\n\n示例：\n\n```\nfetch('http://example.com/movies.json')\n  .then(function(response) {\n    return response.json();\n  })\n  .then(function(myJson) {\n    console.log(myJson);\n  });\n```\n\nts对fetch简单封装下：\n\n```\nimport _ from 'lodash';\nimport 'whatwg-fetch';\n\ninterface ReqInit extends RequestInit {\n  headers?: Record<string, string>;\n  /** eg. ?a=1 */\n  params?: { [key: string]: any };\n  /** eg. /:id/.. */\n  router?: { [key: string]: any };\n  /** 超时时间，默认3000 */\n  timeout?: number;\n}\n\nasync function request<T = any>(path: string, init: ReqInit = {}): Promise<T> {\n  const mergeInit = {\n    ...request.default,\n    ...init,\n    headers: { ...request.default.headers, ...init.headers },\n  };\n  const { params, router, body, timeout, headers } = mergeInit;\n  let url = path;\n\n  if (router) {\n    url = path.replace(/:([A-Za-z]+)/g, (substring, p1: string) => router[p1]);\n  }\n  if (params) {\n    url += _(\n      _.reduce(params, (prev, val, key) => `${prev}${key}=${val}&`, '?'),\n    ).trimEnd('&');\n  }\n\n  if (!Reflect.get(headers, 'Content-Type')) {\n    if (typeof body === 'string') {\n      Reflect.set(headers, 'Content-Type', 'application/json');\n    }\n  }\n\n  try {\n    const response: Response = await Promise.race([\n      fetch(url, mergeInit),\n      new Promise<any>((resolve, reject) => {\n        setTimeout(\n          () => reject({ status: 408, statusText: 'TIME_OUT_ERR', url }),\n          timeout,\n        );\n      }),\n    ]);\n\n    if (response.ok) {\n      if (request.interceptors.response) {\n        return await request.interceptors.response(response);\n      }\n      return await response.json();\n    }\n    throw response;\n  } catch (error) {\n    if (request.interceptors.catch) {\n      request.interceptors.catch(error);\n    }\n\n    throw error;\n  }\n}\n\nrequest.default = {\n  method: 'GET',\n  headers: {\n    Accept: '*/*',\n  },\n  mode: 'cors',\n  timeout: 3000,\n  // credentials: 'include' // send cookies\n} as ReqInit;\n\nrequest.interceptors = {\n  response: null,\n  catch: null,\n} as {\n  response: ((response: Response) => Promise<any>) | null;\n  catch: ((error: Partial<Response>) => void) | null;\n};\n\nexport default request;\n\n```\n\n","tags":["数据请求","前端基础"],"categories":["前端基础"]}]