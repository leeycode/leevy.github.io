{"title":"nginx超时设置","slug":"nginx超时设置","date":"2020-12-16T03:12:36.000Z","updated":"2022-01-05T09:29:03.971Z","comments":true,"path":"api/articles/nginx超时设置.json","excerpt":null,"covers":null,"content":"<p>nginx访问出现504 Gateway Time-out，一般是由于程序执行时间过长导致响应超时，例如程序需要执行90秒，而nginx最大响应等待时间为30秒，这样就会出现超时。</p>\n<h2 id=\"导致超时的场景\"><a href=\"#导致超时的场景\" class=\"headerlink\" title=\"导致超时的场景\"></a>导致超时的场景</h2><ol>\n<li>程序在处理大量数据，导致等待超时。</li>\n<li>程序中调用外部请求，而外部请求响应超时。</li>\n<li>连接数据库失败而没有停止，死循环重新连。</li>\n</ol>\n<h2 id=\"nginx常用的超时配置说明\"><a href=\"#nginx常用的超时配置说明\" class=\"headerlink\" title=\"nginx常用的超时配置说明\"></a>nginx常用的超时配置说明</h2><h3 id=\"client-header-timeout\"><a href=\"#client-header-timeout\" class=\"headerlink\" title=\"client_header_timeout\"></a>client_header_timeout</h3><p>语法 client_header_timeout time<br>默认值 60s<br>上下文 http server<br>说明 指定等待client发送一个请求头的超时时间（例如：GET / HTTP/1.1）.仅当在一次read中，没有收到请求头，才会算成超时。如果在超时时间内，client没发送任何东西，nginx返回HTTP状态码408(“Request timed out”)</p>\n<h3 id=\"client-body-timeout\"><a href=\"#client-body-timeout\" class=\"headerlink\" title=\"client_body_timeout\"></a>client_body_timeout</h3><p>语法 client_body_timeout time<br>默认值 60s<br>上下文 http server location<br>说明 该指令设置请求体（request body）的读超时时间。仅当在一次readstep中，没有得到请求体，就会设为超时。超时后，nginx返回HTTP状态码408(“Request timed out”)</p>\n<h3 id=\"keepalive-timeout\"><a href=\"#keepalive-timeout\" class=\"headerlink\" title=\"keepalive_timeout\"></a>keepalive_timeout</h3><p>语法 keepalive_timeout timeout [ header_timeout ]<br>默认值 75s<br>上下文 http server location<br>说明 第一个参数指定了与client的keep-alive连接超时时间。服务器将会在这个时间后关闭连接。可选的第二个参数指定了在响应头Keep-Alive: timeout=time中的time值。这个头能够让一些浏览器主动关闭连接，这样服务器就不必要去关闭连接了。没有这个参数，nginx不会发送Keep-Alive响应头（尽管并不是由这个头来决定连接是否“keep-alive”）<br>两个参数的值可并不相同</p>\n<p>注意不同浏览器怎么处理“keep-alive”头<br>MSIE和Opera忽略掉”Keep-Alive: timeout=<n>“ header.<br>MSIE保持连接大约60-65秒，然后发送TCP RST<br>Opera永久保持长连接<br>Mozilla keeps the connection alive for N plus about 1-10 seconds.<br>Konqueror保持长连接N秒</n></p>\n<h3 id=\"lingering-timeout\"><a href=\"#lingering-timeout\" class=\"headerlink\" title=\"lingering_timeout\"></a>lingering_timeout</h3><p>语法 lingering_timeout time<br>默认值 5s<br>上下文 http server location<br>说明 lingering_close生效后，在关闭连接前，会检测是否有用户发送的数据到达服务器，如果超过lingering_timeout时间后还没有数据可读，就直接关闭连接；否则，必须在读取完连接缓冲区上的数据并丢弃掉后才会关闭连接。</p>\n<h3 id=\"resolver-timeout\"><a href=\"#resolver-timeout\" class=\"headerlink\" title=\"resolver_timeout\"></a>resolver_timeout</h3><p>语法 resolver_timeout time<br>默认值 30s<br>上下文 http server location<br>说明 该指令设置DNS解析超时时间</p>\n<h3 id=\"proxy-connect-timeout\"><a href=\"#proxy-connect-timeout\" class=\"headerlink\" title=\"proxy_connect_timeout\"></a>proxy_connect_timeout</h3><p>语法 proxy_connect_timeout time<br>默认值 60s<br>上下文 http server location<br>说明 该指令设置与upstream server的连接超时时间，有必要记住，这个超时不能超过75秒。<br>这个不是等待后端返回页面的时间，那是由proxy_read_timeout声明的。如果你的upstream服务器起来了，但是hanging住了（例如，没有足够的线程处理请求，所以把你的请求放到请求池里稍后处理），那么这个声明是没有用的，由于与upstream服务器的连接已经建立了。</p>\n<h3 id=\"proxy-read-timeout\"><a href=\"#proxy-read-timeout\" class=\"headerlink\" title=\"proxy_read_timeout\"></a>proxy_read_timeout</h3><p>语法 proxy_read_timeout time<br>默认值 60s<br>上下文 http server location<br>说明 该指令设置与代理服务器的读超时时间。它决定了nginx会等待多长时间来获得请求的响应。这个时间不是获得整个response的时间，而是两次reading操作的时间。</p>\n<h3 id=\"proxy-send-timeout\"><a href=\"#proxy-send-timeout\" class=\"headerlink\" title=\"proxy_send_timeout\"></a>proxy_send_timeout</h3><p>语法 proxy_send_timeout time<br>默认值 60s<br>上下文 http server location<br>说明 这个指定设置了发送请求给upstream服务器的超时时间。超时设置不是为了整个发送期间，而是在两次write操作期间。如果超时后，upstream没有收到新的数据，nginx会关闭连接</p>\n<h3 id=\"proxy-upstream-fail-timeout（fail-timeout）\"><a href=\"#proxy-upstream-fail-timeout（fail-timeout）\" class=\"headerlink\" title=\"proxy_upstream_fail_timeout（fail_timeout）\"></a>proxy_upstream_fail_timeout（fail_timeout）</h3><p>语法 server address [fail_timeout=30s]<br>默认值 10s<br>上下文 upstream<br>说明 Upstream模块下 server指令的参数，设置了某一个upstream后端失败了指定次数（max_fails）后，该后端不可操作的时间，默认为10秒</p>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><h3 id=\"请求超时\"><a href=\"#请求超时\" class=\"headerlink\" title=\"请求超时\"></a>请求超时</h3><pre><code>http {\n    include       mime.types;\n    server_names_hash_bucket_size  512;     \n    default_type  application/octet-stream;\n    sendfile        on;\n    keepalive_timeout  65;  #保持\n    tcp_nodelay on;\n    client_header_timeout 15;\n    client_body_timeout 15;\n    send_timeout 25;\n    include vhosts/*.conf;\n}</code></pre>\n<h3 id=\"后端服务器处理请求的时间设置\"><a href=\"#后端服务器处理请求的时间设置\" class=\"headerlink\" title=\"后端服务器处理请求的时间设置\"></a>后端服务器处理请求的时间设置</h3><p>如果只集成了一台nginx机器不用设置</p>\n<pre><code>location / {\n        ...\n        proxy_read_timeout 150;  # 秒\n        ...\n    }</code></pre>\n","more":"<p>nginx访问出现504 Gateway Time-out，一般是由于程序执行时间过长导致响应超时，例如程序需要执行90秒，而nginx最大响应等待时间为30秒，这样就会出现超时。</p>\n<h2 id=\"导致超时的场景\"><a href=\"#导致超时的场景\" class=\"headerlink\" title=\"导致超时的场景\"></a>导致超时的场景</h2><ol>\n<li>程序在处理大量数据，导致等待超时。</li>\n<li>程序中调用外部请求，而外部请求响应超时。</li>\n<li>连接数据库失败而没有停止，死循环重新连。</li>\n</ol>\n<h2 id=\"nginx常用的超时配置说明\"><a href=\"#nginx常用的超时配置说明\" class=\"headerlink\" title=\"nginx常用的超时配置说明\"></a>nginx常用的超时配置说明</h2><h3 id=\"client-header-timeout\"><a href=\"#client-header-timeout\" class=\"headerlink\" title=\"client_header_timeout\"></a>client_header_timeout</h3><p>语法 client_header_timeout time<br>默认值 60s<br>上下文 http server<br>说明 指定等待client发送一个请求头的超时时间（例如：GET / HTTP/1.1）.仅当在一次read中，没有收到请求头，才会算成超时。如果在超时时间内，client没发送任何东西，nginx返回HTTP状态码408(“Request timed out”)</p>\n<h3 id=\"client-body-timeout\"><a href=\"#client-body-timeout\" class=\"headerlink\" title=\"client_body_timeout\"></a>client_body_timeout</h3><p>语法 client_body_timeout time<br>默认值 60s<br>上下文 http server location<br>说明 该指令设置请求体（request body）的读超时时间。仅当在一次readstep中，没有得到请求体，就会设为超时。超时后，nginx返回HTTP状态码408(“Request timed out”)</p>\n<h3 id=\"keepalive-timeout\"><a href=\"#keepalive-timeout\" class=\"headerlink\" title=\"keepalive_timeout\"></a>keepalive_timeout</h3><p>语法 keepalive_timeout timeout [ header_timeout ]<br>默认值 75s<br>上下文 http server location<br>说明 第一个参数指定了与client的keep-alive连接超时时间。服务器将会在这个时间后关闭连接。可选的第二个参数指定了在响应头Keep-Alive: timeout=time中的time值。这个头能够让一些浏览器主动关闭连接，这样服务器就不必要去关闭连接了。没有这个参数，nginx不会发送Keep-Alive响应头（尽管并不是由这个头来决定连接是否“keep-alive”）<br>两个参数的值可并不相同</p>\n<p>注意不同浏览器怎么处理“keep-alive”头<br>MSIE和Opera忽略掉”Keep-Alive: timeout=<N>“ header.<br>MSIE保持连接大约60-65秒，然后发送TCP RST<br>Opera永久保持长连接<br>Mozilla keeps the connection alive for N plus about 1-10 seconds.<br>Konqueror保持长连接N秒</p>\n<h3 id=\"lingering-timeout\"><a href=\"#lingering-timeout\" class=\"headerlink\" title=\"lingering_timeout\"></a>lingering_timeout</h3><p>语法 lingering_timeout time<br>默认值 5s<br>上下文 http server location<br>说明 lingering_close生效后，在关闭连接前，会检测是否有用户发送的数据到达服务器，如果超过lingering_timeout时间后还没有数据可读，就直接关闭连接；否则，必须在读取完连接缓冲区上的数据并丢弃掉后才会关闭连接。</p>\n<h3 id=\"resolver-timeout\"><a href=\"#resolver-timeout\" class=\"headerlink\" title=\"resolver_timeout\"></a>resolver_timeout</h3><p>语法 resolver_timeout time<br>默认值 30s<br>上下文 http server location<br>说明 该指令设置DNS解析超时时间</p>\n<h3 id=\"proxy-connect-timeout\"><a href=\"#proxy-connect-timeout\" class=\"headerlink\" title=\"proxy_connect_timeout\"></a>proxy_connect_timeout</h3><p>语法 proxy_connect_timeout time<br>默认值 60s<br>上下文 http server location<br>说明 该指令设置与upstream server的连接超时时间，有必要记住，这个超时不能超过75秒。<br>这个不是等待后端返回页面的时间，那是由proxy_read_timeout声明的。如果你的upstream服务器起来了，但是hanging住了（例如，没有足够的线程处理请求，所以把你的请求放到请求池里稍后处理），那么这个声明是没有用的，由于与upstream服务器的连接已经建立了。</p>\n<h3 id=\"proxy-read-timeout\"><a href=\"#proxy-read-timeout\" class=\"headerlink\" title=\"proxy_read_timeout\"></a>proxy_read_timeout</h3><p>语法 proxy_read_timeout time<br>默认值 60s<br>上下文 http server location<br>说明 该指令设置与代理服务器的读超时时间。它决定了nginx会等待多长时间来获得请求的响应。这个时间不是获得整个response的时间，而是两次reading操作的时间。</p>\n<h3 id=\"proxy-send-timeout\"><a href=\"#proxy-send-timeout\" class=\"headerlink\" title=\"proxy_send_timeout\"></a>proxy_send_timeout</h3><p>语法 proxy_send_timeout time<br>默认值 60s<br>上下文 http server location<br>说明 这个指定设置了发送请求给upstream服务器的超时时间。超时设置不是为了整个发送期间，而是在两次write操作期间。如果超时后，upstream没有收到新的数据，nginx会关闭连接</p>\n<h3 id=\"proxy-upstream-fail-timeout（fail-timeout）\"><a href=\"#proxy-upstream-fail-timeout（fail-timeout）\" class=\"headerlink\" title=\"proxy_upstream_fail_timeout（fail_timeout）\"></a>proxy_upstream_fail_timeout（fail_timeout）</h3><p>语法 server address [fail_timeout=30s]<br>默认值 10s<br>上下文 upstream<br>说明 Upstream模块下 server指令的参数，设置了某一个upstream后端失败了指定次数（max_fails）后，该后端不可操作的时间，默认为10秒</p>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><h3 id=\"请求超时\"><a href=\"#请求超时\" class=\"headerlink\" title=\"请求超时\"></a>请求超时</h3><pre><code>http &#123;\n    include       mime.types;\n    server_names_hash_bucket_size  512;     \n    default_type  application/octet-stream;\n    sendfile        on;\n    keepalive_timeout  65;  #保持\n    tcp_nodelay on;\n    client_header_timeout 15;\n    client_body_timeout 15;\n    send_timeout 25;\n    include vhosts/*.conf;\n&#125;</code></pre>\n<h3 id=\"后端服务器处理请求的时间设置\"><a href=\"#后端服务器处理请求的时间设置\" class=\"headerlink\" title=\"后端服务器处理请求的时间设置\"></a>后端服务器处理请求的时间设置</h3><p>如果只集成了一台nginx机器不用设置</p>\n<pre><code>location / &#123;\n        ...\n        proxy_read_timeout 150;  # 秒\n        ...\n    &#125;</code></pre>\n","categories":[{"name":"nginx专题","path":"api/categories/nginx专题.json"}],"tags":[{"name":"nginx","path":"api/tags/nginx.json"}]}