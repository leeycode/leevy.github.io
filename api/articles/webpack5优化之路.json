{"title":"webpack5优化之路","slug":"webpack5优化之路","date":"2023-07-31T07:24:49.000Z","updated":"2023-08-09T02:15:25.259Z","comments":true,"path":"api/articles/webpack5优化之路.json","excerpt":null,"covers":null,"content":"<p>本篇将从优化开发体验、加快编译速度、减小打包体积、加快加载速度 4 个角度出发，介绍如何对 webpack 项目进行优化。</p>\n<h1 id=\"优化效率工具\"><a href=\"#优化效率工具\" class=\"headerlink\" title=\"优化效率工具\"></a>优化效率工具</h1><p>安装以下 webpack 插件，帮助我们分析优化效率：</p>\n<ul>\n<li>progress-bar-webpack-plugin：查看编译进度；</li>\n<li>speed-measure-webpack-plugin：查看编译速度；</li>\n<li>webpack-bundle-analyzer：打包体积分析。</li>\n</ul>\n<h2 id=\"1-编译进度条\"><a href=\"#1-编译进度条\" class=\"headerlink\" title=\"1. 编译进度条\"></a>1. 编译进度条</h2><p>一般来说，中型项目的首次编译时间为 5-20s，没个进度条等得多着急，通过 progress-bar-webpack-plugin 插件查看编译进度，方便我们掌握编译情况。</p>\n<p>安装：</p>\n<pre><code>npm i -D progress-bar-webpack-plugin</code></pre>\n<p>webpack.common.js 配置方式如下：</p>\n<pre><code>const chalk = require('chalk')\nconst ProgressBarPlugin = require('progress-bar-webpack-plugin')\nmodule.exports = {\n  plugins: [\n    // 进度条 贴心的为进度百分比添加了加粗和绿色高亮态样式。\n    new ProgressBarPlugin({\n        format: `  :msg [:bar] ${chalk.green.bold(':percent')} (:elapsed s)`\n      })\n  ],\n}\n</code></pre>\n<h2 id=\"2-编译速度分析\"><a href=\"#2-编译速度分析\" class=\"headerlink\" title=\"2. 编译速度分析\"></a>2. 编译速度分析</h2><p>优化 webpack 构建速度，首先需要知道是哪些插件、哪些 loader 耗时长，方便我们针对性的优化。<br>通过 speed-measure-webpack-plugin 插件进行构建速度分析，可以看到各个 loader、plugin 的构建时长，后续可针对耗时 loader、plugin 进行优化。</p>\n<p>安装：</p>\n<pre><code>npm i -D speed-measure-webpack-plugin</code></pre>\n<p>webpack.dev.js 配置方式如下：</p>\n<pre><code>\nconst SpeedMeasurePlugin = require(\"speed-measure-webpack-plugin\");\nconst smp = new SpeedMeasurePlugin();\nmodule.exports = smp.wrap({\n  // ...webpack config...\n})\n</code></pre>\n<h2 id=\"3-打包体积分析\"><a href=\"#3-打包体积分析\" class=\"headerlink\" title=\"3. 打包体积分析\"></a>3. 打包体积分析</h2><p>使用 webpack-bundle-analyzer 查看打包后生成的 bundle 体积分析，将 bundle 内容展示为一个便捷的、交互式、可缩放的树状图形式。帮助我们分析输出结果来检查模块在何处结束。</p>\n<p>安装：</p>\n<pre><code>npm i -D webpack-bundle-analyzer</code></pre>\n<p>webpack.prod.js 配置方式如下：</p>\n<pre><code>\nconst BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;\nmodule.exports = {\n  plugins: [\n    // 打包体积分析\n    new BundleAnalyzerPlugin()\n  ],\n}\n</code></pre>\n<h1 id=\"优化开发体验\"><a href=\"#优化开发体验\" class=\"headerlink\" title=\"优化开发体验\"></a>优化开发体验</h1><h2 id=\"1-自动更新\"><a href=\"#1-自动更新\" class=\"headerlink\" title=\"1. 自动更新\"></a>1. 自动更新</h2><p>自动更新 指的是，在开发过程中，修改代码后，无需手动再次编译，可以自动编译代码更新编译后代码的功能。<br>webpack 提供了以下几种可选方式，实现自动更新功能：</p>\n<ul>\n<li>webpack’s&nbsp;Watch Mode</li>\n<li>webpack-dev-server</li>\n<li>webpack-dev-middleware</li>\n</ul>\n<h2 id=\"2-热更新\"><a href=\"#2-热更新\" class=\"headerlink\" title=\"2. 热更新\"></a>2. 热更新</h2><p>热更新 指的是，在开发过程中，修改代码后，仅更新修改部分的内容，无需刷新整个页面。</p>\n<p>使用 webpack 内置的 HMR 插件，更新 webpack-dev-server 配置。</p>\n<p>webpack.dev.js 配置方式如下：</p>\n<pre><code>module.export = {\n    devServer: {\n        contentBase: './dist',\n        hot: true, // 热更新\n      },\n}\n</code></pre>\n<h1 id=\"加快构建速度\"><a href=\"#加快构建速度\" class=\"headerlink\" title=\"加快构建速度\"></a>加快构建速度</h1><h2 id=\"1-更新版本\"><a href=\"#1-更新版本\" class=\"headerlink\" title=\"1. 更新版本\"></a>1. 更新版本</h2><ul>\n<li><p>webpack 版本<br>使用最新的 webpack 版本，通过 webpack 自身的迭代优化，来加快构建速度。这一点是非常有效的，如 webpack5 较于 webpack4，新增了持久化缓存、改进缓存算法等优化。</p>\n</li>\n<li><p>包管理工具版本</p>\n</li>\n</ul>\n<p>将 Node.js 、package 管理工具（例如 npm 或者 yarn）更新到最新版本，也有助于提高性能。较新的版本能够建立更高效的模块树以及提高解析速度。</p>\n<h2 id=\"2-缓存\"><a href=\"#2-缓存\" class=\"headerlink\" title=\"2. 缓存\"></a>2. 缓存</h2><ul>\n<li>cache<br>通过配置 webpack 持久化缓存 cache: filesystem，来缓存生成的 webpack 模块和 chunk，改善构建速度。<br>简单来说，通过 cache: filesystem 可以将构建过程的 webpack 模板进行缓存，大幅提升二次构建速度、打包速度，当构建突然中断，二次进行构建时，可以直接从缓存中拉取，可提速 90% 左右。</li>\n</ul>\n<p>webpack.common.js 配置方式如下：</p>\n<pre><code>module.exports = {\n    cache: {\n      type: 'filesystem', // 使用文件缓存\n    },\n}\n</code></pre>\n<ul>\n<li>dll动态链接库</li>\n</ul>\n<p>使用 DllPlugin 为更改不频繁的代码生成单独的编译结果。这可以提高应用程序的编译速度，尽管它增加了构建过程的复杂度。<br>但是用上webpage4版本，DLL优化效率有限， webpack5 开箱即用的持久缓存是比 dll 更优的解决方案。</p>\n<h2 id=\"减少-loader、plugins\"><a href=\"#减少-loader、plugins\" class=\"headerlink\" title=\"减少 loader、plugins\"></a>减少 loader、plugins</h2><p>每个的 loader、plugin 都有其启动时间。尽量少地使用工具，将非必须的 loader、plugins 删除。</p>\n<ul>\n<li>指定 include<br>为 loader 指定 include，减少 loader 应用范围，仅应用于最少数量的必要模块，</li>\n</ul>\n<p>webpack.common.js 配置方式如下：</p>\n<pre><code>module.exports = {\n    rules: [\n        {\n            test: /\\.(js|ts|jsx|tsx)$/,\n            include: paths.appSrc,\n            use: [\n              {\n                loader: 'esbuild-loader',\n                options: {\n                  loader: 'tsx',\n                  target: 'es2015',\n                },\n              }\n            ]\n         }\n    ]\n}\n</code></pre>\n<p>定义 loader 的 include 后，构建时间将减少 12%。</p>\n<ul>\n<li>管理资源</li>\n</ul>\n<p>使用 webpack 资源模块 (asset module) 代替旧的 assets loader（如 file-loader/url-loader/raw-loader 等），减少 loader 配置数量。</p>\n<pre><code>module.exports = {\n    rules: [\n       {\n        test: /\\.(png|svg|jpg|jpeg|gif)$/i,\n        include: [\n          paths.appSrc,\n        ],\n        type: 'asset/resource',\n      },\n    ]\n}\n</code></pre>\n<p>引入资源模块后，构建时间将减少 7%。</p>\n<h2 id=\"优化-resolve-配置\"><a href=\"#优化-resolve-配置\" class=\"headerlink\" title=\"优化 resolve 配置\"></a>优化 resolve 配置</h2><ul>\n<li>alias</li>\n</ul>\n<p>alias 可以创建 import 或 require 的别名，用来简化模块引入。</p>\n<p>webpack.common.js 配置方式如下：</p>\n<pre><code>module.exports = {\n    resolve: {\n        alias: {\n          '@': paths.appSrc, // @ 代表 src 路径\n        },\n    }\n}\n\n</code></pre>\n<ul>\n<li>extensions</li>\n</ul>\n<p>extensions 表示需要解析的文件类型列表。<br>根据项目中的文件类型，定义 extensions，以覆盖 webpack 默认的 extensions，加快解析速度。<br>由于 webpack 的解析顺序是从左到右，因此要将使用频率高的文件类型放在左侧，如下我将 tsx 放在最左侧。</p>\n<p>webpack.common.js 配置方式如下：</p>\n<pre><code>module.exports = {\n    resolve: {\n        extensions: ['.tsx', '.js'], // 因为我的项目只有这两种类型的文件，如果有其他类型，需要添加进去。\n    }\n}\n</code></pre>\n<ul>\n<li>modules</li>\n</ul>\n<p>modules 表示 webpack 解析模块时需要解析的目录。</p>\n<p>指定目录可缩小 webpack 解析范围，加快构建速度。</p>\n<p>webpack.common.js 配置方式如下：</p>\n<pre><code>module.exports = {\n    modules: [\n      'node_modules',\n       paths.appSrc,\n    ]\n}\n</code></pre>\n<ul>\n<li>symlinks</li>\n</ul>\n<p>如果项目不使用 symlinks（例如 npm link 或者 yarn link），可以设置 resolve.symlinks: false，减少解析工作量。</p>\n<p>webpack.common.js 配置方式如下：</p>\n<pre><code>module.exports = {\n    resolve: {\n        symlinks: false,\n    },\n}\n</code></pre>\n<p>优化 resolve 配置后，构建时间将减少 1.5%</p>\n<h2 id=\"多进程\"><a href=\"#多进程\" class=\"headerlink\" title=\"多进程\"></a>多进程</h2><p>可以通过多进程来实现，比如将 sass-loader 放在一个独立的 worker 池中运行，就不会阻碍其他 loader 的构建了，可以大大加快构建速度。</p>\n<ul>\n<li>thread-loader</li>\n</ul>\n<pre><code>npm i -D thread-loader</code></pre>\n<p>webpack.common.js 配置方式如下：</p>\n<pre><code>module.exports = {\n    rules: [\n        {\n        test: /\\.module\\.(scss|sass)$/,\n        include: paths.appSrc,\n        use: [\n          'style-loader',\n          {\n            loader: 'css-loader',\n            options: {\n              modules: true,\n              importLoaders: 2,\n            },\n          },\n          {\n            loader: 'postcss-loader',\n            options: {\n              postcssOptions: {\n                plugins: [\n                  [\n                    'postcss-preset-env',\n                  ],\n                ],\n              },\n            },\n          },\n          {\n            loader: 'thread-loader',\n            options: {\n              workerParallelJobs: 2\n            }\n          },\n          'sass-loader',\n        ].filter(Boolean),\n      },\n    ]\n}\n</code></pre>\n<h1 id=\"减小打包体积\"><a href=\"#减小打包体积\" class=\"headerlink\" title=\"减小打包体积\"></a>减小打包体积</h1><h2 id=\"1-代码压缩\"><a href=\"#1-代码压缩\" class=\"headerlink\" title=\"1. 代码压缩\"></a>1. 代码压缩</h2><p>体积优化第一步是压缩代码，通过 webpack 插件，将 JS、CSS 等文件进行压缩。</p>\n<ul>\n<li>JS 压缩</li>\n</ul>\n<p>webpack5 自带最新的&nbsp;terser-webpack-plugin，无需手动安装。<br>terser-webpack-plugin 默认开启了 parallel: true 配置，并发运行的默认数量：&nbsp;os.cpus().length - 1&nbsp;，本文配置的 parallel 数量为 4，使用多进程并发运行压缩以提高构建速度。</p>\n<p>webpack.prod.js 配置方式如下：</p>\n<pre><code>const TerserPlugin = require('terser-webpack-plugin');\nmodule.exports = {\n    optimization: {\n        minimizer: [\n            new TerserPlugin({\n              parallel: 4,\n              terserOptions: {\n                parse: {\n                  ecma: 8,\n                },\n                compress: {\n                  ecma: 5,\n                  warnings: false,\n                  comparisons: false,\n                  inline: 2,\n                },\n                mangle: {\n                  safari10: true,\n                },\n                output: {\n                  ecma: 5,\n                  comments: false,\n                  ascii_only: true,\n                },\n              },\n            }),\n        ]\n    }\n}\n\n</code></pre>\n<ul>\n<li>CSS 压缩<br>使用 CssMinimizerWebpackPlugin 压缩 CSS 文件。</li>\n</ul>\n<p>安装：</p>\n<pre><code>npm install -D css-minimizer-webpack-plugin\n</code></pre>\n<p>webpack.prod.js 配置方式如下：</p>\n<pre><code>const CssMinimizerPlugin = require(\"css-minimizer-webpack-plugin\");\n\nmodule.exports = {\n  optimization: {\n    minimizer: [\n      new CssMinimizerPlugin({\n          parallel: 4,\n        }),\n    ],\n  }\n}\n</code></pre>\n<h2 id=\"2-代码分离\"><a href=\"#2-代码分离\" class=\"headerlink\" title=\"2. 代码分离\"></a>2. 代码分离</h2><p>代码分离能够把代码分离到不同的 bundle 中，然后可以按需加载或并行加载这些文件。代码分离可以用于获取更小的 bundle，以及控制资源加载优先级，可以缩短页面加载时间。</p>\n<ul>\n<li>抽离重复代码</li>\n</ul>\n<p>SplitChunksPlugin&nbsp;插件开箱即用，可以将公共的依赖模块提取到已有的入口 chunk 中，或者提取到一个新生成的 chunk。<br>webpack 将根据以下条件自动拆分 chunks：</p>\n<ol>\n<li>新的 chunk 可以被共享，或者模块来自于&nbsp;node_modules&nbsp;文件夹；</li>\n<li>新的 chunk 体积大于 20kb（在进行 min+gz 之前的体积）；</li>\n<li>当按需加载 chunks 时，并行请求的最大数量小于或等于 30；</li>\n<li>当加载初始化页面时，并发请求的最大数量小于或等于 30；通过 splitChunks 把 react 等公共库抽离出来，不重复引入占用体积。</li>\n</ol>\n<blockquote>\n<p>注意：切记不要为 cacheGroups 定义固定的 name，因为 cacheGroups.name 指定字符串或始终返回相同字符串的函数时，会将所有常见模块和 vendor 合并为一个 chunk。这会导致更大的初始下载量并减慢页面加载速度。</p>\n</blockquote>\n<p>webpack.prod.js 配置方式如下：</p>\n<pre><code>module.exports = {\n    splitChunks: {\n      // include all types of chunks\n      chunks: 'all',\n      // 重复打包问题\n      cacheGroups:{\n        vendors:{ // node_modules里的代码\n          test: /[\\\\/]node_modules[\\\\/]/,\n          chunks: \"all\",\n          // name: 'vendors', 一定不要定义固定的name\n          priority: 10, // 优先级\n          enforce: true \n        }\n      }\n    },\n}\n</code></pre>\n<ul>\n<li> CSS 文件分离</li>\n</ul>\n<p>MiniCssExtractPlugin 插件将 CSS 提取到单独的文件中，为每个包含 CSS 的 JS 文件创建一个 CSS 文件，并且支持 CSS 和 SourceMaps 的按需加载。</p>\n<p>安装：</p>\n<pre><code>npm install -D mini-css-extract-plugin\n</code></pre>\n<p>webpack.common.js 配置方式如下：</p>\n<pre><code>const MiniCssExtractPlugin = require(\"mini-css-extract-plugin\");\n\nmodule.exports = {\n  plugins: [new MiniCssExtractPlugin()],\n  module: {\n    rules: [\n        {\n        test: /\\.module\\.(scss|sass)$/,\n        include: paths.appSrc,\n        use: [\n          'style-loader',\n          isEnvProduction &amp;&amp; MiniCssExtractPlugin.loader, // 仅生产环境\n          {\n            loader: 'css-loader',\n            options: {\n              modules: true,\n              importLoaders: 2,\n            },\n          },\n          {\n            loader: 'postcss-loader',\n            options: {\n              postcssOptions: {\n                plugins: [\n                  [\n                    'postcss-preset-env',\n                  ],\n                ],\n              },\n            },\n          },\n          {\n            loader: 'thread-loader',\n            options: {\n              workerParallelJobs: 2\n            }\n          },\n          'sass-loader',\n        ].filter(Boolean),\n      },\n    ]\n  },\n};\n</code></pre>\n<blockquote>\n<p>注意：MiniCssExtractPlugin.loader 要放在 style-loader 后面。</p>\n</blockquote>\n<ul>\n<li>最小化 entry chunk</li>\n</ul>\n<p>通过配置 optimization.runtimeChunk = true，为运行时代码创建一个额外的 chunk，减少 entry chunk 体积，提高性能。</p>\n<p>webpack.prod.js 配置方式如下：</p>\n<pre><code>module.exports = {\n    optimization: {\n        runtimeChunk: true,\n      },\n    };\n}\n</code></pre>\n<h2 id=\"Tree-Shaking（摇树）\"><a href=\"#Tree-Shaking（摇树）\" class=\"headerlink\" title=\"Tree Shaking（摇树）\"></a>Tree Shaking（摇树）</h2><p>摇树，顾名思义，就是将枯黄的落叶摇下来，只留下树上活的叶子。枯黄的落叶代表项目中未引用的无用代码，活的树叶代表项目中实际用到的源</p>\n<h3 id=\"js\"><a href=\"#js\" class=\"headerlink\" title=\"js\"></a>js</h3><p>JS Tree Shaking 将 JavaScript 上下文中的未引用代码（Dead Code）移除，通过&nbsp;package.json&nbsp;的&nbsp;“sideEffects”&nbsp;属性作为标记，向 compiler 提供提示，表明项目中的哪些文件是 “pure(纯正 ES2015 模块)”，由此可以安全地删除文件中未使用的部分。<br>Dead Code 一般具有以下几个特征：</p>\n<ol>\n<li>代码不会被执行，不可到达；</li>\n<li>代码执行的结果不会被用到；</li>\n<li>代码只会影响死变量（只写不读）。</li>\n</ol>\n<ul>\n<li>webpack5 sideEffects<br>通过 package.json 的 “sideEffects” 属性，来实现这种方式。</li>\n</ul>\n<pre><code>{\n  \"name\": \"your-project\",\n  \"sideEffects\": false\n}\n</code></pre>\n<p>需注意的是，当代码有副作用时，需要将 sideEffects 改为提供一个数组，添加有副作用代码的文件路径：</p>\n<pre><code>{\n  \"name\": \"your-project\",\n  \"sideEffects\": [\"./src/some-side-effectful-file.js\"]\n}\n</code></pre>\n<p>添加 TreeShaking 后，未引用的代码，将不会被打包。</p>\n<ul>\n<li>对组件库引用的优化</li>\n</ul>\n<p>webpack5 sideEffects 只能清除无副作用的引用，而有副作用的引用则只能通过优化引用方式来进行 Tree Shaking。</p>\n<ol>\n<li>lodash<br>类似 import { throttle } from ‘lodash’ 就属于有副作用的引用，会将整个 lodash 文件进行打包。<br>优化方式是使用 import { throttle } from ‘lodash-es’ 代替 import { throttle } from ‘lodash’，lodash-es 将 Lodash 库导出为 ES 模块，支持基于 ES modules 的 tree shaking，实现按需引入。</li>\n<li>ant-design<br>ant-design 默认支持基于 ES modules 的 tree shaking，对于 js 部分，直接引入&nbsp;import { Button } from ‘antd’&nbsp;就会有按需加载的效果。<br>假如项目中仅引入少部分组件，import { Button } from ‘antd’ 也属于有副作用，webpack不能把其他组件进行tree-shaking。这时可以缩小引用范围，将引入方式修改为 import { Button } from ‘antd/lib/button’ 来进一步优化。</li>\n</ol>\n<h3 id=\"CSS\"><a href=\"#CSS\" class=\"headerlink\" title=\"CSS\"></a>CSS</h3><p>上述对 JS 代码做了 Tree Shaking 操作，同样，CSS 代码也需要摇摇树，打包时把没有用的 CSS 代码摇走，可以大幅减少打包后的 CSS 文件大小。<br>使用 purgecss-webpack-plugin 对 CSS Tree Shaking。</p>\n<p>安装：</p>\n<pre><code>npm i purgecss-webpack-plugin -D\n</code></pre>\n<p>因为打包时 CSS 默认放在 JS 文件内，因此要结合 webpack 分离 CSS 文件插件 mini-css-extract-plugin 一起使用，先将 CSS 文件分离，再进行 CSS Tree Shaking。<br>webpack.prod.js 配置方式如下：</p>\n<pre><code>const glob = require('glob')\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin')\nconst PurgeCSSPlugin = require('purgecss-webpack-plugin')\nconst paths = require('paths')\n\nmodule.exports = {\n  plugins: [\n    // 打包体积分析\n    new BundleAnalyzerPlugin(),\n    // 提取 CSS\n    new MiniCssExtractPlugin({\n      filename: \"[name].css\",\n    }),\n    // CSS Tree Shaking\n    new PurgeCSSPlugin({\n      paths: glob.sync(`${paths.appSrc}/**/*`,  { nodir: true }),\n    }),\n  ]\n}\n</code></pre>\n<h3 id=\"CDN\"><a href=\"#CDN\" class=\"headerlink\" title=\"CDN\"></a>CDN</h3><p>上述是对 webpack 配置的优化，另一方面还可以通过 CDN 来减小打包体积。</p>\n<ol>\n<li>字体：压缩并上传至 CDN；</li>\n<li>图片：压缩并上传至 CDN。</li>\n</ol>\n<h1 id=\"加快加载速度\"><a href=\"#加快加载速度\" class=\"headerlink\" title=\"加快加载速度\"></a>加快加载速度</h1><h2 id=\"按需加载\"><a href=\"#按需加载\" class=\"headerlink\" title=\"按需加载\"></a>按需加载</h2><p>通过 webpack 提供的 import() 语法 动态导入 功能进行代码分离，通过按需加载，大大提升网页加载速度。</p>\n<p>使用方式如下：</p>\n<pre><code>export default function App () {\n    return (\n        &lt;div&gt;\n            hello react 111\n            &lt;Hello /&gt;\n            &lt;button onClick={() =&gt; import('lodash')}&gt;加载lodash&lt;/button&gt;\n        &lt;/div&gt;\n    )\n}\n</code></pre>\n<h2 id=\"浏览器缓存\"><a href=\"#浏览器缓存\" class=\"headerlink\" title=\"浏览器缓存\"></a>浏览器缓存</h2><p>浏览器缓存，就是进入某个网站后，加载的静态资源被浏览器缓存，再次进入该网站后，将直接拉取缓存资源，加快加载速度。<br>webpack 支持根据资源内容，创建 hash id，当资源内容发生变化时，将会创建新的 hash id。<br>配置 JS bundle hash，webpack.common.js 配置方式如下：</p>\n<pre><code>module.exports = {\n  // 输出\n  output: {\n    // 仅在生产环境添加 hash\n    filename: ctx.isEnvProduction ? '[name].[contenthash].bundle.js' : '[name].bundle.js',\n  },\n}\n</code></pre>\n<p>配置 CSS bundle hash，webpack.prod.js 配置方式如下：</p>\n<pre><code>module.exports = {\n  plugins: [\n    // 提取 CSS\n    new MiniCssExtractPlugin({\n      filename: \"[hash].[name].css\",\n    }),\n  ],\n}\n</code></pre>\n<p>配置 optimization.moduleIds，让公共包 splitChunks 的 hash 不因为新的依赖而改变，减少非必要的 hash 变动，webpack.prod.js 配置方式如下：</p>\n<pre><code>module.exports = {\n  optimization: {\n    moduleIds: 'deterministic',\n  }\n}\n</code></pre>\n<p>通过配置 contenthash/hash，浏览器缓存了未改动的文件，仅重新加载有改动的文件，大大加快加载速度。</p>\n<h2 id=\"CDN-1\"><a href=\"#CDN-1\" class=\"headerlink\" title=\"CDN\"></a>CDN</h2><p>将所有的静态资源，上传至 CDN，通过 CDN 加速来提升加载速度。</p>\n<p>webpack.common.js 配置方式如下：</p>\n<pre><code>export.modules = {\noutput: {\n    publicPath: ctx.isEnvProduction ? 'https://xxx.com' : '', // CDN 域名\n  },\n}\n</code></pre>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><ol>\n<li>在小型项目中，添加过多的优化配置，作用不大，反而会因为额外的 loader、plugin 增加构建时间。</li>\n<li>在加快构建时间方面，作用最大的是配置 cache，可大大加快二次构建速度。</li>\n<li>在减小打包体积方面，作用最大的是压缩代码、分离重复代码、Tree Shaking，可最大幅度减小打包体积。</li>\n<li>在加快加载速度方面，按需加载、浏览器缓存、CDN 效果都很显著。</li>\n</ol>\n","more":"<p>本篇将从优化开发体验、加快编译速度、减小打包体积、加快加载速度 4 个角度出发，介绍如何对 webpack 项目进行优化。</p>\n<h1 id=\"优化效率工具\"><a href=\"#优化效率工具\" class=\"headerlink\" title=\"优化效率工具\"></a>优化效率工具</h1><p>安装以下 webpack 插件，帮助我们分析优化效率：</p>\n<ul>\n<li>progress-bar-webpack-plugin：查看编译进度；</li>\n<li>speed-measure-webpack-plugin：查看编译速度；</li>\n<li>webpack-bundle-analyzer：打包体积分析。</li>\n</ul>\n<h2 id=\"1-编译进度条\"><a href=\"#1-编译进度条\" class=\"headerlink\" title=\"1. 编译进度条\"></a>1. 编译进度条</h2><p>一般来说，中型项目的首次编译时间为 5-20s，没个进度条等得多着急，通过 progress-bar-webpack-plugin 插件查看编译进度，方便我们掌握编译情况。</p>\n<p>安装：</p>\n<pre><code>npm i -D progress-bar-webpack-plugin</code></pre>\n<p>webpack.common.js 配置方式如下：</p>\n<pre><code>const chalk = require(&#39;chalk&#39;)\nconst ProgressBarPlugin = require(&#39;progress-bar-webpack-plugin&#39;)\nmodule.exports = &#123;\n  plugins: [\n    // 进度条 贴心的为进度百分比添加了加粗和绿色高亮态样式。\n    new ProgressBarPlugin(&#123;\n        format: `  :msg [:bar] $&#123;chalk.green.bold(&#39;:percent&#39;)&#125; (:elapsed s)`\n      &#125;)\n  ],\n&#125;\n</code></pre>\n<h2 id=\"2-编译速度分析\"><a href=\"#2-编译速度分析\" class=\"headerlink\" title=\"2. 编译速度分析\"></a>2. 编译速度分析</h2><p>优化 webpack 构建速度，首先需要知道是哪些插件、哪些 loader 耗时长，方便我们针对性的优化。<br>通过 speed-measure-webpack-plugin 插件进行构建速度分析，可以看到各个 loader、plugin 的构建时长，后续可针对耗时 loader、plugin 进行优化。</p>\n<p>安装：</p>\n<pre><code>npm i -D speed-measure-webpack-plugin</code></pre>\n<p>webpack.dev.js 配置方式如下：</p>\n<pre><code>\nconst SpeedMeasurePlugin = require(&quot;speed-measure-webpack-plugin&quot;);\nconst smp = new SpeedMeasurePlugin();\nmodule.exports = smp.wrap(&#123;\n  // ...webpack config...\n&#125;)\n</code></pre>\n<h2 id=\"3-打包体积分析\"><a href=\"#3-打包体积分析\" class=\"headerlink\" title=\"3. 打包体积分析\"></a>3. 打包体积分析</h2><p>使用 webpack-bundle-analyzer 查看打包后生成的 bundle 体积分析，将 bundle 内容展示为一个便捷的、交互式、可缩放的树状图形式。帮助我们分析输出结果来检查模块在何处结束。</p>\n<p>安装：</p>\n<pre><code>npm i -D webpack-bundle-analyzer</code></pre>\n<p>webpack.prod.js 配置方式如下：</p>\n<pre><code>\nconst BundleAnalyzerPlugin = require(&#39;webpack-bundle-analyzer&#39;).BundleAnalyzerPlugin;\nmodule.exports = &#123;\n  plugins: [\n    // 打包体积分析\n    new BundleAnalyzerPlugin()\n  ],\n&#125;\n</code></pre>\n<h1 id=\"优化开发体验\"><a href=\"#优化开发体验\" class=\"headerlink\" title=\"优化开发体验\"></a>优化开发体验</h1><h2 id=\"1-自动更新\"><a href=\"#1-自动更新\" class=\"headerlink\" title=\"1. 自动更新\"></a>1. 自动更新</h2><p>自动更新 指的是，在开发过程中，修改代码后，无需手动再次编译，可以自动编译代码更新编译后代码的功能。<br>webpack 提供了以下几种可选方式，实现自动更新功能：</p>\n<ul>\n<li>webpack’s Watch Mode</li>\n<li>webpack-dev-server</li>\n<li>webpack-dev-middleware</li>\n</ul>\n<h2 id=\"2-热更新\"><a href=\"#2-热更新\" class=\"headerlink\" title=\"2. 热更新\"></a>2. 热更新</h2><p>热更新 指的是，在开发过程中，修改代码后，仅更新修改部分的内容，无需刷新整个页面。</p>\n<p>使用 webpack 内置的 HMR 插件，更新 webpack-dev-server 配置。</p>\n<p>webpack.dev.js 配置方式如下：</p>\n<pre><code>module.export = &#123;\n    devServer: &#123;\n        contentBase: &#39;./dist&#39;,\n        hot: true, // 热更新\n      &#125;,\n&#125;\n</code></pre>\n<h1 id=\"加快构建速度\"><a href=\"#加快构建速度\" class=\"headerlink\" title=\"加快构建速度\"></a>加快构建速度</h1><h2 id=\"1-更新版本\"><a href=\"#1-更新版本\" class=\"headerlink\" title=\"1. 更新版本\"></a>1. 更新版本</h2><ul>\n<li><p>webpack 版本<br>使用最新的 webpack 版本，通过 webpack 自身的迭代优化，来加快构建速度。这一点是非常有效的，如 webpack5 较于 webpack4，新增了持久化缓存、改进缓存算法等优化。</p>\n</li>\n<li><p>包管理工具版本</p>\n</li>\n</ul>\n<p>将 Node.js 、package 管理工具（例如 npm 或者 yarn）更新到最新版本，也有助于提高性能。较新的版本能够建立更高效的模块树以及提高解析速度。</p>\n<h2 id=\"2-缓存\"><a href=\"#2-缓存\" class=\"headerlink\" title=\"2. 缓存\"></a>2. 缓存</h2><ul>\n<li>cache<br>通过配置 webpack 持久化缓存 cache: filesystem，来缓存生成的 webpack 模块和 chunk，改善构建速度。<br>简单来说，通过 cache: filesystem 可以将构建过程的 webpack 模板进行缓存，大幅提升二次构建速度、打包速度，当构建突然中断，二次进行构建时，可以直接从缓存中拉取，可提速 90% 左右。</li>\n</ul>\n<p>webpack.common.js 配置方式如下：</p>\n<pre><code>module.exports = &#123;\n    cache: &#123;\n      type: &#39;filesystem&#39;, // 使用文件缓存\n    &#125;,\n&#125;\n</code></pre>\n<ul>\n<li>dll动态链接库</li>\n</ul>\n<p>使用 DllPlugin 为更改不频繁的代码生成单独的编译结果。这可以提高应用程序的编译速度，尽管它增加了构建过程的复杂度。<br>但是用上webpage4版本，DLL优化效率有限， webpack5 开箱即用的持久缓存是比 dll 更优的解决方案。</p>\n<h2 id=\"减少-loader、plugins\"><a href=\"#减少-loader、plugins\" class=\"headerlink\" title=\"减少 loader、plugins\"></a>减少 loader、plugins</h2><p>每个的 loader、plugin 都有其启动时间。尽量少地使用工具，将非必须的 loader、plugins 删除。</p>\n<ul>\n<li>指定 include<br>为 loader 指定 include，减少 loader 应用范围，仅应用于最少数量的必要模块，</li>\n</ul>\n<p>webpack.common.js 配置方式如下：</p>\n<pre><code>module.exports = &#123;\n    rules: [\n        &#123;\n            test: /\\.(js|ts|jsx|tsx)$/,\n            include: paths.appSrc,\n            use: [\n              &#123;\n                loader: &#39;esbuild-loader&#39;,\n                options: &#123;\n                  loader: &#39;tsx&#39;,\n                  target: &#39;es2015&#39;,\n                &#125;,\n              &#125;\n            ]\n         &#125;\n    ]\n&#125;\n</code></pre>\n<p>定义 loader 的 include 后，构建时间将减少 12%。</p>\n<ul>\n<li>管理资源</li>\n</ul>\n<p>使用 webpack 资源模块 (asset module) 代替旧的 assets loader（如 file-loader/url-loader/raw-loader 等），减少 loader 配置数量。</p>\n<pre><code>module.exports = &#123;\n    rules: [\n       &#123;\n        test: /\\.(png|svg|jpg|jpeg|gif)$/i,\n        include: [\n          paths.appSrc,\n        ],\n        type: &#39;asset/resource&#39;,\n      &#125;,\n    ]\n&#125;\n</code></pre>\n<p>引入资源模块后，构建时间将减少 7%。</p>\n<h2 id=\"优化-resolve-配置\"><a href=\"#优化-resolve-配置\" class=\"headerlink\" title=\"优化 resolve 配置\"></a>优化 resolve 配置</h2><ul>\n<li>alias</li>\n</ul>\n<p>alias 可以创建 import 或 require 的别名，用来简化模块引入。</p>\n<p>webpack.common.js 配置方式如下：</p>\n<pre><code>module.exports = &#123;\n    resolve: &#123;\n        alias: &#123;\n          &#39;@&#39;: paths.appSrc, // @ 代表 src 路径\n        &#125;,\n    &#125;\n&#125;\n\n</code></pre>\n<ul>\n<li>extensions</li>\n</ul>\n<p>extensions 表示需要解析的文件类型列表。<br>根据项目中的文件类型，定义 extensions，以覆盖 webpack 默认的 extensions，加快解析速度。<br>由于 webpack 的解析顺序是从左到右，因此要将使用频率高的文件类型放在左侧，如下我将 tsx 放在最左侧。</p>\n<p>webpack.common.js 配置方式如下：</p>\n<pre><code>module.exports = &#123;\n    resolve: &#123;\n        extensions: [&#39;.tsx&#39;, &#39;.js&#39;], // 因为我的项目只有这两种类型的文件，如果有其他类型，需要添加进去。\n    &#125;\n&#125;\n</code></pre>\n<ul>\n<li>modules</li>\n</ul>\n<p>modules 表示 webpack 解析模块时需要解析的目录。</p>\n<p>指定目录可缩小 webpack 解析范围，加快构建速度。</p>\n<p>webpack.common.js 配置方式如下：</p>\n<pre><code>module.exports = &#123;\n    modules: [\n      &#39;node_modules&#39;,\n       paths.appSrc,\n    ]\n&#125;\n</code></pre>\n<ul>\n<li>symlinks</li>\n</ul>\n<p>如果项目不使用 symlinks（例如 npm link 或者 yarn link），可以设置 resolve.symlinks: false，减少解析工作量。</p>\n<p>webpack.common.js 配置方式如下：</p>\n<pre><code>module.exports = &#123;\n    resolve: &#123;\n        symlinks: false,\n    &#125;,\n&#125;\n</code></pre>\n<p>优化 resolve 配置后，构建时间将减少 1.5%</p>\n<h2 id=\"多进程\"><a href=\"#多进程\" class=\"headerlink\" title=\"多进程\"></a>多进程</h2><p>可以通过多进程来实现，比如将 sass-loader 放在一个独立的 worker 池中运行，就不会阻碍其他 loader 的构建了，可以大大加快构建速度。</p>\n<ul>\n<li>thread-loader</li>\n</ul>\n<pre><code>npm i -D thread-loader</code></pre>\n<p>webpack.common.js 配置方式如下：</p>\n<pre><code>module.exports = &#123;\n    rules: [\n        &#123;\n        test: /\\.module\\.(scss|sass)$/,\n        include: paths.appSrc,\n        use: [\n          &#39;style-loader&#39;,\n          &#123;\n            loader: &#39;css-loader&#39;,\n            options: &#123;\n              modules: true,\n              importLoaders: 2,\n            &#125;,\n          &#125;,\n          &#123;\n            loader: &#39;postcss-loader&#39;,\n            options: &#123;\n              postcssOptions: &#123;\n                plugins: [\n                  [\n                    &#39;postcss-preset-env&#39;,\n                  ],\n                ],\n              &#125;,\n            &#125;,\n          &#125;,\n          &#123;\n            loader: &#39;thread-loader&#39;,\n            options: &#123;\n              workerParallelJobs: 2\n            &#125;\n          &#125;,\n          &#39;sass-loader&#39;,\n        ].filter(Boolean),\n      &#125;,\n    ]\n&#125;\n</code></pre>\n<h1 id=\"减小打包体积\"><a href=\"#减小打包体积\" class=\"headerlink\" title=\"减小打包体积\"></a>减小打包体积</h1><h2 id=\"1-代码压缩\"><a href=\"#1-代码压缩\" class=\"headerlink\" title=\"1. 代码压缩\"></a>1. 代码压缩</h2><p>体积优化第一步是压缩代码，通过 webpack 插件，将 JS、CSS 等文件进行压缩。</p>\n<ul>\n<li>JS 压缩</li>\n</ul>\n<p>webpack5 自带最新的 terser-webpack-plugin，无需手动安装。<br>terser-webpack-plugin 默认开启了 parallel: true 配置，并发运行的默认数量： os.cpus().length - 1 ，本文配置的 parallel 数量为 4，使用多进程并发运行压缩以提高构建速度。</p>\n<p>webpack.prod.js 配置方式如下：</p>\n<pre><code>const TerserPlugin = require(&#39;terser-webpack-plugin&#39;);\nmodule.exports = &#123;\n    optimization: &#123;\n        minimizer: [\n            new TerserPlugin(&#123;\n              parallel: 4,\n              terserOptions: &#123;\n                parse: &#123;\n                  ecma: 8,\n                &#125;,\n                compress: &#123;\n                  ecma: 5,\n                  warnings: false,\n                  comparisons: false,\n                  inline: 2,\n                &#125;,\n                mangle: &#123;\n                  safari10: true,\n                &#125;,\n                output: &#123;\n                  ecma: 5,\n                  comments: false,\n                  ascii_only: true,\n                &#125;,\n              &#125;,\n            &#125;),\n        ]\n    &#125;\n&#125;\n\n</code></pre>\n<ul>\n<li>CSS 压缩<br>使用 CssMinimizerWebpackPlugin 压缩 CSS 文件。</li>\n</ul>\n<p>安装：</p>\n<pre><code>npm install -D css-minimizer-webpack-plugin\n</code></pre>\n<p>webpack.prod.js 配置方式如下：</p>\n<pre><code>const CssMinimizerPlugin = require(&quot;css-minimizer-webpack-plugin&quot;);\n\nmodule.exports = &#123;\n  optimization: &#123;\n    minimizer: [\n      new CssMinimizerPlugin(&#123;\n          parallel: 4,\n        &#125;),\n    ],\n  &#125;\n&#125;\n</code></pre>\n<h2 id=\"2-代码分离\"><a href=\"#2-代码分离\" class=\"headerlink\" title=\"2. 代码分离\"></a>2. 代码分离</h2><p>代码分离能够把代码分离到不同的 bundle 中，然后可以按需加载或并行加载这些文件。代码分离可以用于获取更小的 bundle，以及控制资源加载优先级，可以缩短页面加载时间。</p>\n<ul>\n<li>抽离重复代码</li>\n</ul>\n<p>SplitChunksPlugin 插件开箱即用，可以将公共的依赖模块提取到已有的入口 chunk 中，或者提取到一个新生成的 chunk。<br>webpack 将根据以下条件自动拆分 chunks：</p>\n<ol>\n<li>新的 chunk 可以被共享，或者模块来自于 node_modules 文件夹；</li>\n<li>新的 chunk 体积大于 20kb（在进行 min+gz 之前的体积）；</li>\n<li>当按需加载 chunks 时，并行请求的最大数量小于或等于 30；</li>\n<li>当加载初始化页面时，并发请求的最大数量小于或等于 30；通过 splitChunks 把 react 等公共库抽离出来，不重复引入占用体积。</li>\n</ol>\n<blockquote>\n<p>注意：切记不要为 cacheGroups 定义固定的 name，因为 cacheGroups.name 指定字符串或始终返回相同字符串的函数时，会将所有常见模块和 vendor 合并为一个 chunk。这会导致更大的初始下载量并减慢页面加载速度。</p>\n</blockquote>\n<p>webpack.prod.js 配置方式如下：</p>\n<pre><code>module.exports = &#123;\n    splitChunks: &#123;\n      // include all types of chunks\n      chunks: &#39;all&#39;,\n      // 重复打包问题\n      cacheGroups:&#123;\n        vendors:&#123; // node_modules里的代码\n          test: /[\\\\/]node_modules[\\\\/]/,\n          chunks: &quot;all&quot;,\n          // name: &#39;vendors&#39;, 一定不要定义固定的name\n          priority: 10, // 优先级\n          enforce: true \n        &#125;\n      &#125;\n    &#125;,\n&#125;\n</code></pre>\n<ul>\n<li> CSS 文件分离</li>\n</ul>\n<p>MiniCssExtractPlugin 插件将 CSS 提取到单独的文件中，为每个包含 CSS 的 JS 文件创建一个 CSS 文件，并且支持 CSS 和 SourceMaps 的按需加载。</p>\n<p>安装：</p>\n<pre><code>npm install -D mini-css-extract-plugin\n</code></pre>\n<p>webpack.common.js 配置方式如下：</p>\n<pre><code>const MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;);\n\nmodule.exports = &#123;\n  plugins: [new MiniCssExtractPlugin()],\n  module: &#123;\n    rules: [\n        &#123;\n        test: /\\.module\\.(scss|sass)$/,\n        include: paths.appSrc,\n        use: [\n          &#39;style-loader&#39;,\n          isEnvProduction &amp;&amp; MiniCssExtractPlugin.loader, // 仅生产环境\n          &#123;\n            loader: &#39;css-loader&#39;,\n            options: &#123;\n              modules: true,\n              importLoaders: 2,\n            &#125;,\n          &#125;,\n          &#123;\n            loader: &#39;postcss-loader&#39;,\n            options: &#123;\n              postcssOptions: &#123;\n                plugins: [\n                  [\n                    &#39;postcss-preset-env&#39;,\n                  ],\n                ],\n              &#125;,\n            &#125;,\n          &#125;,\n          &#123;\n            loader: &#39;thread-loader&#39;,\n            options: &#123;\n              workerParallelJobs: 2\n            &#125;\n          &#125;,\n          &#39;sass-loader&#39;,\n        ].filter(Boolean),\n      &#125;,\n    ]\n  &#125;,\n&#125;;\n</code></pre>\n<blockquote>\n<p>注意：MiniCssExtractPlugin.loader 要放在 style-loader 后面。</p>\n</blockquote>\n<ul>\n<li>最小化 entry chunk</li>\n</ul>\n<p>通过配置 optimization.runtimeChunk = true，为运行时代码创建一个额外的 chunk，减少 entry chunk 体积，提高性能。</p>\n<p>webpack.prod.js 配置方式如下：</p>\n<pre><code>module.exports = &#123;\n    optimization: &#123;\n        runtimeChunk: true,\n      &#125;,\n    &#125;;\n&#125;\n</code></pre>\n<h2 id=\"Tree-Shaking（摇树）\"><a href=\"#Tree-Shaking（摇树）\" class=\"headerlink\" title=\"Tree Shaking（摇树）\"></a>Tree Shaking（摇树）</h2><p>摇树，顾名思义，就是将枯黄的落叶摇下来，只留下树上活的叶子。枯黄的落叶代表项目中未引用的无用代码，活的树叶代表项目中实际用到的源</p>\n<h3 id=\"js\"><a href=\"#js\" class=\"headerlink\" title=\"js\"></a>js</h3><p>JS Tree Shaking 将 JavaScript 上下文中的未引用代码（Dead Code）移除，通过 package.json 的 “sideEffects” 属性作为标记，向 compiler 提供提示，表明项目中的哪些文件是 “pure(纯正 ES2015 模块)”，由此可以安全地删除文件中未使用的部分。<br>Dead Code 一般具有以下几个特征：</p>\n<ol>\n<li>代码不会被执行，不可到达；</li>\n<li>代码执行的结果不会被用到；</li>\n<li>代码只会影响死变量（只写不读）。</li>\n</ol>\n<ul>\n<li>webpack5 sideEffects<br>通过 package.json 的 “sideEffects” 属性，来实现这种方式。</li>\n</ul>\n<pre><code>&#123;\n  &quot;name&quot;: &quot;your-project&quot;,\n  &quot;sideEffects&quot;: false\n&#125;\n</code></pre>\n<p>需注意的是，当代码有副作用时，需要将 sideEffects 改为提供一个数组，添加有副作用代码的文件路径：</p>\n<pre><code>&#123;\n  &quot;name&quot;: &quot;your-project&quot;,\n  &quot;sideEffects&quot;: [&quot;./src/some-side-effectful-file.js&quot;]\n&#125;\n</code></pre>\n<p>添加 TreeShaking 后，未引用的代码，将不会被打包。</p>\n<ul>\n<li>对组件库引用的优化</li>\n</ul>\n<p>webpack5 sideEffects 只能清除无副作用的引用，而有副作用的引用则只能通过优化引用方式来进行 Tree Shaking。</p>\n<ol>\n<li>lodash<br>类似 import { throttle } from ‘lodash’ 就属于有副作用的引用，会将整个 lodash 文件进行打包。<br>优化方式是使用 import { throttle } from ‘lodash-es’ 代替 import { throttle } from ‘lodash’，lodash-es 将 Lodash 库导出为 ES 模块，支持基于 ES modules 的 tree shaking，实现按需引入。</li>\n<li>ant-design<br>ant-design 默认支持基于 ES modules 的 tree shaking，对于 js 部分，直接引入 import { Button } from ‘antd’ 就会有按需加载的效果。<br>假如项目中仅引入少部分组件，import { Button } from ‘antd’ 也属于有副作用，webpack不能把其他组件进行tree-shaking。这时可以缩小引用范围，将引入方式修改为 import { Button } from ‘antd/lib/button’ 来进一步优化。</li>\n</ol>\n<h3 id=\"CSS\"><a href=\"#CSS\" class=\"headerlink\" title=\"CSS\"></a>CSS</h3><p>上述对 JS 代码做了 Tree Shaking 操作，同样，CSS 代码也需要摇摇树，打包时把没有用的 CSS 代码摇走，可以大幅减少打包后的 CSS 文件大小。<br>使用 purgecss-webpack-plugin 对 CSS Tree Shaking。</p>\n<p>安装：</p>\n<pre><code>npm i purgecss-webpack-plugin -D\n</code></pre>\n<p>因为打包时 CSS 默认放在 JS 文件内，因此要结合 webpack 分离 CSS 文件插件 mini-css-extract-plugin 一起使用，先将 CSS 文件分离，再进行 CSS Tree Shaking。<br>webpack.prod.js 配置方式如下：</p>\n<pre><code>const glob = require(&#39;glob&#39;)\nconst MiniCssExtractPlugin = require(&#39;mini-css-extract-plugin&#39;)\nconst PurgeCSSPlugin = require(&#39;purgecss-webpack-plugin&#39;)\nconst paths = require(&#39;paths&#39;)\n\nmodule.exports = &#123;\n  plugins: [\n    // 打包体积分析\n    new BundleAnalyzerPlugin(),\n    // 提取 CSS\n    new MiniCssExtractPlugin(&#123;\n      filename: &quot;[name].css&quot;,\n    &#125;),\n    // CSS Tree Shaking\n    new PurgeCSSPlugin(&#123;\n      paths: glob.sync(`$&#123;paths.appSrc&#125;/**/*`,  &#123; nodir: true &#125;),\n    &#125;),\n  ]\n&#125;\n</code></pre>\n<h3 id=\"CDN\"><a href=\"#CDN\" class=\"headerlink\" title=\"CDN\"></a>CDN</h3><p>上述是对 webpack 配置的优化，另一方面还可以通过 CDN 来减小打包体积。</p>\n<ol>\n<li>字体：压缩并上传至 CDN；</li>\n<li>图片：压缩并上传至 CDN。</li>\n</ol>\n<h1 id=\"加快加载速度\"><a href=\"#加快加载速度\" class=\"headerlink\" title=\"加快加载速度\"></a>加快加载速度</h1><h2 id=\"按需加载\"><a href=\"#按需加载\" class=\"headerlink\" title=\"按需加载\"></a>按需加载</h2><p>通过 webpack 提供的 import() 语法 动态导入 功能进行代码分离，通过按需加载，大大提升网页加载速度。</p>\n<p>使用方式如下：</p>\n<pre><code>export default function App () &#123;\n    return (\n        &lt;div&gt;\n            hello react 111\n            &lt;Hello /&gt;\n            &lt;button onClick=&#123;() =&gt; import(&#39;lodash&#39;)&#125;&gt;加载lodash&lt;/button&gt;\n        &lt;/div&gt;\n    )\n&#125;\n</code></pre>\n<h2 id=\"浏览器缓存\"><a href=\"#浏览器缓存\" class=\"headerlink\" title=\"浏览器缓存\"></a>浏览器缓存</h2><p>浏览器缓存，就是进入某个网站后，加载的静态资源被浏览器缓存，再次进入该网站后，将直接拉取缓存资源，加快加载速度。<br>webpack 支持根据资源内容，创建 hash id，当资源内容发生变化时，将会创建新的 hash id。<br>配置 JS bundle hash，webpack.common.js 配置方式如下：</p>\n<pre><code>module.exports = &#123;\n  // 输出\n  output: &#123;\n    // 仅在生产环境添加 hash\n    filename: ctx.isEnvProduction ? &#39;[name].[contenthash].bundle.js&#39; : &#39;[name].bundle.js&#39;,\n  &#125;,\n&#125;\n</code></pre>\n<p>配置 CSS bundle hash，webpack.prod.js 配置方式如下：</p>\n<pre><code>module.exports = &#123;\n  plugins: [\n    // 提取 CSS\n    new MiniCssExtractPlugin(&#123;\n      filename: &quot;[hash].[name].css&quot;,\n    &#125;),\n  ],\n&#125;\n</code></pre>\n<p>配置 optimization.moduleIds，让公共包 splitChunks 的 hash 不因为新的依赖而改变，减少非必要的 hash 变动，webpack.prod.js 配置方式如下：</p>\n<pre><code>module.exports = &#123;\n  optimization: &#123;\n    moduleIds: &#39;deterministic&#39;,\n  &#125;\n&#125;\n</code></pre>\n<p>通过配置 contenthash/hash，浏览器缓存了未改动的文件，仅重新加载有改动的文件，大大加快加载速度。</p>\n<h2 id=\"CDN-1\"><a href=\"#CDN-1\" class=\"headerlink\" title=\"CDN\"></a>CDN</h2><p>将所有的静态资源，上传至 CDN，通过 CDN 加速来提升加载速度。</p>\n<p>webpack.common.js 配置方式如下：</p>\n<pre><code>export.modules = &#123;\noutput: &#123;\n    publicPath: ctx.isEnvProduction ? &#39;https://xxx.com&#39; : &#39;&#39;, // CDN 域名\n  &#125;,\n&#125;\n</code></pre>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><ol>\n<li>在小型项目中，添加过多的优化配置，作用不大，反而会因为额外的 loader、plugin 增加构建时间。</li>\n<li>在加快构建时间方面，作用最大的是配置 cache，可大大加快二次构建速度。</li>\n<li>在减小打包体积方面，作用最大的是压缩代码、分离重复代码、Tree Shaking，可最大幅度减小打包体积。</li>\n<li>在加快加载速度方面，按需加载、浏览器缓存、CDN 效果都很显著。</li>\n</ol>\n","categories":[{"name":"webpack专区","path":"api/categories/webpack专区.json"}],"tags":[{"name":"webpack","path":"api/tags/webpack.json"}]}