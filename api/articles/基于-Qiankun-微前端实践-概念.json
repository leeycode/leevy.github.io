{"title":"基于 Qiankun 微前端实践-概念","slug":"基于-Qiankun-微前端实践-概念","date":"2022-09-10T01:48:40.000Z","updated":"2022-09-10T02:24:03.789Z","comments":true,"path":"api/articles/基于-Qiankun-微前端实践-概念.json","excerpt":null,"covers":["https://s3.bmp.ovh/imgs/2022/09/10/1f56765344a88594.png","https://s3.bmp.ovh/imgs/2022/09/10/c0df382ee16dc37e.png","https://s3.bmp.ovh/imgs/2022/09/10/20002f8f80cd926e.png"],"content":"<blockquote>\n<p>微前端就是将不同的功能按照不同的维度拆分成多个子应用。通过主应用来加载这些子应用。微前端的核心在于拆，拆完后再合！</p>\n</blockquote>\n<h2 id=\"为什么需要微前端\"><a href=\"#为什么需要微前端\" class=\"headerlink\" title=\"为什么需要微前端\"></a>为什么需要微前端</h2><ol>\n<li>使用背景</li>\n</ol>\n<p>1)在同一个页面可以使用多个前端框架(React, AngularJS, Vue 等);</p>\n<p>2)用新框架编写新代码，无需重写已有的 app;</p>\n<p>3)代码的延迟加载可以缩减初次加载时长;</p>\n<ol start=\"2\">\n<li>主要解决的问题：</li>\n</ol>\n<p>1)在一个 app 中不同的模块由不同的团队维护，而每个团队所用的技术栈可能不同，而且发版周期不同。</p>\n<p>2)所使用的前端框架升级负担，新版本可能存在不兼容的更新，升级后可能对已有的业务产生 bug，造成难以升级。限制了前端框架新版本的使用。</p>\n<ol start=\"3\">\n<li>导图<br><img src=\"https://s3.bmp.ovh/imgs/2022/09/10/1f56765344a88594.png\" alt=\"微前端导图\"></li>\n</ol>\n<h2 id=\"什么是微前端\"><a href=\"#什么是微前端\" class=\"headerlink\" title=\"什么是微前端\"></a>什么是微前端</h2><p><img src=\"https://s3.bmp.ovh/imgs/2022/09/10/c0df382ee16dc37e.png\"></p>\n<p>微前端就是将不同的功能按照不同的维度拆分成多个子应用。通过主应用来加载这些子应用。</p>\n<h3 id=\"微前端核心价值\"><a href=\"#微前端核心价值\" class=\"headerlink\" title=\"微前端核心价值\"></a>微前端核心价值</h3><p>微前端架构具备以下几个核心价值：(重要)(摘自 qiankun官方文档)</p>\n<p>1)技术栈无关</p>\n<p>主框架不限制接入应用的技术栈，微应用具备完全自主权;</p>\n<p>2)独立开发、独立部署</p>\n<p>微应用仓库独立，前后端可独立开发，部署完成后主框架自动完成同步更新;</p>\n<p>3)增量升级</p>\n<p>在面对各种复杂场景时，我们通常很难对一个已经存在的系统做全量的技术栈升级或重构，而微前端是一种非常好的实施渐进式重构的手段和策略;</p>\n<p>4)独立运行时</p>\n<p>每个微应用之间状态隔离，运行时状态不共享;</p>\n<h3 id=\"怎么落地微前端\"><a href=\"#怎么落地微前端\" class=\"headerlink\" title=\"怎么落地微前端\"></a>怎么落地微前端</h3><p><img src=\"https://s3.bmp.ovh/imgs/2022/09/10/20002f8f80cd926e.png\"></p>\n<p>2018年 Single-SPA 诞生了，single-spa 是一个用于前端微服务化的 JavaScript 前端解决方案(本身没有处理样式隔离，js 执行隔离)实现了路由劫持和应用加载。</p>\n<p>说明：single-spa 解决了以应用为维度的路由，应用的注册，监听，最重要的是赋予了应用生命周期和生命周期相关事件。</p>\n<p>*Single-SPA 缺陷：不够灵活，不能动态加载js文件;样式不隔离，没有js沙箱的机制。</p>\n<p>2019年 qiankun 是微前端框架，提供了更加开箱即用的 API (single-spa + sandbox + import-html-entry)，它基于 single-spa，具备 js 沙箱、样式隔离、HTML Loader、预加载 等微前端系统所需的能力。qiakun 升级 2.0 后，支持多个微应用的同时加载，有了这个特性，我们基本可以像接入 iframe 一样方便的接入微应用。</p>\n<p>*总结：子应用可以独立构建，运行时动态加载，主子应用完全解耦，技术栈无关，靠的是协议接入(子应用必须导出 bootstrap，mount，unmount方法)</p>\n<h2 id=\"微前端核心功能实现\"><a href=\"#微前端核心功能实现\" class=\"headerlink\" title=\"微前端核心功能实现\"></a>微前端核心功能实现</h2><h3 id=\"css-隔离方案\"><a href=\"#css-隔离方案\" class=\"headerlink\" title=\"css 隔离方案\"></a>css 隔离方案</h3><p>子应用之间样式隔离：</p>\n<p>Dynamic Stylesheet 动态样式表，当应用切换时移除老应用样式，添加新应用样式;</p>\n<p>主应用和子应用之间的样式隔离：</p>\n<p>1)BEM(Block Element Modifier ) 约定项目前缀;</p>\n<p>2)css-Modules 打包时生成不冲突的选择器名;</p>\n<p>3)Shadow DOM 真正意义上的隔离;</p>\n<p>4)css-in-js</p>\n<h3 id=\"沙箱-shaowDom\"><a href=\"#沙箱-shaowDom\" class=\"headerlink\" title=\"沙箱 shaowDom\"></a>沙箱 shaowDom</h3><ol>\n<li>css 解决方法：</li>\n</ol>\n<pre class=\" language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// dom的api</span>\n<span class=\"token comment\" spellcheck=\"true\">// 外界无法访问 shadow dom</span>\n<span class=\"token keyword\">let</span> shadowDOM <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'x'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">attachShadow</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>mode<span class=\"token punctuation\">:</span> <span class=\"token string\">'closed'</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n<span class=\"token keyword\">let</span> pElm <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span><span class=\"token string\">'p'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\npElm<span class=\"token punctuation\">.</span>innerHTML <span class=\"token operator\">=</span> <span class=\"token string\">'hello'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> styleElm <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span><span class=\"token string\">'style'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nstyleElm<span class=\"token punctuation\">.</span>textContent <span class=\"token operator\">=</span> <span class=\"token template-string\"><span class=\"token string\">`\n p{color: red}\n`</span></span>\nshadowDOM<span class=\"token punctuation\">.</span><span class=\"token function\">appendchild</span><span class=\"token punctuation\">(</span>styleElm<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nshadowDOM<span class=\"token punctuation\">.</span><span class=\"token function\">appendchild</span><span class=\"token punctuation\">(</span>pElm<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<ol start=\"2\">\n<li>JS 沙箱 proxy</li>\n</ol>\n<p>快照沙箱简单理解：1年前拍一张 在拍一张 (将区别保存起来) 在回到一年前</p>\n<pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">let</span> sandbox <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">SnapshotSandbox</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">SnapshotSandbox</span><span class=\"token punctuation\">{</span>\n <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n   <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>proxy <span class=\"token operator\">=</span> window<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// window属性</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>modifyPropsmap <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 记录在window上的修改</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">active</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token function\">active</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">// 激活</span>\n   <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>windowSnapshot <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//拍照</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> prop <span class=\"token keyword\">in</span> window<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n     <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>window<span class=\"token punctuation\">.</span><span class=\"token function\">hasOwnProperty</span><span class=\"token punctuation\">(</span>prop<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n       <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>windowsnapshot<span class=\"token punctuation\">[</span>prop<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> window<span class=\"token punctuation\">[</span>prop<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    object<span class=\"token punctuation\">.</span><span class=\"token function\">keys</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>modifyPropsMap<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span>p<span class=\"token operator\">=</span><span class=\"token operator\">></span><span class=\"token punctuation\">{</span>\n     window<span class=\"token punctuation\">[</span>p<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>modifyPropsMap<span class=\"token punctuation\">[</span>p<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token function\">inactive</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">// 失活</span>\n   <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> prop <span class=\"token keyword\">in</span> window<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n     <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>window<span class=\"token punctuation\">.</span><span class=\"token function\">hasOwnProperty</span><span class=\"token punctuation\">(</span>prop<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n       <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>window<span class=\"token punctuation\">[</span>prop<span class=\"token punctuation\">]</span> <span class=\"token operator\">!==</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>windowsnapshot<span class=\"token punctuation\">[</span>prop<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n         <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>modifyPropsMap<span class=\"token punctuation\">[</span>prop<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> window<span class=\"token punctuation\">[</span>prop<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n          window<span class=\"token punctuation\">[</span>prop<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>windowsnapshot<span class=\"token punctuation\">[</span>prop<span class=\"token punctuation\">]</span>\n        <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 应用的运行 从开始到结束， 切换后不会影响全局</span>\n<span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>window<span class=\"token punctuation\">)</span><span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n window<span class=\"token punctuation\">.</span>a <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n  window<span class=\"token punctuation\">.</span>b <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>window<span class=\"token punctuation\">.</span>a<span class=\"token punctuation\">,</span>window<span class=\"token punctuation\">.</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  sandbox<span class=\"token punctuation\">.</span><span class=\"token function\">inactive</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>window<span class=\"token punctuation\">.</span>a<span class=\"token punctuation\">,</span>window<span class=\"token punctuation\">.</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  sandbox<span class=\"token punctuation\">.</span><span class=\"token function\">active</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>window<span class=\"token punctuation\">.</span>a<span class=\"token punctuation\">,</span>window<span class=\"token punctuation\">.</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>sandbox<span class=\"token punctuation\">.</span>proxy<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// sandbox.proxy 就是window</span>\n<span class=\"token comment\" spellcheck=\"true\">// 如果是多个子应用就不能使用这种方式了，es6的proxy</span>\n<span class=\"token comment\" spellcheck=\"true\">// 代理沙箱可以实现多应用沙箱。把不同的应用用不同的代理来处理</span></code></pre>\n","more":"<blockquote>\n<p>微前端就是将不同的功能按照不同的维度拆分成多个子应用。通过主应用来加载这些子应用。微前端的核心在于拆，拆完后再合！</p>\n</blockquote>\n<h2 id=\"为什么需要微前端\"><a href=\"#为什么需要微前端\" class=\"headerlink\" title=\"为什么需要微前端\"></a>为什么需要微前端</h2><ol>\n<li>使用背景</li>\n</ol>\n<p>1)在同一个页面可以使用多个前端框架(React, AngularJS, Vue 等);</p>\n<p>2)用新框架编写新代码，无需重写已有的 app;</p>\n<p>3)代码的延迟加载可以缩减初次加载时长;</p>\n<ol start=\"2\">\n<li>主要解决的问题：</li>\n</ol>\n<p>1)在一个 app 中不同的模块由不同的团队维护，而每个团队所用的技术栈可能不同，而且发版周期不同。</p>\n<p>2)所使用的前端框架升级负担，新版本可能存在不兼容的更新，升级后可能对已有的业务产生 bug，造成难以升级。限制了前端框架新版本的使用。</p>\n<ol start=\"3\">\n<li>导图<br><img src=\"https://s3.bmp.ovh/imgs/2022/09/10/1f56765344a88594.png\" alt=\"微前端导图\"></li>\n</ol>\n<h2 id=\"什么是微前端\"><a href=\"#什么是微前端\" class=\"headerlink\" title=\"什么是微前端\"></a>什么是微前端</h2><p><img src=\"https://s3.bmp.ovh/imgs/2022/09/10/c0df382ee16dc37e.png\"></p>\n<p>微前端就是将不同的功能按照不同的维度拆分成多个子应用。通过主应用来加载这些子应用。</p>\n<h3 id=\"微前端核心价值\"><a href=\"#微前端核心价值\" class=\"headerlink\" title=\"微前端核心价值\"></a>微前端核心价值</h3><p>微前端架构具备以下几个核心价值：(重要)(摘自 qiankun官方文档)</p>\n<p>1)技术栈无关</p>\n<p>主框架不限制接入应用的技术栈，微应用具备完全自主权;</p>\n<p>2)独立开发、独立部署</p>\n<p>微应用仓库独立，前后端可独立开发，部署完成后主框架自动完成同步更新;</p>\n<p>3)增量升级</p>\n<p>在面对各种复杂场景时，我们通常很难对一个已经存在的系统做全量的技术栈升级或重构，而微前端是一种非常好的实施渐进式重构的手段和策略;</p>\n<p>4)独立运行时</p>\n<p>每个微应用之间状态隔离，运行时状态不共享;</p>\n<h3 id=\"怎么落地微前端\"><a href=\"#怎么落地微前端\" class=\"headerlink\" title=\"怎么落地微前端\"></a>怎么落地微前端</h3><p><img src=\"https://s3.bmp.ovh/imgs/2022/09/10/20002f8f80cd926e.png\"></p>\n<p>2018年 Single-SPA 诞生了，single-spa 是一个用于前端微服务化的 JavaScript 前端解决方案(本身没有处理样式隔离，js 执行隔离)实现了路由劫持和应用加载。</p>\n<p>说明：single-spa 解决了以应用为维度的路由，应用的注册，监听，最重要的是赋予了应用生命周期和生命周期相关事件。</p>\n<p>*Single-SPA 缺陷：不够灵活，不能动态加载js文件;样式不隔离，没有js沙箱的机制。</p>\n<p>2019年 qiankun 是微前端框架，提供了更加开箱即用的 API (single-spa + sandbox + import-html-entry)，它基于 single-spa，具备 js 沙箱、样式隔离、HTML Loader、预加载 等微前端系统所需的能力。qiakun 升级 2.0 后，支持多个微应用的同时加载，有了这个特性，我们基本可以像接入 iframe 一样方便的接入微应用。</p>\n<p>*总结：子应用可以独立构建，运行时动态加载，主子应用完全解耦，技术栈无关，靠的是协议接入(子应用必须导出 bootstrap，mount，unmount方法)</p>\n<h2 id=\"微前端核心功能实现\"><a href=\"#微前端核心功能实现\" class=\"headerlink\" title=\"微前端核心功能实现\"></a>微前端核心功能实现</h2><h3 id=\"css-隔离方案\"><a href=\"#css-隔离方案\" class=\"headerlink\" title=\"css 隔离方案\"></a>css 隔离方案</h3><p>子应用之间样式隔离：</p>\n<p>Dynamic Stylesheet 动态样式表，当应用切换时移除老应用样式，添加新应用样式;</p>\n<p>主应用和子应用之间的样式隔离：</p>\n<p>1)BEM(Block Element Modifier ) 约定项目前缀;</p>\n<p>2)css-Modules 打包时生成不冲突的选择器名;</p>\n<p>3)Shadow DOM 真正意义上的隔离;</p>\n<p>4)css-in-js</p>\n<h3 id=\"沙箱-shaowDom\"><a href=\"#沙箱-shaowDom\" class=\"headerlink\" title=\"沙箱 shaowDom\"></a>沙箱 shaowDom</h3><ol>\n<li>css 解决方法：</li>\n</ol>\n<pre><code class=\"js\">// dom的api\n// 外界无法访问 shadow dom\nlet shadowDOM = document.getElementById(&#39;x&#39;).attachShadow(&#123;mode: &#39;closed&#39;&#125;); \nlet pElm = document.createElement(&#39;p&#39;);\npElm.innerHTML = &#39;hello&#39;;\nlet styleElm = document.createElement(&#39;style&#39;);\nstyleElm.textContent = `\n p&#123;color: red&#125;\n`\nshadowDOM.appendchild(styleElm);\nshadowDOM.appendchild(pElm);</code></pre>\n<ol start=\"2\">\n<li>JS 沙箱 proxy</li>\n</ol>\n<p>快照沙箱简单理解：1年前拍一张 在拍一张 (将区别保存起来) 在回到一年前</p>\n<pre><code class=\"js\">let sandbox = new SnapshotSandbox();\n\nclass SnapshotSandbox&#123;\n constructor()&#123;\n   this.proxy = window; // window属性\n    this.modifyPropsmap = &#123;&#125;; // 记录在window上的修改\n    this.active();\n  &#125;\n  active() &#123; // 激活\n   this.windowSnapshot = &#123;&#125;; //拍照\n    for(const prop in window) &#123;\n     if(window.hasOwnProperty(prop))&#123;\n       this.windowsnapshot[prop] = window[prop];\n      &#125;\n    &#125;\n    object.keys(this.modifyPropsMap).forEach(p=&gt;&#123;\n     window[p] = this.modifyPropsMap[p];\n    &#125;)\n  &#125;\n\n  inactive()&#123; // 失活\n   for(const prop in window)&#123;\n     if(window.hasOwnProperty(prop))&#123;\n       if(window[prop] !== this.windowsnapshot[prop])&#123;\n         this.modifyPropsMap[prop] = window[prop];\n          window[prop] = this.windowsnapshot[prop]\n        &#125;\n      &#125;\n    &#125;\n  &#125;\n&#125;\n\n// 应用的运行 从开始到结束， 切换后不会影响全局\n((window)=&gt; &#123;\n window.a = 1;\n  window.b = 2;\n  console.log(window.a,window.b);\n  sandbox.inactive();\n  console.log(window.a,window.b);\n  sandbox.active();\n  console.log(window.a,window.b);\n&#125;)(sandbox.proxy); // sandbox.proxy 就是window\n// 如果是多个子应用就不能使用这种方式了，es6的proxy\n// 代理沙箱可以实现多应用沙箱。把不同的应用用不同的代理来处理</code></pre>\n","categories":[{"name":"微前端","path":"api/categories/微前端.json"}],"tags":[{"name":"qiankun","path":"api/tags/qiankun.json"}]}