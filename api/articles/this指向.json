{"title":"this指向","slug":"this指向","date":"2020-11-25T07:00:56.000Z","updated":"2022-01-05T09:30:00.555Z","comments":true,"path":"api/articles/this指向.json","excerpt":null,"covers":null,"content":"<h1 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h1><p><code>this</code> 既不指向函数自身也不指向函数的作用域，在函数真正被调用执行的时候确定的，函数定义的时候确定不了。</p>\n<ol>\n<li><code>this</code>的指向，<strong>是在函数被调用的时候确定的</strong>，也就是执行上下文被创建时确定的；</li>\n<li><code>this</code> 的指向和函数声明的位置没有任何关系，只取决于函数的调用位置（也即由谁、在什么地方调用这个函数）；</li>\n<li>正因为在执行上下文的创建阶段<code>this</code>的指向就已经被确定了，在执行阶段<code>this</code>指向不可再被更改。</li>\n</ol>\n<pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> obj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    a<span class=\"token punctuation\">:</span> <span class=\"token string\">\"1891\"</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span> <span class=\"token operator\">=</span> obj<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//报错，因为在执行阶段试图修改this的指向</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<h1 id=\"this的指向规则\"><a href=\"#this的指向规则\" class=\"headerlink\" title=\"this的指向规则\"></a>this的指向规则</h1><h2 id=\"默认指向\"><a href=\"#默认指向\" class=\"headerlink\" title=\"默认指向\"></a>默认指向</h2><h3 id=\"独立函数调用\"><a href=\"#独立函数调用\" class=\"headerlink\" title=\"独立函数调用\"></a>独立函数调用</h3><pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>a <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// this指向全局对象</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">var</span> a <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//>> 2</span></code></pre>\n<p>对于<strong>默认指向</strong>来说，决定<code>this</code>指向对象的并不是<strong>调用位置</strong>是否处于严格模式，而是函数体是否处于严格模式。如果函数体处于严格模式，<code>this</code>会指向<code>undefined</code>，否则<code>this</code>会指向全局对象。</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token string\">\"use strict\"</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//函数体处于严格模式下，this指向undefined</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">var</span> a <span class=\"token operator\">=</span> <span class=\"token string\">\"1891\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//>> 报错</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">var</span> a <span class=\"token operator\">=</span> <span class=\"token string\">\"1891\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token string\">\"use strict\"</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//>> 1891</span>\n  <span class=\"token comment\" spellcheck=\"true\">//这里输出 1891 而不是报错，是因为严格模式下，this的指向与func的调用位置无关</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<h3 id=\"SetTimeout或SetInterval中的this指向\"><a href=\"#SetTimeout或SetInterval中的this指向\" class=\"headerlink\" title=\"SetTimeout或SetInterval中的this指向\"></a>SetTimeout或SetInterval中的this指向</h3><pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> num <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Obj</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span>num<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>num <span class=\"token operator\">=</span> num<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>num<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">func1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"setTimeout:\"</span><span class=\"token operator\">+</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>num<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">func2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token function\">setInterval</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>num<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2000</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">var</span> obj <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Obj</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nobj<span class=\"token punctuation\">.</span><span class=\"token function\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//>> 1　             输出的是obj.num</span>\nobj<span class=\"token punctuation\">.</span><span class=\"token function\">func1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token comment\" spellcheck=\"true\">//>> setTimeout:0　  输出的是window.num</span>\nobj<span class=\"token punctuation\">.</span><span class=\"token function\">func2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token comment\" spellcheck=\"true\">//>> 0 0 0 0 ……　    输出的是window.num</span></code></pre>\n<p>可以发现在setInterval和setTimeout中传入函数时，函数中的this会指向window对象。</p>\n<h2 id=\"隐式指向\"><a href=\"#隐式指向\" class=\"headerlink\" title=\"隐式指向\"></a>隐式指向</h2><ol>\n<li><p>如果一个函数中有this，这个函数有被上一级的对象所调用，那么this指向的就是上一级的对象。</p>\n</li>\n<li><p>如果一个函数中有this，这个函数中包含多个对象，尽管这个函数是被最外层的对象所调用，this指向的也只是它上一级的对象。</p>\n</li>\n</ol>\n<pre class=\" language-javaScript\"><code class=\"language-javaScript\">var o = {\n    a:10,\n    b:{\n        // a:12,\n        fn:function(){\n            console.log(this.a); //undefined\n        }\n    }\n}\no.b.fn();\n</code></pre>\n<p>尽管对象b中没有属性a，这个this指向的也是对象b，因为this只会指向它的上一级对象，不管这个对象中有没有this要的东西。</p>\n<h2 id=\"隐式丢失\"><a href=\"#隐式丢失\" class=\"headerlink\" title=\"隐式丢失\"></a>隐式丢失</h2><pre class=\" language-javaScript\"><code class=\"language-javaScript\">\nvar o = {\n    a:10,\n    b:{\n        a:12,\n        fn:function(){\n            console.log(this.a); //undefined\n            console.log(this); //window\n        }\n    }\n}\nvar j = o.b.fn;\nj();   //this指向window\n</code></pre>\n<p>这里this指向的是window,this永远指向的是最后调用它的对象。</p>\n<p><strong>隐式丢失最容易在赋值时发生</strong>；隐式丢失发生时，调用这个函数会应用<strong>默认指向规则</strong>。下面再举一段更具迷惑性的例子：</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">var</span> a <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> o <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> a<span class=\"token punctuation\">:</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> func<span class=\"token punctuation\">:</span> func <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> p <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> a<span class=\"token punctuation\">:</span> <span class=\"token number\">4</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\no<span class=\"token punctuation\">.</span><span class=\"token function\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//>> 3</span>\n<span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">.</span>func <span class=\"token operator\">=</span> o<span class=\"token punctuation\">.</span>func<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//>> 2</span>\n<span class=\"token comment\" spellcheck=\"true\">// 赋值表达式 p.func=o.func 的返回值是目标函数的引用，也就是 func 函数的引用</span>\n<span class=\"token comment\" spellcheck=\"true\">// 因此调用位置是 func() 而不是 p.func() 或者 o.func()</span></code></pre>\n<h2 id=\"显式指向\"><a href=\"#显式指向\" class=\"headerlink\" title=\"显式指向\"></a>显式指向</h2><p>JavaScript内置对象<code>Function</code>的三个原型方法<code>call()</code>、<code>apply()</code>和<code>bind()</code>，它们的第一个参数是一个对象，它们会把这个对象绑定到<code>this</code>，接着在调用函数时让<code>this</code>指向这个对象。</p>\n<h3 id=\"call-apply-改变this的指向\"><a href=\"#call-apply-改变this的指向\" class=\"headerlink\" title=\"call(),apply()改变this的指向\"></a>call(),apply()改变this的指向</h3><pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> a <span class=\"token operator\">=</span> <span class=\"token string\">\"makai\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>a <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">var</span> obj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    a<span class=\"token punctuation\">:</span><span class=\"token string\">\"coffe1891\"</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\nfunc<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//>> coffe1891</span>\n<span class=\"token comment\" spellcheck=\"true\">// 在调用 func 时强制把它的 this 绑定到 obj 上</span></code></pre>\n<p>通过在call方法，给第一个参数添加要把b添加到哪个环境中，简单来说，this就会指向那个对象。</p>\n<p>call方法除了第一个参数以外还可以添加多个参数，如下：</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> a <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    user<span class=\"token punctuation\">:</span><span class=\"token string\">\"追梦子\"</span><span class=\"token punctuation\">,</span>\n    fn<span class=\"token punctuation\">:</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">,</span>ee<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>user<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//追梦子</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>e<span class=\"token operator\">+</span>ee<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//3</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">var</span> b <span class=\"token operator\">=</span> a<span class=\"token punctuation\">.</span>fn<span class=\"token punctuation\">;</span>\nb<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<p>注意如果call和apply的第一个参数写的是null，那么this指向的是window对象.</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> a <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    user<span class=\"token punctuation\">:</span><span class=\"token string\">\"追梦子\"</span><span class=\"token punctuation\">,</span>\n    fn<span class=\"token punctuation\">:</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//Window {external: Object, chrome: Object, document: document, a: Object, speechSynthesis: SpeechSynthesis…}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">var</span> b <span class=\"token operator\">=</span> a<span class=\"token punctuation\">.</span>fn<span class=\"token punctuation\">;</span>\nb<span class=\"token punctuation\">.</span><span class=\"token function\">apply</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<h3 id=\"bind-改变this的指向\"><a href=\"#bind-改变this的指向\" class=\"headerlink\" title=\"bind()改变this的指向\"></a>bind()改变this的指向</h3><pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> a <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    user<span class=\"token punctuation\">:</span><span class=\"token string\">\"追梦子\"</span><span class=\"token punctuation\">,</span>\n    fn<span class=\"token punctuation\">:</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>user<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">var</span> b <span class=\"token operator\">=</span> a<span class=\"token punctuation\">.</span>fn<span class=\"token punctuation\">;</span>\nb<span class=\"token punctuation\">.</span><span class=\"token function\">bind</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>我们发现代码没有被打印，对，这就是bind和call、apply方法的不同，实际上bind方法返回的是一个修改过后的函数。</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> a <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    user<span class=\"token punctuation\">:</span><span class=\"token string\">\"追梦子\"</span><span class=\"token punctuation\">,</span>\n    fn<span class=\"token punctuation\">:</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>user<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">var</span> b <span class=\"token operator\">=</span> a<span class=\"token punctuation\">.</span>fn<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> c <span class=\"token operator\">=</span> b<span class=\"token punctuation\">.</span><span class=\"token function\">bind</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//function() { [native code] }</span>\n</code></pre>\n<p>那么我们现在执行一下函数c看看，能不能打印出对象a里面的user。</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> a <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    user<span class=\"token punctuation\">:</span><span class=\"token string\">\"追梦子\"</span><span class=\"token punctuation\">,</span>\n    fn<span class=\"token punctuation\">:</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>user<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//追梦子</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">var</span> b <span class=\"token operator\">=</span> a<span class=\"token punctuation\">.</span>fn<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> c <span class=\"token operator\">=</span> b<span class=\"token punctuation\">.</span><span class=\"token function\">bind</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">c</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>同样bind也可以有多个参数，并且参数可以执行的时候再次添加，但是要注意的是，参数是按照形参的顺序进行的,且绑定在函数表达式上。</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> a <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    user<span class=\"token punctuation\">:</span><span class=\"token string\">\"追梦子\"</span><span class=\"token punctuation\">,</span>\n    fn<span class=\"token punctuation\">:</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">,</span>d<span class=\"token punctuation\">,</span>f<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>user<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//追梦子</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">,</span>d<span class=\"token punctuation\">,</span>f<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//10 1 2</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">var</span> b <span class=\"token operator\">=</span> a<span class=\"token punctuation\">.</span>fn<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> c <span class=\"token operator\">=</span> b<span class=\"token punctuation\">.</span><span class=\"token function\">bind</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">c</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>另外，使用<code>bind</code>可以修正SetTimeout和SetInterval的this指向:</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> num <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Obj</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span>num<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>num <span class=\"token operator\">=</span> num<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>num<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">func1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"setTimeout:\"</span><span class=\"token operator\">+</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>num<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">.</span><span class=\"token function\">bind</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//bind</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">func2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token function\">setInterval</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>num<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">.</span><span class=\"token function\">bind</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//bind</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">var</span> obj <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Obj</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nobj<span class=\"token punctuation\">.</span><span class=\"token function\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//>> 1　             输出的是obj.num</span>\nobj<span class=\"token punctuation\">.</span><span class=\"token function\">func1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token comment\" spellcheck=\"true\">//>> setTimeout:1　  输出的是obj.num</span>\nobj<span class=\"token punctuation\">.</span><span class=\"token function\">func2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token comment\" spellcheck=\"true\">//>> 1 1 1 1 ……　    输出的是obj.num</span>\n</code></pre>\n<p>总结：call和apply都是改变上下文中的this并立即执行这个函数，bind方法可以让对应的函数想什么时候调就什么时候调用，并且可以将参数在执行的时候添加，这是它们的区别，根据自己的实际情况来选择使用。</p>\n<h2 id=\"“new”操作符指向\"><a href=\"#“new”操作符指向\" class=\"headerlink\" title=\"“new”操作符指向\"></a>“new”操作符指向</h2><p>在JavaScript 中，<strong>构造函数</strong>只是一些<strong>使用<code>new</code>操作符时被调用的函数</strong>。它们并不会属于某个类，也不会实例化一个类。实际上，它们甚至都不能算是一种特殊的类型（class），它们<strong>只是被<code>new</code>操作符调用的普通函数而已</strong>。</p>\n<p>使用<code>new</code> 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作：</p>\n<ol>\n<li>创建（或者说构造）一个全新的对象；</li>\n<li>将构造函数的作用域赋给新对象（因此<code>this</code>就指向了这个新对象）；</li>\n<li>执行构造函数中的代码（为这个新对象添加属性、方法等）；</li>\n<li>如果函数没有返回其他对象，那么返回这个新对象。</li>\n</ol>\n<pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">Fn</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>user <span class=\"token operator\">=</span> <span class=\"token string\">\"Caraxiong\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">var</span> a <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Fn</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">.</span>user<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//Caraxiong</span>\n</code></pre>\n<p>这里之所以对象a可以点出函数Fn里面的user是因为new关键字可以改变this的指向，将这个this指向对象a.调用这个函数Fn的是对象a，那么this指向的自然是对象a，那么为什么对象Fn中会有user，因为你已经复制了一份Fn函数到对象a中，用了new关键字就等同于复制了一份。</p>\n<h2 id=\"箭头函数的this\"><a href=\"#箭头函数的this\" class=\"headerlink\" title=\"箭头函数的this\"></a>箭头函数的this</h2><p>箭头函数内部的this是语法作用域，由上下文确定，有了箭头函数，可以修复this的指向，this总是指向语法作用域，也就是外层调用者。即箭头函数的this指向是<strong>根据函数定义时的作用域来决定 <code>this</code> 的指向</strong>。何谓“定义时的作用域”？就是你定义这个箭头函数的时候，该箭头函数在哪个函数里，那么箭头函数体内的this就是它父函数的this。</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 返回一个箭头函数</span>\n  <span class=\"token keyword\">return</span> a <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">//this 继承自 func()</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">var</span> obj1 <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  a<span class=\"token punctuation\">:</span> <span class=\"token number\">2</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> obj2 <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  a<span class=\"token punctuation\">:</span> <span class=\"token number\">3</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">var</span> bar <span class=\"token operator\">=</span> func<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>obj1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nbar<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>obj2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//>> 2         不是 3 ！</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// func() 内部创建的箭头函数会捕获调用时 func() 的 this。</span>\n<span class=\"token comment\" spellcheck=\"true\">// 由于 func() 的 this 绑定到 obj1， bar（引用箭头函数）的 this 也会绑定到 obj1，</span>\n<span class=\"token comment\" spellcheck=\"true\">// this一旦被确定，就不可更改，所以箭头函数的绑定无法被修改。（new 也不行！）</span></code></pre>\n","more":"<h1 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h1><p><code>this</code> 既不指向函数自身也不指向函数的作用域，在函数真正被调用执行的时候确定的，函数定义的时候确定不了。</p>\n<ol>\n<li><code>this</code>的指向，<strong>是在函数被调用的时候确定的</strong>，也就是执行上下文被创建时确定的；</li>\n<li><code>this</code> 的指向和函数声明的位置没有任何关系，只取决于函数的调用位置（也即由谁、在什么地方调用这个函数）；</li>\n<li>正因为在执行上下文的创建阶段<code>this</code>的指向就已经被确定了，在执行阶段<code>this</code>指向不可再被更改。</li>\n</ol>\n<pre><code class=\"javascript\">var obj = &#123;\n    a: &quot;1891&quot;\n&#125;\n\nfunction func() &#123;\n    this = obj; //报错，因为在执行阶段试图修改this的指向\n    console.log(this.a);\n&#125;\n\nfunc();</code></pre>\n<h1 id=\"this的指向规则\"><a href=\"#this的指向规则\" class=\"headerlink\" title=\"this的指向规则\"></a>this的指向规则</h1><h2 id=\"默认指向\"><a href=\"#默认指向\" class=\"headerlink\" title=\"默认指向\"></a>默认指向</h2><h3 id=\"独立函数调用\"><a href=\"#独立函数调用\" class=\"headerlink\" title=\"独立函数调用\"></a>独立函数调用</h3><pre><code class=\"javascript\">function func() &#123;\n    console.log( this.a ); // this指向全局对象\n&#125;\nvar a = 2;\nfunc(); //&gt;&gt; 2</code></pre>\n<p>对于<strong>默认指向</strong>来说，决定<code>this</code>指向对象的并不是<strong>调用位置</strong>是否处于严格模式，而是函数体是否处于严格模式。如果函数体处于严格模式，<code>this</code>会指向<code>undefined</code>，否则<code>this</code>会指向全局对象。</p>\n<pre><code class=\"javascript\">function func() &#123;\n  &quot;use strict&quot;;//函数体处于严格模式下，this指向undefined\n  console.log(this.a);\n&#125;\n\nvar a = &quot;1891&quot;;\n(function() &#123;\n  func(); //&gt;&gt; 报错\n&#125;)();</code></pre>\n<pre><code class=\"javascript\">function func() &#123;\n  console.log(this.a);\n&#125;\n\nvar a = &quot;1891&quot;;\n(function() &#123;\n  &quot;use strict&quot;;\n  func(); //&gt;&gt; 1891\n  //这里输出 1891 而不是报错，是因为严格模式下，this的指向与func的调用位置无关\n&#125;)();</code></pre>\n<h3 id=\"SetTimeout或SetInterval中的this指向\"><a href=\"#SetTimeout或SetInterval中的this指向\" class=\"headerlink\" title=\"SetTimeout或SetInterval中的this指向\"></a>SetTimeout或SetInterval中的this指向</h3><pre><code class=\"javascript\">var num = 0;\nclass Obj &#123;\n    constructor(num)&#123;\n        this.num = num;\n    &#125;\n    func()&#123;\n        console.log(this.num);\n    &#125;\n    func1()&#123;\n        setTimeout(function () &#123;\n            console.log(&quot;setTimeout:&quot;+this.num);\n        &#125;, 1000)\n    &#125;\n    func2()&#123;\n        setInterval(function () &#123;\n            console.log(this.num);\n        &#125;, 2000)\n    &#125;\n&#125;\nvar obj = new Obj(1);\nobj.func();//&gt;&gt; 1　             输出的是obj.num\nobj.func1()//&gt;&gt; setTimeout:0　  输出的是window.num\nobj.func2()//&gt;&gt; 0 0 0 0 ……　    输出的是window.num</code></pre>\n<p>可以发现在setInterval和setTimeout中传入函数时，函数中的this会指向window对象。</p>\n<h2 id=\"隐式指向\"><a href=\"#隐式指向\" class=\"headerlink\" title=\"隐式指向\"></a>隐式指向</h2><ol>\n<li><p>如果一个函数中有this，这个函数有被上一级的对象所调用，那么this指向的就是上一级的对象。</p>\n</li>\n<li><p>如果一个函数中有this，这个函数中包含多个对象，尽管这个函数是被最外层的对象所调用，this指向的也只是它上一级的对象。</p>\n</li>\n</ol>\n<pre><code class=\"javaScript\">var o = &#123;\n    a:10,\n    b:&#123;\n        // a:12,\n        fn:function()&#123;\n            console.log(this.a); //undefined\n        &#125;\n    &#125;\n&#125;\no.b.fn();\n</code></pre>\n<p>尽管对象b中没有属性a，这个this指向的也是对象b，因为this只会指向它的上一级对象，不管这个对象中有没有this要的东西。</p>\n<h2 id=\"隐式丢失\"><a href=\"#隐式丢失\" class=\"headerlink\" title=\"隐式丢失\"></a>隐式丢失</h2><pre><code class=\"javaScript\">\nvar o = &#123;\n    a:10,\n    b:&#123;\n        a:12,\n        fn:function()&#123;\n            console.log(this.a); //undefined\n            console.log(this); //window\n        &#125;\n    &#125;\n&#125;\nvar j = o.b.fn;\nj();   //this指向window\n</code></pre>\n<p>这里this指向的是window,this永远指向的是最后调用它的对象。</p>\n<p><strong>隐式丢失最容易在赋值时发生</strong>；隐式丢失发生时，调用这个函数会应用<strong>默认指向规则</strong>。下面再举一段更具迷惑性的例子：</p>\n<pre><code class=\"javascript\">function func() &#123;\n  console.log(this.a);\n&#125;\nvar a = 2;\nvar o = &#123; a: 3, func: func &#125;;\nvar p = &#123; a: 4 &#125;;\no.func(); //&gt;&gt; 3\n(p.func = o.func)(); //&gt;&gt; 2\n// 赋值表达式 p.func=o.func 的返回值是目标函数的引用，也就是 func 函数的引用\n// 因此调用位置是 func() 而不是 p.func() 或者 o.func()</code></pre>\n<h2 id=\"显式指向\"><a href=\"#显式指向\" class=\"headerlink\" title=\"显式指向\"></a>显式指向</h2><p>JavaScript内置对象<code>Function</code>的三个原型方法<code>call()</code>、<code>apply()</code>和<code>bind()</code>，它们的第一个参数是一个对象，它们会把这个对象绑定到<code>this</code>，接着在调用函数时让<code>this</code>指向这个对象。</p>\n<h3 id=\"call-apply-改变this的指向\"><a href=\"#call-apply-改变this的指向\" class=\"headerlink\" title=\"call(),apply()改变this的指向\"></a>call(),apply()改变this的指向</h3><pre><code class=\"javascript\">var a = &quot;makai&quot;;\n\nfunction func() &#123;\n    console.log( this.a );\n&#125;\nvar obj = &#123;\n    a:&quot;coffe1891&quot;\n&#125;;\n\nfunc.call(obj); //&gt;&gt; coffe1891\n// 在调用 func 时强制把它的 this 绑定到 obj 上</code></pre>\n<p>通过在call方法，给第一个参数添加要把b添加到哪个环境中，简单来说，this就会指向那个对象。</p>\n<p>call方法除了第一个参数以外还可以添加多个参数，如下：</p>\n<pre><code class=\"javascript\">var a = &#123;\n    user:&quot;追梦子&quot;,\n    fn:function(e,ee)&#123;\n        console.log(this.user); //追梦子\n        console.log(e+ee); //3\n    &#125;\n&#125;\nvar b = a.fn;\nb.call(a,1,2);</code></pre>\n<p>注意如果call和apply的第一个参数写的是null，那么this指向的是window对象.</p>\n<pre><code class=\"javascript\">var a = &#123;\n    user:&quot;追梦子&quot;,\n    fn:function()&#123;\n        console.log(this); //Window &#123;external: Object, chrome: Object, document: document, a: Object, speechSynthesis: SpeechSynthesis…&#125;\n    &#125;\n&#125;\nvar b = a.fn;\nb.apply(null);</code></pre>\n<h3 id=\"bind-改变this的指向\"><a href=\"#bind-改变this的指向\" class=\"headerlink\" title=\"bind()改变this的指向\"></a>bind()改变this的指向</h3><pre><code class=\"javascript\">var a = &#123;\n    user:&quot;追梦子&quot;,\n    fn:function()&#123;\n        console.log(this.user);\n    &#125;\n&#125;\nvar b = a.fn;\nb.bind(a);\n</code></pre>\n<p>我们发现代码没有被打印，对，这就是bind和call、apply方法的不同，实际上bind方法返回的是一个修改过后的函数。</p>\n<pre><code class=\"javascript\">var a = &#123;\n    user:&quot;追梦子&quot;,\n    fn:function()&#123;\n        console.log(this.user);\n    &#125;\n&#125;\nvar b = a.fn;\nvar c = b.bind(a);\nconsole.log(c); //function() &#123; [native code] &#125;\n</code></pre>\n<p>那么我们现在执行一下函数c看看，能不能打印出对象a里面的user。</p>\n<pre><code class=\"javascript\">var a = &#123;\n    user:&quot;追梦子&quot;,\n    fn:function()&#123;\n        console.log(this.user); //追梦子\n    &#125;\n&#125;\nvar b = a.fn;\nvar c = b.bind(a);\nc();\n</code></pre>\n<p>同样bind也可以有多个参数，并且参数可以执行的时候再次添加，但是要注意的是，参数是按照形参的顺序进行的,且绑定在函数表达式上。</p>\n<pre><code class=\"javascript\">var a = &#123;\n    user:&quot;追梦子&quot;,\n    fn:function(e,d,f)&#123;\n        console.log(this.user); //追梦子\n        console.log(e,d,f); //10 1 2\n    &#125;\n&#125;\nvar b = a.fn;\nvar c = b.bind(a,10);\nc(1,2);\n</code></pre>\n<p>另外，使用<code>bind</code>可以修正SetTimeout和SetInterval的this指向:</p>\n<pre><code class=\"javascript\">var num = 0;\nclass Obj &#123;\n    constructor(num)&#123;\n        this.num = num;\n    &#125;\n    func()&#123;\n        console.log(this.num);\n    &#125;\n    func1()&#123;\n        setTimeout(function () &#123;\n            console.log(&quot;setTimeout:&quot;+this.num);\n        &#125;.bind(this), 1000);//bind\n    &#125;\n    func2()&#123;\n        setInterval(function () &#123;\n            console.log(this.num);\n        &#125;.bind(this), 2000);//bind\n    &#125;\n&#125;\nvar obj = new Obj(1);\nobj.func();//&gt;&gt; 1　             输出的是obj.num\nobj.func1()//&gt;&gt; setTimeout:1　  输出的是obj.num\nobj.func2()//&gt;&gt; 1 1 1 1 ……　    输出的是obj.num\n</code></pre>\n<p>总结：call和apply都是改变上下文中的this并立即执行这个函数，bind方法可以让对应的函数想什么时候调就什么时候调用，并且可以将参数在执行的时候添加，这是它们的区别，根据自己的实际情况来选择使用。</p>\n<h2 id=\"“new”操作符指向\"><a href=\"#“new”操作符指向\" class=\"headerlink\" title=\"“new”操作符指向\"></a>“new”操作符指向</h2><p>在JavaScript 中，<strong>构造函数</strong>只是一些<strong>使用<code>new</code>操作符时被调用的函数</strong>。它们并不会属于某个类，也不会实例化一个类。实际上，它们甚至都不能算是一种特殊的类型（class），它们<strong>只是被<code>new</code>操作符调用的普通函数而已</strong>。</p>\n<p>使用<code>new</code> 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作：</p>\n<ol>\n<li>创建（或者说构造）一个全新的对象；</li>\n<li>将构造函数的作用域赋给新对象（因此<code>this</code>就指向了这个新对象）；</li>\n<li>执行构造函数中的代码（为这个新对象添加属性、方法等）；</li>\n<li>如果函数没有返回其他对象，那么返回这个新对象。</li>\n</ol>\n<pre><code class=\"javascript\">function Fn()&#123;\n    this.user = &quot;Caraxiong&quot;;\n&#125;\nvar a = new Fn();\nconsole.log(a.user); //Caraxiong\n</code></pre>\n<p>这里之所以对象a可以点出函数Fn里面的user是因为new关键字可以改变this的指向，将这个this指向对象a.调用这个函数Fn的是对象a，那么this指向的自然是对象a，那么为什么对象Fn中会有user，因为你已经复制了一份Fn函数到对象a中，用了new关键字就等同于复制了一份。</p>\n<h2 id=\"箭头函数的this\"><a href=\"#箭头函数的this\" class=\"headerlink\" title=\"箭头函数的this\"></a>箭头函数的this</h2><p>箭头函数内部的this是语法作用域，由上下文确定，有了箭头函数，可以修复this的指向，this总是指向语法作用域，也就是外层调用者。即箭头函数的this指向是<strong>根据函数定义时的作用域来决定 <code>this</code> 的指向</strong>。何谓“定义时的作用域”？就是你定义这个箭头函数的时候，该箭头函数在哪个函数里，那么箭头函数体内的this就是它父函数的this。</p>\n<pre><code class=\"javascript\">function func() &#123;\n  // 返回一个箭头函数\n  return a =&gt; &#123;\n    //this 继承自 func()\n    console.log(this.a);\n  &#125;;\n&#125;\nvar obj1 = &#123;\n  a: 2\n&#125;;\nvar obj2 = &#123;\n  a: 3\n&#125;;\n\nvar bar = func.call(obj1);\nbar.call(obj2); //&gt;&gt; 2         不是 3 ！\n\n// func() 内部创建的箭头函数会捕获调用时 func() 的 this。\n// 由于 func() 的 this 绑定到 obj1， bar（引用箭头函数）的 this 也会绑定到 obj1，\n// this一旦被确定，就不可更改，所以箭头函数的绑定无法被修改。（new 也不行！）</code></pre>\n","categories":[{"name":"ES语法","path":"api/categories/ES语法.json"}],"tags":[{"name":"javaScript","path":"api/tags/javaScript.json"}]}