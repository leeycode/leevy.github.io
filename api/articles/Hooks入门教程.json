{"title":"Hooks入门教程","slug":"Hooks入门教程","date":"2019-09-16T09:09:12.000Z","updated":"2020-11-02T07:27:34.516Z","comments":true,"path":"api/articles/Hooks入门教程.json","excerpt":null,"covers":["https://7.dusays.com/2020/11/02/d812bf44ed5ef.png"],"content":"<p><img src=\"https://7.dusays.com/2020/11/02/d812bf44ed5ef.png\" alt=\"react\"></p>\n<h1 id=\"Hooks的含义\"><a href=\"#Hooks的含义\" class=\"headerlink\" title=\"Hooks的含义:\"></a>Hooks的含义:</h1><p>React Hooks 的意思是，组件尽量写成<strong>纯函数</strong>，如果需要外部功能和副作用，就用钩子把外部代码”钩”进来。 React Hooks 就是那些钩子。</p>\n<p>React默认提供了一些常用的钩子函数，你也可以自己定义钩子函数。</p>\n<p>React 团队希望，组件不要变成复杂的容器，最好只是数据流的管道。开发者根据需要，组合管道即可。 <strong>组件的最佳写法应该是函数</strong>，而不是类。</p>\n<p>React 约定，钩子一律使用<strong>use</strong>前缀命名，便于识别。</p>\n<h1 id=\"常见的钩子函数\"><a href=\"#常见的钩子函数\" class=\"headerlink\" title=\"常见的钩子函数\"></a>常见的钩子函数</h1><h2 id=\"1-useState-状态钩子\"><a href=\"#1-useState-状态钩子\" class=\"headerlink\" title=\"1. useState():状态钩子\"></a>1. useState():状态钩子</h2><pre><code>useState用于为函数组件引入状态（state）。纯函数不能有状态，所以把状态放在钩子里面\n\nuseState()这个函数接受状态的初始值，作为参数，返回一个数组，数组第一个成员是一个变量，指向状态的当前值。第二个成员是函数，用来更新状态，约定用set前缀加上状态的变量名。\n\nconst [buttonText, setButtonText] = useState(\"Click me, please\");</code></pre>\n<h2 id=\"2-useContext-共享状态钩子\"><a href=\"#2-useContext-共享状态钩子\" class=\"headerlink\" title=\"2. useContext()共享状态钩子\"></a>2. useContext()共享状态钩子</h2><pre><code>如果组件之间需要共享状态，可以使用useContext()。\n\n&lt;div className=\"App\"&gt;\n  &lt;Navbar/&gt;\n  &lt;Messages/&gt;\n&lt;/div&gt;\n\n如果Navbar跟Messages实现通信，第一步在组件外部建立一个context:\nconst AppContext = React.creatContext({})\n\n组件封装的代码如下：\n&lt;AppContext.Provider value={{\n  username: 'superawesome'\n}}&gt;\n  &lt;div className=\"App\"&gt;\n    &lt;Navbar/&gt;\n    &lt;Messages/&gt;\n  &lt;/div&gt;\n&lt;/AppContext.Provider&gt;\n\n在组件中的使用如下：\nconst Navbar = () =&gt; {\n  const { username } = useContext(AppContext);\n  return (\n    &lt;div className=\"navbar\"&gt;\n      &lt;p&gt;AwesomeSite&lt;/p&gt;\n      &lt;p&gt;{username}&lt;/p&gt;\n    &lt;/div&gt;\n  );\n}\n</code></pre>\n<h2 id=\"3-useReducer-action钩子\"><a href=\"#3-useReducer-action钩子\" class=\"headerlink\" title=\"3. useReducer():action钩子\"></a>3. useReducer():action钩子</h2><pre><code>React 本身不提供状态管理功能，通常需要使用外部库。这方面最常用的库是 Redux。\n\nRedux 的核心概念是，组件发出 action 与状态管理器通信。状态管理器收到 action 以后，使用 Reducer 函数算出新的状态，Reducer 函数的形式是(state, action) =&gt; newState。\n\nuseReducers()钩子用来引入 Reducer 功能。\n\nconst [state, dispatch] = useReducer(reducer, initialState);\n</code></pre>\n<h2 id=\"4-useEffect-副作用钩子\"><a href=\"#4-useEffect-副作用钩子\" class=\"headerlink\" title=\"4. useEffect():副作用钩子\"></a>4. useEffect():副作用钩子</h2><pre><code>useEffect()用来引入具有副作用的操作，最常见的就是向服务器请求数据。以前，放在componentDidMount里面的代码，现在可以放在useEffect()。\n\nuseEffect()的用法如下。\n\nuseEffect(()  =&gt;  {\n  // Async Action\n}, [dependencies])\n\nuseEffect()接受两个参数。第一个参数是函数，异步操作的代码放里面，第二个参数是一个数组，用于给出Effect的依赖，只要这个数组发生变化，useEffect()就会执行。第二个参数可以省略，这时每次组件渲染时，就会执行useEffect()。</code></pre>\n<p>React首次渲染和之后的每次渲染都会调用一遍useEffect函数，而之前我们要用两个生命周期函数分别表示首次渲染(componentDidMonut)和更新导致的重新渲染(componentDidUpdate)。</p>\n<p>useEffect中定义的函数的执行不会阻碍浏览器更新视图，也就是说这些函数时异步执行的，而componentDidMonut和componentDidUpdate中的代码都是同步执行的。个人认为这个有好处也有坏处吧，比如我们要根据页面的大小，然后绘制当前弹出窗口的大小，如果时异步的就不好操作了。</p>\n","more":"<p><img src=\"https://7.dusays.com/2020/11/02/d812bf44ed5ef.png\" alt=\"react\"></p>\n<h1 id=\"Hooks的含义\"><a href=\"#Hooks的含义\" class=\"headerlink\" title=\"Hooks的含义:\"></a>Hooks的含义:</h1><p>React Hooks 的意思是，组件尽量写成<strong>纯函数</strong>，如果需要外部功能和副作用，就用钩子把外部代码”钩”进来。 React Hooks 就是那些钩子。</p>\n<p>React默认提供了一些常用的钩子函数，你也可以自己定义钩子函数。</p>\n<p>React 团队希望，组件不要变成复杂的容器，最好只是数据流的管道。开发者根据需要，组合管道即可。 <strong>组件的最佳写法应该是函数</strong>，而不是类。</p>\n<p>React 约定，钩子一律使用<strong>use</strong>前缀命名，便于识别。</p>\n<h1 id=\"常见的钩子函数\"><a href=\"#常见的钩子函数\" class=\"headerlink\" title=\"常见的钩子函数\"></a>常见的钩子函数</h1><h2 id=\"1-useState-状态钩子\"><a href=\"#1-useState-状态钩子\" class=\"headerlink\" title=\"1. useState():状态钩子\"></a>1. useState():状态钩子</h2><pre><code>useState用于为函数组件引入状态（state）。纯函数不能有状态，所以把状态放在钩子里面\n\nuseState()这个函数接受状态的初始值，作为参数，返回一个数组，数组第一个成员是一个变量，指向状态的当前值。第二个成员是函数，用来更新状态，约定用set前缀加上状态的变量名。\n\nconst [buttonText, setButtonText] = useState(&quot;Click me, please&quot;);</code></pre>\n<h2 id=\"2-useContext-共享状态钩子\"><a href=\"#2-useContext-共享状态钩子\" class=\"headerlink\" title=\"2. useContext()共享状态钩子\"></a>2. useContext()共享状态钩子</h2><pre><code>如果组件之间需要共享状态，可以使用useContext()。\n\n&lt;div className=&quot;App&quot;&gt;\n  &lt;Navbar/&gt;\n  &lt;Messages/&gt;\n&lt;/div&gt;\n\n如果Navbar跟Messages实现通信，第一步在组件外部建立一个context:\nconst AppContext = React.creatContext(&#123;&#125;)\n\n组件封装的代码如下：\n&lt;AppContext.Provider value=&#123;&#123;\n  username: 'superawesome'\n&#125;&#125;&gt;\n  &lt;div className=&quot;App&quot;&gt;\n    &lt;Navbar/&gt;\n    &lt;Messages/&gt;\n  &lt;/div&gt;\n&lt;/AppContext.Provider&gt;\n\n在组件中的使用如下：\nconst Navbar = () =&gt; &#123;\n  const &#123; username &#125; = useContext(AppContext);\n  return (\n    &lt;div className=&quot;navbar&quot;&gt;\n      &lt;p&gt;AwesomeSite&lt;/p&gt;\n      &lt;p&gt;&#123;username&#125;&lt;/p&gt;\n    &lt;/div&gt;\n  );\n&#125;\n</code></pre>\n<h2 id=\"3-useReducer-action钩子\"><a href=\"#3-useReducer-action钩子\" class=\"headerlink\" title=\"3. useReducer():action钩子\"></a>3. useReducer():action钩子</h2><pre><code>React 本身不提供状态管理功能，通常需要使用外部库。这方面最常用的库是 Redux。\n\nRedux 的核心概念是，组件发出 action 与状态管理器通信。状态管理器收到 action 以后，使用 Reducer 函数算出新的状态，Reducer 函数的形式是(state, action) =&gt; newState。\n\nuseReducers()钩子用来引入 Reducer 功能。\n\nconst [state, dispatch] = useReducer(reducer, initialState);\n</code></pre>\n<h2 id=\"4-useEffect-副作用钩子\"><a href=\"#4-useEffect-副作用钩子\" class=\"headerlink\" title=\"4. useEffect():副作用钩子\"></a>4. useEffect():副作用钩子</h2><pre><code>useEffect()用来引入具有副作用的操作，最常见的就是向服务器请求数据。以前，放在componentDidMount里面的代码，现在可以放在useEffect()。\n\nuseEffect()的用法如下。\n\nuseEffect(()  =&gt;  &#123;\n  // Async Action\n&#125;, [dependencies])\n\nuseEffect()接受两个参数。第一个参数是函数，异步操作的代码放里面，第二个参数是一个数组，用于给出Effect的依赖，只要这个数组发生变化，useEffect()就会执行。第二个参数可以省略，这时每次组件渲染时，就会执行useEffect()。</code></pre>\n<p>React首次渲染和之后的每次渲染都会调用一遍useEffect函数，而之前我们要用两个生命周期函数分别表示首次渲染(componentDidMonut)和更新导致的重新渲染(componentDidUpdate)。</p>\n<p>useEffect中定义的函数的执行不会阻碍浏览器更新视图，也就是说这些函数时异步执行的，而componentDidMonut和componentDidUpdate中的代码都是同步执行的。个人认为这个有好处也有坏处吧，比如我们要根据页面的大小，然后绘制当前弹出窗口的大小，如果时异步的就不好操作了。</p>\n","categories":[{"name":"新鲜技能","path":"api/categories/新鲜技能.json"}],"tags":[{"name":"react","path":"api/tags/react.json"},{"name":"hooks","path":"api/tags/hooks.json"}]}