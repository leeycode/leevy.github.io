{"title":"前端请求方式：xhr、ajax、axios与fetch的区别比较","slug":"前端请求方式：xhr、ajax、axios与fetch的区别比较","date":"2017-06-13T13:23:12.000Z","updated":"2020-10-31T08:42:31.016Z","comments":true,"path":"api/articles/前端请求方式：xhr、ajax、axios与fetch的区别比较.json","excerpt":null,"covers":null,"content":"<p>这些都是异步请求数据的方法。在不重新刷新页面的情况下与服务器通信，交换数据，或更新页面。</p>\n<h1 id=\"XMLHttpRequest对象\"><a href=\"#XMLHttpRequest对象\" class=\"headerlink\" title=\"XMLHttpRequest对象\"></a>XMLHttpRequest对象</h1><p>优点：</p>\n<ul>\n<li>不重新加载页面的情况下更新网页</li>\n<li>在页面已加载后从服务器请求/接收数据</li>\n<li>在后台向服务器发送数据</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>使用起来也比较繁琐，需要设置很多值。</li>\n<li>早期的IE浏览器有自己的实现，这样需要写兼容代码。</li>\n</ul>\n<p>示例：</p>\n<pre><code>if (window.XMLHttpRequest) { // model browser\n  xhr = new XMLHttpRequest()\n} else if (window.ActiveXObject) { // IE 6 and older\n  xhr = new ActiveXObject('Microsoft.XMLHTTP')\n}\nxhr.open('POST', url, true)\nxhr.send(data)\nxhr.onreadystatechange = function () {\nif (request.readyState === 4) { // 成功完成\n        // 判断响应状态码\n        if (request.status === 200) {\n            // 成功，通过responseText拿到响应的文本:\n            return success(request.responseText);\n        } else {\n            // 失败，根据响应码判断失败原因:\n            return fail(request.status);\n        }\n    } else {\n        // HTTP请求还在继续...\n    }\n}</code></pre>\n<h1 id=\"jQuery-ajax\"><a href=\"#jQuery-ajax\" class=\"headerlink\" title=\"jQuery ajax\"></a>jQuery ajax</h1><p>AJAX请求也兼容了各浏览器，对XMLHttpRequest对象的封装。</p>\n<p>优点：</p>\n<ul>\n<li>对原生XHR的封装，做了兼容处理，简化了使用。</li>\n<li>增加了对JSONP的支持，可以简单处理部分跨域。</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>如果有多个请求，并且有依赖关系的话，容易形成回调地狱。</li>\n<li>本身是针对MVC的编程，不符合现在前端MVVM的浪潮。</li>\n<li>ajax是jQuery中的一个方法。如果只是要使用ajax却要引入整个jQuery非常的不合理。</li>\n</ul>\n<p>示例：</p>\n<pre><code>$.ajax({\n  type: 'POST',\n  url: url, \n  data: data,\n  dataType: dataType,\n  success: function () {},\n  error: function () {}\n})</code></pre>\n<h1 id=\"axios\"><a href=\"#axios\" class=\"headerlink\" title=\"axios\"></a>axios</h1><p>Axios是一个基于promise的HTTP库，可以用在浏览器和 node.js 中。它本质也是对原生XMLHttpRequest的封装，只不过它是Promise的实现版本，符合最新的ES规范。</p>\n<p>优点：</p>\n<ul>\n<li>从浏览器中创建XMLHttpRequests</li>\n<li>从 node.js 创建 http 请求</li>\n<li>支持 Promise API</li>\n<li>拦截请求和响应</li>\n<li>转换请求数据和响应数据</li>\n<li>取消请求</li>\n<li>自动转换 JSON 数据</li>\n<li>客户端支持防御 XSRF</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>只持现代代浏览器。</li>\n</ul>\n<pre><code>axios({\n    method: 'post',\n    url: '/user/12345',\n    data: {\n      firstName: 'liu',\n      lastName: 'weiqin'\n    }\n  })\n  .then(res =&gt; console.log(res))\n  .catch(err =&gt; console.log(err))</code></pre>\n<h1 id=\"fetch\"><a href=\"#fetch\" class=\"headerlink\" title=\"fetch\"></a>fetch</h1><p>优点：</p>\n<ul>\n<li>语法简洁，更加语义化</li>\n<li>基于标准 Promise 实现，支持 async/await</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>Fetch 请求默认是不带 cookie 的，需要设置 fetch(url, {credentials: ‘include’})</li>\n<li>服务器返回 400，500 错误码时并不会 reject，只有网络错误这些导致请求不能完成时，fetch 才会被 reject。</li>\n</ul>\n<p>示例：</p>\n<pre><code>fetch('http://example.com/movies.json')\n  .then(function(response) {\n    return response.json();\n  })\n  .then(function(myJson) {\n    console.log(myJson);\n  });</code></pre>\n<p>ts对fetch简单封装下：</p>\n<pre><code>import _ from 'lodash';\nimport 'whatwg-fetch';\n\ninterface ReqInit extends RequestInit {\n  headers?: Record&lt;string, string&gt;;\n  /** eg. ?a=1 */\n  params?: { [key: string]: any };\n  /** eg. /:id/.. */\n  router?: { [key: string]: any };\n  /** 超时时间，默认3000 */\n  timeout?: number;\n}\n\nasync function request&lt;T = any&gt;(path: string, init: ReqInit = {}): Promise&lt;T&gt; {\n  const mergeInit = {\n    ...request.default,\n    ...init,\n    headers: { ...request.default.headers, ...init.headers },\n  };\n  const { params, router, body, timeout, headers } = mergeInit;\n  let url = path;\n\n  if (router) {\n    url = path.replace(/:([A-Za-z]+)/g, (substring, p1: string) =&gt; router[p1]);\n  }\n  if (params) {\n    url += _(\n      _.reduce(params, (prev, val, key) =&gt; `${prev}${key}=${val}&amp;`, '?'),\n    ).trimEnd('&amp;');\n  }\n\n  if (!Reflect.get(headers, 'Content-Type')) {\n    if (typeof body === 'string') {\n      Reflect.set(headers, 'Content-Type', 'application/json');\n    }\n  }\n\n  try {\n    const response: Response = await Promise.race([\n      fetch(url, mergeInit),\n      new Promise&lt;any&gt;((resolve, reject) =&gt; {\n        setTimeout(\n          () =&gt; reject({ status: 408, statusText: 'TIME_OUT_ERR', url }),\n          timeout,\n        );\n      }),\n    ]);\n\n    if (response.ok) {\n      if (request.interceptors.response) {\n        return await request.interceptors.response(response);\n      }\n      return await response.json();\n    }\n    throw response;\n  } catch (error) {\n    if (request.interceptors.catch) {\n      request.interceptors.catch(error);\n    }\n\n    throw error;\n  }\n}\n\nrequest.default = {\n  method: 'GET',\n  headers: {\n    Accept: '*/*',\n  },\n  mode: 'cors',\n  timeout: 3000,\n  // credentials: 'include' // send cookies\n} as ReqInit;\n\nrequest.interceptors = {\n  response: null,\n  catch: null,\n} as {\n  response: ((response: Response) =&gt; Promise&lt;any&gt;) | null;\n  catch: ((error: Partial&lt;Response&gt;) =&gt; void) | null;\n};\n\nexport default request;\n</code></pre>\n","more":"<p>这些都是异步请求数据的方法。在不重新刷新页面的情况下与服务器通信，交换数据，或更新页面。</p>\n<h1 id=\"XMLHttpRequest对象\"><a href=\"#XMLHttpRequest对象\" class=\"headerlink\" title=\"XMLHttpRequest对象\"></a>XMLHttpRequest对象</h1><p>优点：</p>\n<ul>\n<li>不重新加载页面的情况下更新网页</li>\n<li>在页面已加载后从服务器请求/接收数据</li>\n<li>在后台向服务器发送数据</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>使用起来也比较繁琐，需要设置很多值。</li>\n<li>早期的IE浏览器有自己的实现，这样需要写兼容代码。</li>\n</ul>\n<p>示例：</p>\n<pre><code>if (window.XMLHttpRequest) &#123; // model browser\n  xhr = new XMLHttpRequest()\n&#125; else if (window.ActiveXObject) &#123; // IE 6 and older\n  xhr = new ActiveXObject(&#39;Microsoft.XMLHTTP&#39;)\n&#125;\nxhr.open(&#39;POST&#39;, url, true)\nxhr.send(data)\nxhr.onreadystatechange = function () &#123;\nif (request.readyState === 4) &#123; // 成功完成\n        // 判断响应状态码\n        if (request.status === 200) &#123;\n            // 成功，通过responseText拿到响应的文本:\n            return success(request.responseText);\n        &#125; else &#123;\n            // 失败，根据响应码判断失败原因:\n            return fail(request.status);\n        &#125;\n    &#125; else &#123;\n        // HTTP请求还在继续...\n    &#125;\n&#125;</code></pre>\n<h1 id=\"jQuery-ajax\"><a href=\"#jQuery-ajax\" class=\"headerlink\" title=\"jQuery ajax\"></a>jQuery ajax</h1><p>AJAX请求也兼容了各浏览器，对XMLHttpRequest对象的封装。</p>\n<p>优点：</p>\n<ul>\n<li>对原生XHR的封装，做了兼容处理，简化了使用。</li>\n<li>增加了对JSONP的支持，可以简单处理部分跨域。</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>如果有多个请求，并且有依赖关系的话，容易形成回调地狱。</li>\n<li>本身是针对MVC的编程，不符合现在前端MVVM的浪潮。</li>\n<li>ajax是jQuery中的一个方法。如果只是要使用ajax却要引入整个jQuery非常的不合理。</li>\n</ul>\n<p>示例：</p>\n<pre><code>$.ajax(&#123;\n  type: &#39;POST&#39;,\n  url: url, \n  data: data,\n  dataType: dataType,\n  success: function () &#123;&#125;,\n  error: function () &#123;&#125;\n&#125;)</code></pre>\n<h1 id=\"axios\"><a href=\"#axios\" class=\"headerlink\" title=\"axios\"></a>axios</h1><p>Axios是一个基于promise的HTTP库，可以用在浏览器和 node.js 中。它本质也是对原生XMLHttpRequest的封装，只不过它是Promise的实现版本，符合最新的ES规范。</p>\n<p>优点：</p>\n<ul>\n<li>从浏览器中创建XMLHttpRequests</li>\n<li>从 node.js 创建 http 请求</li>\n<li>支持 Promise API</li>\n<li>拦截请求和响应</li>\n<li>转换请求数据和响应数据</li>\n<li>取消请求</li>\n<li>自动转换 JSON 数据</li>\n<li>客户端支持防御 XSRF</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>只持现代代浏览器。</li>\n</ul>\n<pre><code>axios(&#123;\n    method: &#39;post&#39;,\n    url: &#39;/user/12345&#39;,\n    data: &#123;\n      firstName: &#39;liu&#39;,\n      lastName: &#39;weiqin&#39;\n    &#125;\n  &#125;)\n  .then(res =&gt; console.log(res))\n  .catch(err =&gt; console.log(err))</code></pre>\n<h1 id=\"fetch\"><a href=\"#fetch\" class=\"headerlink\" title=\"fetch\"></a>fetch</h1><p>优点：</p>\n<ul>\n<li>语法简洁，更加语义化</li>\n<li>基于标准 Promise 实现，支持 async/await</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>Fetch 请求默认是不带 cookie 的，需要设置 fetch(url, {credentials: ‘include’})</li>\n<li>服务器返回 400，500 错误码时并不会 reject，只有网络错误这些导致请求不能完成时，fetch 才会被 reject。</li>\n</ul>\n<p>示例：</p>\n<pre><code>fetch(&#39;http://example.com/movies.json&#39;)\n  .then(function(response) &#123;\n    return response.json();\n  &#125;)\n  .then(function(myJson) &#123;\n    console.log(myJson);\n  &#125;);</code></pre>\n<p>ts对fetch简单封装下：</p>\n<pre><code>import _ from &#39;lodash&#39;;\nimport &#39;whatwg-fetch&#39;;\n\ninterface ReqInit extends RequestInit &#123;\n  headers?: Record&lt;string, string&gt;;\n  /** eg. ?a=1 */\n  params?: &#123; [key: string]: any &#125;;\n  /** eg. /:id/.. */\n  router?: &#123; [key: string]: any &#125;;\n  /** 超时时间，默认3000 */\n  timeout?: number;\n&#125;\n\nasync function request&lt;T = any&gt;(path: string, init: ReqInit = &#123;&#125;): Promise&lt;T&gt; &#123;\n  const mergeInit = &#123;\n    ...request.default,\n    ...init,\n    headers: &#123; ...request.default.headers, ...init.headers &#125;,\n  &#125;;\n  const &#123; params, router, body, timeout, headers &#125; = mergeInit;\n  let url = path;\n\n  if (router) &#123;\n    url = path.replace(/:([A-Za-z]+)/g, (substring, p1: string) =&gt; router[p1]);\n  &#125;\n  if (params) &#123;\n    url += _(\n      _.reduce(params, (prev, val, key) =&gt; `$&#123;prev&#125;$&#123;key&#125;=$&#123;val&#125;&amp;`, &#39;?&#39;),\n    ).trimEnd(&#39;&amp;&#39;);\n  &#125;\n\n  if (!Reflect.get(headers, &#39;Content-Type&#39;)) &#123;\n    if (typeof body === &#39;string&#39;) &#123;\n      Reflect.set(headers, &#39;Content-Type&#39;, &#39;application/json&#39;);\n    &#125;\n  &#125;\n\n  try &#123;\n    const response: Response = await Promise.race([\n      fetch(url, mergeInit),\n      new Promise&lt;any&gt;((resolve, reject) =&gt; &#123;\n        setTimeout(\n          () =&gt; reject(&#123; status: 408, statusText: &#39;TIME_OUT_ERR&#39;, url &#125;),\n          timeout,\n        );\n      &#125;),\n    ]);\n\n    if (response.ok) &#123;\n      if (request.interceptors.response) &#123;\n        return await request.interceptors.response(response);\n      &#125;\n      return await response.json();\n    &#125;\n    throw response;\n  &#125; catch (error) &#123;\n    if (request.interceptors.catch) &#123;\n      request.interceptors.catch(error);\n    &#125;\n\n    throw error;\n  &#125;\n&#125;\n\nrequest.default = &#123;\n  method: &#39;GET&#39;,\n  headers: &#123;\n    Accept: &#39;*/*&#39;,\n  &#125;,\n  mode: &#39;cors&#39;,\n  timeout: 3000,\n  // credentials: &#39;include&#39; // send cookies\n&#125; as ReqInit;\n\nrequest.interceptors = &#123;\n  response: null,\n  catch: null,\n&#125; as &#123;\n  response: ((response: Response) =&gt; Promise&lt;any&gt;) | null;\n  catch: ((error: Partial&lt;Response&gt;) =&gt; void) | null;\n&#125;;\n\nexport default request;\n</code></pre>\n","categories":[{"name":"前端基础","path":"api/categories/前端基础.json"}],"tags":[{"name":"数据请求","path":"api/tags/数据请求.json"},{"name":"前端基础","path":"api/tags/前端基础.json"}]}