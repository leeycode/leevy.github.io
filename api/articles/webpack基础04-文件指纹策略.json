{"title":"webpack基础04-文件指纹策略","slug":"webpack基础04-文件指纹策略","date":"2020-12-11T01:38:41.000Z","updated":"2022-01-05T09:30:23.683Z","comments":true,"path":"api/articles/webpack基础04-文件指纹策略.json","excerpt":null,"covers":null,"content":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>webpack的指纹策略是通过给文件加上hash后缀，做到当代码有修改时打包出来的文件后缀也会修改，从而可以把静态资源开启持久缓存，这样每次有更新的代码打包后生成的都是新的问题件，从而最大程度上使用缓存。</p>\n<h2 id=\"文件指纹类型\"><a href=\"#文件指纹类型\" class=\"headerlink\" title=\"文件指纹类型\"></a>文件指纹类型</h2><p>webpack提供了三种hash类似</p>\n<h3 id=\"hash\"><a href=\"#hash\" class=\"headerlink\" title=\"hash\"></a>hash</h3><p>和整个项目构建相关，只要一个文件有修改，整个项目的hash值就会改变。<br>例如</p>\n<pre><code>// webpack.prod.js\nentry: {\n    index: \"./src/index\",    \n    search: \"./src/search\"\n},\noutput: {\n    path: path.join(__dirname, \"dist\"),\n    filename: \"[name]_[hash:8].js\",\n    publicPath: \"./dist\"\n}\n</code></pre>\n<p>它的问题是当项目有多入口或者使用code spliting，只要有一个文件修改打包的生成的js代码hash都会改变。不利于缓存。</p>\n<h3 id=\"chunkhash\"><a href=\"#chunkhash\" class=\"headerlink\" title=\"chunkhash\"></a>chunkhash</h3><p>模块的hash，根据模块的修改才改变对应的hash值。<br>根据不同的入口文件(Entry)进行依赖文件解析、构建对应的chunk，生成对应的哈希值。我们在生产环境里把一些公共库和程序入口文件区分开，单独打包构建，接着我们采用chunkhash的方式生成哈希值，那么只要我们不改动公共库的代码，就可以保证其哈希值不会受影响</p>\n<pre><code>output: {\n    path: path.resolve(__dirname, 'dist'),\n    filename: '[name]_[chunkhash:8].js'\n},</code></pre>\n<h3 id=\"contenthash\"><a href=\"#contenthash\" class=\"headerlink\" title=\"contenthash\"></a>contenthash</h3><p>据文件内容来定义 hash ，文件内容不变，则 contenthash 不变。</p>\n<p>某个页面既有js资源，又有css资源。如果css资源也使用Chunkhash。如果修改了js。由于css资源使用了Chunkhash，就会导致css内容没有变化，发布上线的文件却发生了变化。因此，通常对css资源使用Contenthash。这个时候可以使用mini-css-extract-plugin里的contenthash值，保证即使css文件所处的模块里就算其他文件内容改变，只要css文件内容不变，那么不会重复构建</p>\n<pre><code>module.exports = {\n    entry: {\n        app: './src/app.js',\n        search: './src/search.js'\n    },\n    output: {\n        filename: '[name][chunkhash:8].js',\n        path: __dirname + '/dist'\n    },\n    plugins: [\n        new MiniCssExtractPlugin({\n            filename: `[name][contenthash:8].css`\n        }),\n    ]\n};\n</code></pre>\n<h3 id=\"图片，字体文件的文件指纹设置\"><a href=\"#图片，字体文件的文件指纹设置\" class=\"headerlink\" title=\"图片，字体文件的文件指纹设置\"></a>图片，字体文件的文件指纹设置</h3><p>设置 file-loader（或url-loader） 的 name，使用 [hash]<br>图片，字体文件的hash和css/js资源的hash概念不一样，图片，字体文件的hash是由内容决定的</p>\n<pre><code>{\n    test: /\\.(png|svg|jpg|gif)$/,\n    use: [{\n        loader: 'file-loader',\n        options: {\n            name: 'img/[name][hash:8].[ext] '\n        }\n    }]\n}\n</code></pre>\n","more":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>webpack的指纹策略是通过给文件加上hash后缀，做到当代码有修改时打包出来的文件后缀也会修改，从而可以把静态资源开启持久缓存，这样每次有更新的代码打包后生成的都是新的问题件，从而最大程度上使用缓存。</p>\n<h2 id=\"文件指纹类型\"><a href=\"#文件指纹类型\" class=\"headerlink\" title=\"文件指纹类型\"></a>文件指纹类型</h2><p>webpack提供了三种hash类似</p>\n<h3 id=\"hash\"><a href=\"#hash\" class=\"headerlink\" title=\"hash\"></a>hash</h3><p>和整个项目构建相关，只要一个文件有修改，整个项目的hash值就会改变。<br>例如</p>\n<pre><code>// webpack.prod.js\nentry: &#123;\n    index: &quot;./src/index&quot;,    \n    search: &quot;./src/search&quot;\n&#125;,\noutput: &#123;\n    path: path.join(__dirname, &quot;dist&quot;),\n    filename: &quot;[name]_[hash:8].js&quot;,\n    publicPath: &quot;./dist&quot;\n&#125;\n</code></pre>\n<p>它的问题是当项目有多入口或者使用code spliting，只要有一个文件修改打包的生成的js代码hash都会改变。不利于缓存。</p>\n<h3 id=\"chunkhash\"><a href=\"#chunkhash\" class=\"headerlink\" title=\"chunkhash\"></a>chunkhash</h3><p>模块的hash，根据模块的修改才改变对应的hash值。<br>根据不同的入口文件(Entry)进行依赖文件解析、构建对应的chunk，生成对应的哈希值。我们在生产环境里把一些公共库和程序入口文件区分开，单独打包构建，接着我们采用chunkhash的方式生成哈希值，那么只要我们不改动公共库的代码，就可以保证其哈希值不会受影响</p>\n<pre><code>output: &#123;\n    path: path.resolve(__dirname, &#39;dist&#39;),\n    filename: &#39;[name]_[chunkhash:8].js&#39;\n&#125;,</code></pre>\n<h3 id=\"contenthash\"><a href=\"#contenthash\" class=\"headerlink\" title=\"contenthash\"></a>contenthash</h3><p>据文件内容来定义 hash ，文件内容不变，则 contenthash 不变。</p>\n<p>某个页面既有js资源，又有css资源。如果css资源也使用Chunkhash。如果修改了js。由于css资源使用了Chunkhash，就会导致css内容没有变化，发布上线的文件却发生了变化。因此，通常对css资源使用Contenthash。这个时候可以使用mini-css-extract-plugin里的contenthash值，保证即使css文件所处的模块里就算其他文件内容改变，只要css文件内容不变，那么不会重复构建</p>\n<pre><code>module.exports = &#123;\n    entry: &#123;\n        app: &#39;./src/app.js&#39;,\n        search: &#39;./src/search.js&#39;\n    &#125;,\n    output: &#123;\n        filename: &#39;[name][chunkhash:8].js&#39;,\n        path: __dirname + &#39;/dist&#39;\n    &#125;,\n    plugins: [\n        new MiniCssExtractPlugin(&#123;\n            filename: `[name][contenthash:8].css`\n        &#125;),\n    ]\n&#125;;\n</code></pre>\n<h3 id=\"图片，字体文件的文件指纹设置\"><a href=\"#图片，字体文件的文件指纹设置\" class=\"headerlink\" title=\"图片，字体文件的文件指纹设置\"></a>图片，字体文件的文件指纹设置</h3><p>设置 file-loader（或url-loader） 的 name，使用 [hash]<br>图片，字体文件的hash和css/js资源的hash概念不一样，图片，字体文件的hash是由内容决定的</p>\n<pre><code>&#123;\n    test: /\\.(png|svg|jpg|gif)$/,\n    use: [&#123;\n        loader: &#39;file-loader&#39;,\n        options: &#123;\n            name: &#39;img/[name][hash:8].[ext] &#39;\n        &#125;\n    &#125;]\n&#125;\n</code></pre>\n","categories":[{"name":"webpack专区","path":"api/categories/webpack专区.json"}],"tags":[{"name":"webpack","path":"api/tags/webpack.json"}]}