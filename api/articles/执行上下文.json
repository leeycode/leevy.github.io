{"title":"执行上下文相关概念","slug":"执行上下文","date":"2020-11-16T08:22:19.000Z","updated":"2022-01-05T09:27:58.670Z","comments":true,"path":"api/articles/执行上下文.json","excerpt":null,"covers":["https://7.dusays.com/2020/11/16/9349c5ea172d6.png","https://7.dusays.com/2020/11/16/d7d64d01245e3.png","https://7.dusays.com/2020/11/16/55431837a2be8.png","https://7.dusays.com/2020/11/16/7fad446d8076c.png","https://7.dusays.com/2020/11/16/867543641bca6.png","https://7.dusays.com/2020/11/16/8dc21cd5da203.png"],"content":"<h1 id=\"执行上下文（Execution-Context）\"><a href=\"#执行上下文（Execution-Context）\" class=\"headerlink\" title=\"执行上下文（Execution Context）\"></a>执行上下文（Execution Context）</h1><h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>执行上下文就是当前 JavaScript 代码被解析和执行时所在的环境，也叫作执行环境。</p>\n<p>它是一个抽象概念，JavaScript 中运行任何的代码都是在执行上下文中运行，在该执行上下文的创建阶段，变量对象（Variable Object，本文接下来会详述）、作用域链、this指向会分别被确定。</p>\n<p><img src=\"https://7.dusays.com/2020/11/16/9349c5ea172d6.png\"></p>\n<h2 id=\"执行上下文类型\"><a href=\"#执行上下文类型\" class=\"headerlink\" title=\"执行上下文类型\"></a>执行上下文类型</h2><p>执行上下文总共有三种类型：</p>\n<ul>\n<li><strong>全局执行上下文</strong>：这是默认的、最基础的执行上下文。不在任何函数中的代码都位于全局执行上下文中。它做了两件事：</li>\n</ul>\n<ol>\n<li>创建一个全局对象，在浏览器中这个全局对象就是 window 对象；</li>\n<li>将 this 指针指向这个全局对象。一个程序中只能存在一个全局执行上下文。</li>\n</ol>\n<ul>\n<li><strong>函数执行上下文</strong>：每次调用函数时，都会为该函数创建一个新的执行上下文。每个函数都拥有自己的执行上下文，但是只有在函数被调用的时候才会被创建。一个程序中可以存在任意数量的函数执行上下文。每当一个新的执行上下文被创建，它都会按照特定的顺序执行一系列步骤，具体过程将在本文后面讨论。</li>\n<li>eval执行上下文：运行在 eval 函数中的代码也获得了自己的执行上下文，ES6 之后不再推荐使用 eval 函数，所以本书出于面试实用考虑，不会深入讨论eval。</li>\n</ul>\n<h2 id=\"执行上下文的生命周期\"><a href=\"#执行上下文的生命周期\" class=\"headerlink\" title=\"执行上下文的生命周期\"></a>执行上下文的生命周期</h2><p>执行上下文的生命周期包括三个阶段：创建阶段 → 执行阶段 → 回收阶段，本文重点介绍创建阶段。</p>\n<h3 id=\"a-创建阶段\"><a href=\"#a-创建阶段\" class=\"headerlink\" title=\"a. 创建阶段\"></a>a. 创建阶段</h3><p>当函数被调用，但未执行任何其内部代码之前，会做以下三件事：</p>\n<ul>\n<li>创建变量对象：首先初始化函数的参数 arguments，提升函数声明和变量声明（变量的<strong>声明提前</strong>有赖于<code>var</code>关键字）。</li>\n<li>创建作用域链：在执行期上下文的创建阶段，作用域链是在变量对象之后创建的。作用域链本身包含变量对象。作用域链用于解析变量。当被要求解析变量时，JavaScript 始终从代码嵌套的最内层开始，如果最内层没有找到变量，就会跳转到上一层父作用域中查找，直到找到该变量。</li>\n<li>确定 this 指向。</li>\n</ul>\n<h3 id=\"b-执行阶段\"><a href=\"#b-执行阶段\" class=\"headerlink\" title=\"b. 执行阶段\"></a>b. 执行阶段</h3><p>创建完成之后，就会开始执行代码，在这个阶段，会完成变量赋值、函数引用、以及执行其他代码。</p>\n<h3 id=\"c-回收阶段\"><a href=\"#c-回收阶段\" class=\"headerlink\" title=\"c. 回收阶段\"></a>c. 回收阶段</h3><p>函数调用完毕后，函数出栈，对应的执行上下文也出栈，等待垃圾回收器回收执行上下文。</p>\n<p><img src=\"https://7.dusays.com/2020/11/16/d7d64d01245e3.png\"></p>\n<h2 id=\"执行上下文栈\"><a href=\"#执行上下文栈\" class=\"headerlink\" title=\"执行上下文栈\"></a>执行上下文栈</h2><pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> a <span class=\"token operator\">=</span> <span class=\"token string\">\"coffe\"</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//1.进入全局执行上下文</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">out</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> b <span class=\"token operator\">=</span> <span class=\"token string\">\"18\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">function</span> <span class=\"token function\">inner</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">var</span> c <span class=\"token operator\">=</span> <span class=\"token string\">\"91\"</span><span class=\"token punctuation\">;</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>a<span class=\"token operator\">+</span>b<span class=\"token operator\">+</span>c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">inner</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//3.进入inner函数的执行上下文</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token function\">out</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//2.进入out函数的执行上下文</span></code></pre>\n<p> 在代码开始执行时，首先会产生一个<strong>全局执行上下文</strong>，调用函数时，会产生<strong>函数执行上下文</strong>，函数调用完成后，它的执行上下文以及其中的数据都会被销毁，重新回到全局执行环境，网页关闭后全局执行环境也会销毁。其实这是一个入栈出栈的过程，<strong>全局上下文永远在栈底，而当前正在函数执行上下文在栈顶</strong>。以上代码的执行会经历以下过程：</p>\n<ol>\n<li>当代码开始执行时就<strong>创建全局执行上下文，全局执行上下文入栈</strong>。</li>\n<li>全局执行上下文入栈后，其中的代码开始执行，进行赋值、函数调用等操作，执行到<code>out()</code>时，<strong>激活函数<code>out</code>创建自己的执行上下文，<code>out</code>函数执行上下文入栈</strong>。</li>\n<li><code>out</code>函数执行上下文入栈后，其中的代码开始执行，进行赋值、函数调用等操作，执行到<code>inner()</code>时，<strong>激活函数<code>inner</code>创建自己的执行上下文，<code>inner</code>函数执行上下文入栈</strong>。</li>\n<li><code>inner</code>函数上下文入栈后，其中的代码开始执行，进行赋值、函数调用、打印等操作，由于里面没有可以生成其他执行上下文的需要，所有代码执行完毕后，**<code>inner</code>函数上下文出栈**。</li>\n<li><code>inner</code>函数执行上下文出栈，又回到了<code>out</code>函数执行上下文环境，接着执行<code>out</code>函数中后面剩下的代码，由于后面没有可以生成其他执行上下文的需要，所有代码执行完毕后，**<code>out</code>函数执行上下文出栈**。</li>\n<li><code>out</code>函数执行上下文出栈后，又回到了全局执行上下文环境，直到浏览器窗口关闭，<strong>全局执行上下文出栈</strong>。</li>\n</ol>\n<p><img src=\"https://7.dusays.com/2020/11/16/55431837a2be8.png\"></p>\n<p>我们可以发现：</p>\n<ol>\n<li>全局执行上下文在代码开始执行时就创建，有且只有一个，永远在执行上下文栈的栈底，浏览器窗口关闭时它才出栈。</li>\n<li>函数被调用的时候创建函数的执行上下文环境，并且入栈。</li>\n<li>只有栈顶的执行上下文才是处于活动状态的，也即只有栈顶的变量对象才会变成活动对象。</li>\n</ol>\n<h1 id=\"变量对象（Variable-Object，VO\"><a href=\"#变量对象（Variable-Object，VO\" class=\"headerlink\" title=\"变量对象（Variable Object，VO)\"></a>变量对象（Variable Object，VO)</h1><p>变量对象（VO）是一个类似于容器的对象，与作用域链、执行上下文息息相关。</p>\n<h2 id=\"变量对象的创建过程的三条规则：\"><a href=\"#变量对象的创建过程的三条规则：\" class=\"headerlink\" title=\"变量对象的创建过程的三条规则：\"></a>变量对象的创建过程的三条规则：</h2><ol>\n<li><strong>建立<code>arguments</code>对象</strong>。检查当前执行上下文中的参数，建立该对象下的属性与属性值。</li>\n<li><strong>检查当前执行上下文的函数声明，也就是使用<code>function</code>关键字声明的函数</strong>。在变量对象中以函数名建立一个属性，属性值为指向该函数所在内存地址的引用。如果该属性之前已经存在，那么该属性将会被新的引用所覆盖。</li>\n<li><strong>检查当前执行上下文中的变量声明，每找到一个变量声明，就在变量对象中以变量名建立一个属性，属性值为<code>undefined</code>**。</strong>如果该变量名的属性已经存在，为了防止同名的函数被修改为<code>undefined</code>，则会直接跳过，原属性值不会被修改**。</li>\n</ol>\n<p><img src=\"https://7.dusays.com/2020/11/16/7fad446d8076c.png\"></p>\n<p>可以用以下伪代码来表示变量对象：</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\">VO<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>\n    Arguments<span class=\"token punctuation\">:</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span><span class=\"token comment\" spellcheck=\"true\">//实参</span>\n    Param_Variable<span class=\"token punctuation\">:</span>具体值<span class=\"token punctuation\">,</span><span class=\"token comment\" spellcheck=\"true\">//形参</span>\n    Function<span class=\"token punctuation\">:</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">function</span> reference<span class=\"token operator\">></span><span class=\"token punctuation\">,</span><span class=\"token comment\" spellcheck=\"true\">//函数的引用</span>\n    Variable<span class=\"token punctuation\">:</span>undefined<span class=\"token comment\" spellcheck=\"true\">//其他变量</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>当执行上下文进入执行阶段后，变量对象会变为<strong>活动对象</strong>（Active Object，AO）。此时原先声明的变量会被赋值。<strong>变量对象和活动对象都是指同一个对象，只是处于执行上下文的不同阶段</strong>。</p>\n<p>我们可以通过以下伪代码来表示活动对象：</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\">AO<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>\n    Arguments<span class=\"token punctuation\">:</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span><span class=\"token comment\" spellcheck=\"true\">//实参</span>\n    Param_Variable<span class=\"token punctuation\">:</span>具体值<span class=\"token punctuation\">,</span>  <span class=\"token comment\" spellcheck=\"true\">//形参</span>\n    Function<span class=\"token punctuation\">:</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">function</span> reference<span class=\"token operator\">></span><span class=\"token punctuation\">,</span><span class=\"token comment\" spellcheck=\"true\">//函数的引用</span>\n    Variable<span class=\"token punctuation\">:</span>具体值<span class=\"token comment\" spellcheck=\"true\">//注意，这里已经赋值了喔</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>未进入执行上下文的执行阶段之前，变量对象中的属性都不能访问。但是<strong>进入执行阶段之后，变量对象转变为了活动对象（被激活了）</strong>，里面的属性可以被访问了，然后开始进行执行阶段的操作。</p>\n<h2 id=\"全局执行上下文的变量对象\"><a href=\"#全局执行上下文的变量对象\" class=\"headerlink\" title=\"全局执行上下文的变量对象\"></a>全局执行上下文的变量对象</h2><p>全局执行上下文的变量对象是<code>window</code>对象，而这个特殊，在<code>this</code>指向上也同样适用，<code>this</code>也是指向<code>window</code>。</p>\n<p>除此之外，全局执行上下文的生命周期，与程序的生命周期一致，只要程序运行不结束（比如关掉浏览器窗口），全局执行上下文就会一直存在。其他所有的执行上下文，都能直接访问全局执行上下文里的内容。</p>\n<h2 id=\"再看一段代码，留意注释\"><a href=\"#再看一段代码，留意注释\" class=\"headerlink\" title=\"再看一段代码，留意注释\"></a>再看一段代码，留意注释</h2><pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'function func'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">var</span> func <span class=\"token operator\">=</span> <span class=\"token string\">\"coffe\"</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>func<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//>> coffe</span>\n<span class=\"token comment\" spellcheck=\"true\">// 以上代码中，按三条规则，变量声明的 func 遇到函数声明的 func 应该会跳过，</span>\n<span class=\"token comment\" spellcheck=\"true\">// 可是为什么最后 func 的输出结果仍然是被覆盖了显示\"coffe\"呢？</span>\n<span class=\"token comment\" spellcheck=\"true\">// 那是因为三条规则仅仅适用于变量对象的创建阶段，也即执行上下文的创建阶段。</span>\n<span class=\"token comment\" spellcheck=\"true\">// 而 func=\"coffe\" 是在执行上下文的执行阶段中运行的，输出结果自然会是\"coffe\"。</span></code></pre>\n<p>这种现象很容易让人费解，其实也是因为<code>var</code>声明的变量允许重名导致的，若使用关键字<code>let</code>来声明变量，就可以避免这种令人费解的情况发生。</p>\n<h1 id=\"作用域链（Scope-Chain）\"><a href=\"#作用域链（Scope-Chain）\" class=\"headerlink\" title=\"作用域链（Scope Chain）\"></a>作用域链（Scope Chain）</h1><h2 id=\"定义-1\"><a href=\"#定义-1\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p><strong>多个作用域对应的变量对象串联起来组成的链表就是作用域链，</strong>这个链表是以引用的形式保持对变量对象的访问<strong>。</strong>作用域链保证了当前执行上下文对符合访问权限的变量和函数的有序访问。</p>\n<p><img src=\"https://7.dusays.com/2020/11/16/867543641bca6.png\" alt=\"作用域链的图示\"></p>\n<p>作用域链的最顶端一定是当前作用域（local scope）对应的变量对象，最底端一定是全局作用域对应的变量对象（全局VO）。</p>\n<p>作用域链可以形象地比如为一个蒸笼。</p>\n<p><img src=\"https://7.dusays.com/2020/11/16/8dc21cd5da203.png\" alt=\"蒸笼\"></p>\n<p>最底下的一屉，相当于是全局作用域，它里面的蒸汽（变量和函数的可见性）可以渗透到整个蒸笼，底层之上的其他屉相当于局部作用域，这些上面屉的蒸汽只能影响更上面的屉。</p>\n<p>作用域链可以理解为下面这种伪代码格式：</p>\n<pre class=\" language-text\"><code class=\"language-text\">{\n    Scope: [\n        { //当前作用域对应的VO\n            实参,\n            形参,\n            变量,\n            函数\n        }, \n        { //第二个作用域对应的VO\n            实参,\n            形参,\n            变量,\n            函数\n        },\n        ... \n        { //全局作用域对应的VO\n            变量,\n            函数\n        }\n    ]\n}</code></pre>\n<h2 id=\"变量-函数的查找机制\"><a href=\"#变量-函数的查找机制\" class=\"headerlink\" title=\"变量/函数的查找机制\"></a>变量/函数的查找机制</h2><p>  查找变量/函数时JS引擎是从里离它最近作用域开始的查找的，也即从离它最近的变量对象（VO）开始查找。</p>\n<p>如果在当前的变量对象里面找不到目标变量/函数，就在上一级作用域的变量对象里面查找。若这时找到了目标变量/函数，则停止查找；若找不到，一直回溯到全局作用域的变量对象里查找，若仍找不到目标变量/函数，停止查找。</p>\n","more":"<h1 id=\"执行上下文（Execution-Context）\"><a href=\"#执行上下文（Execution-Context）\" class=\"headerlink\" title=\"执行上下文（Execution Context）\"></a>执行上下文（Execution Context）</h1><h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>执行上下文就是当前 JavaScript 代码被解析和执行时所在的环境，也叫作执行环境。</p>\n<p>它是一个抽象概念，JavaScript 中运行任何的代码都是在执行上下文中运行，在该执行上下文的创建阶段，变量对象（Variable Object，本文接下来会详述）、作用域链、this指向会分别被确定。</p>\n<p><img src=\"https://7.dusays.com/2020/11/16/9349c5ea172d6.png\"></p>\n<h2 id=\"执行上下文类型\"><a href=\"#执行上下文类型\" class=\"headerlink\" title=\"执行上下文类型\"></a>执行上下文类型</h2><p>执行上下文总共有三种类型：</p>\n<ul>\n<li><strong>全局执行上下文</strong>：这是默认的、最基础的执行上下文。不在任何函数中的代码都位于全局执行上下文中。它做了两件事：</li>\n</ul>\n<ol>\n<li>创建一个全局对象，在浏览器中这个全局对象就是 window 对象；</li>\n<li>将 this 指针指向这个全局对象。一个程序中只能存在一个全局执行上下文。</li>\n</ol>\n<ul>\n<li><strong>函数执行上下文</strong>：每次调用函数时，都会为该函数创建一个新的执行上下文。每个函数都拥有自己的执行上下文，但是只有在函数被调用的时候才会被创建。一个程序中可以存在任意数量的函数执行上下文。每当一个新的执行上下文被创建，它都会按照特定的顺序执行一系列步骤，具体过程将在本文后面讨论。</li>\n<li>eval执行上下文：运行在 eval 函数中的代码也获得了自己的执行上下文，ES6 之后不再推荐使用 eval 函数，所以本书出于面试实用考虑，不会深入讨论eval。</li>\n</ul>\n<h2 id=\"执行上下文的生命周期\"><a href=\"#执行上下文的生命周期\" class=\"headerlink\" title=\"执行上下文的生命周期\"></a>执行上下文的生命周期</h2><p>执行上下文的生命周期包括三个阶段：创建阶段 → 执行阶段 → 回收阶段，本文重点介绍创建阶段。</p>\n<h3 id=\"a-创建阶段\"><a href=\"#a-创建阶段\" class=\"headerlink\" title=\"a. 创建阶段\"></a>a. 创建阶段</h3><p>当函数被调用，但未执行任何其内部代码之前，会做以下三件事：</p>\n<ul>\n<li>创建变量对象：首先初始化函数的参数 arguments，提升函数声明和变量声明（变量的<strong>声明提前</strong>有赖于<code>var</code>关键字）。</li>\n<li>创建作用域链：在执行期上下文的创建阶段，作用域链是在变量对象之后创建的。作用域链本身包含变量对象。作用域链用于解析变量。当被要求解析变量时，JavaScript 始终从代码嵌套的最内层开始，如果最内层没有找到变量，就会跳转到上一层父作用域中查找，直到找到该变量。</li>\n<li>确定 this 指向。</li>\n</ul>\n<h3 id=\"b-执行阶段\"><a href=\"#b-执行阶段\" class=\"headerlink\" title=\"b. 执行阶段\"></a>b. 执行阶段</h3><p>创建完成之后，就会开始执行代码，在这个阶段，会完成变量赋值、函数引用、以及执行其他代码。</p>\n<h3 id=\"c-回收阶段\"><a href=\"#c-回收阶段\" class=\"headerlink\" title=\"c. 回收阶段\"></a>c. 回收阶段</h3><p>函数调用完毕后，函数出栈，对应的执行上下文也出栈，等待垃圾回收器回收执行上下文。</p>\n<p><img src=\"https://7.dusays.com/2020/11/16/d7d64d01245e3.png\"></p>\n<h2 id=\"执行上下文栈\"><a href=\"#执行上下文栈\" class=\"headerlink\" title=\"执行上下文栈\"></a>执行上下文栈</h2><pre><code class=\"javascript\">var a = &quot;coffe&quot;; //1.进入全局执行上下文\nfunction out() &#123;\n    var b = &quot;18&quot;;\n    function inner() &#123;\n        var c = &quot;91&quot;;\n        console.log(a+b+c);\n    &#125;\n    inner(); //3.进入inner函数的执行上下文\n&#125;\nout(); //2.进入out函数的执行上下文</code></pre>\n<p> 在代码开始执行时，首先会产生一个<strong>全局执行上下文</strong>，调用函数时，会产生<strong>函数执行上下文</strong>，函数调用完成后，它的执行上下文以及其中的数据都会被销毁，重新回到全局执行环境，网页关闭后全局执行环境也会销毁。其实这是一个入栈出栈的过程，<strong>全局上下文永远在栈底，而当前正在函数执行上下文在栈顶</strong>。以上代码的执行会经历以下过程：</p>\n<ol>\n<li>当代码开始执行时就<strong>创建全局执行上下文，全局执行上下文入栈</strong>。</li>\n<li>全局执行上下文入栈后，其中的代码开始执行，进行赋值、函数调用等操作，执行到<code>out()</code>时，<strong>激活函数<code>out</code>创建自己的执行上下文，<code>out</code>函数执行上下文入栈</strong>。</li>\n<li><code>out</code>函数执行上下文入栈后，其中的代码开始执行，进行赋值、函数调用等操作，执行到<code>inner()</code>时，<strong>激活函数<code>inner</code>创建自己的执行上下文，<code>inner</code>函数执行上下文入栈</strong>。</li>\n<li><code>inner</code>函数上下文入栈后，其中的代码开始执行，进行赋值、函数调用、打印等操作，由于里面没有可以生成其他执行上下文的需要，所有代码执行完毕后，**<code>inner</code>函数上下文出栈**。</li>\n<li><code>inner</code>函数执行上下文出栈，又回到了<code>out</code>函数执行上下文环境，接着执行<code>out</code>函数中后面剩下的代码，由于后面没有可以生成其他执行上下文的需要，所有代码执行完毕后，**<code>out</code>函数执行上下文出栈**。</li>\n<li><code>out</code>函数执行上下文出栈后，又回到了全局执行上下文环境，直到浏览器窗口关闭，<strong>全局执行上下文出栈</strong>。</li>\n</ol>\n<p><img src=\"https://7.dusays.com/2020/11/16/55431837a2be8.png\"></p>\n<p>我们可以发现：</p>\n<ol>\n<li>全局执行上下文在代码开始执行时就创建，有且只有一个，永远在执行上下文栈的栈底，浏览器窗口关闭时它才出栈。</li>\n<li>函数被调用的时候创建函数的执行上下文环境，并且入栈。</li>\n<li>只有栈顶的执行上下文才是处于活动状态的，也即只有栈顶的变量对象才会变成活动对象。</li>\n</ol>\n<h1 id=\"变量对象（Variable-Object，VO\"><a href=\"#变量对象（Variable-Object，VO\" class=\"headerlink\" title=\"变量对象（Variable Object，VO)\"></a>变量对象（Variable Object，VO)</h1><p>变量对象（VO）是一个类似于容器的对象，与作用域链、执行上下文息息相关。</p>\n<h2 id=\"变量对象的创建过程的三条规则：\"><a href=\"#变量对象的创建过程的三条规则：\" class=\"headerlink\" title=\"变量对象的创建过程的三条规则：\"></a>变量对象的创建过程的三条规则：</h2><ol>\n<li><strong>建立<code>arguments</code>对象</strong>。检查当前执行上下文中的参数，建立该对象下的属性与属性值。</li>\n<li><strong>检查当前执行上下文的函数声明，也就是使用<code>function</code>关键字声明的函数</strong>。在变量对象中以函数名建立一个属性，属性值为指向该函数所在内存地址的引用。如果该属性之前已经存在，那么该属性将会被新的引用所覆盖。</li>\n<li><strong>检查当前执行上下文中的变量声明，每找到一个变量声明，就在变量对象中以变量名建立一个属性，属性值为<code>undefined</code>**。</strong>如果该变量名的属性已经存在，为了防止同名的函数被修改为<code>undefined</code>，则会直接跳过，原属性值不会被修改**。</li>\n</ol>\n<p><img src=\"https://7.dusays.com/2020/11/16/7fad446d8076c.png\"></p>\n<p>可以用以下伪代码来表示变量对象：</p>\n<pre><code class=\"javascript\">VO=&#123;\n    Arguments:&#123;&#125;,//实参\n    Param_Variable:具体值,//形参\n    Function:&lt;function reference&gt;,//函数的引用\n    Variable:undefined//其他变量\n&#125;</code></pre>\n<p>当执行上下文进入执行阶段后，变量对象会变为<strong>活动对象</strong>（Active Object，AO）。此时原先声明的变量会被赋值。<strong>变量对象和活动对象都是指同一个对象，只是处于执行上下文的不同阶段</strong>。</p>\n<p>我们可以通过以下伪代码来表示活动对象：</p>\n<pre><code class=\"javascript\">AO=&#123;\n    Arguments:&#123;&#125;,//实参\n    Param_Variable:具体值,  //形参\n    Function:&lt;function reference&gt;,//函数的引用\n    Variable:具体值//注意，这里已经赋值了喔\n&#125;</code></pre>\n<p>未进入执行上下文的执行阶段之前，变量对象中的属性都不能访问。但是<strong>进入执行阶段之后，变量对象转变为了活动对象（被激活了）</strong>，里面的属性可以被访问了，然后开始进行执行阶段的操作。</p>\n<h2 id=\"全局执行上下文的变量对象\"><a href=\"#全局执行上下文的变量对象\" class=\"headerlink\" title=\"全局执行上下文的变量对象\"></a>全局执行上下文的变量对象</h2><p>全局执行上下文的变量对象是<code>window</code>对象，而这个特殊，在<code>this</code>指向上也同样适用，<code>this</code>也是指向<code>window</code>。</p>\n<p>除此之外，全局执行上下文的生命周期，与程序的生命周期一致，只要程序运行不结束（比如关掉浏览器窗口），全局执行上下文就会一直存在。其他所有的执行上下文，都能直接访问全局执行上下文里的内容。</p>\n<h2 id=\"再看一段代码，留意注释\"><a href=\"#再看一段代码，留意注释\" class=\"headerlink\" title=\"再看一段代码，留意注释\"></a>再看一段代码，留意注释</h2><pre><code class=\"javascript\">function func() &#123;\n    console.log(&#39;function func&#39;);\n&#125;\nvar func = &quot;coffe&quot;;\nconsole.log(func); //&gt;&gt; coffe\n// 以上代码中，按三条规则，变量声明的 func 遇到函数声明的 func 应该会跳过，\n// 可是为什么最后 func 的输出结果仍然是被覆盖了显示&quot;coffe&quot;呢？\n// 那是因为三条规则仅仅适用于变量对象的创建阶段，也即执行上下文的创建阶段。\n// 而 func=&quot;coffe&quot; 是在执行上下文的执行阶段中运行的，输出结果自然会是&quot;coffe&quot;。</code></pre>\n<p>这种现象很容易让人费解，其实也是因为<code>var</code>声明的变量允许重名导致的，若使用关键字<code>let</code>来声明变量，就可以避免这种令人费解的情况发生。</p>\n<h1 id=\"作用域链（Scope-Chain）\"><a href=\"#作用域链（Scope-Chain）\" class=\"headerlink\" title=\"作用域链（Scope Chain）\"></a>作用域链（Scope Chain）</h1><h2 id=\"定义-1\"><a href=\"#定义-1\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p><strong>多个作用域对应的变量对象串联起来组成的链表就是作用域链，</strong>这个链表是以引用的形式保持对变量对象的访问<strong>。</strong>作用域链保证了当前执行上下文对符合访问权限的变量和函数的有序访问。</p>\n<p><img src=\"https://7.dusays.com/2020/11/16/867543641bca6.png\" alt=\"&#x4F5C;&#x7528;&#x57DF;&#x94FE;&#x7684;&#x56FE;&#x793A;\"></p>\n<p>作用域链的最顶端一定是当前作用域（local scope）对应的变量对象，最底端一定是全局作用域对应的变量对象（全局VO）。</p>\n<p>作用域链可以形象地比如为一个蒸笼。</p>\n<p><img src=\"https://7.dusays.com/2020/11/16/8dc21cd5da203.png\" alt=\"&#x84B8;&#x7B3C;\"></p>\n<p>最底下的一屉，相当于是全局作用域，它里面的蒸汽（变量和函数的可见性）可以渗透到整个蒸笼，底层之上的其他屉相当于局部作用域，这些上面屉的蒸汽只能影响更上面的屉。</p>\n<p>作用域链可以理解为下面这种伪代码格式：</p>\n<pre><code class=\"text\">&#123;\n    Scope: [\n        &#123; //当前作用域对应的VO\n            实参,\n            形参,\n            变量,\n            函数\n        &#125;, \n        &#123; //第二个作用域对应的VO\n            实参,\n            形参,\n            变量,\n            函数\n        &#125;,\n        ... \n        &#123; //全局作用域对应的VO\n            变量,\n            函数\n        &#125;\n    ]\n&#125;</code></pre>\n<h2 id=\"变量-函数的查找机制\"><a href=\"#变量-函数的查找机制\" class=\"headerlink\" title=\"变量/函数的查找机制\"></a>变量/函数的查找机制</h2><p>  查找变量/函数时JS引擎是从里离它最近作用域开始的查找的，也即从离它最近的变量对象（VO）开始查找。</p>\n<p>如果在当前的变量对象里面找不到目标变量/函数，就在上一级作用域的变量对象里面查找。若这时找到了目标变量/函数，则停止查找；若找不到，一直回溯到全局作用域的变量对象里查找，若仍找不到目标变量/函数，停止查找。</p>\n","categories":[{"name":"ES语法","path":"api/categories/ES语法.json"}],"tags":[{"name":"javaScript","path":"api/tags/javaScript.json"}]}