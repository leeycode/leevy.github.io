{"title":"前端权限管理","slug":"前端权限管理","date":"2021-01-05T07:31:42.000Z","updated":"2021-01-05T07:33:49.316Z","comments":true,"path":"api/articles/前端权限管理.json","excerpt":null,"covers":null,"content":"<h2 id=\"接口权限\"><a href=\"#接口权限\" class=\"headerlink\" title=\"接口权限\"></a>接口权限</h2><blockquote>\n<p>接口权限目前一般采用==jwt==的形式来验证，没有通过的话一般返回401，跳转到登录页面重新进行登录。</p>\n</blockquote>\n<p>登录完拿到token，将token存起来，通过axios请求拦截器进行拦截，每次请求的时候头部携带token。</p>\n<pre><code>axios.interceptors.request.use(config =&gt; {\n    config.headers['token'] = cookie.get('token')\n    return config\n})\naxios.interceptors.response.use(res=&gt;{},{response}=&gt;{\n    if (response.data.code === 40099 || response.data.code === 40098) { //token过期或者错误\n        router.push('/login')\n    }\n})</code></pre>\n<h2 id=\"路由权限控制\"><a href=\"#路由权限控制\" class=\"headerlink\" title=\"路由权限控制\"></a>路由权限控制</h2><blockquote>\n<p>用户登录后只能看到自己有权访问的导航菜单，也只能访问自己有权访问的路由地址，否则将跳转 4xx 提示页</p>\n</blockquote>\n<p>初始化即挂载全部路由，并且在路由上标记相应的权限信息，每次路由跳转前做校验。</p>\n<pre><code>const routerMap = [\n  {\n    path: '/permission',\n    component: Layout,\n    redirect: '/permission/index',\n    alwaysShow: true, // will always show the root menu\n    meta: {\n      title: 'permission',\n      icon: 'lock',\n      roles: ['admin', 'editor'] // you can set roles in root nav\n    },\n    children: [{\n      path: 'page',\n      component: () =&gt; import('@/views/permission/page'),\n      name: 'pagePermission',\n      meta: {\n        title: 'pagePermission',\n        roles: ['admin'] // or you can only set roles in sub nav\n      }\n    }, {\n      path: 'directive',\n      component: () =&gt; import('@/views/permission/directive'),\n      name: 'directivePermission',\n      meta: {\n        title: 'directivePermission'\n        // if do not set roles, means: this page does not require permission\n      }\n    }]\n  }]</code></pre>\n<p>登录后，获取用户的权限信息，然后筛选有权限访问的路由，在全局路由守卫里进行调用==addRoutes==添加路由</p>\n<pre><code>import router from './router'\nimport store from './store'\nimport { Message } from 'element-ui'\nimport NProgress from 'nprogress' // progress bar\nimport 'nprogress/nprogress.css'// progress bar style\nimport { getToken } from '@/utils/auth' // getToken from cookie\n\nNProgress.configure({ showSpinner: false })// NProgress Configuration\n\n// permission judge function\nfunction hasPermission(roles, permissionRoles) {\n  if (roles.indexOf('admin') &gt;= 0) return true // admin permission passed directly\n  if (!permissionRoles) return true\n  return roles.some(role =&gt; permissionRoles.indexOf(role) &gt;= 0)\n}\n\nconst whiteList = ['/login', '/authredirect']// no redirect whitelist\n\nrouter.beforeEach((to, from, next) =&gt; {\n  NProgress.start() // start progress bar\n  if (getToken()) { // determine if there has token\n    /* has token*/\n    if (to.path === '/login') {\n      next({ path: '/' })\n      NProgress.done() // if current page is dashboard will not trigger afterEach hook, so manually handle it\n    } else {\n      if (store.getters.roles.length === 0) { // 判断当前用户是否已拉取完user_info信息\n        store.dispatch('GetUserInfo').then(res =&gt; { // 拉取user_info\n          const roles = res.data.roles // note: roles must be a array! such as: ['editor','develop']\n          store.dispatch('GenerateRoutes', { roles }).then(() =&gt; { // 根据roles权限生成可访问的路由表\n            router.addRoutes(store.getters.addRouters) // 动态添加可访问路由表\n            next({ ...to, replace: true }) // hack方法 确保addRoutes已完成 ,set the replace: true so the navigation will not leave a history record\n          })\n        }).catch((err) =&gt; {\n          store.dispatch('FedLogOut').then(() =&gt; {\n            Message.error(err || 'Verification failed, please login again')\n            next({ path: '/' })\n          })\n        })\n      } else {\n        // 没有动态改变权限的需求可直接next() 删除下方权限判断 ↓\n        if (hasPermission(store.getters.roles, to.meta.roles)) {\n          next()//\n        } else {\n          next({ path: '/401', replace: true, query: { noGoBack: true }})\n        }\n        // 可删 ↑\n      }\n    }\n  } else {\n    /* has no token*/\n    if (whiteList.indexOf(to.path) !== -1) { // 在免登录白名单，直接进入\n      next()\n    } else {\n      next('/login') // 否则全部重定向到登录页\n      NProgress.done() // if current page is login will not trigger afterEach hook, so manually handle it\n    }\n  }\n})\n\nrouter.afterEach(() =&gt; {\n  NProgress.done() // finish progress bar\n})\n</code></pre>\n<p>按需挂载，路由就需要知道用户的路由权限，也就是在用户登录进来的时候就要知道当前用户拥有哪些路由权限</p>\n<p>这种方式也存在了以下的缺点：</p>\n<ul>\n<li>全局路由守卫里，每次路由跳转都要做判断</li>\n<li>菜单信息写死在前端，要改个显示文字或权限信息，需要重新编译</li>\n<li>菜单跟路由耦合在一起，定义路由的时候还有添加菜单显示标题，图标之类的信息，而且路由不一定作为菜单显示，还要多加字段进行标识</li>\n</ul>\n<h2 id=\"菜单权限\"><a href=\"#菜单权限\" class=\"headerlink\" title=\"菜单权限\"></a>菜单权限</h2><p>菜单权限可以理解成将页面与路由进行解耦</p>\n<h3 id=\"方案一\"><a href=\"#方案一\" class=\"headerlink\" title=\"方案一\"></a>方案一</h3><p>菜单与路由分离，菜单由后端返回<br>前端定义路由信息</p>\n<pre><code>{\n    name: \"login\",\n    path: \"/login\",\n    component: () =&gt; import(\"@/pages/Login.vue\")\n}</code></pre>\n<p>name字段都不为空，需要根据此字段与后端返回菜单做关联，后端返回的菜单信息中必须要有name对应的字段，并且做唯一性校验</p>\n<p>全局路由守卫里做判断</p>\n<pre><code>function hasPermission(router, accessMenu) {\n  if (whiteList.indexOf(router.path) !== -1) {\n    return true;\n  }\n  let menu = Util.getMenuByName(router.name, accessMenu);\n  if (menu.name) {\n    return true;\n  }\n  return false;\n\n}\n\nRouter.beforeEach(async (to, from, next) =&gt; {\n  if (getToken()) {\n    let userInfo = store.state.user.userInfo;\n    if (!userInfo.name) {\n      try {\n        await store.dispatch(\"GetUserInfo\")\n        await store.dispatch('updateAccessMenu')\n        if (to.path === '/login') {\n          next({ name: 'home_index' })\n        } else {\n          //Util.toDefaultPage([...routers], to.name, router, next);\n          next({ ...to, replace: true })//菜单权限更新完成,重新进一次当前路由\n        }\n      }  \n      catch (e) {\n        if (whiteList.indexOf(to.path) !== -1) { // 在免登录白名单，直接进入\n          next()\n        } else {\n          next('/login')\n        }\n      }\n    } else {\n      if (to.path === '/login') {\n        next({ name: 'home_index' })\n      } else {\n        if (hasPermission(to, store.getters.accessMenu)) {\n          Util.toDefaultPage(store.getters.accessMenu,to, routes, next);\n        } else {\n          next({ path: '/403',replace:true })\n        }\n      }\n    }\n  } else {\n    if (whiteList.indexOf(to.path) !== -1) { // 在免登录白名单，直接进入\n      next()\n    } else {\n      next('/login')\n    }\n  }\n  let menu = Util.getMenuByName(to.name, store.getters.accessMenu);\n  Util.title(menu.title);\n});\n\nRouter.afterEach((to) =&gt; {\n  window.scrollTo(0, 0);\n});</code></pre>\n<p>每次路由跳转的时候都要判断权限，这里的判断也很简单，因为菜单的name与路由的name是一一对应的，而后端返回的菜单就已经是经过权限过滤的。</p>\n<p>如果根据路由name找不到对应的菜单，就表示用户有没权限访问。</p>\n<p>如果路由很多，可以在应用初始化的时候，只挂载不需要权限控制的路由。取得后端返回的菜单后，根据菜单与路由的对应关系，筛选出可访问的路由，通过==addRoutes==动态挂载。</p>\n<p>这种方式的缺点：</p>\n<ul>\n<li>菜单需要与路由做一一对应，前端添加了新功能，需要通过菜单管理功能添加新的菜单，如果菜单配置的不对会导致应用不能正常使用</li>\n<li>全局路由守卫里，每次路由跳转都要做判断</li>\n</ul>\n<h3 id=\"方案二\"><a href=\"#方案二\" class=\"headerlink\" title=\"方案二\"></a>方案二</h3><p>菜单和路由都由后端返回，<br>前端统一定义路由组件。</p>\n<pre><code>const Home = () =&gt; import(\"../pages/Home.vue\");\nconst UserInfo = () =&gt; import(\"../pages/UserInfo.vue\");\nexport default {\n    home: Home,\n    userInfo: UserInfo\n};</code></pre>\n<p>后端路由组件返回以下格式</p>\n<pre><code>[\n    {\n        name: \"home\",\n        path: \"/\",\n        component: \"home\"\n    },\n    {\n        name: \"home\",\n        path: \"/userinfo\",\n        component: \"userInfo\"\n    }\n]</code></pre>\n<p>在将后端返回路由通过addRoutes动态挂载之间，需要将数据处理一下，将component字段换为真正的组件<br>如果有嵌套路由，后端功能设计的时候，要注意添加相应的字段，前端拿到数据也要做相应的处理。</p>\n<p>这种方法也会存在缺点：</p>\n<ul>\n<li>全局路由守卫里，每次路由跳转都要做判断</li>\n<li>前后端的配合要求更高</li>\n</ul>\n<h2 id=\"按钮权限\"><a href=\"#按钮权限\" class=\"headerlink\" title=\"按钮权限\"></a>按钮权限</h2><h3 id=\"方案一-1\"><a href=\"#方案一-1\" class=\"headerlink\" title=\"方案一\"></a>方案一</h3><p>按钮权限也可以用v-if判断<br>但是如果页面过多，每个页面页面都要获取用户权限role和路由表里的meta.btnPermissions，然后再做判断<br>这种方式就不展开举例了</p>\n<h3 id=\"方案二-1\"><a href=\"#方案二-1\" class=\"headerlink\" title=\"方案二\"></a>方案二</h3><blockquote>\n<p>通过自定义指令进行按钮权限的判断</p>\n</blockquote>\n<p>首先配置路由</p>\n<pre><code>{\n    path: '/permission',\n    component: Layout,\n    name: '权限测试',\n    meta: {\n        btnPermissions: ['admin', 'supper', 'normal']\n    },\n    //页面需要的权限\n    children: [{\n        path: 'supper',\n        component: _import('system/supper'),\n        name: '权限测试页',\n        meta: {\n            btnPermissions: ['admin', 'supper']\n        } //页面需要的权限\n    },\n    {\n        path: 'normal',\n        component: _import('system/normal'),\n        name: '权限测试页',\n        meta: {\n            btnPermissions: ['admin']\n        } //页面需要的权限\n    }]\n}</code></pre>\n<p>自定义权限鉴定指令</p>\n<pre><code>import Vue from 'vue'\n/**权限指令**/\nconst has = Vue.directive('has', {\n    bind: function (el, binding, vnode) {\n        // 获取页面按钮权限\n        let btnPermissionsArr = [];\n        if(binding.value){\n            // 如果指令传值，获取指令参数，根据指令参数和当前登录人按钮权限做比较。\n            btnPermissionsArr = Array.of(binding.value);\n        }else{\n            // 否则获取路由中的参数，根据路由的btnPermissionsArr和当前登录人按钮权限做比较。\n            btnPermissionsArr = vnode.context.$route.meta.btnPermissions;\n        }\n        if (!Vue.prototype.$_has(btnPermissionsArr)) {\n            el.parentNode.removeChild(el);\n        }\n    }\n});\n// 权限检查方法\nVue.prototype.$_has = function (value) {\n    let isExist = false;\n    // 获取用户按钮权限\n    let btnPermissionsStr = sessionStorage.getItem(\"btnPermissions\");\n    if (btnPermissionsStr == undefined || btnPermissionsStr == null) {\n        return false;\n    }\n    if (value.indexOf(btnPermissionsStr) &gt; -1) {\n        isExist = true;\n    }\n    return isExist;\n};\nexport {has}</code></pre>\n<p>在使用的按钮中只需要引用v-has指令</p>\n<pre><code>&lt;el-button @click='editClick' type=\"primary\" v-has&gt;编辑&lt;/el-button&gt;</code></pre>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>关于权限如何选择哪种合适的方案，可以根据自己项目的方案项目，如考虑路由与菜单是否分离<br>权限需要前后端结合，前端尽可能的去控制，更多的需要后台判断</p>\n","more":"<h2 id=\"接口权限\"><a href=\"#接口权限\" class=\"headerlink\" title=\"接口权限\"></a>接口权限</h2><blockquote>\n<p>接口权限目前一般采用==jwt==的形式来验证，没有通过的话一般返回401，跳转到登录页面重新进行登录。</p>\n</blockquote>\n<p>登录完拿到token，将token存起来，通过axios请求拦截器进行拦截，每次请求的时候头部携带token。</p>\n<pre><code>axios.interceptors.request.use(config =&gt; &#123;\n    config.headers[&#39;token&#39;] = cookie.get(&#39;token&#39;)\n    return config\n&#125;)\naxios.interceptors.response.use(res=&gt;&#123;&#125;,&#123;response&#125;=&gt;&#123;\n    if (response.data.code === 40099 || response.data.code === 40098) &#123; //token过期或者错误\n        router.push(&#39;/login&#39;)\n    &#125;\n&#125;)</code></pre>\n<h2 id=\"路由权限控制\"><a href=\"#路由权限控制\" class=\"headerlink\" title=\"路由权限控制\"></a>路由权限控制</h2><blockquote>\n<p>用户登录后只能看到自己有权访问的导航菜单，也只能访问自己有权访问的路由地址，否则将跳转 4xx 提示页</p>\n</blockquote>\n<p>初始化即挂载全部路由，并且在路由上标记相应的权限信息，每次路由跳转前做校验。</p>\n<pre><code>const routerMap = [\n  &#123;\n    path: &#39;/permission&#39;,\n    component: Layout,\n    redirect: &#39;/permission/index&#39;,\n    alwaysShow: true, // will always show the root menu\n    meta: &#123;\n      title: &#39;permission&#39;,\n      icon: &#39;lock&#39;,\n      roles: [&#39;admin&#39;, &#39;editor&#39;] // you can set roles in root nav\n    &#125;,\n    children: [&#123;\n      path: &#39;page&#39;,\n      component: () =&gt; import(&#39;@/views/permission/page&#39;),\n      name: &#39;pagePermission&#39;,\n      meta: &#123;\n        title: &#39;pagePermission&#39;,\n        roles: [&#39;admin&#39;] // or you can only set roles in sub nav\n      &#125;\n    &#125;, &#123;\n      path: &#39;directive&#39;,\n      component: () =&gt; import(&#39;@/views/permission/directive&#39;),\n      name: &#39;directivePermission&#39;,\n      meta: &#123;\n        title: &#39;directivePermission&#39;\n        // if do not set roles, means: this page does not require permission\n      &#125;\n    &#125;]\n  &#125;]</code></pre>\n<p>登录后，获取用户的权限信息，然后筛选有权限访问的路由，在全局路由守卫里进行调用==addRoutes==添加路由</p>\n<pre><code>import router from &#39;./router&#39;\nimport store from &#39;./store&#39;\nimport &#123; Message &#125; from &#39;element-ui&#39;\nimport NProgress from &#39;nprogress&#39; // progress bar\nimport &#39;nprogress/nprogress.css&#39;// progress bar style\nimport &#123; getToken &#125; from &#39;@/utils/auth&#39; // getToken from cookie\n\nNProgress.configure(&#123; showSpinner: false &#125;)// NProgress Configuration\n\n// permission judge function\nfunction hasPermission(roles, permissionRoles) &#123;\n  if (roles.indexOf(&#39;admin&#39;) &gt;= 0) return true // admin permission passed directly\n  if (!permissionRoles) return true\n  return roles.some(role =&gt; permissionRoles.indexOf(role) &gt;= 0)\n&#125;\n\nconst whiteList = [&#39;/login&#39;, &#39;/authredirect&#39;]// no redirect whitelist\n\nrouter.beforeEach((to, from, next) =&gt; &#123;\n  NProgress.start() // start progress bar\n  if (getToken()) &#123; // determine if there has token\n    /* has token*/\n    if (to.path === &#39;/login&#39;) &#123;\n      next(&#123; path: &#39;/&#39; &#125;)\n      NProgress.done() // if current page is dashboard will not trigger afterEach hook, so manually handle it\n    &#125; else &#123;\n      if (store.getters.roles.length === 0) &#123; // 判断当前用户是否已拉取完user_info信息\n        store.dispatch(&#39;GetUserInfo&#39;).then(res =&gt; &#123; // 拉取user_info\n          const roles = res.data.roles // note: roles must be a array! such as: [&#39;editor&#39;,&#39;develop&#39;]\n          store.dispatch(&#39;GenerateRoutes&#39;, &#123; roles &#125;).then(() =&gt; &#123; // 根据roles权限生成可访问的路由表\n            router.addRoutes(store.getters.addRouters) // 动态添加可访问路由表\n            next(&#123; ...to, replace: true &#125;) // hack方法 确保addRoutes已完成 ,set the replace: true so the navigation will not leave a history record\n          &#125;)\n        &#125;).catch((err) =&gt; &#123;\n          store.dispatch(&#39;FedLogOut&#39;).then(() =&gt; &#123;\n            Message.error(err || &#39;Verification failed, please login again&#39;)\n            next(&#123; path: &#39;/&#39; &#125;)\n          &#125;)\n        &#125;)\n      &#125; else &#123;\n        // 没有动态改变权限的需求可直接next() 删除下方权限判断 ↓\n        if (hasPermission(store.getters.roles, to.meta.roles)) &#123;\n          next()//\n        &#125; else &#123;\n          next(&#123; path: &#39;/401&#39;, replace: true, query: &#123; noGoBack: true &#125;&#125;)\n        &#125;\n        // 可删 ↑\n      &#125;\n    &#125;\n  &#125; else &#123;\n    /* has no token*/\n    if (whiteList.indexOf(to.path) !== -1) &#123; // 在免登录白名单，直接进入\n      next()\n    &#125; else &#123;\n      next(&#39;/login&#39;) // 否则全部重定向到登录页\n      NProgress.done() // if current page is login will not trigger afterEach hook, so manually handle it\n    &#125;\n  &#125;\n&#125;)\n\nrouter.afterEach(() =&gt; &#123;\n  NProgress.done() // finish progress bar\n&#125;)\n</code></pre>\n<p>按需挂载，路由就需要知道用户的路由权限，也就是在用户登录进来的时候就要知道当前用户拥有哪些路由权限</p>\n<p>这种方式也存在了以下的缺点：</p>\n<ul>\n<li>全局路由守卫里，每次路由跳转都要做判断</li>\n<li>菜单信息写死在前端，要改个显示文字或权限信息，需要重新编译</li>\n<li>菜单跟路由耦合在一起，定义路由的时候还有添加菜单显示标题，图标之类的信息，而且路由不一定作为菜单显示，还要多加字段进行标识</li>\n</ul>\n<h2 id=\"菜单权限\"><a href=\"#菜单权限\" class=\"headerlink\" title=\"菜单权限\"></a>菜单权限</h2><p>菜单权限可以理解成将页面与路由进行解耦</p>\n<h3 id=\"方案一\"><a href=\"#方案一\" class=\"headerlink\" title=\"方案一\"></a>方案一</h3><p>菜单与路由分离，菜单由后端返回<br>前端定义路由信息</p>\n<pre><code>&#123;\n    name: &quot;login&quot;,\n    path: &quot;/login&quot;,\n    component: () =&gt; import(&quot;@/pages/Login.vue&quot;)\n&#125;</code></pre>\n<p>name字段都不为空，需要根据此字段与后端返回菜单做关联，后端返回的菜单信息中必须要有name对应的字段，并且做唯一性校验</p>\n<p>全局路由守卫里做判断</p>\n<pre><code>function hasPermission(router, accessMenu) &#123;\n  if (whiteList.indexOf(router.path) !== -1) &#123;\n    return true;\n  &#125;\n  let menu = Util.getMenuByName(router.name, accessMenu);\n  if (menu.name) &#123;\n    return true;\n  &#125;\n  return false;\n\n&#125;\n\nRouter.beforeEach(async (to, from, next) =&gt; &#123;\n  if (getToken()) &#123;\n    let userInfo = store.state.user.userInfo;\n    if (!userInfo.name) &#123;\n      try &#123;\n        await store.dispatch(&quot;GetUserInfo&quot;)\n        await store.dispatch(&#39;updateAccessMenu&#39;)\n        if (to.path === &#39;/login&#39;) &#123;\n          next(&#123; name: &#39;home_index&#39; &#125;)\n        &#125; else &#123;\n          //Util.toDefaultPage([...routers], to.name, router, next);\n          next(&#123; ...to, replace: true &#125;)//菜单权限更新完成,重新进一次当前路由\n        &#125;\n      &#125;  \n      catch (e) &#123;\n        if (whiteList.indexOf(to.path) !== -1) &#123; // 在免登录白名单，直接进入\n          next()\n        &#125; else &#123;\n          next(&#39;/login&#39;)\n        &#125;\n      &#125;\n    &#125; else &#123;\n      if (to.path === &#39;/login&#39;) &#123;\n        next(&#123; name: &#39;home_index&#39; &#125;)\n      &#125; else &#123;\n        if (hasPermission(to, store.getters.accessMenu)) &#123;\n          Util.toDefaultPage(store.getters.accessMenu,to, routes, next);\n        &#125; else &#123;\n          next(&#123; path: &#39;/403&#39;,replace:true &#125;)\n        &#125;\n      &#125;\n    &#125;\n  &#125; else &#123;\n    if (whiteList.indexOf(to.path) !== -1) &#123; // 在免登录白名单，直接进入\n      next()\n    &#125; else &#123;\n      next(&#39;/login&#39;)\n    &#125;\n  &#125;\n  let menu = Util.getMenuByName(to.name, store.getters.accessMenu);\n  Util.title(menu.title);\n&#125;);\n\nRouter.afterEach((to) =&gt; &#123;\n  window.scrollTo(0, 0);\n&#125;);</code></pre>\n<p>每次路由跳转的时候都要判断权限，这里的判断也很简单，因为菜单的name与路由的name是一一对应的，而后端返回的菜单就已经是经过权限过滤的。</p>\n<p>如果根据路由name找不到对应的菜单，就表示用户有没权限访问。</p>\n<p>如果路由很多，可以在应用初始化的时候，只挂载不需要权限控制的路由。取得后端返回的菜单后，根据菜单与路由的对应关系，筛选出可访问的路由，通过==addRoutes==动态挂载。</p>\n<p>这种方式的缺点：</p>\n<ul>\n<li>菜单需要与路由做一一对应，前端添加了新功能，需要通过菜单管理功能添加新的菜单，如果菜单配置的不对会导致应用不能正常使用</li>\n<li>全局路由守卫里，每次路由跳转都要做判断</li>\n</ul>\n<h3 id=\"方案二\"><a href=\"#方案二\" class=\"headerlink\" title=\"方案二\"></a>方案二</h3><p>菜单和路由都由后端返回，<br>前端统一定义路由组件。</p>\n<pre><code>const Home = () =&gt; import(&quot;../pages/Home.vue&quot;);\nconst UserInfo = () =&gt; import(&quot;../pages/UserInfo.vue&quot;);\nexport default &#123;\n    home: Home,\n    userInfo: UserInfo\n&#125;;</code></pre>\n<p>后端路由组件返回以下格式</p>\n<pre><code>[\n    &#123;\n        name: &quot;home&quot;,\n        path: &quot;/&quot;,\n        component: &quot;home&quot;\n    &#125;,\n    &#123;\n        name: &quot;home&quot;,\n        path: &quot;/userinfo&quot;,\n        component: &quot;userInfo&quot;\n    &#125;\n]</code></pre>\n<p>在将后端返回路由通过addRoutes动态挂载之间，需要将数据处理一下，将component字段换为真正的组件<br>如果有嵌套路由，后端功能设计的时候，要注意添加相应的字段，前端拿到数据也要做相应的处理。</p>\n<p>这种方法也会存在缺点：</p>\n<ul>\n<li>全局路由守卫里，每次路由跳转都要做判断</li>\n<li>前后端的配合要求更高</li>\n</ul>\n<h2 id=\"按钮权限\"><a href=\"#按钮权限\" class=\"headerlink\" title=\"按钮权限\"></a>按钮权限</h2><h3 id=\"方案一-1\"><a href=\"#方案一-1\" class=\"headerlink\" title=\"方案一\"></a>方案一</h3><p>按钮权限也可以用v-if判断<br>但是如果页面过多，每个页面页面都要获取用户权限role和路由表里的meta.btnPermissions，然后再做判断<br>这种方式就不展开举例了</p>\n<h3 id=\"方案二-1\"><a href=\"#方案二-1\" class=\"headerlink\" title=\"方案二\"></a>方案二</h3><blockquote>\n<p>通过自定义指令进行按钮权限的判断</p>\n</blockquote>\n<p>首先配置路由</p>\n<pre><code>&#123;\n    path: &#39;/permission&#39;,\n    component: Layout,\n    name: &#39;权限测试&#39;,\n    meta: &#123;\n        btnPermissions: [&#39;admin&#39;, &#39;supper&#39;, &#39;normal&#39;]\n    &#125;,\n    //页面需要的权限\n    children: [&#123;\n        path: &#39;supper&#39;,\n        component: _import(&#39;system/supper&#39;),\n        name: &#39;权限测试页&#39;,\n        meta: &#123;\n            btnPermissions: [&#39;admin&#39;, &#39;supper&#39;]\n        &#125; //页面需要的权限\n    &#125;,\n    &#123;\n        path: &#39;normal&#39;,\n        component: _import(&#39;system/normal&#39;),\n        name: &#39;权限测试页&#39;,\n        meta: &#123;\n            btnPermissions: [&#39;admin&#39;]\n        &#125; //页面需要的权限\n    &#125;]\n&#125;</code></pre>\n<p>自定义权限鉴定指令</p>\n<pre><code>import Vue from &#39;vue&#39;\n/**权限指令**/\nconst has = Vue.directive(&#39;has&#39;, &#123;\n    bind: function (el, binding, vnode) &#123;\n        // 获取页面按钮权限\n        let btnPermissionsArr = [];\n        if(binding.value)&#123;\n            // 如果指令传值，获取指令参数，根据指令参数和当前登录人按钮权限做比较。\n            btnPermissionsArr = Array.of(binding.value);\n        &#125;else&#123;\n            // 否则获取路由中的参数，根据路由的btnPermissionsArr和当前登录人按钮权限做比较。\n            btnPermissionsArr = vnode.context.$route.meta.btnPermissions;\n        &#125;\n        if (!Vue.prototype.$_has(btnPermissionsArr)) &#123;\n            el.parentNode.removeChild(el);\n        &#125;\n    &#125;\n&#125;);\n// 权限检查方法\nVue.prototype.$_has = function (value) &#123;\n    let isExist = false;\n    // 获取用户按钮权限\n    let btnPermissionsStr = sessionStorage.getItem(&quot;btnPermissions&quot;);\n    if (btnPermissionsStr == undefined || btnPermissionsStr == null) &#123;\n        return false;\n    &#125;\n    if (value.indexOf(btnPermissionsStr) &gt; -1) &#123;\n        isExist = true;\n    &#125;\n    return isExist;\n&#125;;\nexport &#123;has&#125;</code></pre>\n<p>在使用的按钮中只需要引用v-has指令</p>\n<pre><code>&lt;el-button @click=&#39;editClick&#39; type=&quot;primary&quot; v-has&gt;编辑&lt;/el-button&gt;</code></pre>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>关于权限如何选择哪种合适的方案，可以根据自己项目的方案项目，如考虑路由与菜单是否分离<br>权限需要前后端结合，前端尽可能的去控制，更多的需要后台判断</p>\n","categories":[],"tags":[{"name":"vue","path":"api/tags/vue.json"},{"name":"项目总结","path":"api/tags/项目总结.json"}]}