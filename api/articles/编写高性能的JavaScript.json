{"title":"编写高性能的JavaScript","slug":"编写高性能的JavaScript","date":"2022-01-04T07:53:34.000Z","updated":"2022-01-05T09:25:20.020Z","comments":true,"path":"api/articles/编写高性能的JavaScript.json","excerpt":null,"covers":null,"content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>随着计算机硬件的不断升级，开发者越发觉得<code>Javascript</code>性能优化的好不好对网页的执行效率影响不明显，所以一些性能方面的知识被很多开发者忽视。但在某些情况下，不优化的<code>Javascript</code>代码必然会影响用户的体验。因此，即使在当前硬件性能已经大大提升的时代，在编写<code>Javascript</code>代码时，若能遵循<code>Javascript</code>规范和注意一些性能方面的知识，对于提升代码的可维护性和优化性能将大有好处。那么，接下来我们讨论几种能够提高<code>JavaScript性能</code>的方法。</p>\n<h2 id=\"1、js文件加载和执行\"><a href=\"#1、js文件加载和执行\" class=\"headerlink\" title=\"1、js文件加载和执行\"></a>1、js文件加载和执行</h2><p>（1）将<code>&lt;script&gt;</code>标签放到<code>&lt;body&gt;</code>标签的底部</p>\n<p>（2）可以合并多个<code>js</code>文件，减少页面中<code>&lt;script&gt;</code>标签改善性能</p>\n<p>（3）使用 <code>defer</code> 属性，加载后续文档元素的过程将和<code>script.js</code>的加载并行进行，但是 <code>script.js</code> 的执行要在所有元素解析完成之后，<code>DOMContentLoaded </code>事件触发之前完成。</p>\n<p>（4）使用 <code>async</code> 属性，加载和渲染后续文档元素的过程将和<code>script.js</code>的加载与执行并行进行</p>\n<p>（5）动态加载脚本元素，无论在何时启动瞎子，文件的下载和执行过程都不会阻塞页面其它进程</p>\n<pre><code>var script = document.createElement('script');\nscript.type = 'text/javascript';\nscript.src = 'file.js';\ndocument.getElementsByTagName('head')[0].appendChild(script);</code></pre>\n<h2 id=\"2、标识符所在的作用域链的位置越深\"><a href=\"#2、标识符所在的作用域链的位置越深\" class=\"headerlink\" title=\"2、标识符所在的作用域链的位置越深\"></a>2、标识符所在的作用域链的位置越深</h2><p>标识符所在的作用域链的位置越深，那么它的标识符解析的性能就越慢。所以一个好的性能提升的经验法则是：如果某个跨作用域的值在函数中被引用一次以上，那么就把它存储到局部变量里。</p>\n<pre><code>function fun1() {  \n// 将全局变量的引用先存储在一个局部变量中，然后使用这个局部变量代替全局变量，从而提高         \n// 性能；不然每次(3次)都要遍历整个作用域链找到\ndocument  var doc = document;   \n var bd = doc.body;  \n var links = doc.getElementsByTagName('a');  \n doc.getElementById('btn').onclick = function(){   \n console.log('btn');  \n }\n}</code></pre>\n<h2 id=\"3、避免过长原型链继承\"><a href=\"#3、避免过长原型链继承\" class=\"headerlink\" title=\"3、避免过长原型链继承\"></a>3、避免过长原型链继承</h2><p>方法或属性在原型链中存在的位置越深，搜索它的性能也就越慢，所以要避免N多层原型链的写法。</p>\n<h2 id=\"4、对象成员嵌套过深\"><a href=\"#4、对象成员嵌套过深\" class=\"headerlink\" title=\"4、对象成员嵌套过深\"></a>4、对象成员嵌套过深</h2><p>对象的嵌套成员，对象成员嵌套越深，读取速度也就越慢。所以好的经验法则是：如果在函数中需要多次读取一个对象属性，最佳做法是将该属性值保存在局部变量中，避免多次查找带来的性能开销。</p>\n<pre><code>function f() { \n // 因为在以下函数中需要3次用到DOM对象属性，所以先将它存储在一个局部变量        \n // 中，然后使用这个局部变量代替它进行后续操作，从而提高性能  \nvar dom = YaHOO.util.Dom;  \nif(Dom.hasClass(element,'selected')){   \n  Dom.removeClass(elemet,'selected');  \n}else{   \n  Dom.addClass(elemet,'selected');  \n }\n}</code></pre>\n<h2 id=\"5、DOM操作\"><a href=\"#5、DOM操作\" class=\"headerlink\" title=\"5、DOM操作\"></a>5、DOM操作</h2><p>用<code>js</code>访问和操作<code>DOM</code>都会带来性能损失，可通过以下几点来减少性能损失：</p>\n<p>（1）尽可能减少<code>DOM</code>访问次数；</p>\n<p>（2）如果需要多次访问某个<code>DOM</code>节点，请使用局部变量存储它的引用；</p>\n<p>（3）小心处理<code>HTML</code>集合，因为它实时连系着底层文档；我们可以把集合的长度缓存到一个变量中，并在迭代中使用它；</p>\n<p>（4）下述情况会发生重排：</p>\n<ul>\n<li>添加或删除可见的<code>DOM</code>元素；</li>\n<li>元素位置改变；</li>\n<li>元素尺寸改变（包括：外边距、内边距、边框厚度、宽度、高度等属性）；</li>\n<li>内容改变（例如：文本改变或图片被另一个不同尺寸的图片改变）；</li>\n<li>页面渲染器初始化；</li>\n<li>浏览器窗口尺寸改变</li>\n</ul>\n<p>可通过以下方式减少重排：</p>\n<ul>\n<li>留意上面会导致重排的操作，尽量避免；</li>\n<li>获取布局信息的操作会导致强制渲染队列重排，应该尽量避免使用以下获取布局信息的操作方法或属性或者缓存布局信息，例如：<code>offsetTop,offsetLeft,offsetWidthoffsetHeight,``scrollTop,scrollLeft,scrollWidth,scrollHeight,clientTop,clientLeft,clientWidth,clientHeight,getComputedStyle()</code>等;</li>\n<li>批量修改样式，例如使用：</li>\n</ul>\n<pre><code>function f() {  \n  // 推荐使用以下操作  \n  var el1 = document.getElementById('mydiv');  \n  el1.style.cssText = 'border:1px;padding:2px;margin:3px';  \n  // 不推荐使用以下操作  \n  var el2 = document.getElementById('mydiv');  \n  el2.style.border = '1px';  \n  el2.style.padding = '2px';  \n  el2.style.margin = '3px';\n}</code></pre>\n<ul>\n<li><p>当需要批量修改<code>DOM</code>时，可以通过以下步骤减少重绘和重排的次数：</p>\n</li>\n<li><ul>\n<li>使元素脱离文档流（隐藏元素、拷贝元素）</li>\n<li>对其应用多重改变；</li>\n<li>把元素带回文档中</li>\n</ul>\n</li>\n<li><p>使用事件委托（事件逐层冒泡并能被父级元素捕获，使用事件代理，只需给外层元素绑定一个处理器，就可以处理其子元素上触发的所用事件），因为给<code>DOM</code>元素绑定事件以及浏览器需要跟踪每个事件处理器都需要消耗性能。</p>\n</li>\n</ul>\n<h2 id=\"6、字符串连接\"><a href=\"#6、字符串连接\" class=\"headerlink\" title=\"6、字符串连接\"></a>6、字符串连接</h2><pre><code>str += 'one'+'two';\nstr= str+'one'+'two';</code></pre>\n<p>后者方式会比前者少在内存中创建一个临时字符串，所以性能有相应的提升，所以，所以推荐后者的写法。</p>\n<h2 id=\"7、直接使用字面量\"><a href=\"#7、直接使用字面量\" class=\"headerlink\" title=\"7、直接使用字面量\"></a>7、直接使用字面量</h2><p>创建对象和数组推荐使用字面量，因为这不仅是性能最优也有助于节省代码量。</p>\n<pre><code>var obj = {   \n name:'tom',    \n age:15,    \n sex:'男'\n}</code></pre>\n<p>​    </p>\n<h2 id=\"8、数组长度缓存\"><a href=\"#8、数组长度缓存\" class=\"headerlink\" title=\"8、数组长度缓存\"></a>8、数组长度缓存</h2><p>如果需要遍历数组，应该先缓存数组长度，将数组长度放入局部变量中，避免多次查询数组长度。</p>\n<h2 id=\"9、循环比较\"><a href=\"#9、循环比较\" class=\"headerlink\" title=\"9、循环比较\"></a>9、循环比较</h2><p><code>JS</code>提供了三种循环：<code>for(;;)、while()、for(in)</code>。在这三种循环中 <code>for(in)</code>的效率最差，因为它需要查询Hash键，因此应尽量少用<code>for(in)</code>循环，<code>for(;;)、while()</code>循环的性能基本持平。</p>\n<h2 id=\"10、少用eval\"><a href=\"#10、少用eval\" class=\"headerlink\" title=\"10、少用eval\"></a>10、少用eval</h2><p>尽量少使用<code>eval</code>，每次使用<code>eval</code>需要消耗大量时间，这时候使用<code>JS</code>所支持的闭包可以实现函数模板。</p>\n<h2 id=\"11、字符串转换\"><a href=\"#11、字符串转换\" class=\"headerlink\" title=\"11、字符串转换\"></a>11、字符串转换</h2><p>当需要将数字转换成字符时，采用如下方式：<code>\"\" + 1</code>。从性能上来看，将数字转换成字符时，有如下公式：<code>(\"\" +) &gt; String() &gt; .toString() &gt; new String()</code>。<code>String()</code>属于内部函数，所以速度很快。而<code>.toString()</code>要查询原型中的函数，所以速度逊色一些，<code>new String()</code>需要重新创建一个字符串对象，速度最慢。</p>\n<h2 id=\"12、浮点数转换整形\"><a href=\"#12、浮点数转换整形\" class=\"headerlink\" title=\"12、浮点数转换整形\"></a>12、浮点数转换整形</h2><p>当需要将浮点数转换成整型时，应该使用<code>Math.floor()</code>或者<code>Math.round()</code>。而不是使用<code>parseInt()</code>,该方法用于将字符串转换成数字。而且<code>Math</code>是内部对象，所以<code>Math.floor()</code>其实并没有多少查询方法和调用时间，速度是最快的。</p>\n","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>随着计算机硬件的不断升级，开发者越发觉得<code>Javascript</code>性能优化的好不好对网页的执行效率影响不明显，所以一些性能方面的知识被很多开发者忽视。但在某些情况下，不优化的<code>Javascript</code>代码必然会影响用户的体验。因此，即使在当前硬件性能已经大大提升的时代，在编写<code>Javascript</code>代码时，若能遵循<code>Javascript</code>规范和注意一些性能方面的知识，对于提升代码的可维护性和优化性能将大有好处。那么，接下来我们讨论几种能够提高<code>JavaScript性能</code>的方法。</p>\n<h2 id=\"1、js文件加载和执行\"><a href=\"#1、js文件加载和执行\" class=\"headerlink\" title=\"1、js文件加载和执行\"></a>1、js文件加载和执行</h2><p>（1）将<code>&lt;script&gt;</code>标签放到<code>&lt;body&gt;</code>标签的底部</p>\n<p>（2）可以合并多个<code>js</code>文件，减少页面中<code>&lt;script&gt;</code>标签改善性能</p>\n<p>（3）使用 <code>defer</code> 属性，加载后续文档元素的过程将和<code>script.js</code>的加载并行进行，但是 <code>script.js</code> 的执行要在所有元素解析完成之后，<code>DOMContentLoaded </code>事件触发之前完成。</p>\n<p>（4）使用 <code>async</code> 属性，加载和渲染后续文档元素的过程将和<code>script.js</code>的加载与执行并行进行</p>\n<p>（5）动态加载脚本元素，无论在何时启动瞎子，文件的下载和执行过程都不会阻塞页面其它进程</p>\n<pre><code>var script = document.createElement(&#39;script&#39;);\nscript.type = &#39;text/javascript&#39;;\nscript.src = &#39;file.js&#39;;\ndocument.getElementsByTagName(&#39;head&#39;)[0].appendChild(script);</code></pre>\n<h2 id=\"2、标识符所在的作用域链的位置越深\"><a href=\"#2、标识符所在的作用域链的位置越深\" class=\"headerlink\" title=\"2、标识符所在的作用域链的位置越深\"></a>2、标识符所在的作用域链的位置越深</h2><p>标识符所在的作用域链的位置越深，那么它的标识符解析的性能就越慢。所以一个好的性能提升的经验法则是：如果某个跨作用域的值在函数中被引用一次以上，那么就把它存储到局部变量里。</p>\n<pre><code>function fun1() &#123;  \n// 将全局变量的引用先存储在一个局部变量中，然后使用这个局部变量代替全局变量，从而提高         \n// 性能；不然每次(3次)都要遍历整个作用域链找到\ndocument  var doc = document;   \n var bd = doc.body;  \n var links = doc.getElementsByTagName(&#39;a&#39;);  \n doc.getElementById(&#39;btn&#39;).onclick = function()&#123;   \n console.log(&#39;btn&#39;);  \n &#125;\n&#125;</code></pre>\n<h2 id=\"3、避免过长原型链继承\"><a href=\"#3、避免过长原型链继承\" class=\"headerlink\" title=\"3、避免过长原型链继承\"></a>3、避免过长原型链继承</h2><p>方法或属性在原型链中存在的位置越深，搜索它的性能也就越慢，所以要避免N多层原型链的写法。</p>\n<h2 id=\"4、对象成员嵌套过深\"><a href=\"#4、对象成员嵌套过深\" class=\"headerlink\" title=\"4、对象成员嵌套过深\"></a>4、对象成员嵌套过深</h2><p>对象的嵌套成员，对象成员嵌套越深，读取速度也就越慢。所以好的经验法则是：如果在函数中需要多次读取一个对象属性，最佳做法是将该属性值保存在局部变量中，避免多次查找带来的性能开销。</p>\n<pre><code>function f() &#123; \n // 因为在以下函数中需要3次用到DOM对象属性，所以先将它存储在一个局部变量        \n // 中，然后使用这个局部变量代替它进行后续操作，从而提高性能  \nvar dom = YaHOO.util.Dom;  \nif(Dom.hasClass(element,&#39;selected&#39;))&#123;   \n  Dom.removeClass(elemet,&#39;selected&#39;);  \n&#125;else&#123;   \n  Dom.addClass(elemet,&#39;selected&#39;);  \n &#125;\n&#125;</code></pre>\n<h2 id=\"5、DOM操作\"><a href=\"#5、DOM操作\" class=\"headerlink\" title=\"5、DOM操作\"></a>5、DOM操作</h2><p>用<code>js</code>访问和操作<code>DOM</code>都会带来性能损失，可通过以下几点来减少性能损失：</p>\n<p>（1）尽可能减少<code>DOM</code>访问次数；</p>\n<p>（2）如果需要多次访问某个<code>DOM</code>节点，请使用局部变量存储它的引用；</p>\n<p>（3）小心处理<code>HTML</code>集合，因为它实时连系着底层文档；我们可以把集合的长度缓存到一个变量中，并在迭代中使用它；</p>\n<p>（4）下述情况会发生重排：</p>\n<ul>\n<li>添加或删除可见的<code>DOM</code>元素；</li>\n<li>元素位置改变；</li>\n<li>元素尺寸改变（包括：外边距、内边距、边框厚度、宽度、高度等属性）；</li>\n<li>内容改变（例如：文本改变或图片被另一个不同尺寸的图片改变）；</li>\n<li>页面渲染器初始化；</li>\n<li>浏览器窗口尺寸改变</li>\n</ul>\n<p>可通过以下方式减少重排：</p>\n<ul>\n<li>留意上面会导致重排的操作，尽量避免；</li>\n<li>获取布局信息的操作会导致强制渲染队列重排，应该尽量避免使用以下获取布局信息的操作方法或属性或者缓存布局信息，例如：<code>offsetTop,offsetLeft,offsetWidthoffsetHeight,``scrollTop,scrollLeft,scrollWidth,scrollHeight,clientTop,clientLeft,clientWidth,clientHeight,getComputedStyle()</code>等;</li>\n<li>批量修改样式，例如使用：</li>\n</ul>\n<pre><code>function f() &#123;  \n  // 推荐使用以下操作  \n  var el1 = document.getElementById(&#39;mydiv&#39;);  \n  el1.style.cssText = &#39;border:1px;padding:2px;margin:3px&#39;;  \n  // 不推荐使用以下操作  \n  var el2 = document.getElementById(&#39;mydiv&#39;);  \n  el2.style.border = &#39;1px&#39;;  \n  el2.style.padding = &#39;2px&#39;;  \n  el2.style.margin = &#39;3px&#39;;\n&#125;</code></pre>\n<ul>\n<li><p>当需要批量修改<code>DOM</code>时，可以通过以下步骤减少重绘和重排的次数：</p>\n</li>\n<li><ul>\n<li>使元素脱离文档流（隐藏元素、拷贝元素）</li>\n<li>对其应用多重改变；</li>\n<li>把元素带回文档中</li>\n</ul>\n</li>\n<li><p>使用事件委托（事件逐层冒泡并能被父级元素捕获，使用事件代理，只需给外层元素绑定一个处理器，就可以处理其子元素上触发的所用事件），因为给<code>DOM</code>元素绑定事件以及浏览器需要跟踪每个事件处理器都需要消耗性能。</p>\n</li>\n</ul>\n<h2 id=\"6、字符串连接\"><a href=\"#6、字符串连接\" class=\"headerlink\" title=\"6、字符串连接\"></a>6、字符串连接</h2><pre><code>str += &#39;one&#39;+&#39;two&#39;;\nstr= str+&#39;one&#39;+&#39;two&#39;;</code></pre>\n<p>后者方式会比前者少在内存中创建一个临时字符串，所以性能有相应的提升，所以，所以推荐后者的写法。</p>\n<h2 id=\"7、直接使用字面量\"><a href=\"#7、直接使用字面量\" class=\"headerlink\" title=\"7、直接使用字面量\"></a>7、直接使用字面量</h2><p>创建对象和数组推荐使用字面量，因为这不仅是性能最优也有助于节省代码量。</p>\n<pre><code>var obj = &#123;   \n name:&#39;tom&#39;,    \n age:15,    \n sex:&#39;男&#39;\n&#125;</code></pre>\n<p>​    </p>\n<h2 id=\"8、数组长度缓存\"><a href=\"#8、数组长度缓存\" class=\"headerlink\" title=\"8、数组长度缓存\"></a>8、数组长度缓存</h2><p>如果需要遍历数组，应该先缓存数组长度，将数组长度放入局部变量中，避免多次查询数组长度。</p>\n<h2 id=\"9、循环比较\"><a href=\"#9、循环比较\" class=\"headerlink\" title=\"9、循环比较\"></a>9、循环比较</h2><p><code>JS</code>提供了三种循环：<code>for(;;)、while()、for(in)</code>。在这三种循环中 <code>for(in)</code>的效率最差，因为它需要查询Hash键，因此应尽量少用<code>for(in)</code>循环，<code>for(;;)、while()</code>循环的性能基本持平。</p>\n<h2 id=\"10、少用eval\"><a href=\"#10、少用eval\" class=\"headerlink\" title=\"10、少用eval\"></a>10、少用eval</h2><p>尽量少使用<code>eval</code>，每次使用<code>eval</code>需要消耗大量时间，这时候使用<code>JS</code>所支持的闭包可以实现函数模板。</p>\n<h2 id=\"11、字符串转换\"><a href=\"#11、字符串转换\" class=\"headerlink\" title=\"11、字符串转换\"></a>11、字符串转换</h2><p>当需要将数字转换成字符时，采用如下方式：<code>&quot;&quot; + 1</code>。从性能上来看，将数字转换成字符时，有如下公式：<code>(&quot;&quot; +) &gt; String() &gt; .toString() &gt; new String()</code>。<code>String()</code>属于内部函数，所以速度很快。而<code>.toString()</code>要查询原型中的函数，所以速度逊色一些，<code>new String()</code>需要重新创建一个字符串对象，速度最慢。</p>\n<h2 id=\"12、浮点数转换整形\"><a href=\"#12、浮点数转换整形\" class=\"headerlink\" title=\"12、浮点数转换整形\"></a>12、浮点数转换整形</h2><p>当需要将浮点数转换成整型时，应该使用<code>Math.floor()</code>或者<code>Math.round()</code>。而不是使用<code>parseInt()</code>,该方法用于将字符串转换成数字。而且<code>Math</code>是内部对象，所以<code>Math.floor()</code>其实并没有多少查询方法和调用时间，速度是最快的。</p>\n","categories":[{"name":"ES语法","path":"api/categories/ES语法.json"}],"tags":[{"name":"项目总结","path":"api/tags/项目总结.json"}]}