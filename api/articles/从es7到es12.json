{"title":"从es7到es12","slug":"从es7到es12","date":"2020-11-10T08:08:18.000Z","updated":"2022-01-05T09:25:40.657Z","comments":true,"path":"api/articles/从es7到es12.json","excerpt":null,"covers":null,"content":"<h1 id=\"本篇导读\"><a href=\"#本篇导读\" class=\"headerlink\" title=\"本篇导读\"></a>本篇导读</h1><p>JavaScript是一门支持多种编程范式的语言，灵活性很高，功能也十分强大。因为灵活性，JavaScript有很多种使用方式，被应用到浏览器、客户端软件、嵌入式硬件等多种场景下。在面向对象（OOP）这种编程范式大行其道的今天，这种变化多端的语言因其编程范式多样，每种场景下使用形态各异，使用者之间思维差别大，见解又各不相同，因此也就被误解得极深。正是由于这种相对的复杂性，前端工程师们有必要更系统、深入地对这门语言进行学习和研究。</p>\n<p>现在，JavaScript在TC39（TC39由包括浏览器厂商在内的各方组成，他们开会推动JavaScript特性的提案沿着一条严格的流程推进）的推动下正加速地迭代更新，每年都会有一些新特性出现。前端工程师们有必要了解一下这些新特性，以便更好地在一线互联网企业发挥出自己的能量。</p>\n<h1 id=\"JavaScript-和-ECMAScript-6-的关系\"><a href=\"#JavaScript-和-ECMAScript-6-的关系\" class=\"headerlink\" title=\"JavaScript 和 ECMAScript 6 的关系\"></a>JavaScript 和 ECMAScript 6 的关系</h1><p>JavaScript起源于1995年Netscape为自家游览器创造的脚本语言LiveScript。后来因为Sun公司的Java语言兴起，Netscape为了沾热度将LiveScript改名为JavaScript，但其实Java和JavaScript没有一点关系。</p>\n<p>1997年Netscape将JavaScript规范提交到 Ecma International（<a href=\"https://www.ecma-international.org/\">www.ecma-international.org</a>，简称EI），诞生了ECMAScript （简称“ES”）第1个版本。</p>\n<p>随后在1999年诞生了十分稳定的ES 3，也就是2009年12月之前前端工程师们最广泛使用的版本。</p>\n<p>在2009年12月诞生了ES 5。你可能会问ES 4 呢，抱歉，版本4因为太激进，EI委员会成员之间的意见不一，最后胎死腹中，改由更加平滑温和的版本5继承版本4的一些新特性和功能。</p>\n<p>EI于2015年6月发布了ES 6，也就是我们今天广泛使用的版本。这之后每年6月发布一个极小更新的ES版本。</p>\n<p>综上可见，<strong>JavaScript是ECMAScript规范的一种实现</strong>。为方便读者理解交流，而且由于ECAMScript 6 之后变化并不是特别大，如果没有特别说明，本书后面讲述的JavaScript对应的规范默认为 ES 6。</p>\n<p>本文下面会介绍ES 7~12的新特性。</p>\n<h1 id=\"ES-7-新特性\"><a href=\"#ES-7-新特性\" class=\"headerlink\" title=\"ES 7 新特性\"></a>ES 7 新特性</h1><table>\n<thead>\n<tr>\n<th align=\"left\">新特性</th>\n<th align=\"left\">中文说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>Array.prototype.includes</code></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">Exponentiation operator</td>\n<td align=\"left\">指数函数的中缀表示法</td>\n</tr>\n</tbody></table>\n<h2 id=\"Array-prototype-includes\"><a href=\"#Array-prototype-includes\" class=\"headerlink\" title=\"Array.prototype.includes\"></a>Array.prototype.includes</h2><p>includes是一个Array上很有用的方法，用于快速查找数组中是否包含某个元素，包括NaN（所以和indexOf不一样)。</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> arr <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">NaN</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">.</span><span class=\"token function\">includes</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">//查找2是否存在于arr数组中</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"找到了!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//>> 找到了！</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>arr<span class=\"token punctuation\">.</span><span class=\"token function\">includes</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">//第二个参数3表示数组下标为3的项，也即第4项开始查找</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">warn</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"不存在!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//>> 不存在！</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">//下面两句说明incluedes和indexOf的区别</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">.</span><span class=\"token function\">includes</span><span class=\"token punctuation\">(</span><span class=\"token number\">NaN</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//true</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">.</span><span class=\"token function\">indexOf</span><span class=\"token punctuation\">(</span><span class=\"token number\">NaN</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//false</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<h2 id=\"指数函数的中缀表示法\"><a href=\"#指数函数的中缀表示法\" class=\"headerlink\" title=\"指数函数的中缀表示法\"></a>指数函数的中缀表示法</h2><p>这个是与<code>Math.pow</code>有关的特性，还记得<code>i++</code>,<code>x += x</code>这种写法吗，指数函数的中缀表示法与之类似。与python语言一样，JavaScript也采用两个星符号<code>**</code>来表示<code>Math.pow</code>。好处有两个：<br>a. 中缀表示法比函数表示法更简洁，这使它更可取。<br>b. 方便数学、物理、机器人学等领域的计算。</p>\n<p>用法示例如下：</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\" spellcheck=\"true\">//用法一：x ** y</span>\n\n<span class=\"token keyword\">let</span> squared <span class=\"token operator\">=</span> <span class=\"token number\">2</span> <span class=\"token operator\">**</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//等同于: 2 * 2</span>\n<span class=\"token keyword\">let</span> cubed <span class=\"token operator\">=</span> <span class=\"token number\">2</span> <span class=\"token operator\">**</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//等同于: 2 * 2 * 2</span></code></pre>\n<pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\" spellcheck=\"true\">//用法二：x **= y</span>\n\n<span class=\"token keyword\">let</span> a <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\na <span class=\"token operator\">**</span><span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//等同于: a = a * a;</span>\n\n<span class=\"token keyword\">let</span> b <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span>\nb <span class=\"token operator\">**</span><span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//等同于: b = b * b * b;</span></code></pre>\n<h1 id=\"ES-8-新特性\"><a href=\"#ES-8-新特性\" class=\"headerlink\" title=\"ES 8 新特性\"></a>ES 8 新特性</h1><table>\n<thead>\n<tr>\n<th align=\"left\">新特性</th>\n<th align=\"left\">中文说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>Object.values</code> / <code>Object.entries</code></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">String padding</td>\n<td align=\"left\">字符串追加</td>\n</tr>\n<tr>\n<td align=\"left\"><code>Object.getOwnPropertyDescriptors</code></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">Trailing commas in function parameter lists and calls</td>\n<td align=\"left\">结尾允许逗号</td>\n</tr>\n<tr>\n<td align=\"left\">Async functions</td>\n<td align=\"left\">异步函数</td>\n</tr>\n<tr>\n<td align=\"left\">Shared memory and atomics</td>\n<td align=\"left\">共享内存和 Atomics 对象</td>\n</tr>\n</tbody></table>\n<h2 id=\"Object-values-Object-entries\"><a href=\"#Object-values-Object-entries\" class=\"headerlink\" title=\"Object.values() / Object.entries\"></a>Object.values() / Object.entries</h2><p>定义是<code>Object.values(obj)</code>，<code>obj</code> 参数是对目标对象的操作，它可以是一个对象或者数组。</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> obj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> x<span class=\"token punctuation\">:</span> <span class=\"token string\">'xxx'</span><span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">:</span> <span class=\"token number\">1</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\nObject<span class=\"token punctuation\">.</span><span class=\"token function\">values</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// ['xxx', 1]</span>\n\n<span class=\"token keyword\">const</span> obj <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'e'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'s'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'8'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 等同于 { 0: 'e', 1: 's', 2: '8' };</span>\nObject<span class=\"token punctuation\">.</span><span class=\"token function\">values</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// ['e', 's', '8']</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//当把数字对象的当键的时候，返回的数组以键的值升序排序</span>\n<span class=\"token keyword\">const</span> obj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> <span class=\"token number\">10</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'xxx'</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'yyy'</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'zzz'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\nObject<span class=\"token punctuation\">.</span><span class=\"token function\">values</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// ['yyy', 'zzz', 'xxx']</span>\nObject<span class=\"token punctuation\">.</span><span class=\"token function\">values</span><span class=\"token punctuation\">(</span><span class=\"token string\">'es8'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// ['e', 's', '8']</span></code></pre>\n<p><code>Object.entries</code>方法返回一个给定对象可枚举属性值的数组[key, value]，与<code>Object.values</code>类似。</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> obj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> x<span class=\"token punctuation\">:</span> <span class=\"token string\">'xxx'</span><span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">:</span> <span class=\"token number\">1</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\nObject<span class=\"token punctuation\">.</span><span class=\"token function\">entries</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// [['x', 'xxx'], ['y', 1]]</span>\n\n<span class=\"token keyword\">const</span> obj <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'e'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'s'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'8'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nObject<span class=\"token punctuation\">.</span><span class=\"token function\">entries</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// [['0', 'e'], ['1', 's'], ['2', '8']]</span>\n\n<span class=\"token keyword\">const</span> obj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> <span class=\"token number\">10</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'xxx'</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'yyy'</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'zzz'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\nObject<span class=\"token punctuation\">.</span><span class=\"token function\">entries</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// [['1', 'yyy'], ['3', 'zzz'], ['10', 'xxx']]</span>\nObject<span class=\"token punctuation\">.</span><span class=\"token function\">entries</span><span class=\"token punctuation\">(</span><span class=\"token string\">'es8'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// [['0', 'e'], ['1', 's'], ['2', '8']]</span></code></pre>\n<h2 id=\"字符串追加\"><a href=\"#字符串追加\" class=\"headerlink\" title=\"字符串追加\"></a>字符串追加</h2><p>在 ES 8 中String新增了两个实例函数<code>String.prototype.padStart</code>和<code>String.prototype.padEnd</code>，允许将空字符串或其他字符串添加到原始字符串的开头或结尾。</p>\n<ul>\n<li><p><code>String.padStart(targetLength,[padString])</code><br>_targetLength：_当前字符串需要填充到的目标长度。如果这个数值小于当前字符串的长度，则返回当前字符串本身。</p>\n<p>_padString：_(可选)填充字符串。如果字符串太长，使填充后的字符串长度超过了目标长度，则只保留最左侧的部分，其他部分会被截断，此参数的缺省值为空格。</p>\n</li>\n<li><p><code>String.padEnd(targetLength,padString])</code> 参数释义同上。</p>\n</li>\n</ul>\n<pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token string\">'es8'</span><span class=\"token punctuation\">.</span><span class=\"token function\">padStart</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>          <span class=\"token comment\" spellcheck=\"true\">// 'es8'</span>\n<span class=\"token string\">'es8'</span><span class=\"token punctuation\">.</span><span class=\"token function\">padStart</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>          <span class=\"token comment\" spellcheck=\"true\">// '  es8'</span>\n<span class=\"token string\">'es8'</span><span class=\"token punctuation\">.</span><span class=\"token function\">padStart</span><span class=\"token punctuation\">(</span><span class=\"token number\">6</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'1891'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// '189es8'</span>\n<span class=\"token string\">'es8'</span><span class=\"token punctuation\">.</span><span class=\"token function\">padStart</span><span class=\"token punctuation\">(</span><span class=\"token number\">14</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'coffe'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 'coffecoffeces8'</span>\n<span class=\"token string\">'es8'</span><span class=\"token punctuation\">.</span><span class=\"token function\">padStart</span><span class=\"token punctuation\">(</span><span class=\"token number\">7</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'0'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>     <span class=\"token comment\" spellcheck=\"true\">// '0000es8'</span>\n\n<span class=\"token string\">'es8'</span><span class=\"token punctuation\">.</span><span class=\"token function\">padEnd</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>            <span class=\"token comment\" spellcheck=\"true\">// 'es8'</span>\n<span class=\"token string\">'es8'</span><span class=\"token punctuation\">.</span><span class=\"token function\">padEnd</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>            <span class=\"token comment\" spellcheck=\"true\">// 'es8  '</span>\n<span class=\"token string\">'es8'</span><span class=\"token punctuation\">.</span><span class=\"token function\">padEnd</span><span class=\"token punctuation\">(</span><span class=\"token number\">6</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'1891'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\" spellcheck=\"true\">// 'es8189'</span>\n<span class=\"token string\">'es8'</span><span class=\"token punctuation\">.</span><span class=\"token function\">padEnd</span><span class=\"token punctuation\">(</span><span class=\"token number\">14</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'coffe'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\" spellcheck=\"true\">// 'es8coffecoffec'</span>\n<span class=\"token string\">'es8'</span><span class=\"token punctuation\">.</span><span class=\"token function\">padEnd</span><span class=\"token punctuation\">(</span><span class=\"token number\">7</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'9'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>       <span class=\"token comment\" spellcheck=\"true\">// 'es89999'</span></code></pre>\n<h2 id=\"Object-getOwnPropertyDescriptors\"><a href=\"#Object-getOwnPropertyDescriptors\" class=\"headerlink\" title=\"Object.getOwnPropertyDescriptors\"></a>Object.getOwnPropertyDescriptors</h2><p><code>getOwnPropertyDescriptors</code>方法返回一指定对象自己所有的属性内容，并且属性内容只是自身直接定义的，而不是从object的原型继承而来的。<br>定义是：<code>Object.getOwnPropertyDescriptors(obj)</code>，<code>obj</code> 是指目标对象，这个方法返回的值可能是 configurable、enumerable、writable、get、set 和 value。</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> obj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> \n  <span class=\"token keyword\">get</span> <span class=\"token function\">es7</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">return</span> <span class=\"token number\">7</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token keyword\">get</span> <span class=\"token function\">es8</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">return</span> <span class=\"token number\">8</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\nObject<span class=\"token punctuation\">.</span><span class=\"token function\">getOwnPropertyDescriptors</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// {</span>\n<span class=\"token comment\" spellcheck=\"true\">//   es7: {</span>\n<span class=\"token comment\" spellcheck=\"true\">//     configurable: true,</span>\n<span class=\"token comment\" spellcheck=\"true\">//     enumerable: true,</span>\n<span class=\"token comment\" spellcheck=\"true\">//     get: function es7(){}, //the getter function</span>\n<span class=\"token comment\" spellcheck=\"true\">//     set: undefined</span>\n<span class=\"token comment\" spellcheck=\"true\">//   },</span>\n<span class=\"token comment\" spellcheck=\"true\">//   es8: {</span>\n<span class=\"token comment\" spellcheck=\"true\">//     configurable: true,</span>\n<span class=\"token comment\" spellcheck=\"true\">//     enumerable: true,</span>\n<span class=\"token comment\" spellcheck=\"true\">//     get: function es8(){}, //the getter function</span>\n<span class=\"token comment\" spellcheck=\"true\">//     set: undefined</span>\n<span class=\"token comment\" spellcheck=\"true\">//   }</span>\n<span class=\"token comment\" spellcheck=\"true\">// }</span></code></pre>\n<h2 id=\"结尾允许逗号\"><a href=\"#结尾允许逗号\" class=\"headerlink\" title=\"结尾允许逗号\"></a>结尾允许逗号</h2><p>用法示例如下：</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\" spellcheck=\"true\">//定义参数时</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span>\n    param1<span class=\"token punctuation\">,</span>\n    param2<span class=\"token punctuation\">,</span><span class=\"token comment\" spellcheck=\"true\">//结尾逗号</span>\n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">//传参时</span>\n<span class=\"token function\">foo</span><span class=\"token punctuation\">(</span>\n    <span class=\"token string\">'coffe'</span><span class=\"token punctuation\">,</span>\n    <span class=\"token string\">'1891'</span><span class=\"token punctuation\">,</span><span class=\"token comment\" spellcheck=\"true\">//结尾逗号</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">//对象中</span>\n<span class=\"token keyword\">let</span> obj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token string\">\"a\"</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'coffe'</span><span class=\"token punctuation\">,</span>\n    <span class=\"token string\">\"b\"</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'1891'</span><span class=\"token punctuation\">,</span><span class=\"token comment\" spellcheck=\"true\">//结尾逗号</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">//数组中</span>\n<span class=\"token keyword\">let</span> arr <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>\n    <span class=\"token string\">'coffe'</span><span class=\"token punctuation\">,</span>\n    <span class=\"token string\">'1891'</span><span class=\"token punctuation\">,</span><span class=\"token comment\" spellcheck=\"true\">//结尾逗号</span>\n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></code></pre>\n<p>这样改动的好处有两点：</p>\n<ul>\n<li>重新排列项目更简单，因为如果最后一项更改其位置，则不必添加和删除逗号。</li>\n<li>可以帮助git等版本控制系统跟踪实际发生的变化，在查看代码改动、合并代码的时候，少报一些无用信息。例如，从</li>\n</ul>\n<pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token punctuation\">[</span>\n    <span class=\"token string\">'coffe'</span>\n<span class=\"token punctuation\">]</span></code></pre>\n<p>变更为</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token punctuation\">[</span>\n    <span class=\"token string\">'coffe'</span><span class=\"token punctuation\">,</span>\n    <span class=\"token string\">'1891'</span>\n<span class=\"token punctuation\">]</span></code></pre>\n<p>在git里它会报同时修改了两行代码，采用结尾逗号<code>'coffe',</code>之后，就只会报仅有一行代码<code>'1891',</code>的变动，这样做代码review（代码复查）的时候就更省眼力了。</p>\n<h2 id=\"异步函数\"><a href=\"#异步函数\" class=\"headerlink\" title=\"异步函数\"></a>异步函数</h2><p>Async Functions也就是我们常说的Async/Await，相信大家对于这个概念都已经不陌生了。Async/Await是一种用于处理JS异步操作的语法糖，可以帮助我们摆脱<strong>回调地狱</strong>（callback hell），编写更加优雅的代码。</p>\n<p>通俗的理解，<code>async</code>关键字的作用是告诉编译器对于标定的函数要区别对待。当编译器遇到标定的函数中的<code>await</code>关键字时，要暂时停止运行，等到<code>await</code>标定的函数处理完毕后，再进行相应操作。如果该函数fulfiled了，则返回值是fulfillment value，否则得到的就是reject value。</p>\n<p>下面通过拿普通的promise写法来对比，就很好理解了：</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">asyncFunc</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> result <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token function\">otherAsyncFunc</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">// otherAsyncFunc()返回一个Promise对象</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 等同于:</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">asyncFunc</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">otherAsyncFunc</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token comment\" spellcheck=\"true\">// otherAsyncFunc()返回一个Promise对象</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>result <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>按顺序处理多个异步函数的时候优势更为明显：</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">asyncFunc</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> result1 <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token function\">otherAsyncFunc1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">// otherAsyncFunc1()返回一个Promise对象</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>result1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">const</span> result2 <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token function\">otherAsyncFunc2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">// otherAsyncFunc2()返回一个Promise对象</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>result2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 等同于:</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">asyncFunc</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">otherAsyncFunc1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token comment\" spellcheck=\"true\">// otherAsyncFunc1()返回一个Promise对象</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>result1 <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>result1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token function\">otherAsyncFunc2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">// otherAsyncFunc2()返回一个Promise对象</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>result2 <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>result2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>并行处理多个异步函数：</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">asyncFunc</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>result1<span class=\"token punctuation\">,</span> result2<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> Promise<span class=\"token punctuation\">.</span><span class=\"token function\">all</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>\n        <span class=\"token function\">otherAsyncFunc1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token comment\" spellcheck=\"true\">// otherAsyncFunc1()返回一个Promise对象</span>\n        <span class=\"token function\">otherAsyncFunc2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// otherAsyncFunc2()返回一个Promise对象</span>\n    <span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>result1<span class=\"token punctuation\">,</span> result2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 等同于:</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">asyncFunc</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> Promise<span class=\"token punctuation\">.</span><span class=\"token function\">all</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>\n        <span class=\"token function\">otherAsyncFunc1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token comment\" spellcheck=\"true\">// otherAsyncFunc1()返回一个Promise对象</span>\n        <span class=\"token function\">otherAsyncFunc2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// otherAsyncFunc2()返回一个Promise对象</span>\n    <span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>result1<span class=\"token punctuation\">,</span> result2<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>result1<span class=\"token punctuation\">,</span> result2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>处理错误：</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">asyncFunc</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">await</span> <span class=\"token function\">otherAsyncFunc</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">// otherAsyncFunc()返回一个Promise对象</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">err</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">error</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 等同于:</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">asyncFunc</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">otherAsyncFunc</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token comment\" spellcheck=\"true\">// otherAsyncFunc()返回一个Promise对象</span>\n    <span class=\"token punctuation\">.</span><span class=\"token keyword\">catch</span><span class=\"token punctuation\">(</span>err <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">error</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>Async Functions若是要展开讲可以占很大的篇幅，鉴于本篇是一篇介绍性文章，故此不再进行深入论述。</p>\n<h2 id=\"共享内存和-Atomics-对象\"><a href=\"#共享内存和-Atomics-对象\" class=\"headerlink\" title=\"共享内存和 Atomics 对象\"></a>共享内存和 Atomics 对象</h2><p>SharedArrayBuffer 对象用来表示一个通用的，固定长度的原始二进制数据缓冲区，类似于 ArrayBuffer对象（如果之前你没有接触过ArrayBuffer相关知识的话，建议从<a href=\"https://hacks.mozilla.org/2017/06/a-cartoon-intro-to-arraybuffers-and-sharedarraybuffers/\">内存管理速成教程系列漫画解说入门</a>） ，它们都可以用来在共享内存（shared memory）上创建视图。与 ArrayBuffer 不同的是，SharedArrayBuffer 不能被分离。</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\" spellcheck=\"true\">/**\n * \n * @param {*} length 所创建的数组缓冲区的大小，以字节(byte)为单位。  \n * @returns {SharedArrayBuffer} 一个大小指定的新 SharedArrayBuffer 对象。其内容被初始化为 0。\n */</span>\n<span class=\"token keyword\">new</span> <span class=\"token class-name\">SharedArrayBuffer</span><span class=\"token punctuation\">(</span>length<span class=\"token punctuation\">)</span>\n</code></pre>\n<p>Atomics 对象提供了一组静态方法用来对 SharedArrayBuffer 对象进行原子操作，这些原子操作属于 Atomics 模块。Atomics 不是构造函数，因此不能使用 new 操作符调用，也不能将其当作函数直接调用。Atomics 的所有属性和方法都是静态的（与 Math 对象一样）。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">方法名</th>\n<th align=\"left\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">Atomics.add()</td>\n<td align=\"left\">将指定位置上的数组元素与给定的值相加，并返回相加前该元素的值。</td>\n</tr>\n<tr>\n<td align=\"left\">Atomics.and()</td>\n<td align=\"left\">将指定位置上的数组元素与给定的值相与，并返回与操作前该元素的值。</td>\n</tr>\n<tr>\n<td align=\"left\">Atomics.compareExchange()</td>\n<td align=\"left\">如果数组中指定的元素与给定的值相等，则将其更新为新的值，并返回该元素原先的值。</td>\n</tr>\n<tr>\n<td align=\"left\">Atomics.exchange()</td>\n<td align=\"left\">将数组中指定的元素更新为给定的值，并返回该元素更新前的值。</td>\n</tr>\n<tr>\n<td align=\"left\">Atomics.load()</td>\n<td align=\"left\">返回数组中指定元素的值。</td>\n</tr>\n<tr>\n<td align=\"left\">Atomics.or()</td>\n<td align=\"left\">将指定位置上的数组元素与给定的值相或，并返回或操作前该元素的值。</td>\n</tr>\n<tr>\n<td align=\"left\">Atomics.store()</td>\n<td align=\"left\">将数组中指定的元素设置为给定的值，并返回该值。</td>\n</tr>\n<tr>\n<td align=\"left\">Atomics.sub()</td>\n<td align=\"left\">将指定位置上的数组元素与给定的值相减，并返回相减前该元素的值。</td>\n</tr>\n<tr>\n<td align=\"left\">Atomics.xor()</td>\n<td align=\"left\">将指定位置上的数组元素与给定的值相异或，并返回异或操作前该元素的值。</td>\n</tr>\n<tr>\n<td align=\"left\">Atomics.wait()</td>\n<td align=\"left\">检测数组中某个指定位置上的值是否仍然是给定值，是则保持挂起直到被唤醒或超时。返回值为 “ok”、”not-equal” 或 “time-out”。调用时，如果当前线程不允许阻塞，则会抛出异常（大多数浏览器都不允许在主线程中调用 wait()）。</td>\n</tr>\n<tr>\n<td align=\"left\">Atomics.wake()</td>\n<td align=\"left\">唤醒等待队列中正在数组指定位置的元素上等待的线程。返回值为成功唤醒的线程数量。</td>\n</tr>\n<tr>\n<td align=\"left\">Atomics.isLockFree(size)</td>\n<td align=\"left\">可以用来检测当前系统是否支持硬件级的原子操作。对于指定大小的数组，如果当前系统支持硬件级的原子操作，则返回 true；否则就意味着对于该数组，Atomics 对象中的各原子操作都只能用锁来实现。此静态方法面向的是技术专家。</td>\n</tr>\n</tbody></table>\n<h1 id=\"ES-9-新特性\"><a href=\"#ES-9-新特性\" class=\"headerlink\" title=\"ES 9 新特性\"></a>ES 9 新特性</h1><table>\n<thead>\n<tr>\n<th align=\"left\">新特性</th>\n<th align=\"left\">中文说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">Asynchronous Iteration</td>\n<td align=\"left\">异步迭代器</td>\n</tr>\n<tr>\n<td align=\"left\"><code>Promise.prototype.finally</code></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">Lifting template literal restriction</td>\n<td align=\"left\">重新修订了字面量的转义</td>\n</tr>\n<tr>\n<td align=\"left\">Rest/Spread Properties</td>\n<td align=\"left\">Rest/Spread 属性</td>\n</tr>\n<tr>\n<td align=\"left\"><code>s</code> (dotAll) flag for regular expressions</td>\n<td align=\"left\">正则表达式dotAll模式</td>\n</tr>\n<tr>\n<td align=\"left\">RegExp named capture groups</td>\n<td align=\"left\">正则表达式命名捕获组</td>\n</tr>\n<tr>\n<td align=\"left\">RegExp Lookbehind Assertions</td>\n<td align=\"left\">正则表达式反向断言</td>\n</tr>\n<tr>\n<td align=\"left\">RegExp Unicode Property Escapes</td>\n<td align=\"left\">正则表达式 Unicode 转义</td>\n</tr>\n</tbody></table>\n<h2 id=\"异步迭代器\"><a href=\"#异步迭代器\" class=\"headerlink\" title=\"异步迭代器\"></a>异步迭代器</h2><p>在<code>async</code>/<code>await</code>的某些时刻，你可能尝试在同步循环中调用异步函数。例如：</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">func</span><span class=\"token punctuation\">(</span>array<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token keyword\">of</span> array<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">await</span> <span class=\"token function\">someFunc</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>这段代码不会达到预期目的，下面这段同样也不会：</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">func</span><span class=\"token punctuation\">(</span>array<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  array<span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">async</span> i <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">await</span> <span class=\"token function\">someFunc</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>上面这段代码中，循环本身依旧保持同步，并在内部异步函数之前全部调用完成。</p>\n<p>引入异步迭代器后，就像常规迭代器，除了<code>next()</code>方法返回一个Promise。因此<code>await</code>可以和<code>for...of</code>循环一起使用，以串行的方式运行异步操作。</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">func</span><span class=\"token punctuation\">(</span>array<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">for</span> <span class=\"token keyword\">await</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token keyword\">of</span> array<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token comment\" spellcheck=\"true\">//异步迭代</span>\n    <span class=\"token function\">someFunc</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"Promise-prototype-finally\"><a href=\"#Promise-prototype-finally\" class=\"headerlink\" title=\"Promise.prototype.finally\"></a>Promise.prototype.finally</h2><p>一个Promise调用链要么成功到达最后一个<code>.then()</code>，要么失败触发<code>.catch()</code>。在某些情况下，你想要在无论Promise运行成功还是失败，运行相同的代码，例如清除数组、删除对话、关闭数据库连接等，<code>.finally()</code>允许实现这样的目的。</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">promiseFunc</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">//返回一个Promise对象</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token keyword\">catch</span><span class=\"token punctuation\">(</span>err <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n      console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token keyword\">finally</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\" spellcheck=\"true\">//无论promiseFunc()运行成功还是失败，这里的代码会被调用到</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"重新修订了字面量的转义\"><a href=\"#重新修订了字面量的转义\" class=\"headerlink\" title=\"重新修订了字面量的转义\"></a>重新修订了字面量的转义</h2><p>ES9 之前，<code>\\u</code>表示 unicode 转义，<code>\\x</code>表示十六进制转义，<code>\\</code>后跟一个数字表示八进制转义，这使得创建特定的字符串变得不可能，例如Windows文件路径<code>C:\\uuu\\xxx\\111</code>。</p>\n<p>要取消转义序列的语法限制，可在模板字符串之前使用标记函数<code>String.raw</code>。</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">let</span> s <span class=\"token operator\">=</span> <span class=\"token template-string\"><span class=\"token string\">`\\u{54}`</span></span> <span class=\"token comment\" spellcheck=\"true\">//会转义成unicode \"T\"</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//>> T</span>\n\n<span class=\"token keyword\">let</span> str <span class=\"token operator\">=</span> String<span class=\"token punctuation\">.</span>raw<span class=\"token template-string\"><span class=\"token string\">`\\u{54}`</span></span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//不会被转义</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//>> \\u{54}</span></code></pre>\n<h2 id=\"Rest-Spread\"><a href=\"#Rest-Spread\" class=\"headerlink\" title=\"Rest / Spread\"></a>Rest / Spread</h2><p>这个就是我们通常所说的三个点<code>...</code>，这项特性在ES6中已经引入，但是ES6中的作用对象仅限于数组。在ES9中，为对象提供了像数组一样的rest参数和扩展运算符：</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> obj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  a<span class=\"token punctuation\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span>\n  b<span class=\"token punctuation\">:</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span>\n  c<span class=\"token punctuation\">:</span> <span class=\"token number\">3</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> a<span class=\"token punctuation\">,</span> <span class=\"token operator\">...</span>param <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> obj<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//这里...是rest</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//>> 1</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>param<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//>> {b: 2, c: 3}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> a<span class=\"token punctuation\">,</span> <span class=\"token operator\">...</span>param <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token comment\" spellcheck=\"true\">//这里...还是rest</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//>> 1</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>param<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//>> {b: 2, c: 3}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> param <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> b<span class=\"token punctuation\">:</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> c<span class=\"token punctuation\">:</span> <span class=\"token number\">3</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> a<span class=\"token punctuation\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">...</span>param <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">//此处...为spread</span></code></pre>\n<h2 id=\"正则表达式dotAll模式\"><a href=\"#正则表达式dotAll模式\" class=\"headerlink\" title=\"正则表达式dotAll模式\"></a>正则表达式dotAll模式</h2><p>正则表达式中点<code>.</code>匹配除回车外的任何单字符，标记<code>s</code>改变这种行为，允许匹配回车换行。</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token regex\">/hello.world/</span><span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">'hello\\nworld'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// false</span>\n<span class=\"token operator\">/</span>hello<span class=\"token punctuation\">.</span>world<span class=\"token operator\">/</span>s<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">'hello\\nworld'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// true</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token operator\">/</span>hello<span class=\"token punctuation\">.</span>world<span class=\"token operator\">/</span>s<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token string\">`hello\nworld`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>   <span class=\"token comment\" spellcheck=\"true\">//>> true</span></code></pre>\n<h2 id=\"正则表达式命名捕获组\"><a href=\"#正则表达式命名捕获组\" class=\"headerlink\" title=\"正则表达式命名捕获组\"></a>正则表达式命名捕获组</h2><p>Javascript正则表达式中使用<code>exec()</code>匹配后，能够返回一个包含匹配字符串的类数组对象。</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> reDate <span class=\"token operator\">=</span> <span class=\"token regex\">/(\\d{4})-(\\d{2})-(\\d{2})/</span><span class=\"token punctuation\">,</span>\n  match <span class=\"token operator\">=</span> reDate<span class=\"token punctuation\">.</span><span class=\"token function\">exec</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"2018-08-06\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>match<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//>> [2018-08-06, 2018, 08, 06]</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//这样就可以直接用索引来获取年月日：</span>\n<span class=\"token keyword\">let</span> year <span class=\"token operator\">=</span> match<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//>> 2018</span>\n<span class=\"token keyword\">let</span> month <span class=\"token operator\">=</span> match<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//>> 08</span>\n<span class=\"token keyword\">let</span> day <span class=\"token operator\">=</span> match<span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//>> 06</span></code></pre>\n<p>返回数组的第0项为与正则表达式相匹配的文本，第 1 项是与 <code>reDate</code> 的第 1 个分组<code>\\d{4}</code>相匹配的文本（如果有的话），第 2 项是与 <code>reDate</code> 的第 2 个分组<code>\\d{2}</code>相匹配的文本（如果有的话），以此类推。正则表达式的组以<code>()</code>包起来。</p>\n<p>上面的案例，若是日期格式变成<code>月日年</code>，那么改变正则表达式的结构后，还有可能会改变变量的赋值部分的代码。如下示例：</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> reDate <span class=\"token operator\">=</span> <span class=\"token regex\">/(\\d{2})-(\\d{2})-(\\d{4})/</span><span class=\"token punctuation\">,</span><span class=\"token comment\" spellcheck=\"true\">//表达式结构变化了</span>\n  match <span class=\"token operator\">=</span> reDate<span class=\"token punctuation\">.</span><span class=\"token function\">exec</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"08-06-2018\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>match<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//>> [08-06-2018, 08, 06, 2018]</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//此时年月日的赋值代码也要改了,改的地方真多啊！怎么办？</span>\n<span class=\"token keyword\">let</span> year <span class=\"token operator\">=</span> match<span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//>> 2018</span>\n<span class=\"token keyword\">let</span> month <span class=\"token operator\">=</span> match<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//>> 08</span>\n<span class=\"token keyword\">let</span> day <span class=\"token operator\">=</span> match<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//>> 06</span></code></pre>\n<p>可以发现上面的写法改的地方太多了，有没有办法少改点代码省省事呢？有！ ES9 允许使用符号<code>?&lt;name&gt;</code>来命名<strong>捕获组</strong>（也即“匹配到的组”），示例如下：</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> reDate <span class=\"token operator\">=</span> <span class=\"token regex\">/(?&lt;year>\\d{4})-(?&lt;month>\\d{2})-(?&lt;day>\\d{2})/</span><span class=\"token punctuation\">,</span>\n  match <span class=\"token operator\">=</span> reDate<span class=\"token punctuation\">.</span><span class=\"token function\">exec</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"2018-08-06\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>match<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">//>> [2018-08-06, 08, 06, 2018, groups: {day: 06, month: 08, year: 2018}]</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//此时用groups对象来获取年月日，无论正则表达式怎么变换，这下面三行不用改了，省事！</span>\n<span class=\"token keyword\">let</span> year <span class=\"token operator\">=</span> match<span class=\"token punctuation\">.</span>groups<span class=\"token punctuation\">.</span>year<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//>> 2018</span>\n<span class=\"token keyword\">let</span> month <span class=\"token operator\">=</span> match<span class=\"token punctuation\">.</span>groups<span class=\"token punctuation\">.</span>month<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//>> 08</span>\n<span class=\"token keyword\">let</span> day <span class=\"token operator\">=</span> match<span class=\"token punctuation\">.</span>groups<span class=\"token punctuation\">.</span>day<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//>> 06</span></code></pre>\n<p>命名捕获组的写法相当于是把每个捕获组都定义了一个名字，然后存储到返回值的<code>groups</code>属性中。</p>\n<h3 id=\"正则表达式后行断言\"><a href=\"#正则表达式后行断言\" class=\"headerlink\" title=\"正则表达式后行断言\"></a>正则表达式后行断言</h3><p>先看看正则表达式<strong>先行断言</strong>示例：</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> re1 <span class=\"token operator\">=</span> <span class=\"token regex\">/\\D(\\d+)/</span><span class=\"token punctuation\">,</span>\n    re2 <span class=\"token operator\">=</span> <span class=\"token regex\">/\\D(?=\\d+)/</span><span class=\"token punctuation\">,</span><span class=\"token comment\" spellcheck=\"true\">//\"?=\"是正向先行断言</span>\n    match1 <span class=\"token operator\">=</span> re1<span class=\"token punctuation\">.</span><span class=\"token function\">exec</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"$123.45\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    match2 <span class=\"token operator\">=</span> re2<span class=\"token punctuation\">.</span><span class=\"token function\">exec</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"$123.45\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>match1<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//>> $123</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>match2<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//>> $</span></code></pre>\n<blockquote>\n<p><strong>(?=pattern)</strong> 零宽正向先行断言(zero-width positive lookahead assertion)<br>代表字符串中的一个位置，<strong>紧接该位置之后</strong>的字符序列<strong>能够匹配</strong>pattern；</p>\n<p>(<strong>?!pattern)</strong> 零宽负向先行断言(zero-width negative lookahead assertion)<br>代表字符串中的一个位置，<strong>紧接该位置之后</strong>的字符序列<strong>不能匹配</strong>pattern；</p>\n<p><strong>(?&lt;=pattern)</strong> 零宽正向后行断言(zero-width positive lookbehind assertion)<br>代表字符串中的一个位置，<strong>紧接该位置之前</strong>的字符序列<strong>能够匹配</strong>pattern；</p>\n<p><strong>(?&lt;!pattern)</strong> 零宽负向后行断言(zero-width negative lookbehind assertion)<br>代表字符串中的一个位置，<strong>紧接该位置之前</strong>的字符序列<strong>不能匹配</strong>pattern。</p>\n</blockquote>\n<p>在ES9中，可以允许使用<code>?&lt;=</code>进行<strong>正向后行断言</strong>，可以获取货币的价格而忽略货币符号。</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> re<span class=\"token operator\">=</span> <span class=\"token regex\">/(?&lt;=\\D)[\\d\\.]+/</span><span class=\"token punctuation\">,</span>\n    match <span class=\"token operator\">=</span> re<span class=\"token punctuation\">.</span><span class=\"token function\">exec</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"$123.45\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>match<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//>> 123.45</span></code></pre>\n<p>上面的正向后行断言，也就是说<code>\\D</code>这个条件必须满足，但<code>\\D</code>匹配的字符不会作为结果输出（因为<strong>先行/后行断言</strong>其实只是匹配了一个位置）。如果是下面这样：</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> re<span class=\"token operator\">=</span> <span class=\"token regex\">/(?&lt;=\\D)[\\d\\.]+/</span><span class=\"token punctuation\">,</span>\n    match1 <span class=\"token operator\">=</span> re<span class=\"token punctuation\">.</span><span class=\"token function\">exec</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"123.45\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    match2 <span class=\"token operator\">=</span> re<span class=\"token punctuation\">.</span><span class=\"token function\">exec</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"12345\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>match1 <span class=\"token operator\">&amp;&amp;</span> match1<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//>> 45</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>match2 <span class=\"token operator\">&amp;&amp;</span> match1<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//>> null</span></code></pre>\n<p>可以看到<code>match1</code>匹配到的是<code>45</code>,这是由于在<code>.</code>前面没有任何符合<code>\\D</code>的匹配内容，它会一直找到符合<code>\\D</code>的内容，也就是<code>.</code>然后返回后面的内容。而<code>match2</code>若是没有满足前面肯定反向断言的条件的话，则结果返回<code>null</code>。</p>\n<h2 id=\"正则表达式-Unicode-转义\"><a href=\"#正则表达式-Unicode-转义\" class=\"headerlink\" title=\"正则表达式 Unicode 转义\"></a>正则表达式 Unicode 转义</h2><p>ES9 之前，在正则表达式中本地访问 Unicode 字符属性是不被允许的。ES9 添加了 Unicode 属性转义，形式为<code>\\p{...}</code>和<code>\\P{...}</code>，在正则表达式中使用标记 <code>u</code> (unicode) 设置，在<code>\\p</code>的<code>{...}</code>内，可用键值对的方式设置需要匹配的属性而非具体内容。</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> regex <span class=\"token operator\">=</span> <span class=\"token regex\">/\\p{Script=Greek}/u</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//Greek为希腊语的意思</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>regex<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">'a'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//>> flase</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>regex<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Σ'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//>> true</span></code></pre>\n<h1 id=\"ES-10-新特性\"><a href=\"#ES-10-新特性\" class=\"headerlink\" title=\"ES 10 新特性\"></a>ES 10 新特性</h1><table>\n<thead>\n<tr>\n<th align=\"left\">新特性</th>\n<th align=\"left\">中文说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">Optional <code>catch</code> binding</td>\n<td align=\"left\">可选的 catch 变量绑定</td>\n</tr>\n<tr>\n<td align=\"left\">JSON superset</td>\n<td align=\"left\">JSON超集</td>\n</tr>\n<tr>\n<td align=\"left\"><code>Symbol.prototype.description</code></td>\n<td align=\"left\">Symbol 对象的 description 属性</td>\n</tr>\n<tr>\n<td align=\"left\"><code>Function.prototype.toString</code> revision</td>\n<td align=\"left\">修订<code>Function.prototype.toString</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>Object.fromEntries</code></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">Well-formed <code>JSON.stringify</code></td>\n<td align=\"left\">更加友好的JSON.stringify</td>\n</tr>\n<tr>\n<td align=\"left\"><code>String.prototype.{trimStart,trimEnd}</code></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\"><code>Array.prototype.{flat,flatMap}</code></td>\n<td align=\"left\"></td>\n</tr>\n</tbody></table>\n<h2 id=\"可选的-catch-变量绑定\"><a href=\"#可选的-catch-变量绑定\" class=\"headerlink\" title=\"可选的 catch 变量绑定\"></a>可选的 catch 变量绑定</h2><p>在 ES10 之前，我们必须通过语法为 catch 子句绑定异常变量，无论是否有必要。很多时候 catch 块是多余的，而 ES10 使我们能够简单的把变量省略掉。</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\" spellcheck=\"true\">//之前是</span>\n<span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//ES10之后可以写成，</span>\n<span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token comment\" spellcheck=\"true\">//省掉了变量e</span></code></pre>\n<h2 id=\"JSON超集\"><a href=\"#JSON超集\" class=\"headerlink\" title=\"JSON超集\"></a>JSON超集</h2><p>什么是 JSON 超集？简单来说就是 JSON 是 ECMAScript 的子集，也就是说让 ECMAScript 兼容 JSON 的内容所支持的全部文本。</p>\n<p>ECMAScript 在标准 <a href=\"https://tc39.es/ecma262/#sec-json.parse\">JSON.parse</a> 部分阐明了 JSON 确为其一个子集，但由于 JSON 的内容可以正常包含 <code>U+2028</code> 行分隔符与 <code>U+2029</code> 段落分隔符，而 ECMAScript 却不行，所以，该草案旨在解决这一问题。在这之前，如果你使用 <code>JSON.parse()</code> 执行带如上特殊字符的字符串时，只会收到 <code>SyntaxError</code> 的错误提示。该草案同样是向后兼容的，其对用户唯一的影响是保持原样，即在暂不支持特殊字符解析的运行环境中保持报错 <code>SyntaxError</code> 。</p>\n<h2 id=\"Symbol-对象的-description-属性\"><a href=\"#Symbol-对象的-description-属性\" class=\"headerlink\" title=\"Symbol 对象的 description 属性\"></a>Symbol 对象的 description 属性</h2><p>ES10 中为 Symbol 对象添加了只读属性 <code>description</code> ，该对象返回包含 Symbol 描述的字符串。在创建Symbol时向其添加<code>description</code> (描述)，能够直接访问<code>description</code> ，对调试是很有用的。</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">let</span> sym <span class=\"token operator\">=</span> <span class=\"token function\">Symbol</span><span class=\"token punctuation\">(</span><span class=\"token string\">'foo'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//添加的描述内容为“foo”</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>sym<span class=\"token punctuation\">.</span>description<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//>> foo</span>\n\nsym <span class=\"token operator\">=</span> <span class=\"token function\">Symbol</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>sym<span class=\"token punctuation\">.</span>description<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//>> undefined</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//和 Symbol() 不同的是，用 Symbol.for() 方法创建的的 symbol 会被放入一个全局 </span>\n<span class=\"token comment\" spellcheck=\"true\">//symbol 注册表中。Symbol.for() 并不是每次都会创建一个新的 symbol，它会首先检</span>\n<span class=\"token comment\" spellcheck=\"true\">//查给定的 key 是否已经在注册表中了。假如是，则会直接返回上次存储的那个。否则，它</span>\n<span class=\"token comment\" spellcheck=\"true\">//会再新建一个。</span>\nsym <span class=\"token operator\">=</span> Symbol<span class=\"token punctuation\">.</span><span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token string\">'bar'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>sym<span class=\"token punctuation\">.</span>description<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//>> bar</span></code></pre>\n<h2 id=\"修订Function-prototype-toString\"><a href=\"#修订Function-prototype-toString\" class=\"headerlink\" title=\"修订Function.prototype.toString\"></a>修订Function.prototype.toString</h2><p>函数原型上的方法<code>toString()</code>现在返回精确字符，包括空格和注释。</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token comment\" spellcheck=\"true\">/* comment */</span> foo <span class=\"token comment\" spellcheck=\"true\">/* another comment */</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//ES10之前不会打印注释部分</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>foo<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//>> function foo(){}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//ES10里，会把注释一同打印</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>foo<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//>> function </span><span class=\"token comment\" spellcheck=\"true\">/* comment */</span> foo <span class=\"token comment\" spellcheck=\"true\">/* another comment */</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//注意：</span>\n<span class=\"token comment\" spellcheck=\"true\">//箭头函数是个例外</span>\n<span class=\"token keyword\">const</span> bar <span class=\"token comment\" spellcheck=\"true\">/* comment */</span> <span class=\"token operator\">=</span> <span class=\"token comment\" spellcheck=\"true\">/* another comment */</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>bar<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//>> () => {}</span></code></pre>\n<h2 id=\"Object-fromEntries\"><a href=\"#Object-fromEntries\" class=\"headerlink\" title=\"Object.fromEntries\"></a>Object.fromEntries</h2><p>在 JavaScript 操作中，数据在各种数据结构之间的转换都是很容易的，比如 Map 到数组、Map 到 Set、对象到 Map 等等。</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">let</span> map <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Map</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">set</span><span class=\"token punctuation\">(</span><span class=\"token string\">'foo'</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">set</span><span class=\"token punctuation\">(</span><span class=\"token string\">'bar'</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> arr <span class=\"token operator\">=</span> Array<span class=\"token punctuation\">.</span><span class=\"token keyword\">from</span><span class=\"token punctuation\">(</span>map<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> <span class=\"token keyword\">set</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Set</span><span class=\"token punctuation\">(</span>map<span class=\"token punctuation\">.</span><span class=\"token function\">values</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">let</span> obj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> foo<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span> bar<span class=\"token punctuation\">:</span> <span class=\"token boolean\">false</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">//下一句 Object.entries() 方法返回给定对象 obj 自身可枚举属性的键值对数组,</span>\n<span class=\"token comment\" spellcheck=\"true\">//形如：[[\"foo\",true],[\"bar\",false]]</span>\n<span class=\"token keyword\">let</span> newMap <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Map</span><span class=\"token punctuation\">(</span>Object<span class=\"token punctuation\">.</span><span class=\"token function\">entries</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<p>但是如果我们需要将一个键值对列表转换为对象，就要写点费劲的代码了。</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">let</span> map <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Map</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">set</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"foo\"</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">set</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"bar\"</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> obj <span class=\"token operator\">=</span> Array<span class=\"token punctuation\">.</span><span class=\"token keyword\">from</span><span class=\"token punctuation\">(</span>map<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">reduce</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>acc<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">,</span> val<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> Object<span class=\"token punctuation\">.</span><span class=\"token function\">assign</span><span class=\"token punctuation\">(</span>acc<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span> val\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<p>该特性的目的在于为对象添加一个新的静态方法 <code>Object.fromEntries</code>，用于将符合键值对的列表（例如 Map、数组等）转换为一个对象。上一块的代码中的转换逻辑，现在我们只需要一行代码即可搞定。</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> map <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Map</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">set</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"foo\"</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">set</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"bar\"</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> obj <span class=\"token operator\">=</span> Object<span class=\"token punctuation\">.</span><span class=\"token function\">fromEntries</span><span class=\"token punctuation\">(</span>map<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<h2 id=\"更加友好的-JSON-stringify\"><a href=\"#更加友好的-JSON-stringify\" class=\"headerlink\" title=\"更加友好的 JSON.stringify\"></a>更加友好的 JSON.stringify</h2><p>ES10 之前，当你使用 <code>JSON.stringify()</code> 处理无法用 UTF-8 编码表示的字符时（U+D800 至 U+DFFF），返回的结果会是一个乱码 Unicode 字符“�”。该特性提出用<code>JSON.stringify()</code>来安全的表示这些不正常的UTF-8字符。</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">let</span> r<span class=\"token punctuation\">;</span>\nr <span class=\"token operator\">=</span> JSON<span class=\"token punctuation\">.</span><span class=\"token function\">stringify</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"❤\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//正常的UTF-8字符原样输出</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>r<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//>> \"❤\"</span>\n\nr <span class=\"token operator\">=</span> JSON<span class=\"token punctuation\">.</span><span class=\"token function\">stringify</span><span class=\"token punctuation\">(</span><span class=\"token string\">'\\u2764'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//正常的UTF-8字符编码，输出解码之后的模样</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>r<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//>> \"❤\"</span>\n\nr <span class=\"token operator\">=</span> JSON<span class=\"token punctuation\">.</span><span class=\"token function\">stringify</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"\\uDF06\\uD834\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//不正常的UTF-8字符编码，则以unicode形式输出</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>r<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//>> \"\\udf06\\ud834\"</span>\n\nr <span class=\"token operator\">=</span> JSON<span class=\"token punctuation\">.</span><span class=\"token function\">stringify</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"\\uDEAD\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//不正常的UTF-8字符编码，则以unicode形式输出</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>r<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//>> \"\\udead\"</span></code></pre>\n<h2 id=\"String-prototype-trimStart-trimEnd\"><a href=\"#String-prototype-trimStart-trimEnd\" class=\"headerlink\" title=\"String.prototype.{trimStart,trimEnd}\"></a>String.prototype.{trimStart,trimEnd}</h2><p>新增了String的<code>trimStart()</code>方法和<code>trimEnd()</code>方法，这两个方法很好理解，分别去除字符串首、尾的空白字符，就不举例占篇幅了。</p>\n<h2 id=\"Array-prototype-flat-flatMap\"><a href=\"#Array-prototype-flat-flatMap\" class=\"headerlink\" title=\"Array.prototype.{flat,flatMap}\"></a>Array.prototype.{flat,flatMap}</h2><p>这个特性新创造了两个方法，其中：</p>\n<ul>\n<li><code>Array.prototype.flat</code> 数组的所有项会以指定的维度降维（扁平化），然后组成新数组返回；</li>\n<li><code>Array.prototype.flatMap</code> 首先会执行一次<code>map()</code>方法，然后再通过类似<code>flat()</code>方法<strong>扁平化</strong>数组。它等同于执行完 <code>map()</code> 后再执行一次 <code>flat()</code> 方法，所以当你执行 <code>map()</code> 返回的结果如果是个数组，然后又要将其扁平化时，这个方法会显得方便。</li>\n</ul>\n<p>来看几个例子解释一下，首先 <code>flat()</code> 方法支持多维数组的扁平化，其中<code>Infinity</code>可以将多维数组压扁成一维数组。</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">let</span> r<span class=\"token punctuation\">;</span>\nr <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"1\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"8\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"9\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"1\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">flat</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//4维数组，默认降维1，变成3维数组</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>r<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//>> [ '1', '8', [ '9', ['1'] ] ]</span>\n\nr <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"1\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"8\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"9\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"1\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">flat</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//4维数组，降维2，变成2维数组</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>r<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//>> [ '1', '8', '9', ['1'] ]</span>\n\nr <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"1\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"8\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"9\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"1\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">flat</span><span class=\"token punctuation\">(</span><span class=\"token number\">Infinity</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//4维数组，最多变成1维数组</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>r<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//>> [ '1', '8', '9', '1' ]</span></code></pre>\n<p>接着来看看<code>flatMap()</code></p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">let</span> r<span class=\"token punctuation\">;</span>\nr <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"I love\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"coffe 1891\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>item <span class=\"token operator\">=</span><span class=\"token operator\">></span> item<span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">\" \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>r<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//>> [ [ 'I', 'love' ], [ 'coffe', '1891' ] ]</span>\n\nr <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"I love\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"coffe 1891\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">flatMap</span><span class=\"token punctuation\">(</span>item <span class=\"token operator\">=</span><span class=\"token operator\">></span> item<span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">\" \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>r<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//>>[ 'I', 'love', 'coffe', '1891' ]</span></code></pre>\n<h1 id=\"ES-2020-ES11-新特性\"><a href=\"#ES-2020-ES11-新特性\" class=\"headerlink\" title=\"ES 2020 (ES11) 新特性\"></a>ES 2020 (ES11) 新特性</h1><p>因为太“新”，现在若想使用ES11新特性，则需要安装babel插件</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\">plugins<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>\n    <span class=\"token string\">\"@babel/plugin-proposal-nullish-coalescing-operator\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token string\">\"@babel/plugin-proposal-optional-chaining\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token string\">\"@babel/plugin-proposal-class-properties\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token string\">\"@babel/plugin-proposal-private-methods\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token string\">\"@babel/plugin-syntax-bigint\"</span>\n<span class=\"token punctuation\">]</span></code></pre>\n<table>\n<thead>\n<tr>\n<th align=\"left\">新特性</th>\n<th align=\"left\">中文说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">Optional Chaining</td>\n<td align=\"left\">可选链操作符</td>\n</tr>\n<tr>\n<td align=\"left\">Nullish coalescing Operator</td>\n<td align=\"left\">空位合并操作符</td>\n</tr>\n<tr>\n<td align=\"left\"><code>String.prototype.matchAll</code></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\"><code>import()</code></td>\n<td align=\"left\">import()函数</td>\n</tr>\n<tr>\n<td align=\"left\"><code>Promise.allSettled</code></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">Bigint</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">globalThis</td>\n<td align=\"left\">全局this</td>\n</tr>\n</tbody></table>\n<h2 id=\"Optional-Chaining\"><a href=\"#Optional-Chaining\" class=\"headerlink\" title=\"Optional Chaining\"></a>Optional Chaining</h2><p><strong>可选链操作符</strong> <code>?</code> 可让我们在查询具有多个层级的对象时，不再需要进行冗余的各种前置校验。</p>\n<p>以前要读取一个对象的属性值，需要写一些防御性的前置校验代码，比如：</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">let</span> second <span class=\"token operator\">=</span> obj <span class=\"token operator\">&amp;&amp;</span> obj<span class=\"token punctuation\">.</span>first <span class=\"token operator\">&amp;&amp;</span> obj<span class=\"token punctuation\">.</span>first<span class=\"token punctuation\">.</span>second<span class=\"token punctuation\">;</span></code></pre>\n<p>在访问 obj.first.second 之前，要先确认 obj 和 obj.first 的值非 null(且不是 undefined)。有了可选链式操作符，则可以大量简化类似繁琐的前置校验操作，而且更安全：</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">let</span> second <span class=\"token operator\">=</span> obj<span class=\"token operator\">?</span><span class=\"token punctuation\">.</span>first<span class=\"token operator\">?</span><span class=\"token punctuation\">.</span>second<span class=\"token punctuation\">;</span></code></pre>\n<p>如果 <code>obj</code> 或<code>obj.first</code>是<code>null</code>/<code>undefined</code>，表达式将会直接返回<code>undefined</code>。</p>\n<h2 id=\"Nullish-coalescing-Operator-空值处理\"><a href=\"#Nullish-coalescing-Operator-空值处理\" class=\"headerlink\" title=\"Nullish coalescing Operator(空值处理)\"></a>Nullish coalescing Operator(空值处理)</h2><p>以前对于如下的情况：</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">let</span> v <span class=\"token operator\">=</span> a <span class=\"token operator\">||</span> <span class=\"token string\">\"some value\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">let</span> z <span class=\"token operator\">=</span> a <span class=\"token operator\">?</span> a <span class=\"token punctuation\">:</span> <span class=\"token string\">\"some value\"</span><span class=\"token punctuation\">;</span></code></pre>\n<p>如果 a 的值是 <code>0</code> 、 空字符串<code>''</code> 、<code>false</code>等可能有意义的值，但是在上面的表达式中被认为是假值，因此v 和 z 也会被赋值为 <code>some value</code>。也即：</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">let</span> a <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 0、''、false可能是有意义的</span>\n<span class=\"token keyword\">let</span> v <span class=\"token operator\">=</span> a <span class=\"token operator\">||</span> <span class=\"token string\">\"some value\"</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//>> some value</span></code></pre>\n<p>为解决这种问题，诞生了<code>??</code> ，如果表达式在<code>??</code>的左侧值为<code>undefined</code>或<code>null</code>，就返回右侧默认的值。</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">let</span> a <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> \n<span class=\"token keyword\">let</span> v <span class=\"token operator\">=</span> a <span class=\"token operator\">?</span><span class=\"token operator\">?</span> <span class=\"token string\">\"some value\"</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//>> 0</span>\n\n<span class=\"token keyword\">let</span> b <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span> \n<span class=\"token keyword\">let</span> z <span class=\"token operator\">=</span> b <span class=\"token operator\">?</span><span class=\"token operator\">?</span> <span class=\"token string\">\"some value\"</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>z<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//>> some value</span></code></pre>\n<h2 id=\"String-prototype-matchAll\"><a href=\"#String-prototype-matchAll\" class=\"headerlink\" title=\"String.prototype.matchAll\"></a>String.prototype.matchAll</h2><p><code>matchAll()</code> 方法返回一个包含所有匹配正则表达式及分组捕获结果的迭代器（iterator）。 在 <code>matchAll</code> 出现之前，通过在循环中调用<code>Regexp.exec</code>来获取所有匹配项信息（<code>Regexp</code>需使用<code>/g</code>标志）：</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> regexp <span class=\"token operator\">=</span> <span class=\"token function\">RegExp</span><span class=\"token punctuation\">(</span><span class=\"token string\">'foo*'</span><span class=\"token punctuation\">,</span><span class=\"token string\">'g'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> str <span class=\"token operator\">=</span> <span class=\"token string\">'coffe football, foosball'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>matches <span class=\"token operator\">=</span> regexp<span class=\"token punctuation\">.</span><span class=\"token function\">exec</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token string\">`找到 </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>matches<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">，下一轮循环从位置 </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>regexp<span class=\"token punctuation\">.</span>lastIndex<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\"> 开始`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\" spellcheck=\"true\">//>> 找到 foo，下一轮循环从位置 9 开始</span>\n  <span class=\"token comment\" spellcheck=\"true\">//>> 找到 foo，下一轮循环从位置 19 开始</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>如果使用<code>matchAll</code> ，就可以不必使用<code>while</code>循环加<code>exec</code>方式（且正则表达式需使用<code>/g</code>标志）。使用<code>matchAll</code> 会得到一个迭代器的返回值，配合 <code>for...of</code>，<code>array spread</code>，<code>Array.from()</code> 可以更方便实现功能。</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> regexp <span class=\"token operator\">=</span> <span class=\"token function\">RegExp</span><span class=\"token punctuation\">(</span><span class=\"token string\">'foo*'</span><span class=\"token punctuation\">,</span><span class=\"token string\">'g'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n<span class=\"token keyword\">const</span> str <span class=\"token operator\">=</span> <span class=\"token string\">'coffe football, foosball'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> matches <span class=\"token operator\">=</span> str<span class=\"token punctuation\">.</span><span class=\"token function\">matchAll</span><span class=\"token punctuation\">(</span>regexp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> match <span class=\"token keyword\">of</span> matches<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>match<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">//>> [ \"foo\" ]</span>\n<span class=\"token comment\" spellcheck=\"true\">//>> [ \"foo\" ]</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//注意：</span>\n<span class=\"token comment\" spellcheck=\"true\">//matches的迭代器在for..of之后已经被消耗掉了，</span>\n<span class=\"token comment\" spellcheck=\"true\">//需要再次调用matchAll创建一个新的迭代器</span>\nmatches <span class=\"token operator\">=</span> str<span class=\"token punctuation\">.</span><span class=\"token function\">matchAll</span><span class=\"token punctuation\">(</span>regexp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">let</span> arr <span class=\"token operator\">=</span> Array<span class=\"token punctuation\">.</span><span class=\"token keyword\">from</span><span class=\"token punctuation\">(</span>matches<span class=\"token punctuation\">,</span> m <span class=\"token operator\">=</span><span class=\"token operator\">></span> m<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">//>> [ \"foo\", \"foo\" ]</span></code></pre>\n<h2 id=\"import-函数\"><a href=\"#import-函数\" class=\"headerlink\" title=\"import()函数\"></a>import()函数</h2><p>这个特性为JavaScript添加了一个类函数（function-like）的<code>import()</code>功能，以便可以像函数传参那样传入参数实现<strong>动态</strong>（没错，<code>import</code>是静态引用的）引用模块（module）。下面有个单页应用简单示例，演示了用<code>import()</code>开启懒加载。</p>\n<pre class=\" language-markup\"><code class=\"language-markup\"><span class=\"token doctype\">&lt;!DOCTYPE html></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>nav</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>a</span> <span class=\"token attr-name\">href</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>books.html<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">data-entry-module</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>books<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>书籍<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>a</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>a</span> <span class=\"token attr-name\">href</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>movies.html<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">data-entry-module</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>movies<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>电影<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>a</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>a</span> <span class=\"token attr-name\">href</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>video-games.html<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">data-entry-module</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>video-games<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>电视游戏<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>a</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>nav</span><span class=\"token punctuation\">></span></span>\n\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>main</span><span class=\"token punctuation\">></span></span>内容将会加载到这里！<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>main</span><span class=\"token punctuation\">></span></span>\n\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>script</span><span class=\"token punctuation\">></span></span><span class=\"token script language-javascript\">\n  <span class=\"token keyword\">const</span> main <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">querySelector</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"main\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> link <span class=\"token keyword\">of</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">querySelectorAll</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"nav > a\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    link<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"click\"</span><span class=\"token punctuation\">,</span> e <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n      e<span class=\"token punctuation\">.</span><span class=\"token function\">preventDefault</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n      <span class=\"token keyword\">import</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token string\">`./section-modules/</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>link<span class=\"token punctuation\">.</span>dataset<span class=\"token punctuation\">.</span>entryModule<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">.js`</span></span><span class=\"token punctuation\">)</span><span class=\"token comment\" spellcheck=\"true\">//动态引用</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>module <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span><span class=\"token comment\" spellcheck=\"true\">//加载模块成功以后，该模块会当作then方法的参数</span>\n          module<span class=\"token punctuation\">.</span><span class=\"token function\">loadPageInto</span><span class=\"token punctuation\">(</span>main<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">.</span><span class=\"token keyword\">catch</span><span class=\"token punctuation\">(</span>err <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span><span class=\"token comment\" spellcheck=\"true\">//捕捉异常</span>\n          main<span class=\"token punctuation\">.</span>textContent <span class=\"token operator\">=</span> err<span class=\"token punctuation\">.</span>message<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>script</span><span class=\"token punctuation\">></span></span></code></pre>\n<p>请注意<code>import()</code>和<code>import</code>的区别：</p>\n<ul>\n<li>import() 可以用在script脚本区，不止是模块内；</li>\n<li>如果在模块内使用import()，它可以在任何地方任何级别执行，而不是被提升到顶级（优先执行）；</li>\n<li>import() 是运行时执行，也即什么时候运行到这句，就会加载参数指定的模块；参数也可以是动态可变的，不止是静态参数；</li>\n<li>import() 不建立可静态分析的依赖关系（静态分析的情况下可以做很多优化），但是，在一些比较简单的情况下，比如<code>import（“/foo.js”）</code>中，实现仍然可以执行静态分析优化。</li>\n</ul>\n<p>如果模块采用<code>default</code>的形式对外暴露接口，则可用<code>default</code>属性直接获得。</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">import</span><span class=\"token punctuation\">(</span><span class=\"token string\">'./module.js'</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>module <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>module<span class=\"token punctuation\">.</span><span class=\"token keyword\">default</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//直接通过default属性获得模块暴露的接口</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<h2 id=\"Promise-allSettled\"><a href=\"#Promise-allSettled\" class=\"headerlink\" title=\"Promise.allSettled\"></a>Promise.allSettled</h2><p>为什么要有<code>Promise.allSettled()</code>？</p>\n<p>举例说明，比如各位用户在页面上面同时填了3个独立的表单，这三个表单分三个接口提交到后端，三个接口独立，没有顺序依赖，这个时候我们需要等到请求全部完成后给与用户提示表单提交的情况。</p>\n<p>在多个<code>promise</code>同时进行时咱们很快会想到使用<code>Promise.all</code>来进行包装，但是由于<code>Promise.all</code>的一票否决的特性，三个提交中若前面任意一个提交失败，则后面的表单也不会进行提交了，这就与咱们需求不符合。</p>\n<p><code>Promise.allSettled</code>跟<code>Promise.all</code>类似，其参数接受一个<code>Promise</code>的数组，返回一个新的<code>Promise</code>，唯一的不同在于，其没有一票否决的特性，也就是说当<code>Promise</code>全部处理完成后我们可以拿到每个<code>Promise</code>的状态，而不管其是否处理成功。</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\">Promise<span class=\"token punctuation\">.</span><span class=\"token function\">allSettled</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>Promise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"coffe\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> Promise<span class=\"token punctuation\">.</span><span class=\"token function\">reject</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"1891\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>\n  arr <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//>> [ { status: \"fulfilled\", value: \"coffe\"},</span>\n                      <span class=\"token comment\" spellcheck=\"true\">//>>   { status: \"rejected\", reason: \"1891\" } ]</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<h2 id=\"Bigint\"><a href=\"#Bigint\" class=\"headerlink\" title=\"Bigint\"></a>Bigint</h2><p>JavasSript 在数学计算领域很糟糕的原因之一是它只能安全的表示<code>-(2^53-1)</code>至 <code>2^53-1</code> 范的值，即<code>Number.MIN_SAFE_INTEGER</code> 至<code>Number.MAX_SAFE_INTEGER</code>，超出这个范围的整数计算或者表示会丢失精度。</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> num <span class=\"token operator\">=</span> Number<span class=\"token punctuation\">.</span>MAX_SAFE_INTEGER<span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// >> 9007199254740991</span>\n\nnum <span class=\"token operator\">=</span> num <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// >> 9007199254740992</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 再次加 +1 后无法正常运算</span>\nnum <span class=\"token operator\">=</span> num <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// >> 9007199254740992</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 两个不同的值，却返回了true</span>\n<span class=\"token number\">9007199254740992</span> <span class=\"token operator\">===</span> <span class=\"token number\">9007199254740993</span>  <span class=\"token comment\" spellcheck=\"true\">// >> true</span></code></pre>\n<p>于是 BigInt 诞生了，<strong>它是JavaScript的第7个原始类型</strong>，可安全地进行大数整型计算。 你可以在BigInt上使用与普通数字相同的运算符，例如 +, -, /, *, %等等。</p>\n<p>创建 BigInt 类型的值也非常简单，只需要在数字后面加上 <code>n</code> 即可。例如，123 变为 123n。也可以使用全局方法 BigInt(value) 转化，入参 value 为数字或数字字符串。</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> aNumber <span class=\"token operator\">=</span> <span class=\"token number\">1891</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> aBigInt <span class=\"token operator\">=</span> <span class=\"token function\">BigInt</span><span class=\"token punctuation\">(</span>aNumber<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\naBigInt <span class=\"token operator\">===</span> 1891n <span class=\"token comment\" spellcheck=\"true\">// true</span>\n<span class=\"token keyword\">typeof</span> aBigInt <span class=\"token operator\">===</span> <span class=\"token string\">'bigint'</span> <span class=\"token comment\" spellcheck=\"true\">// true</span>\n<span class=\"token keyword\">typeof</span> <span class=\"token number\">1891</span> <span class=\"token comment\" spellcheck=\"true\">// \"number\"</span>\n<span class=\"token keyword\">typeof</span> 1891n <span class=\"token comment\" spellcheck=\"true\">// \"bigint\"</span></code></pre>\n<p>只要在数字末尾加上 n，就可以正确计算大数：</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\">1234567890123456789n <span class=\"token operator\">*</span> 123n<span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// -> 151851850485185185047n</span></code></pre>\n<p>最后要注意，不能将 BigInt与Number混合使用。比较Number和 BigInt是可以的，但是不能把它们相加。</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\">1n <span class=\"token operator\">&lt;</span> <span class=\"token number\">2</span> <span class=\"token comment\" spellcheck=\"true\">// true</span>\n\n1n <span class=\"token operator\">+</span> <span class=\"token number\">2</span> <span class=\"token comment\" spellcheck=\"true\">// Uncaught TypeError: Cannot mix BigInt and other types, use explicit conversions</span></code></pre>\n<h2 id=\"globalThis\"><a href=\"#globalThis\" class=\"headerlink\" title=\"globalThis\"></a>globalThis</h2><p>globalThis 是一个全新的标准方法用来获取全局 this 。之前开发者会通过如下的一些方法获取：</p>\n<ul>\n<li>全局变量 window：是一个经典的获取全局对象的方法。但是它在 Node.js 和 Web Workers 中并不能使用</li>\n<li>全局变量 self：通常只在 Web Workers 和浏览器中生效。但是它不支持 Node.js。一些人会通过判断 self 是否存在识别代码是否运行在 Web Workers 和浏览器中</li>\n<li>全局变量 global：只在 Node.js 中生效</li>\n</ul>\n<p>过去获取全局对象，可通过一个全局函数：</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\" spellcheck=\"true\">// ES10之前的解决方案</span>\n<span class=\"token keyword\">const</span> getGlobal <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> self <span class=\"token operator\">!==</span> <span class=\"token string\">'undefined'</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> self\n  <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> window <span class=\"token operator\">!==</span> <span class=\"token string\">'undefined'</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> window\n  <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> global <span class=\"token operator\">!==</span> <span class=\"token string\">'undefined'</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> global\n  <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Error</span><span class=\"token punctuation\">(</span><span class=\"token string\">'unable to locate global object'</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// ES10内置</span>\nglobalThis<span class=\"token punctuation\">.</span><span class=\"token function\">Array</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// [0,1,2]</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 定义一个全局对象v = { value:true } ,ES10用如下方式定义</span>\nglobalThis<span class=\"token punctuation\">.</span>v <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> value<span class=\"token punctuation\">:</span><span class=\"token boolean\">true</span> <span class=\"token punctuation\">}</span></code></pre>\n<p>而 <strong>globalThis 目的就是提供一种标准化方式访问全局对象</strong>，有了 globalThis 后，你可以在任意上下文，任意时刻都能获取到全局对象。如果您在浏览器上，globalThis将为window，如果您在Node上，globalThis则将为global。因此，不再需要考虑不同的环境问题。</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\" spellcheck=\"true\">// worker</span>\nglobalThis <span class=\"token operator\">===</span> self\n<span class=\"token comment\" spellcheck=\"true\">// node</span>\nglobalThis <span class=\"token operator\">===</span> global\n<span class=\"token comment\" spellcheck=\"true\">// browser</span>\nglobalThis <span class=\"token operator\">===</span> window</code></pre>\n<h1 id=\"ES-2021-ES12-等2021年发布\"><a href=\"#ES-2021-ES12-等2021年发布\" class=\"headerlink\" title=\"ES 2021 (ES12) 等2021年发布\"></a>ES 2021 (ES12) 等2021年发布</h1><table>\n<thead>\n<tr>\n<th align=\"left\">新特性</th>\n<th align=\"left\">中文说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">String.prototype.replaceAll</td>\n<td align=\"left\">替换所有符合的字符串</td>\n</tr>\n<tr>\n<td align=\"left\">Promise.any</td>\n<td align=\"left\">返回Promise列表中第一个resolve的结果状态</td>\n</tr>\n<tr>\n<td align=\"left\">WeakRefs</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">逻辑运算符和赋值表达式</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">数字分隔符</td>\n<td align=\"left\"></td>\n</tr>\n</tbody></table>\n<h2 id=\"replaceAll\"><a href=\"#replaceAll\" class=\"headerlink\" title=\"replaceAll\"></a>replaceAll</h2><p>看到replaceAll这个词，相比很容易联想到replace。在JavaScript中，replace方法只能是替换字符串中匹配到的第一个实例字符，而不能进行全局多项匹配替换，唯一的办法是通过正则表达式进行相关规则匹配替换，而replaceAll则是返回一个全新的字符串，所有符合匹配规则的字符都将被替换掉，替换规则可以是字符串或者正则表达式。</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">let</span> string <span class=\"token operator\">=</span> <span class=\"token string\">'I like javaScript,I like css'</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//使用replace</span>\n<span class=\"token keyword\">let</span> replaceStr <span class=\"token operator\">=</span> string<span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span><span class=\"token string\">'like'</span><span class=\"token punctuation\">,</span><span class=\"token string\">'love'</span><span class=\"token punctuation\">)</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>replaceStr<span class=\"token punctuation\">)</span>  <span class=\"token comment\" spellcheck=\"true\">// 'I love javaScript,I like css'</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//replace使用正则匹配所有</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>string<span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span><span class=\"token regex\">/like/g</span><span class=\"token punctuation\">,</span><span class=\"token string\">'love'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 'I love javaScript,I love css'</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//使用replaceAll</span>\n<span class=\"token keyword\">let</span> replaceAllStr <span class=\"token operator\">=</span> string<span class=\"token punctuation\">.</span><span class=\"token function\">replaceAll</span><span class=\"token punctuation\">(</span><span class=\"token string\">'like'</span><span class=\"token punctuation\">,</span><span class=\"token string\">'love'</span><span class=\"token punctuation\">)</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>replaceAllStr<span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 'I love javaScript,I love css'</span>\n</code></pre>\n<h2 id=\"Promise-any\"><a href=\"#Promise-any\" class=\"headerlink\" title=\"Promise.any\"></a>Promise.any</h2><p>当Promise列表中的任意一个promise成功resolve则返回第一个resolve的结果状态。</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\">\nPromise<span class=\"token punctuation\">.</span><span class=\"token function\">any</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>\n  <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">,</span> reject<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span>reject<span class=\"token punctuation\">,</span> <span class=\"token number\">500</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'哎呀，我被拒绝了'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">,</span> reject<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">,</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'哎呀，她接受我了'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">,</span> reject<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">,</span> <span class=\"token number\">2000</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'哎呀，她也接受我了'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>value <span class=\"token operator\">=</span><span class=\"token operator\">></span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token string\">`输出结果: </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>value<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">.</span><span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">err</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//输出结果:哎呀，她接受我了</span>\n</code></pre>\n<p>如果所有的promise均reject，则抛出异常表示所有请求失败。</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\">Promise<span class=\"token punctuation\">.</span><span class=\"token function\">any</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>\n  Promise<span class=\"token punctuation\">.</span><span class=\"token function\">reject</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Error 1'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  Promise<span class=\"token punctuation\">.</span><span class=\"token function\">reject</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Error 2'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  Promise<span class=\"token punctuation\">.</span><span class=\"token function\">reject</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Error 3'</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>value <span class=\"token operator\">=</span><span class=\"token operator\">></span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token string\">`请求结果: </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>value<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">.</span><span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">err</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//输出</span>\nAggregateError<span class=\"token punctuation\">:</span> All promises were rejected\n</code></pre>\n<h2 id=\"WeakRefs\"><a href=\"#WeakRefs\" class=\"headerlink\" title=\"WeakRefs\"></a>WeakRefs</h2><p>使用WeakRefs的Class类创建对对象的弱引用(对对象的弱引用是指当该对象应该被GC回收时不会阻止GC的回收行为)</p>\n<p>当我们通过（const、let、var）创建一个变量时，垃圾收集器GC将永远不会从内存中删除该变量，只要它的引用仍然存在可访问。WeakRef对象包含对对象的弱引用。对对象的弱引用是不会阻止垃圾收集器GC恢复该对象的引用，则GC可以在任何时候删除它。</p>\n<p>WeakRefs在很多情况下都很有用，比如使用Map对象来实现具有很多需要大量内存的键值缓存，在这种情况下最方便的就是尽快释放键值对占用的内存。</p>\n<p>目前，可以通过WeakMap()或者WeakSet()来使用WeakRefs。</p>\n<h2 id=\"数字分隔符\"><a href=\"#数字分隔符\" class=\"headerlink\" title=\"数字分隔符\"></a>数字分隔符</h2><p>数字分隔符，可以在数字之间创建可视化分隔符，通过_下划线来分割数字，使数字更具可读性。</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> money <span class=\"token operator\">=</span> 1_000_000_000\n<span class=\"token comment\" spellcheck=\"true\">//等价于</span>\n<span class=\"token keyword\">const</span> money <span class=\"token operator\">=</span> <span class=\"token number\">1000000000</span>\n\n<span class=\"token keyword\">const</span> totalFee <span class=\"token operator\">=</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">.</span>12_34\n<span class=\"token comment\" spellcheck=\"true\">//等价于</span>\n<span class=\"token keyword\">const</span> totalFee <span class=\"token operator\">=</span> <span class=\"token number\">1000.1234</span>\n</code></pre>\n<p>该新特性同样支持在八进制数中使用</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\">\n<span class=\"token keyword\">const</span> number <span class=\"token operator\">=</span> 0o123_456\n<span class=\"token comment\" spellcheck=\"true\">//等价于</span>\n<span class=\"token keyword\">const</span> number <span class=\"token operator\">=</span> <span class=\"token number\">0o123456</span>\n\n</code></pre>\n<h1 id=\"本篇结语\"><a href=\"#本篇结语\" class=\"headerlink\" title=\"本篇结语\"></a>本篇结语</h1><p>很显然ECMAScript接下来会持续不断地更新，按TC39的计划是每年都会发一个新版本。虽然节奏很快，但是我们完全没必要担心跟不上节奏。除了ES6这个史无前例的版本带来了超大量的新特性外，之后每年发的版本都仅仅带有少量的增量更新，你只需要花45分钟就能搞明白这一年更新的特性。保持一颗好奇的心，你会不断进步，变得更强！</p>\n","more":"<h1 id=\"本篇导读\"><a href=\"#本篇导读\" class=\"headerlink\" title=\"本篇导读\"></a>本篇导读</h1><p>JavaScript是一门支持多种编程范式的语言，灵活性很高，功能也十分强大。因为灵活性，JavaScript有很多种使用方式，被应用到浏览器、客户端软件、嵌入式硬件等多种场景下。在面向对象（OOP）这种编程范式大行其道的今天，这种变化多端的语言因其编程范式多样，每种场景下使用形态各异，使用者之间思维差别大，见解又各不相同，因此也就被误解得极深。正是由于这种相对的复杂性，前端工程师们有必要更系统、深入地对这门语言进行学习和研究。</p>\n<p>现在，JavaScript在TC39（TC39由包括浏览器厂商在内的各方组成，他们开会推动JavaScript特性的提案沿着一条严格的流程推进）的推动下正加速地迭代更新，每年都会有一些新特性出现。前端工程师们有必要了解一下这些新特性，以便更好地在一线互联网企业发挥出自己的能量。</p>\n<h1 id=\"JavaScript-和-ECMAScript-6-的关系\"><a href=\"#JavaScript-和-ECMAScript-6-的关系\" class=\"headerlink\" title=\"JavaScript 和 ECMAScript 6 的关系\"></a>JavaScript 和 ECMAScript 6 的关系</h1><p>JavaScript起源于1995年Netscape为自家游览器创造的脚本语言LiveScript。后来因为Sun公司的Java语言兴起，Netscape为了沾热度将LiveScript改名为JavaScript，但其实Java和JavaScript没有一点关系。</p>\n<p>1997年Netscape将JavaScript规范提交到 Ecma International（<a href=\"https://www.ecma-international.org/\">www.ecma-international.org</a>，简称EI），诞生了ECMAScript （简称“ES”）第1个版本。</p>\n<p>随后在1999年诞生了十分稳定的ES 3，也就是2009年12月之前前端工程师们最广泛使用的版本。</p>\n<p>在2009年12月诞生了ES 5。你可能会问ES 4 呢，抱歉，版本4因为太激进，EI委员会成员之间的意见不一，最后胎死腹中，改由更加平滑温和的版本5继承版本4的一些新特性和功能。</p>\n<p>EI于2015年6月发布了ES 6，也就是我们今天广泛使用的版本。这之后每年6月发布一个极小更新的ES版本。</p>\n<p>综上可见，<strong>JavaScript是ECMAScript规范的一种实现</strong>。为方便读者理解交流，而且由于ECAMScript 6 之后变化并不是特别大，如果没有特别说明，本书后面讲述的JavaScript对应的规范默认为 ES 6。</p>\n<p>本文下面会介绍ES 7~12的新特性。</p>\n<h1 id=\"ES-7-新特性\"><a href=\"#ES-7-新特性\" class=\"headerlink\" title=\"ES 7 新特性\"></a>ES 7 新特性</h1><table>\n<thead>\n<tr>\n<th align=\"left\">新特性</th>\n<th align=\"left\">中文说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>Array.prototype.includes</code></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">Exponentiation operator</td>\n<td align=\"left\">指数函数的中缀表示法</td>\n</tr>\n</tbody></table>\n<h2 id=\"Array-prototype-includes\"><a href=\"#Array-prototype-includes\" class=\"headerlink\" title=\"Array.prototype.includes\"></a>Array.prototype.includes</h2><p>includes是一个Array上很有用的方法，用于快速查找数组中是否包含某个元素，包括NaN（所以和indexOf不一样)。</p>\n<pre><code class=\"javascript\">(() =&gt; &#123;\n  let arr = [1, 2, 3, NaN];\n\n  if (arr.includes(2)) &#123;\n    //查找2是否存在于arr数组中\n    console.log(&quot;找到了!&quot;); //&gt;&gt; 找到了！\n  &#125;\n  if (!arr.includes(2, 3)) &#123;\n    //第二个参数3表示数组下标为3的项，也即第4项开始查找\n    console.warn(&quot;不存在!&quot;); //&gt;&gt; 不存在！\n  &#125;\n\n  //下面两句说明incluedes和indexOf的区别\n  console.log(arr.includes(NaN)); //true\n  console.log(arr.indexOf(NaN) != -1); //false\n&#125;)();</code></pre>\n<h2 id=\"指数函数的中缀表示法\"><a href=\"#指数函数的中缀表示法\" class=\"headerlink\" title=\"指数函数的中缀表示法\"></a>指数函数的中缀表示法</h2><p>这个是与<code>Math.pow</code>有关的特性，还记得<code>i++</code>,<code>x += x</code>这种写法吗，指数函数的中缀表示法与之类似。与python语言一样，JavaScript也采用两个星符号<code>**</code>来表示<code>Math.pow</code>。好处有两个：<br>a. 中缀表示法比函数表示法更简洁，这使它更可取。<br>b. 方便数学、物理、机器人学等领域的计算。</p>\n<p>用法示例如下：</p>\n<pre><code class=\"javascript\">//用法一：x ** y\n\nlet squared = 2 ** 2;//等同于: 2 * 2\nlet cubed = 2 ** 3;//等同于: 2 * 2 * 2</code></pre>\n<pre><code class=\"javascript\">//用法二：x **= y\n\nlet a = 2;\na **= 2;//等同于: a = a * a;\n\nlet b = 3;\nb **= 3;//等同于: b = b * b * b;</code></pre>\n<h1 id=\"ES-8-新特性\"><a href=\"#ES-8-新特性\" class=\"headerlink\" title=\"ES 8 新特性\"></a>ES 8 新特性</h1><table>\n<thead>\n<tr>\n<th align=\"left\">新特性</th>\n<th align=\"left\">中文说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>Object.values</code> / <code>Object.entries</code></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">String padding</td>\n<td align=\"left\">字符串追加</td>\n</tr>\n<tr>\n<td align=\"left\"><code>Object.getOwnPropertyDescriptors</code></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">Trailing commas in function parameter lists and calls</td>\n<td align=\"left\">结尾允许逗号</td>\n</tr>\n<tr>\n<td align=\"left\">Async functions</td>\n<td align=\"left\">异步函数</td>\n</tr>\n<tr>\n<td align=\"left\">Shared memory and atomics</td>\n<td align=\"left\">共享内存和 Atomics 对象</td>\n</tr>\n</tbody></table>\n<h2 id=\"Object-values-Object-entries\"><a href=\"#Object-values-Object-entries\" class=\"headerlink\" title=\"Object.values() / Object.entries\"></a>Object.values() / Object.entries</h2><p>定义是<code>Object.values(obj)</code>，<code>obj</code> 参数是对目标对象的操作，它可以是一个对象或者数组。</p>\n<pre><code class=\"javascript\">const obj = &#123; x: &#39;xxx&#39;, y: 1 &#125;;\nObject.values(obj); // [&#39;xxx&#39;, 1]\n\nconst obj = [&#39;e&#39;, &#39;s&#39;, &#39;8&#39;]; // 等同于 &#123; 0: &#39;e&#39;, 1: &#39;s&#39;, 2: &#39;8&#39; &#125;;\nObject.values(obj); // [&#39;e&#39;, &#39;s&#39;, &#39;8&#39;]\n\n//当把数字对象的当键的时候，返回的数组以键的值升序排序\nconst obj = &#123; 10: &#39;xxx&#39;, 1: &#39;yyy&#39;, 3: &#39;zzz&#39; &#125;;\nObject.values(obj); // [&#39;yyy&#39;, &#39;zzz&#39;, &#39;xxx&#39;]\nObject.values(&#39;es8&#39;); // [&#39;e&#39;, &#39;s&#39;, &#39;8&#39;]</code></pre>\n<p><code>Object.entries</code>方法返回一个给定对象可枚举属性值的数组[key, value]，与<code>Object.values</code>类似。</p>\n<pre><code class=\"javascript\">const obj = &#123; x: &#39;xxx&#39;, y: 1 &#125;;\nObject.entries(obj); // [[&#39;x&#39;, &#39;xxx&#39;], [&#39;y&#39;, 1]]\n\nconst obj = [&#39;e&#39;, &#39;s&#39;, &#39;8&#39;];\nObject.entries(obj); // [[&#39;0&#39;, &#39;e&#39;], [&#39;1&#39;, &#39;s&#39;], [&#39;2&#39;, &#39;8&#39;]]\n\nconst obj = &#123; 10: &#39;xxx&#39;, 1: &#39;yyy&#39;, 3: &#39;zzz&#39; &#125;;\nObject.entries(obj); // [[&#39;1&#39;, &#39;yyy&#39;], [&#39;3&#39;, &#39;zzz&#39;], [&#39;10&#39;, &#39;xxx&#39;]]\nObject.entries(&#39;es8&#39;); // [[&#39;0&#39;, &#39;e&#39;], [&#39;1&#39;, &#39;s&#39;], [&#39;2&#39;, &#39;8&#39;]]</code></pre>\n<h2 id=\"字符串追加\"><a href=\"#字符串追加\" class=\"headerlink\" title=\"字符串追加\"></a>字符串追加</h2><p>在 ES 8 中String新增了两个实例函数<code>String.prototype.padStart</code>和<code>String.prototype.padEnd</code>，允许将空字符串或其他字符串添加到原始字符串的开头或结尾。</p>\n<ul>\n<li><p><code>String.padStart(targetLength,[padString])</code><br>_targetLength：_当前字符串需要填充到的目标长度。如果这个数值小于当前字符串的长度，则返回当前字符串本身。</p>\n<p>_padString：_(可选)填充字符串。如果字符串太长，使填充后的字符串长度超过了目标长度，则只保留最左侧的部分，其他部分会被截断，此参数的缺省值为空格。</p>\n</li>\n<li><p><code>String.padEnd(targetLength,padString])</code> 参数释义同上。</p>\n</li>\n</ul>\n<pre><code class=\"javascript\">&#39;es8&#39;.padStart(2);          // &#39;es8&#39;\n&#39;es8&#39;.padStart(5);          // &#39;  es8&#39;\n&#39;es8&#39;.padStart(6, &#39;1891&#39;);  // &#39;189es8&#39;\n&#39;es8&#39;.padStart(14, &#39;coffe&#39;);  // &#39;coffecoffeces8&#39;\n&#39;es8&#39;.padStart(7, &#39;0&#39;);     // &#39;0000es8&#39;\n\n&#39;es8&#39;.padEnd(2);            // &#39;es8&#39;\n&#39;es8&#39;.padEnd(5);            // &#39;es8  &#39;\n&#39;es8&#39;.padEnd(6, &#39;1891&#39;);    // &#39;es8189&#39;\n&#39;es8&#39;.padEnd(14, &#39;coffe&#39;);    // &#39;es8coffecoffec&#39;\n&#39;es8&#39;.padEnd(7, &#39;9&#39;);       // &#39;es89999&#39;</code></pre>\n<h2 id=\"Object-getOwnPropertyDescriptors\"><a href=\"#Object-getOwnPropertyDescriptors\" class=\"headerlink\" title=\"Object.getOwnPropertyDescriptors\"></a>Object.getOwnPropertyDescriptors</h2><p><code>getOwnPropertyDescriptors</code>方法返回一指定对象自己所有的属性内容，并且属性内容只是自身直接定义的，而不是从object的原型继承而来的。<br>定义是：<code>Object.getOwnPropertyDescriptors(obj)</code>，<code>obj</code> 是指目标对象，这个方法返回的值可能是 configurable、enumerable、writable、get、set 和 value。</p>\n<pre><code class=\"javascript\">const obj = &#123; \n  get es7() &#123; return 7; &#125;,\n  get es8() &#123; return 8; &#125;\n&#125;;\nObject.getOwnPropertyDescriptors(obj);\n// &#123;\n//   es7: &#123;\n//     configurable: true,\n//     enumerable: true,\n//     get: function es7()&#123;&#125;, //the getter function\n//     set: undefined\n//   &#125;,\n//   es8: &#123;\n//     configurable: true,\n//     enumerable: true,\n//     get: function es8()&#123;&#125;, //the getter function\n//     set: undefined\n//   &#125;\n// &#125;</code></pre>\n<h2 id=\"结尾允许逗号\"><a href=\"#结尾允许逗号\" class=\"headerlink\" title=\"结尾允许逗号\"></a>结尾允许逗号</h2><p>用法示例如下：</p>\n<pre><code class=\"javascript\">//定义参数时\nfunction foo(\n    param1,\n    param2,//结尾逗号\n) &#123;&#125;\n//传参时\nfoo(\n    &#39;coffe&#39;,\n    &#39;1891&#39;,//结尾逗号\n);\n//对象中\nlet obj = &#123;\n    &quot;a&quot;: &#39;coffe&#39;,\n    &quot;b&quot;: &#39;1891&#39;,//结尾逗号\n&#125;;\n//数组中\nlet arr = [\n    &#39;coffe&#39;,\n    &#39;1891&#39;,//结尾逗号\n];</code></pre>\n<p>这样改动的好处有两点：</p>\n<ul>\n<li>重新排列项目更简单，因为如果最后一项更改其位置，则不必添加和删除逗号。</li>\n<li>可以帮助git等版本控制系统跟踪实际发生的变化，在查看代码改动、合并代码的时候，少报一些无用信息。例如，从</li>\n</ul>\n<pre><code class=\"javascript\">[\n    &#39;coffe&#39;\n]</code></pre>\n<p>变更为</p>\n<pre><code class=\"javascript\">[\n    &#39;coffe&#39;,\n    &#39;1891&#39;\n]</code></pre>\n<p>在git里它会报同时修改了两行代码，采用结尾逗号<code>&#39;coffe&#39;,</code>之后，就只会报仅有一行代码<code>&#39;1891&#39;,</code>的变动，这样做代码review（代码复查）的时候就更省眼力了。</p>\n<h2 id=\"异步函数\"><a href=\"#异步函数\" class=\"headerlink\" title=\"异步函数\"></a>异步函数</h2><p>Async Functions也就是我们常说的Async/Await，相信大家对于这个概念都已经不陌生了。Async/Await是一种用于处理JS异步操作的语法糖，可以帮助我们摆脱<strong>回调地狱</strong>（callback hell），编写更加优雅的代码。</p>\n<p>通俗的理解，<code>async</code>关键字的作用是告诉编译器对于标定的函数要区别对待。当编译器遇到标定的函数中的<code>await</code>关键字时，要暂时停止运行，等到<code>await</code>标定的函数处理完毕后，再进行相应操作。如果该函数fulfiled了，则返回值是fulfillment value，否则得到的就是reject value。</p>\n<p>下面通过拿普通的promise写法来对比，就很好理解了：</p>\n<pre><code class=\"javascript\">async function asyncFunc() &#123;\n    const result = await otherAsyncFunc();// otherAsyncFunc()返回一个Promise对象\n    console.log(result);\n&#125;\n\n// 等同于:\nfunction asyncFunc() &#123;\n    return otherAsyncFunc()// otherAsyncFunc()返回一个Promise对象\n    .then(result =&gt; &#123;\n        console.log(result);\n    &#125;);\n&#125;</code></pre>\n<p>按顺序处理多个异步函数的时候优势更为明显：</p>\n<pre><code class=\"javascript\">async function asyncFunc() &#123;\n    const result1 = await otherAsyncFunc1();// otherAsyncFunc1()返回一个Promise对象\n    console.log(result1);\n    const result2 = await otherAsyncFunc2();// otherAsyncFunc2()返回一个Promise对象\n    console.log(result2);\n&#125;\n\n// 等同于:\nfunction asyncFunc() &#123;\n    return otherAsyncFunc1()// otherAsyncFunc1()返回一个Promise对象\n    .then(result1 =&gt; &#123;\n        console.log(result1);\n        return otherAsyncFunc2();// otherAsyncFunc2()返回一个Promise对象\n    &#125;)\n    .then(result2 =&gt; &#123;\n        console.log(result2);\n    &#125;);\n&#125;</code></pre>\n<p>并行处理多个异步函数：</p>\n<pre><code class=\"javascript\">async function asyncFunc() &#123;\n    const [result1, result2] = await Promise.all([\n        otherAsyncFunc1(),// otherAsyncFunc1()返回一个Promise对象\n        otherAsyncFunc2() // otherAsyncFunc2()返回一个Promise对象\n    ]);\n    console.log(result1, result2);\n&#125;\n\n// 等同于:\nfunction asyncFunc() &#123;\n    return Promise.all([\n        otherAsyncFunc1(),// otherAsyncFunc1()返回一个Promise对象\n        otherAsyncFunc2() // otherAsyncFunc2()返回一个Promise对象\n    ])\n    .then([result1, result2] =&gt; &#123;\n        console.log(result1, result2);\n    &#125;);\n&#125;</code></pre>\n<p>处理错误：</p>\n<pre><code class=\"javascript\">async function asyncFunc() &#123;\n    try &#123;\n        await otherAsyncFunc();// otherAsyncFunc()返回一个Promise对象\n    &#125; catch (err) &#123;\n        console.error(err);\n    &#125;\n&#125;\n\n// 等同于:\nfunction asyncFunc() &#123;\n    return otherAsyncFunc()// otherAsyncFunc()返回一个Promise对象\n    .catch(err =&gt; &#123;\n        console.error(err);\n    &#125;);\n&#125;</code></pre>\n<p>Async Functions若是要展开讲可以占很大的篇幅，鉴于本篇是一篇介绍性文章，故此不再进行深入论述。</p>\n<h2 id=\"共享内存和-Atomics-对象\"><a href=\"#共享内存和-Atomics-对象\" class=\"headerlink\" title=\"共享内存和 Atomics 对象\"></a>共享内存和 Atomics 对象</h2><p>SharedArrayBuffer 对象用来表示一个通用的，固定长度的原始二进制数据缓冲区，类似于 ArrayBuffer对象（如果之前你没有接触过ArrayBuffer相关知识的话，建议从<a href=\"https://hacks.mozilla.org/2017/06/a-cartoon-intro-to-arraybuffers-and-sharedarraybuffers/\">内存管理速成教程系列漫画解说入门</a>） ，它们都可以用来在共享内存（shared memory）上创建视图。与 ArrayBuffer 不同的是，SharedArrayBuffer 不能被分离。</p>\n<pre><code class=\"javascript\">/**\n * \n * @param &#123;*&#125; length 所创建的数组缓冲区的大小，以字节(byte)为单位。  \n * @returns &#123;SharedArrayBuffer&#125; 一个大小指定的新 SharedArrayBuffer 对象。其内容被初始化为 0。\n */\nnew SharedArrayBuffer(length)\n</code></pre>\n<p>Atomics 对象提供了一组静态方法用来对 SharedArrayBuffer 对象进行原子操作，这些原子操作属于 Atomics 模块。Atomics 不是构造函数，因此不能使用 new 操作符调用，也不能将其当作函数直接调用。Atomics 的所有属性和方法都是静态的（与 Math 对象一样）。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">方法名</th>\n<th align=\"left\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">Atomics.add()</td>\n<td align=\"left\">将指定位置上的数组元素与给定的值相加，并返回相加前该元素的值。</td>\n</tr>\n<tr>\n<td align=\"left\">Atomics.and()</td>\n<td align=\"left\">将指定位置上的数组元素与给定的值相与，并返回与操作前该元素的值。</td>\n</tr>\n<tr>\n<td align=\"left\">Atomics.compareExchange()</td>\n<td align=\"left\">如果数组中指定的元素与给定的值相等，则将其更新为新的值，并返回该元素原先的值。</td>\n</tr>\n<tr>\n<td align=\"left\">Atomics.exchange()</td>\n<td align=\"left\">将数组中指定的元素更新为给定的值，并返回该元素更新前的值。</td>\n</tr>\n<tr>\n<td align=\"left\">Atomics.load()</td>\n<td align=\"left\">返回数组中指定元素的值。</td>\n</tr>\n<tr>\n<td align=\"left\">Atomics.or()</td>\n<td align=\"left\">将指定位置上的数组元素与给定的值相或，并返回或操作前该元素的值。</td>\n</tr>\n<tr>\n<td align=\"left\">Atomics.store()</td>\n<td align=\"left\">将数组中指定的元素设置为给定的值，并返回该值。</td>\n</tr>\n<tr>\n<td align=\"left\">Atomics.sub()</td>\n<td align=\"left\">将指定位置上的数组元素与给定的值相减，并返回相减前该元素的值。</td>\n</tr>\n<tr>\n<td align=\"left\">Atomics.xor()</td>\n<td align=\"left\">将指定位置上的数组元素与给定的值相异或，并返回异或操作前该元素的值。</td>\n</tr>\n<tr>\n<td align=\"left\">Atomics.wait()</td>\n<td align=\"left\">检测数组中某个指定位置上的值是否仍然是给定值，是则保持挂起直到被唤醒或超时。返回值为 “ok”、”not-equal” 或 “time-out”。调用时，如果当前线程不允许阻塞，则会抛出异常（大多数浏览器都不允许在主线程中调用 wait()）。</td>\n</tr>\n<tr>\n<td align=\"left\">Atomics.wake()</td>\n<td align=\"left\">唤醒等待队列中正在数组指定位置的元素上等待的线程。返回值为成功唤醒的线程数量。</td>\n</tr>\n<tr>\n<td align=\"left\">Atomics.isLockFree(size)</td>\n<td align=\"left\">可以用来检测当前系统是否支持硬件级的原子操作。对于指定大小的数组，如果当前系统支持硬件级的原子操作，则返回 true；否则就意味着对于该数组，Atomics 对象中的各原子操作都只能用锁来实现。此静态方法面向的是技术专家。</td>\n</tr>\n</tbody></table>\n<h1 id=\"ES-9-新特性\"><a href=\"#ES-9-新特性\" class=\"headerlink\" title=\"ES 9 新特性\"></a>ES 9 新特性</h1><table>\n<thead>\n<tr>\n<th align=\"left\">新特性</th>\n<th align=\"left\">中文说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">Asynchronous Iteration</td>\n<td align=\"left\">异步迭代器</td>\n</tr>\n<tr>\n<td align=\"left\"><code>Promise.prototype.finally</code></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">Lifting template literal restriction</td>\n<td align=\"left\">重新修订了字面量的转义</td>\n</tr>\n<tr>\n<td align=\"left\">Rest/Spread Properties</td>\n<td align=\"left\">Rest/Spread 属性</td>\n</tr>\n<tr>\n<td align=\"left\"><code>s</code> (dotAll) flag for regular expressions</td>\n<td align=\"left\">正则表达式dotAll模式</td>\n</tr>\n<tr>\n<td align=\"left\">RegExp named capture groups</td>\n<td align=\"left\">正则表达式命名捕获组</td>\n</tr>\n<tr>\n<td align=\"left\">RegExp Lookbehind Assertions</td>\n<td align=\"left\">正则表达式反向断言</td>\n</tr>\n<tr>\n<td align=\"left\">RegExp Unicode Property Escapes</td>\n<td align=\"left\">正则表达式 Unicode 转义</td>\n</tr>\n</tbody></table>\n<h2 id=\"异步迭代器\"><a href=\"#异步迭代器\" class=\"headerlink\" title=\"异步迭代器\"></a>异步迭代器</h2><p>在<code>async</code>/<code>await</code>的某些时刻，你可能尝试在同步循环中调用异步函数。例如：</p>\n<pre><code class=\"javascript\">async function func(array) &#123;\n  for (let i of array) &#123;\n    await someFunc(i);\n  &#125;\n&#125;</code></pre>\n<p>这段代码不会达到预期目的，下面这段同样也不会：</p>\n<pre><code class=\"javascript\">async function func(array) &#123;\n  array.forEach(async i =&gt; &#123;\n    await someFunc(i);\n  &#125;);\n&#125;</code></pre>\n<p>上面这段代码中，循环本身依旧保持同步，并在内部异步函数之前全部调用完成。</p>\n<p>引入异步迭代器后，就像常规迭代器，除了<code>next()</code>方法返回一个Promise。因此<code>await</code>可以和<code>for...of</code>循环一起使用，以串行的方式运行异步操作。</p>\n<pre><code class=\"javascript\">async function func(array) &#123;\n  for await (let i of array) &#123;//异步迭代\n    someFunc(i);\n  &#125;\n&#125;</code></pre>\n<h2 id=\"Promise-prototype-finally\"><a href=\"#Promise-prototype-finally\" class=\"headerlink\" title=\"Promise.prototype.finally\"></a>Promise.prototype.finally</h2><p>一个Promise调用链要么成功到达最后一个<code>.then()</code>，要么失败触发<code>.catch()</code>。在某些情况下，你想要在无论Promise运行成功还是失败，运行相同的代码，例如清除数组、删除对话、关闭数据库连接等，<code>.finally()</code>允许实现这样的目的。</p>\n<pre><code class=\"javascript\">function func() &#123;\n  promiseFunc() //返回一个Promise对象\n    .then(() =&gt; &#123;&#125;)\n    .then(() =&gt; &#123;&#125;)\n    .catch(err =&gt; &#123;\n      console.log(err);\n    &#125;)\n    .finally(() =&gt; &#123;\n      //无论promiseFunc()运行成功还是失败，这里的代码会被调用到\n    &#125;);\n&#125;</code></pre>\n<h2 id=\"重新修订了字面量的转义\"><a href=\"#重新修订了字面量的转义\" class=\"headerlink\" title=\"重新修订了字面量的转义\"></a>重新修订了字面量的转义</h2><p>ES9 之前，<code>\\u</code>表示 unicode 转义，<code>\\x</code>表示十六进制转义，<code>\\</code>后跟一个数字表示八进制转义，这使得创建特定的字符串变得不可能，例如Windows文件路径<code>C:\\uuu\\xxx\\111</code>。</p>\n<p>要取消转义序列的语法限制，可在模板字符串之前使用标记函数<code>String.raw</code>。</p>\n<pre><code class=\"javascript\">let s = `\\u&#123;54&#125;` //会转义成unicode &quot;T&quot;\nconsole.log(s);//&gt;&gt; T\n\nlet str = String.raw`\\u&#123;54&#125;`; //不会被转义\nconsole.log(str);//&gt;&gt; \\u&#123;54&#125;</code></pre>\n<h2 id=\"Rest-Spread\"><a href=\"#Rest-Spread\" class=\"headerlink\" title=\"Rest / Spread\"></a>Rest / Spread</h2><p>这个就是我们通常所说的三个点<code>...</code>，这项特性在ES6中已经引入，但是ES6中的作用对象仅限于数组。在ES9中，为对象提供了像数组一样的rest参数和扩展运算符：</p>\n<pre><code class=\"javascript\">const obj = &#123;\n  a: 1,\n  b: 2,\n  c: 3\n&#125;;\nconst &#123; a, ...param &#125; = obj; //这里...是rest\nconsole.log(a); //&gt;&gt; 1\nconsole.log(param); //&gt;&gt; &#123;b: 2, c: 3&#125;\n\nfunction foo(&#123; a, ...param &#125;) &#123;//这里...还是rest\n  console.log(a); //&gt;&gt; 1\n  console.log(param); //&gt;&gt; &#123;b: 2, c: 3&#125;\n&#125;\n\nconst param = &#123; b: 2, c: 3 &#125;;\nfoo(&#123; a: 1, ...param &#125;);  //此处...为spread</code></pre>\n<h2 id=\"正则表达式dotAll模式\"><a href=\"#正则表达式dotAll模式\" class=\"headerlink\" title=\"正则表达式dotAll模式\"></a>正则表达式dotAll模式</h2><p>正则表达式中点<code>.</code>匹配除回车外的任何单字符，标记<code>s</code>改变这种行为，允许匹配回车换行。</p>\n<pre><code class=\"javascript\">/hello.world/.test(&#39;hello\\nworld&#39;);  // false\n/hello.world/s.test(&#39;hello\\nworld&#39;); // true\nconsole.log(/hello.world/s.test(`hello\nworld`))   //&gt;&gt; true</code></pre>\n<h2 id=\"正则表达式命名捕获组\"><a href=\"#正则表达式命名捕获组\" class=\"headerlink\" title=\"正则表达式命名捕获组\"></a>正则表达式命名捕获组</h2><p>Javascript正则表达式中使用<code>exec()</code>匹配后，能够返回一个包含匹配字符串的类数组对象。</p>\n<pre><code class=\"javascript\">const reDate = /(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)/,\n  match = reDate.exec(&quot;2018-08-06&quot;);\nconsole.log(match);//&gt;&gt; [2018-08-06, 2018, 08, 06]\n\n//这样就可以直接用索引来获取年月日：\nlet year = match[1]; //&gt;&gt; 2018\nlet month = match[2]; //&gt;&gt; 08\nlet day = match[3]; //&gt;&gt; 06</code></pre>\n<p>返回数组的第0项为与正则表达式相匹配的文本，第 1 项是与 <code>reDate</code> 的第 1 个分组<code>\\d&#123;4&#125;</code>相匹配的文本（如果有的话），第 2 项是与 <code>reDate</code> 的第 2 个分组<code>\\d&#123;2&#125;</code>相匹配的文本（如果有的话），以此类推。正则表达式的组以<code>()</code>包起来。</p>\n<p>上面的案例，若是日期格式变成<code>月日年</code>，那么改变正则表达式的结构后，还有可能会改变变量的赋值部分的代码。如下示例：</p>\n<pre><code class=\"javascript\">const reDate = /(\\d&#123;2&#125;)-(\\d&#123;2&#125;)-(\\d&#123;4&#125;)/,//表达式结构变化了\n  match = reDate.exec(&quot;08-06-2018&quot;);\nconsole.log(match);//&gt;&gt; [08-06-2018, 08, 06, 2018]\n\n//此时年月日的赋值代码也要改了,改的地方真多啊！怎么办？\nlet year = match[3]; //&gt;&gt; 2018\nlet month = match[1]; //&gt;&gt; 08\nlet day = match[2]; //&gt;&gt; 06</code></pre>\n<p>可以发现上面的写法改的地方太多了，有没有办法少改点代码省省事呢？有！ ES9 允许使用符号<code>?&lt;name&gt;</code>来命名<strong>捕获组</strong>（也即“匹配到的组”），示例如下：</p>\n<pre><code class=\"javascript\">const reDate = /(?&lt;year&gt;\\d&#123;4&#125;)-(?&lt;month&gt;\\d&#123;2&#125;)-(?&lt;day&gt;\\d&#123;2&#125;)/,\n  match = reDate.exec(&quot;2018-08-06&quot;);\nconsole.log(match);\n//&gt;&gt; [2018-08-06, 08, 06, 2018, groups: &#123;day: 06, month: 08, year: 2018&#125;]\n\n//此时用groups对象来获取年月日，无论正则表达式怎么变换，这下面三行不用改了，省事！\nlet year = match.groups.year; //&gt;&gt; 2018\nlet month = match.groups.month; //&gt;&gt; 08\nlet day = match.groups.day; //&gt;&gt; 06</code></pre>\n<p>命名捕获组的写法相当于是把每个捕获组都定义了一个名字，然后存储到返回值的<code>groups</code>属性中。</p>\n<h3 id=\"正则表达式后行断言\"><a href=\"#正则表达式后行断言\" class=\"headerlink\" title=\"正则表达式后行断言\"></a>正则表达式后行断言</h3><p>先看看正则表达式<strong>先行断言</strong>示例：</p>\n<pre><code class=\"javascript\">const re1 = /\\D(\\d+)/,\n    re2 = /\\D(?=\\d+)/,//&quot;?=&quot;是正向先行断言\n    match1 = re1.exec(&quot;$123.45&quot;),\n    match2 = re2.exec(&quot;$123.45&quot;);\nconsole.log(match1[0]); //&gt;&gt; $123\nconsole.log(match2[0]); //&gt;&gt; $</code></pre>\n<blockquote>\n<p><strong>(?=pattern)</strong> 零宽正向先行断言(zero-width positive lookahead assertion)<br>代表字符串中的一个位置，<strong>紧接该位置之后</strong>的字符序列<strong>能够匹配</strong>pattern；</p>\n<p>(<strong>?!pattern)</strong> 零宽负向先行断言(zero-width negative lookahead assertion)<br>代表字符串中的一个位置，<strong>紧接该位置之后</strong>的字符序列<strong>不能匹配</strong>pattern；</p>\n<p><strong>(?&lt;=pattern)</strong> 零宽正向后行断言(zero-width positive lookbehind assertion)<br>代表字符串中的一个位置，<strong>紧接该位置之前</strong>的字符序列<strong>能够匹配</strong>pattern；</p>\n<p><strong>(?&lt;!pattern)</strong> 零宽负向后行断言(zero-width negative lookbehind assertion)<br>代表字符串中的一个位置，<strong>紧接该位置之前</strong>的字符序列<strong>不能匹配</strong>pattern。</p>\n</blockquote>\n<p>在ES9中，可以允许使用<code>?&lt;=</code>进行<strong>正向后行断言</strong>，可以获取货币的价格而忽略货币符号。</p>\n<pre><code class=\"javascript\">const re= /(?&lt;=\\D)[\\d\\.]+/,\n    match = re.exec(&quot;$123.45&quot;);\nconsole.log(match[0]); //&gt;&gt; 123.45</code></pre>\n<p>上面的正向后行断言，也就是说<code>\\D</code>这个条件必须满足，但<code>\\D</code>匹配的字符不会作为结果输出（因为<strong>先行/后行断言</strong>其实只是匹配了一个位置）。如果是下面这样：</p>\n<pre><code class=\"javascript\">const re= /(?&lt;=\\D)[\\d\\.]+/,\n    match1 = re.exec(&quot;123.45&quot;),\n    match2 = re.exec(&quot;12345&quot;);\nconsole.log(match1 &amp;&amp; match1[0]); //&gt;&gt; 45\nconsole.log(match2 &amp;&amp; match1[0]); //&gt;&gt; null</code></pre>\n<p>可以看到<code>match1</code>匹配到的是<code>45</code>,这是由于在<code>.</code>前面没有任何符合<code>\\D</code>的匹配内容，它会一直找到符合<code>\\D</code>的内容，也就是<code>.</code>然后返回后面的内容。而<code>match2</code>若是没有满足前面肯定反向断言的条件的话，则结果返回<code>null</code>。</p>\n<h2 id=\"正则表达式-Unicode-转义\"><a href=\"#正则表达式-Unicode-转义\" class=\"headerlink\" title=\"正则表达式 Unicode 转义\"></a>正则表达式 Unicode 转义</h2><p>ES9 之前，在正则表达式中本地访问 Unicode 字符属性是不被允许的。ES9 添加了 Unicode 属性转义，形式为<code>\\p&#123;...&#125;</code>和<code>\\P&#123;...&#125;</code>，在正则表达式中使用标记 <code>u</code> (unicode) 设置，在<code>\\p</code>的<code>&#123;...&#125;</code>内，可用键值对的方式设置需要匹配的属性而非具体内容。</p>\n<pre><code class=\"javascript\">const regex = /\\p&#123;Script=Greek&#125;/u;//Greek为希腊语的意思\nconsole.log(regex.test(&#39;a&#39;)); //&gt;&gt; flase\nconsole.log(regex.test(&#39;Σ&#39;)); //&gt;&gt; true</code></pre>\n<h1 id=\"ES-10-新特性\"><a href=\"#ES-10-新特性\" class=\"headerlink\" title=\"ES 10 新特性\"></a>ES 10 新特性</h1><table>\n<thead>\n<tr>\n<th align=\"left\">新特性</th>\n<th align=\"left\">中文说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">Optional <code>catch</code> binding</td>\n<td align=\"left\">可选的 catch 变量绑定</td>\n</tr>\n<tr>\n<td align=\"left\">JSON superset</td>\n<td align=\"left\">JSON超集</td>\n</tr>\n<tr>\n<td align=\"left\"><code>Symbol.prototype.description</code></td>\n<td align=\"left\">Symbol 对象的 description 属性</td>\n</tr>\n<tr>\n<td align=\"left\"><code>Function.prototype.toString</code> revision</td>\n<td align=\"left\">修订<code>Function.prototype.toString</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>Object.fromEntries</code></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">Well-formed <code>JSON.stringify</code></td>\n<td align=\"left\">更加友好的JSON.stringify</td>\n</tr>\n<tr>\n<td align=\"left\"><code>String.prototype.&#123;trimStart,trimEnd&#125;</code></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\"><code>Array.prototype.&#123;flat,flatMap&#125;</code></td>\n<td align=\"left\"></td>\n</tr>\n</tbody></table>\n<h2 id=\"可选的-catch-变量绑定\"><a href=\"#可选的-catch-变量绑定\" class=\"headerlink\" title=\"可选的 catch 变量绑定\"></a>可选的 catch 变量绑定</h2><p>在 ES10 之前，我们必须通过语法为 catch 子句绑定异常变量，无论是否有必要。很多时候 catch 块是多余的，而 ES10 使我们能够简单的把变量省略掉。</p>\n<pre><code class=\"javascript\">//之前是\ntry &#123;&#125; catch(e) &#123;&#125;\n\n//ES10之后可以写成，\ntry &#123;&#125; catch &#123;&#125;//省掉了变量e</code></pre>\n<h2 id=\"JSON超集\"><a href=\"#JSON超集\" class=\"headerlink\" title=\"JSON超集\"></a>JSON超集</h2><p>什么是 JSON 超集？简单来说就是 JSON 是 ECMAScript 的子集，也就是说让 ECMAScript 兼容 JSON 的内容所支持的全部文本。</p>\n<p>ECMAScript 在标准 <a href=\"https://tc39.es/ecma262/#sec-json.parse\">JSON.parse</a> 部分阐明了 JSON 确为其一个子集，但由于 JSON 的内容可以正常包含 <code>U+2028</code> 行分隔符与 <code>U+2029</code> 段落分隔符，而 ECMAScript 却不行，所以，该草案旨在解决这一问题。在这之前，如果你使用 <code>JSON.parse()</code> 执行带如上特殊字符的字符串时，只会收到 <code>SyntaxError</code> 的错误提示。该草案同样是向后兼容的，其对用户唯一的影响是保持原样，即在暂不支持特殊字符解析的运行环境中保持报错 <code>SyntaxError</code> 。</p>\n<h2 id=\"Symbol-对象的-description-属性\"><a href=\"#Symbol-对象的-description-属性\" class=\"headerlink\" title=\"Symbol 对象的 description 属性\"></a>Symbol 对象的 description 属性</h2><p>ES10 中为 Symbol 对象添加了只读属性 <code>description</code> ，该对象返回包含 Symbol 描述的字符串。在创建Symbol时向其添加<code>description</code> (描述)，能够直接访问<code>description</code> ，对调试是很有用的。</p>\n<pre><code class=\"javascript\">let sym = Symbol(&#39;foo&#39;);//添加的描述内容为“foo”\nconsole.log(sym.description);//&gt;&gt; foo\n\nsym = Symbol();\nconsole.log(sym.description);//&gt;&gt; undefined\n\n//和 Symbol() 不同的是，用 Symbol.for() 方法创建的的 symbol 会被放入一个全局 \n//symbol 注册表中。Symbol.for() 并不是每次都会创建一个新的 symbol，它会首先检\n//查给定的 key 是否已经在注册表中了。假如是，则会直接返回上次存储的那个。否则，它\n//会再新建一个。\nsym = Symbol.for(&#39;bar&#39;);\nconsole.log(sym.description);//&gt;&gt; bar</code></pre>\n<h2 id=\"修订Function-prototype-toString\"><a href=\"#修订Function-prototype-toString\" class=\"headerlink\" title=\"修订Function.prototype.toString\"></a>修订Function.prototype.toString</h2><p>函数原型上的方法<code>toString()</code>现在返回精确字符，包括空格和注释。</p>\n<pre><code class=\"javascript\">function /* comment */ foo /* another comment */() &#123;&#125;\n\n//ES10之前不会打印注释部分\nconsole.log(foo.toString()); //&gt;&gt; function foo()&#123;&#125;\n\n//ES10里，会把注释一同打印\nconsole.log(foo.toString()); //&gt;&gt; function /* comment */ foo /* another comment */ ()&#123;&#125;\n\n//注意：\n//箭头函数是个例外\nconst bar /* comment */ = /* another comment */ () =&gt; &#123;&#125;;\nconsole.log(bar.toString()); //&gt;&gt; () =&gt; &#123;&#125;</code></pre>\n<h2 id=\"Object-fromEntries\"><a href=\"#Object-fromEntries\" class=\"headerlink\" title=\"Object.fromEntries\"></a>Object.fromEntries</h2><p>在 JavaScript 操作中，数据在各种数据结构之间的转换都是很容易的，比如 Map 到数组、Map 到 Set、对象到 Map 等等。</p>\n<pre><code class=\"javascript\">let map = new Map().set(&#39;foo&#39;, true).set(&#39;bar&#39;, false);\nlet arr = Array.from(map);\nlet set = new Set(map.values());\n\nlet obj = &#123; foo: true, bar: false &#125;;\n//下一句 Object.entries() 方法返回给定对象 obj 自身可枚举属性的键值对数组,\n//形如：[[&quot;foo&quot;,true],[&quot;bar&quot;,false]]\nlet newMap = new Map(Object.entries(obj));</code></pre>\n<p>但是如果我们需要将一个键值对列表转换为对象，就要写点费劲的代码了。</p>\n<pre><code class=\"javascript\">let map = new Map().set(&quot;foo&quot;, true).set(&quot;bar&quot;, false);\nlet obj = Array.from(map).reduce((acc, [key, val]) =&gt; &#123;\n  return Object.assign(acc, &#123;\n    [key]: val\n  &#125;);\n&#125;, &#123;&#125;);</code></pre>\n<p>该特性的目的在于为对象添加一个新的静态方法 <code>Object.fromEntries</code>，用于将符合键值对的列表（例如 Map、数组等）转换为一个对象。上一块的代码中的转换逻辑，现在我们只需要一行代码即可搞定。</p>\n<pre><code class=\"javascript\">const map = new Map().set(&quot;foo&quot;, true).set(&quot;bar&quot;, false);\nlet obj = Object.fromEntries(map);</code></pre>\n<h2 id=\"更加友好的-JSON-stringify\"><a href=\"#更加友好的-JSON-stringify\" class=\"headerlink\" title=\"更加友好的 JSON.stringify\"></a>更加友好的 JSON.stringify</h2><p>ES10 之前，当你使用 <code>JSON.stringify()</code> 处理无法用 UTF-8 编码表示的字符时（U+D800 至 U+DFFF），返回的结果会是一个乱码 Unicode 字符“�”。该特性提出用<code>JSON.stringify()</code>来安全的表示这些不正常的UTF-8字符。</p>\n<pre><code class=\"javascript\">let r;\nr = JSON.stringify(&quot;❤&quot;); //正常的UTF-8字符原样输出\nconsole.log(r); //&gt;&gt; &quot;❤&quot;\n\nr = JSON.stringify(&#39;\\u2764&#39;); //正常的UTF-8字符编码，输出解码之后的模样\nconsole.log(r); //&gt;&gt; &quot;❤&quot;\n\nr = JSON.stringify(&quot;\\uDF06\\uD834&quot;); //不正常的UTF-8字符编码，则以unicode形式输出\nconsole.log(r); //&gt;&gt; &quot;\\udf06\\ud834&quot;\n\nr = JSON.stringify(&quot;\\uDEAD&quot;); //不正常的UTF-8字符编码，则以unicode形式输出\nconsole.log(r); //&gt;&gt; &quot;\\udead&quot;</code></pre>\n<h2 id=\"String-prototype-trimStart-trimEnd\"><a href=\"#String-prototype-trimStart-trimEnd\" class=\"headerlink\" title=\"String.prototype.{trimStart,trimEnd}\"></a>String.prototype.{trimStart,trimEnd}</h2><p>新增了String的<code>trimStart()</code>方法和<code>trimEnd()</code>方法，这两个方法很好理解，分别去除字符串首、尾的空白字符，就不举例占篇幅了。</p>\n<h2 id=\"Array-prototype-flat-flatMap\"><a href=\"#Array-prototype-flat-flatMap\" class=\"headerlink\" title=\"Array.prototype.{flat,flatMap}\"></a>Array.prototype.{flat,flatMap}</h2><p>这个特性新创造了两个方法，其中：</p>\n<ul>\n<li><code>Array.prototype.flat</code> 数组的所有项会以指定的维度降维（扁平化），然后组成新数组返回；</li>\n<li><code>Array.prototype.flatMap</code> 首先会执行一次<code>map()</code>方法，然后再通过类似<code>flat()</code>方法<strong>扁平化</strong>数组。它等同于执行完 <code>map()</code> 后再执行一次 <code>flat()</code> 方法，所以当你执行 <code>map()</code> 返回的结果如果是个数组，然后又要将其扁平化时，这个方法会显得方便。</li>\n</ul>\n<p>来看几个例子解释一下，首先 <code>flat()</code> 方法支持多维数组的扁平化，其中<code>Infinity</code>可以将多维数组压扁成一维数组。</p>\n<pre><code class=\"javascript\">let r;\nr = [&quot;1&quot;, [&quot;8&quot;, [&quot;9&quot;, [&quot;1&quot;]]]].flat();//4维数组，默认降维1，变成3维数组\nconsole.log(r); //&gt;&gt; [ &#39;1&#39;, &#39;8&#39;, [ &#39;9&#39;, [&#39;1&#39;] ] ]\n\nr = [&quot;1&quot;, [&quot;8&quot;, [&quot;9&quot;, [&quot;1&quot;]]]].flat(2); //4维数组，降维2，变成2维数组\nconsole.log(r); //&gt;&gt; [ &#39;1&#39;, &#39;8&#39;, &#39;9&#39;, [&#39;1&#39;] ]\n\nr = [&quot;1&quot;, [&quot;8&quot;, [&quot;9&quot;, [&quot;1&quot;]]]].flat(Infinity);//4维数组，最多变成1维数组\nconsole.log(r); //&gt;&gt; [ &#39;1&#39;, &#39;8&#39;, &#39;9&#39;, &#39;1&#39; ]</code></pre>\n<p>接着来看看<code>flatMap()</code></p>\n<pre><code class=\"javascript\">let r;\nr = [&quot;I love&quot;, &quot;coffe 1891&quot;].map(item =&gt; item.split(&quot; &quot;));\nconsole.log(r); //&gt;&gt; [ [ &#39;I&#39;, &#39;love&#39; ], [ &#39;coffe&#39;, &#39;1891&#39; ] ]\n\nr = [&quot;I love&quot;, &quot;coffe 1891&quot;].flatMap(item =&gt; item.split(&quot; &quot;));\nconsole.log(r); //&gt;&gt;[ &#39;I&#39;, &#39;love&#39;, &#39;coffe&#39;, &#39;1891&#39; ]</code></pre>\n<h1 id=\"ES-2020-ES11-新特性\"><a href=\"#ES-2020-ES11-新特性\" class=\"headerlink\" title=\"ES 2020 (ES11) 新特性\"></a>ES 2020 (ES11) 新特性</h1><p>因为太“新”，现在若想使用ES11新特性，则需要安装babel插件</p>\n<pre><code class=\"javascript\">plugins: [\n    &quot;@babel/plugin-proposal-nullish-coalescing-operator&quot;,\n    &quot;@babel/plugin-proposal-optional-chaining&quot;,\n    &quot;@babel/plugin-proposal-class-properties&quot;,\n    &quot;@babel/plugin-proposal-private-methods&quot;,\n    &quot;@babel/plugin-syntax-bigint&quot;\n]</code></pre>\n<table>\n<thead>\n<tr>\n<th align=\"left\">新特性</th>\n<th align=\"left\">中文说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">Optional Chaining</td>\n<td align=\"left\">可选链操作符</td>\n</tr>\n<tr>\n<td align=\"left\">Nullish coalescing Operator</td>\n<td align=\"left\">空位合并操作符</td>\n</tr>\n<tr>\n<td align=\"left\"><code>String.prototype.matchAll</code></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\"><code>import()</code></td>\n<td align=\"left\">import()函数</td>\n</tr>\n<tr>\n<td align=\"left\"><code>Promise.allSettled</code></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">Bigint</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">globalThis</td>\n<td align=\"left\">全局this</td>\n</tr>\n</tbody></table>\n<h2 id=\"Optional-Chaining\"><a href=\"#Optional-Chaining\" class=\"headerlink\" title=\"Optional Chaining\"></a>Optional Chaining</h2><p><strong>可选链操作符</strong> <code>?</code> 可让我们在查询具有多个层级的对象时，不再需要进行冗余的各种前置校验。</p>\n<p>以前要读取一个对象的属性值，需要写一些防御性的前置校验代码，比如：</p>\n<pre><code class=\"javascript\">let second = obj &amp;&amp; obj.first &amp;&amp; obj.first.second;</code></pre>\n<p>在访问 obj.first.second 之前，要先确认 obj 和 obj.first 的值非 null(且不是 undefined)。有了可选链式操作符，则可以大量简化类似繁琐的前置校验操作，而且更安全：</p>\n<pre><code class=\"javascript\">let second = obj?.first?.second;</code></pre>\n<p>如果 <code>obj</code> 或<code>obj.first</code>是<code>null</code>/<code>undefined</code>，表达式将会直接返回<code>undefined</code>。</p>\n<h2 id=\"Nullish-coalescing-Operator-空值处理\"><a href=\"#Nullish-coalescing-Operator-空值处理\" class=\"headerlink\" title=\"Nullish coalescing Operator(空值处理)\"></a>Nullish coalescing Operator(空值处理)</h2><p>以前对于如下的情况：</p>\n<pre><code class=\"javascript\">let v = a || &quot;some value&quot;;\n\nlet z = a ? a : &quot;some value&quot;;</code></pre>\n<p>如果 a 的值是 <code>0</code> 、 空字符串<code>&#39;&#39;</code> 、<code>false</code>等可能有意义的值，但是在上面的表达式中被认为是假值，因此v 和 z 也会被赋值为 <code>some value</code>。也即：</p>\n<pre><code class=\"javascript\">let a = 0; // 0、&#39;&#39;、false可能是有意义的\nlet v = a || &quot;some value&quot;;\nconsole.log(v); //&gt;&gt; some value</code></pre>\n<p>为解决这种问题，诞生了<code>??</code> ，如果表达式在<code>??</code>的左侧值为<code>undefined</code>或<code>null</code>，就返回右侧默认的值。</p>\n<pre><code class=\"javascript\">let a = 0; \nlet v = a ?? &quot;some value&quot;;\nconsole.log(v); //&gt;&gt; 0\n\nlet b = null; \nlet z = b ?? &quot;some value&quot;;\nconsole.log(z); //&gt;&gt; some value</code></pre>\n<h2 id=\"String-prototype-matchAll\"><a href=\"#String-prototype-matchAll\" class=\"headerlink\" title=\"String.prototype.matchAll\"></a>String.prototype.matchAll</h2><p><code>matchAll()</code> 方法返回一个包含所有匹配正则表达式及分组捕获结果的迭代器（iterator）。 在 <code>matchAll</code> 出现之前，通过在循环中调用<code>Regexp.exec</code>来获取所有匹配项信息（<code>Regexp</code>需使用<code>/g</code>标志）：</p>\n<pre><code class=\"javascript\">const regexp = RegExp(&#39;foo*&#39;,&#39;g&#39;);\nconst str = &#39;coffe football, foosball&#39;;\n\nwhile ((matches = regexp.exec(str)) !== null) &#123;\n  console.log(`找到 $&#123;matches[0]&#125;，下一轮循环从位置 $&#123;regexp.lastIndex&#125; 开始`);\n  //&gt;&gt; 找到 foo，下一轮循环从位置 9 开始\n  //&gt;&gt; 找到 foo，下一轮循环从位置 19 开始\n&#125;</code></pre>\n<p>如果使用<code>matchAll</code> ，就可以不必使用<code>while</code>循环加<code>exec</code>方式（且正则表达式需使用<code>/g</code>标志）。使用<code>matchAll</code> 会得到一个迭代器的返回值，配合 <code>for...of</code>，<code>array spread</code>，<code>Array.from()</code> 可以更方便实现功能。</p>\n<pre><code class=\"javascript\">const regexp = RegExp(&#39;foo*&#39;,&#39;g&#39;); \nconst str = &#39;coffe football, foosball&#39;;\nlet matches = str.matchAll(regexp);\n\nfor (const match of matches) &#123;\n  console.log(match);\n&#125;\n//&gt;&gt; [ &quot;foo&quot; ]\n//&gt;&gt; [ &quot;foo&quot; ]\n\n//注意：\n//matches的迭代器在for..of之后已经被消耗掉了，\n//需要再次调用matchAll创建一个新的迭代器\nmatches = str.matchAll(regexp);\n\nlet arr = Array.from(matches, m =&gt; m[0]);\nconsole.log(arr);\n//&gt;&gt; [ &quot;foo&quot;, &quot;foo&quot; ]</code></pre>\n<h2 id=\"import-函数\"><a href=\"#import-函数\" class=\"headerlink\" title=\"import()函数\"></a>import()函数</h2><p>这个特性为JavaScript添加了一个类函数（function-like）的<code>import()</code>功能，以便可以像函数传参那样传入参数实现<strong>动态</strong>（没错，<code>import</code>是静态引用的）引用模块（module）。下面有个单页应用简单示例，演示了用<code>import()</code>开启懒加载。</p>\n<pre><code class=\"markup\">&lt;!DOCTYPE html&gt;\n&lt;nav&gt;\n  &lt;a href=&quot;books.html&quot; data-entry-module=&quot;books&quot;&gt;书籍&lt;/a&gt;\n  &lt;a href=&quot;movies.html&quot; data-entry-module=&quot;movies&quot;&gt;电影&lt;/a&gt;\n  &lt;a href=&quot;video-games.html&quot; data-entry-module=&quot;video-games&quot;&gt;电视游戏&lt;/a&gt;\n&lt;/nav&gt;\n\n&lt;main&gt;内容将会加载到这里！&lt;/main&gt;\n\n&lt;script&gt;\n  const main = document.querySelector(&quot;main&quot;);\n  for (const link of document.querySelectorAll(&quot;nav &gt; a&quot;)) &#123;\n    link.addEventListener(&quot;click&quot;, e =&gt; &#123;\n      e.preventDefault();\n\n      import(`./section-modules/$&#123;link.dataset.entryModule&#125;.js`)//动态引用\n        .then(module =&gt; &#123;//加载模块成功以后，该模块会当作then方法的参数\n          module.loadPageInto(main);\n        &#125;)\n        .catch(err =&gt; &#123;//捕捉异常\n          main.textContent = err.message;\n        &#125;);\n    &#125;);\n  &#125;\n&lt;/script&gt;</code></pre>\n<p>请注意<code>import()</code>和<code>import</code>的区别：</p>\n<ul>\n<li>import() 可以用在script脚本区，不止是模块内；</li>\n<li>如果在模块内使用import()，它可以在任何地方任何级别执行，而不是被提升到顶级（优先执行）；</li>\n<li>import() 是运行时执行，也即什么时候运行到这句，就会加载参数指定的模块；参数也可以是动态可变的，不止是静态参数；</li>\n<li>import() 不建立可静态分析的依赖关系（静态分析的情况下可以做很多优化），但是，在一些比较简单的情况下，比如<code>import（“/foo.js”）</code>中，实现仍然可以执行静态分析优化。</li>\n</ul>\n<p>如果模块采用<code>default</code>的形式对外暴露接口，则可用<code>default</code>属性直接获得。</p>\n<pre><code class=\"javascript\">import(&#39;./module.js&#39;)\n.then(module =&gt; &#123;\n  console.log(module.default);//直接通过default属性获得模块暴露的接口\n&#125;);</code></pre>\n<h2 id=\"Promise-allSettled\"><a href=\"#Promise-allSettled\" class=\"headerlink\" title=\"Promise.allSettled\"></a>Promise.allSettled</h2><p>为什么要有<code>Promise.allSettled()</code>？</p>\n<p>举例说明，比如各位用户在页面上面同时填了3个独立的表单，这三个表单分三个接口提交到后端，三个接口独立，没有顺序依赖，这个时候我们需要等到请求全部完成后给与用户提示表单提交的情况。</p>\n<p>在多个<code>promise</code>同时进行时咱们很快会想到使用<code>Promise.all</code>来进行包装，但是由于<code>Promise.all</code>的一票否决的特性，三个提交中若前面任意一个提交失败，则后面的表单也不会进行提交了，这就与咱们需求不符合。</p>\n<p><code>Promise.allSettled</code>跟<code>Promise.all</code>类似，其参数接受一个<code>Promise</code>的数组，返回一个新的<code>Promise</code>，唯一的不同在于，其没有一票否决的特性，也就是说当<code>Promise</code>全部处理完成后我们可以拿到每个<code>Promise</code>的状态，而不管其是否处理成功。</p>\n<pre><code class=\"javascript\">Promise.allSettled([Promise.resolve(&quot;coffe&quot;), Promise.reject(&quot;1891&quot;)]).then(\n  arr =&gt; &#123;\n    console.log(arr); //&gt;&gt; [ &#123; status: &quot;fulfilled&quot;, value: &quot;coffe&quot;&#125;,\n                      //&gt;&gt;   &#123; status: &quot;rejected&quot;, reason: &quot;1891&quot; &#125; ]\n  &#125;\n);</code></pre>\n<h2 id=\"Bigint\"><a href=\"#Bigint\" class=\"headerlink\" title=\"Bigint\"></a>Bigint</h2><p>JavasSript 在数学计算领域很糟糕的原因之一是它只能安全的表示<code>-(2^53-1)</code>至 <code>2^53-1</code> 范的值，即<code>Number.MIN_SAFE_INTEGER</code> 至<code>Number.MAX_SAFE_INTEGER</code>，超出这个范围的整数计算或者表示会丢失精度。</p>\n<pre><code class=\"javascript\">var num = Number.MAX_SAFE_INTEGER;  // &gt;&gt; 9007199254740991\n\nnum = num + 1; // &gt;&gt; 9007199254740992\n\n// 再次加 +1 后无法正常运算\nnum = num + 1; // &gt;&gt; 9007199254740992\n\n// 两个不同的值，却返回了true\n9007199254740992 === 9007199254740993  // &gt;&gt; true</code></pre>\n<p>于是 BigInt 诞生了，<strong>它是JavaScript的第7个原始类型</strong>，可安全地进行大数整型计算。 你可以在BigInt上使用与普通数字相同的运算符，例如 +, -, /, *, %等等。</p>\n<p>创建 BigInt 类型的值也非常简单，只需要在数字后面加上 <code>n</code> 即可。例如，123 变为 123n。也可以使用全局方法 BigInt(value) 转化，入参 value 为数字或数字字符串。</p>\n<pre><code class=\"javascript\">const aNumber = 1891;\nconst aBigInt = BigInt(aNumber);\naBigInt === 1891n // true\ntypeof aBigInt === &#39;bigint&#39; // true\ntypeof 1891 // &quot;number&quot;\ntypeof 1891n // &quot;bigint&quot;</code></pre>\n<p>只要在数字末尾加上 n，就可以正确计算大数：</p>\n<pre><code class=\"javascript\">1234567890123456789n * 123n;\n// -&gt; 151851850485185185047n</code></pre>\n<p>最后要注意，不能将 BigInt与Number混合使用。比较Number和 BigInt是可以的，但是不能把它们相加。</p>\n<pre><code class=\"javascript\">1n &lt; 2 // true\n\n1n + 2 // Uncaught TypeError: Cannot mix BigInt and other types, use explicit conversions</code></pre>\n<h2 id=\"globalThis\"><a href=\"#globalThis\" class=\"headerlink\" title=\"globalThis\"></a>globalThis</h2><p>globalThis 是一个全新的标准方法用来获取全局 this 。之前开发者会通过如下的一些方法获取：</p>\n<ul>\n<li>全局变量 window：是一个经典的获取全局对象的方法。但是它在 Node.js 和 Web Workers 中并不能使用</li>\n<li>全局变量 self：通常只在 Web Workers 和浏览器中生效。但是它不支持 Node.js。一些人会通过判断 self 是否存在识别代码是否运行在 Web Workers 和浏览器中</li>\n<li>全局变量 global：只在 Node.js 中生效</li>\n</ul>\n<p>过去获取全局对象，可通过一个全局函数：</p>\n<pre><code class=\"javascript\">// ES10之前的解决方案\nconst getGlobal = function()&#123;\n  if(typeof self !== &#39;undefined&#39;) return self\n  if(typeof window !== &#39;undefined&#39;) return window\n  if(typeof global !== &#39;undefined&#39;) return global\n  throw new Error(&#39;unable to locate global object&#39;)\n&#125;\n\n// ES10内置\nglobalThis.Array(0,1,2) // [0,1,2]\n\n// 定义一个全局对象v = &#123; value:true &#125; ,ES10用如下方式定义\nglobalThis.v = &#123; value:true &#125;</code></pre>\n<p>而 <strong>globalThis 目的就是提供一种标准化方式访问全局对象</strong>，有了 globalThis 后，你可以在任意上下文，任意时刻都能获取到全局对象。如果您在浏览器上，globalThis将为window，如果您在Node上，globalThis则将为global。因此，不再需要考虑不同的环境问题。</p>\n<pre><code class=\"javascript\">// worker\nglobalThis === self\n// node\nglobalThis === global\n// browser\nglobalThis === window</code></pre>\n<h1 id=\"ES-2021-ES12-等2021年发布\"><a href=\"#ES-2021-ES12-等2021年发布\" class=\"headerlink\" title=\"ES 2021 (ES12) 等2021年发布\"></a>ES 2021 (ES12) 等2021年发布</h1><table>\n<thead>\n<tr>\n<th align=\"left\">新特性</th>\n<th align=\"left\">中文说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">String.prototype.replaceAll</td>\n<td align=\"left\">替换所有符合的字符串</td>\n</tr>\n<tr>\n<td align=\"left\">Promise.any</td>\n<td align=\"left\">返回Promise列表中第一个resolve的结果状态</td>\n</tr>\n<tr>\n<td align=\"left\">WeakRefs</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">逻辑运算符和赋值表达式</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">数字分隔符</td>\n<td align=\"left\"></td>\n</tr>\n</tbody></table>\n<h2 id=\"replaceAll\"><a href=\"#replaceAll\" class=\"headerlink\" title=\"replaceAll\"></a>replaceAll</h2><p>看到replaceAll这个词，相比很容易联想到replace。在JavaScript中，replace方法只能是替换字符串中匹配到的第一个实例字符，而不能进行全局多项匹配替换，唯一的办法是通过正则表达式进行相关规则匹配替换，而replaceAll则是返回一个全新的字符串，所有符合匹配规则的字符都将被替换掉，替换规则可以是字符串或者正则表达式。</p>\n<pre><code class=\"javascript\">let string = &#39;I like javaScript,I like css&#39;\n\n//使用replace\nlet replaceStr = string.replace(&#39;like&#39;,&#39;love&#39;)\nconsole.log(replaceStr)  // &#39;I love javaScript,I like css&#39;\n\n//replace使用正则匹配所有\nconsole.log(string.replace(/like/g,&#39;love&#39;)) // &#39;I love javaScript,I love css&#39;\n\n//使用replaceAll\nlet replaceAllStr = string.replaceAll(&#39;like&#39;,&#39;love&#39;)\nconsole.log(replaceAllStr) // &#39;I love javaScript,I love css&#39;\n</code></pre>\n<h2 id=\"Promise-any\"><a href=\"#Promise-any\" class=\"headerlink\" title=\"Promise.any\"></a>Promise.any</h2><p>当Promise列表中的任意一个promise成功resolve则返回第一个resolve的结果状态。</p>\n<pre><code class=\"javascript\">\nPromise.any([\n  new Promise((resolve, reject) =&gt; setTimeout(reject, 500, &#39;哎呀，我被拒绝了&#39;)),\n  new Promise((resolve, reject) =&gt; setTimeout(resolve, 1000, &#39;哎呀，她接受我了&#39;)),\n  new Promise((resolve, reject) =&gt; setTimeout(resolve, 2000, &#39;哎呀，她也接受我了&#39;)),\n])\n.then(value =&gt; console.log(`输出结果: $&#123;value&#125;`))\n.catch (err =&gt; console.log(err))\n\n//输出结果:哎呀，她接受我了\n</code></pre>\n<p>如果所有的promise均reject，则抛出异常表示所有请求失败。</p>\n<pre><code class=\"javascript\">Promise.any([\n  Promise.reject(&#39;Error 1&#39;),\n  Promise.reject(&#39;Error 2&#39;),\n  Promise.reject(&#39;Error 3&#39;)\n])\n.then(value =&gt; console.log(`请求结果: $&#123;value&#125;`))\n.catch (err =&gt; console.log(err))\n\n//输出\nAggregateError: All promises were rejected\n</code></pre>\n<h2 id=\"WeakRefs\"><a href=\"#WeakRefs\" class=\"headerlink\" title=\"WeakRefs\"></a>WeakRefs</h2><p>使用WeakRefs的Class类创建对对象的弱引用(对对象的弱引用是指当该对象应该被GC回收时不会阻止GC的回收行为)</p>\n<p>当我们通过（const、let、var）创建一个变量时，垃圾收集器GC将永远不会从内存中删除该变量，只要它的引用仍然存在可访问。WeakRef对象包含对对象的弱引用。对对象的弱引用是不会阻止垃圾收集器GC恢复该对象的引用，则GC可以在任何时候删除它。</p>\n<p>WeakRefs在很多情况下都很有用，比如使用Map对象来实现具有很多需要大量内存的键值缓存，在这种情况下最方便的就是尽快释放键值对占用的内存。</p>\n<p>目前，可以通过WeakMap()或者WeakSet()来使用WeakRefs。</p>\n<h2 id=\"数字分隔符\"><a href=\"#数字分隔符\" class=\"headerlink\" title=\"数字分隔符\"></a>数字分隔符</h2><p>数字分隔符，可以在数字之间创建可视化分隔符，通过_下划线来分割数字，使数字更具可读性。</p>\n<pre><code class=\"javascript\">const money = 1_000_000_000\n//等价于\nconst money = 1000000000\n\nconst totalFee = 1000.12_34\n//等价于\nconst totalFee = 1000.1234\n</code></pre>\n<p>该新特性同样支持在八进制数中使用</p>\n<pre><code class=\"javascript\">\nconst number = 0o123_456\n//等价于\nconst number = 0o123456\n\n</code></pre>\n<h1 id=\"本篇结语\"><a href=\"#本篇结语\" class=\"headerlink\" title=\"本篇结语\"></a>本篇结语</h1><p>很显然ECMAScript接下来会持续不断地更新，按TC39的计划是每年都会发一个新版本。虽然节奏很快，但是我们完全没必要担心跟不上节奏。除了ES6这个史无前例的版本带来了超大量的新特性外，之后每年发的版本都仅仅带有少量的增量更新，你只需要花45分钟就能搞明白这一年更新的特性。保持一颗好奇的心，你会不断进步，变得更强！</p>\n","categories":[{"name":"ES语法","path":"api/categories/ES语法.json"}],"tags":[{"name":"es","path":"api/tags/es.json"}]}