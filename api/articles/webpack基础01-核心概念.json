{"title":"webpack基础01-核心概念","slug":"webpack基础01-核心概念","date":"2020-12-06T07:24:49.000Z","updated":"2022-01-05T09:30:11.946Z","comments":true,"path":"api/articles/webpack基础01-核心概念.json","excerpt":null,"covers":null,"content":"<h1 id=\"默认安装\"><a href=\"#默认安装\" class=\"headerlink\" title=\"默认安装\"></a>默认安装</h1><p>npm init -y</p>\n<h2 id=\"安装webpack相关\"><a href=\"#安装webpack相关\" class=\"headerlink\" title=\"安装webpack相关\"></a>安装webpack相关</h2><p>npm install webpack webpack-cli –save-dev</p>\n<h2 id=\"检查webpack版本-cd-node-modules-bin\"><a href=\"#检查webpack版本-cd-node-modules-bin\" class=\"headerlink\" title=\"检查webpack版本 cd node_modules/.bin\"></a>检查webpack版本 cd node_modules/.bin</h2><p>webpack -v</p>\n<h2 id=\"通过npm-stript运行webpack-否则只能在-bin下面执行\"><a href=\"#通过npm-stript运行webpack-否则只能在-bin下面执行\" class=\"headerlink\" title=\"通过npm stript运行webpack,否则只能在.bin下面执行\"></a>通过npm stript运行webpack,否则只能在.bin下面执行</h2><pre><code>package.json中添加 **build\": \"webpack\"**</code></pre>\n<h1 id=\"核心概念\"><a href=\"#核心概念\" class=\"headerlink\" title=\"核心概念\"></a>核心概念</h1><h2 id=\"entry\"><a href=\"#entry\" class=\"headerlink\" title=\"entry\"></a>entry</h2><p>entry是webpack打包文件的入口。入口可以设置多个，比如多页面应用。两者的写法有差异，但入口接收一个字符串，多入口写成对象的形式。</p>\n<h3 id=\"单入口写法\"><a href=\"#单入口写法\" class=\"headerlink\" title=\"单入口写法\"></a>单入口写法</h3><pre><code>module.exports = {\n    entry: \"./path/to/my/entry/file.js\"\n}</code></pre>\n<h3 id=\"多入口写法\"><a href=\"#多入口写法\" class=\"headerlink\" title=\"多入口写法\"></a>多入口写法</h3><pre><code>module.exports = {\n    entry: {\n        app: './src/app.js',\n        adminApp: './src/adminApp.js'\n    }\n}\n</code></pre>\n<h2 id=\"output\"><a href=\"#output\" class=\"headerlink\" title=\"output\"></a>output</h2><p>output用来指定打包输出。多个文件的时候通过占位符做区分 ，比如[name]。</p>\n<pre><code>module.exports = {\n    output: {\n        filename: '[name].js',\n        path: __dirname + '/dist/\n    }\n}\n</code></pre>\n<h2 id=\"loader\"><a href=\"#loader\" class=\"headerlink\" title=\"loader\"></a>loader</h2><p>webpack原生只支持js,json两种文件类型，通过loader去支持其他文件类型并把他们转化成有效的模块，并添加到依赖图中。</p>\n<p>本身是一个函数，接受源文件作为参数，返回转换的结果。</p>\n<h3 id=\"常见的loader\"><a href=\"#常见的loader\" class=\"headerlink\" title=\"常见的loader\"></a>常见的loader</h3><table>\n<thead>\n<tr>\n<th>名称</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>babel-loader</td>\n<td>转换ES6等新特性语法</td>\n</tr>\n<tr>\n<td>css-loader</td>\n<td>.css文件的加载和解析</td>\n</tr>\n<tr>\n<td>less-loader</td>\n<td>将less文件转为css</td>\n</tr>\n<tr>\n<td>ts-loader</td>\n<td>将TS转为js</td>\n</tr>\n<tr>\n<td>file-loader</td>\n<td>进行字体，图片的打包</td>\n</tr>\n<tr>\n<td>raw-loader</td>\n<td>将文件以字符串的形式导入</td>\n</tr>\n<tr>\n<td>thread-loader</td>\n<td>多线程打包css，js</td>\n</tr>\n</tbody></table>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p>放在module中，test用来指定匹配规则，use指定使用的loader名称</p>\n<pre><code>module: {\n        rules: [\n            { test: /\\.txt$/, use: 'raw-loader'}\n        ]\n    }</code></pre>\n<h2 id=\"plugins\"><a href=\"#plugins\" class=\"headerlink\" title=\"plugins\"></a>plugins</h2><p>插件用于bundle文件的优化，资源管理，环境变量的注入，作用于整个构建过程。loader没法做的事情，都是plugins来完成。</p>\n<h3 id=\"常见的plugins\"><a href=\"#常见的plugins\" class=\"headerlink\" title=\"常见的plugins\"></a>常见的plugins</h3><table>\n<thead>\n<tr>\n<th>名称</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>html-webpack-plugin</td>\n<td>创建html文件去承载输出的bundle</td>\n</tr>\n<tr>\n<td>clean-webpack-plugin</td>\n<td>用于在打包前清理上一次项目生成的 bundle 文件</td>\n</tr>\n<tr>\n<td>splitChunks</td>\n<td>提取被重复引入的文件，单独生成一个或多个文件，这样避免在多入口重复打包文件（替换CommonsChunkPlugin）</td>\n</tr>\n<tr>\n<td>copy-webpack-plugin</td>\n<td>将文件或文件夹拷贝到构建的输出目录</td>\n</tr>\n<tr>\n<td>extract-text-webpack-plugin</td>\n<td>抽离 css 样式,防止将样式打包在 js 中引起页面样式加载错乱的现象</td>\n</tr>\n<tr>\n<td>UglifyJsPlugin</td>\n<td>压缩js</td>\n</tr>\n<tr>\n<td>ZipWebpackPlugin</td>\n<td>将打包的出的资源生成一个zip包</td>\n</tr>\n<tr>\n<td>MiniCssExtractPlugin</td>\n<td>提取 JS 中引入的 CSS 打包到单独文件中，然后通过标签 <link>添加到头部</td>\n</tr>\n</tbody></table>\n<h3 id=\"使用-1\"><a href=\"#使用-1\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p>放在plugins数组中：</p>\n<pre><code>plugins: [\n        //moment这个库中，如果引用了./locale/目录的内容，就忽略掉，不会打包进去\n        new Webpack.IgnorePlugin(/\\.\\/locale/, /moment/),\n    ]\n</code></pre>\n<h2 id=\"mode\"><a href=\"#mode\" class=\"headerlink\" title=\"mode\"></a>mode</h2><p>用来指定当前node的构建环境，有三种类型的值:production,development,none。(webpack4)<br>可用webpack内置函数来设置。</p>\n<h3 id=\"选项描述\"><a href=\"#选项描述\" class=\"headerlink\" title=\"选项描述\"></a>选项描述</h3><table>\n<thead>\n<tr>\n<th>名称</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>development</td>\n<td>会将 DefinePlugin 中 process.env.NODE_ENV 的值设置为 development。启用 NamedChunksPlugin 和 NamedModulesPlugin</td>\n</tr>\n<tr>\n<td>production</td>\n<td>会将 DefinePlugin 中 process.env.NODE_ENV 的值设置为 production。启用 FlagDependencyUsagePlugin, FlagIncludedChunksPlugin, ModuleConcatenationPlugin, NoEmitOnErrorsPlugin, OccurrenceOrderPlugin, SideEffectsFlagPlugin 和 TerserPlugin。</td>\n</tr>\n<tr>\n<td>none</td>\n<td>不开启任何优化选项</td>\n</tr>\n</tbody></table>\n","more":"<h1 id=\"默认安装\"><a href=\"#默认安装\" class=\"headerlink\" title=\"默认安装\"></a>默认安装</h1><p>npm init -y</p>\n<h2 id=\"安装webpack相关\"><a href=\"#安装webpack相关\" class=\"headerlink\" title=\"安装webpack相关\"></a>安装webpack相关</h2><p>npm install webpack webpack-cli –save-dev</p>\n<h2 id=\"检查webpack版本-cd-node-modules-bin\"><a href=\"#检查webpack版本-cd-node-modules-bin\" class=\"headerlink\" title=\"检查webpack版本 cd node_modules/.bin\"></a>检查webpack版本 cd node_modules/.bin</h2><p>webpack -v</p>\n<h2 id=\"通过npm-stript运行webpack-否则只能在-bin下面执行\"><a href=\"#通过npm-stript运行webpack-否则只能在-bin下面执行\" class=\"headerlink\" title=\"通过npm stript运行webpack,否则只能在.bin下面执行\"></a>通过npm stript运行webpack,否则只能在.bin下面执行</h2><pre><code>package.json中添加 **build&quot;: &quot;webpack&quot;**</code></pre>\n<h1 id=\"核心概念\"><a href=\"#核心概念\" class=\"headerlink\" title=\"核心概念\"></a>核心概念</h1><h2 id=\"entry\"><a href=\"#entry\" class=\"headerlink\" title=\"entry\"></a>entry</h2><p>entry是webpack打包文件的入口。入口可以设置多个，比如多页面应用。两者的写法有差异，但入口接收一个字符串，多入口写成对象的形式。</p>\n<h3 id=\"单入口写法\"><a href=\"#单入口写法\" class=\"headerlink\" title=\"单入口写法\"></a>单入口写法</h3><pre><code>module.exports = &#123;\n    entry: &quot;./path/to/my/entry/file.js&quot;\n&#125;</code></pre>\n<h3 id=\"多入口写法\"><a href=\"#多入口写法\" class=\"headerlink\" title=\"多入口写法\"></a>多入口写法</h3><pre><code>module.exports = &#123;\n    entry: &#123;\n        app: &#39;./src/app.js&#39;,\n        adminApp: &#39;./src/adminApp.js&#39;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"output\"><a href=\"#output\" class=\"headerlink\" title=\"output\"></a>output</h2><p>output用来指定打包输出。多个文件的时候通过占位符做区分 ，比如[name]。</p>\n<pre><code>module.exports = &#123;\n    output: &#123;\n        filename: &#39;[name].js&#39;,\n        path: __dirname + &#39;/dist/\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"loader\"><a href=\"#loader\" class=\"headerlink\" title=\"loader\"></a>loader</h2><p>webpack原生只支持js,json两种文件类型，通过loader去支持其他文件类型并把他们转化成有效的模块，并添加到依赖图中。</p>\n<p>本身是一个函数，接受源文件作为参数，返回转换的结果。</p>\n<h3 id=\"常见的loader\"><a href=\"#常见的loader\" class=\"headerlink\" title=\"常见的loader\"></a>常见的loader</h3><table>\n<thead>\n<tr>\n<th>名称</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>babel-loader</td>\n<td>转换ES6等新特性语法</td>\n</tr>\n<tr>\n<td>css-loader</td>\n<td>.css文件的加载和解析</td>\n</tr>\n<tr>\n<td>less-loader</td>\n<td>将less文件转为css</td>\n</tr>\n<tr>\n<td>ts-loader</td>\n<td>将TS转为js</td>\n</tr>\n<tr>\n<td>file-loader</td>\n<td>进行字体，图片的打包</td>\n</tr>\n<tr>\n<td>raw-loader</td>\n<td>将文件以字符串的形式导入</td>\n</tr>\n<tr>\n<td>thread-loader</td>\n<td>多线程打包css，js</td>\n</tr>\n</tbody></table>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p>放在module中，test用来指定匹配规则，use指定使用的loader名称</p>\n<pre><code>module: &#123;\n        rules: [\n            &#123; test: /\\.txt$/, use: &#39;raw-loader&#39;&#125;\n        ]\n    &#125;</code></pre>\n<h2 id=\"plugins\"><a href=\"#plugins\" class=\"headerlink\" title=\"plugins\"></a>plugins</h2><p>插件用于bundle文件的优化，资源管理，环境变量的注入，作用于整个构建过程。loader没法做的事情，都是plugins来完成。</p>\n<h3 id=\"常见的plugins\"><a href=\"#常见的plugins\" class=\"headerlink\" title=\"常见的plugins\"></a>常见的plugins</h3><table>\n<thead>\n<tr>\n<th>名称</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>html-webpack-plugin</td>\n<td>创建html文件去承载输出的bundle</td>\n</tr>\n<tr>\n<td>clean-webpack-plugin</td>\n<td>用于在打包前清理上一次项目生成的 bundle 文件</td>\n</tr>\n<tr>\n<td>splitChunks</td>\n<td>提取被重复引入的文件，单独生成一个或多个文件，这样避免在多入口重复打包文件（替换CommonsChunkPlugin）</td>\n</tr>\n<tr>\n<td>copy-webpack-plugin</td>\n<td>将文件或文件夹拷贝到构建的输出目录</td>\n</tr>\n<tr>\n<td>extract-text-webpack-plugin</td>\n<td>抽离 css 样式,防止将样式打包在 js 中引起页面样式加载错乱的现象</td>\n</tr>\n<tr>\n<td>UglifyJsPlugin</td>\n<td>压缩js</td>\n</tr>\n<tr>\n<td>ZipWebpackPlugin</td>\n<td>将打包的出的资源生成一个zip包</td>\n</tr>\n<tr>\n<td>MiniCssExtractPlugin</td>\n<td>提取 JS 中引入的 CSS 打包到单独文件中，然后通过标签 <link>添加到头部</td>\n</tr>\n</tbody></table>\n<h3 id=\"使用-1\"><a href=\"#使用-1\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p>放在plugins数组中：</p>\n<pre><code>plugins: [\n        //moment这个库中，如果引用了./locale/目录的内容，就忽略掉，不会打包进去\n        new Webpack.IgnorePlugin(/\\.\\/locale/, /moment/),\n    ]\n</code></pre>\n<h2 id=\"mode\"><a href=\"#mode\" class=\"headerlink\" title=\"mode\"></a>mode</h2><p>用来指定当前node的构建环境，有三种类型的值:production,development,none。(webpack4)<br>可用webpack内置函数来设置。</p>\n<h3 id=\"选项描述\"><a href=\"#选项描述\" class=\"headerlink\" title=\"选项描述\"></a>选项描述</h3><table>\n<thead>\n<tr>\n<th>名称</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>development</td>\n<td>会将 DefinePlugin 中 process.env.NODE_ENV 的值设置为 development。启用 NamedChunksPlugin 和 NamedModulesPlugin</td>\n</tr>\n<tr>\n<td>production</td>\n<td>会将 DefinePlugin 中 process.env.NODE_ENV 的值设置为 production。启用 FlagDependencyUsagePlugin, FlagIncludedChunksPlugin, ModuleConcatenationPlugin, NoEmitOnErrorsPlugin, OccurrenceOrderPlugin, SideEffectsFlagPlugin 和 TerserPlugin。</td>\n</tr>\n<tr>\n<td>none</td>\n<td>不开启任何优化选项</td>\n</tr>\n</tbody></table>\n","categories":[{"name":"webpack专区","path":"api/categories/webpack专区.json"}],"tags":[{"name":"webpack","path":"api/tags/webpack.json"}]}