{"title":"webpack基础02-静态资源处理","slug":"webpack基础02-静态资源处理","date":"2020-12-08T00:24:49.000Z","updated":"2022-01-05T09:30:18.089Z","comments":true,"path":"api/articles/webpack基础02-静态资源处理.json","excerpt":null,"covers":null,"content":"<blockquote>\n<p>本文主要讲述样式文件，图片和字体资源的解析，html,css,js的压缩</p>\n</blockquote>\n<h2 id=\"解析css-sass-less\"><a href=\"#解析css-sass-less\" class=\"headerlink\" title=\"解析css,sass,less\"></a>解析css,sass,less</h2><p>css-loader: 用于加载.css文件，并且转换成commomjs对象<br>style-loader: 将样式通过<style>标签插入到head中<br>less-loader:将less转换成css</p>\n<pre><code>module: &#123;\n        rules: [\n            &#123; \n                test: /\\.css$/, \n                use: [\n                    &#39;style-loader&#39;,\n                    &#39;css-loader&#39;\n                ]\n            &#125;,\n            &#123; \n                test: /\\.less$/, \n                use: [\n                    &#39;style-loader&#39;,\n                    &#39;css-loader&#39;,\n                    &#39;less-loader&#39;\n                ]\n            &#125;\n        ]\n    &#125;</code></pre>\n<h2 id=\"图片和字体资源解析\"><a href=\"#图片和字体资源解析\" class=\"headerlink\" title=\"图片和字体资源解析\"></a>图片和字体资源解析</h2><p>file-loader: 用于处理图片和字体</p>\n<pre><code>module: &#123;\n        rules: [\n            &#123; \n                test: /\\.(png|svg|jpg|gif)$/, \n                use: [\n                    &#39;file-loader&#39;\n                ]\n            &#125;,\n            &#123; \n                test: /\\.(woff|woff2|eot|otf)$/, \n                use: [\n                    &#39;file-loader&#39;\n                ]\n            &#125;\n        ]\n    &#125;</code></pre>\n<p>url-loader： 也可以处理图片和字体，可以设置较小资源自动base64。</p>\n<pre><code>module: &#123;\n        rules: [\n            &#123; \n                test: /\\.(png|svg|jpg|gif)$/, \n                use: [&#123;\n                        loader: &#39;url-loader&#39;,\n                        options: &#123;\n                            limit: 10240\n                        &#125;\n                    &#125;]\n            &#125;\n        ]\n    &#125;</code></pre>\n<h2 id=\"html压缩\"><a href=\"#html压缩\" class=\"headerlink\" title=\"html压缩\"></a>html压缩</h2><p>html的压缩用’html-webpack-plugin’这个插件。</p>\n<pre><code>\nconst HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);\nmodule.exports = &#123;\n    ...\n\n    plugins: [\n        new HtmlWebpackPlugin(&#123;\n        title: &#39;Custom template&#39;,\n        template: &#39;./src/index.html&#39;, //指定要打包的html路径和文件名\n        filename:&#39;../index.html&#39; //指定输出路径和文件名\n      &#125;),\n    ]\n</code></pre>\n<h2 id=\"js文件压缩、\"><a href=\"#js文件压缩、\" class=\"headerlink\" title=\"js文件压缩、\"></a>js文件压缩、</h2><p>webpack 4之前的版本是通过webpack.optimize.CommonsChunkPlugin来压缩js，webpack 4版本之后被移除了，<br>webpack4内置了uglifyjs-webpack-plugin这个插件，所以默认打包后js已经压缩了。</p>\n<pre><code>\nvar UglifyJsPlugin = require(&#39;uglifyjs-webpack-plugin&#39;)\nvar OptimizeCssAssetsPlugin = require(&#39;optimize-css-assets-webpack-plugin&#39;)\n\nmodule.exports = &#123;\n  optimization: &#123;\n    minimizer: [\n      // 自定义js优化配置，将会覆盖默认配置\n      new UglifyJsPlugin(&#123;\n        exclude: /\\.min\\.js$/, // 过滤掉以&quot;.min.js&quot;结尾的文件，我们认为这个后缀本身就是已经压缩好的代码，没必要进行二次压缩\n        cache: true,\n        parallel: true, // 开启并行压缩，充分利用cpu\n        sourceMap: false,\n        extractComments: false, // 移除注释\n        uglifyOptions: &#123;\n          compress: &#123;\n            unused: true,\n            warnings: false,\n            drop_debugger: true\n          &#125;,\n          output: &#123;\n            comments: false\n          &#125;\n        &#125;\n      &#125;),\n      // 用于优化css文件\n      new OptimizeCssAssetsPlugin(&#123;\n        assetNameRegExp: /\\.css$/g,\n        cssProcessorOptions: &#123;\n          safe: true,\n          autoprefixer: &#123; disable: true &#125;, \n          discardComments: &#123;\n            removeAll: true // 移除注释\n          &#125;\n        &#125;,\n        canPrint: true\n      &#125;)\n    ]\n  &#125;\n&#125;\n</code></pre>\n<h2 id=\"css压缩\"><a href=\"#css压缩\" class=\"headerlink\" title=\"css压缩\"></a>css压缩</h2><p>css-loader在1.0以上版本没有了压缩配置，webpage4常用css压缩插件是’optimize-css-assets-webpack-plugin’，<br>需要配合安装css处理器’cssnano’。</p>\n<pre><code>const optimizeCss = require(&#39;optimize-css-assets-webpack-plugin&#39;);\n\nmodule.exports = &#123;\n\n    .....,\n    //\n    plugins: [\n        new optimizeCss(&#123;\n            assetNameRegExp: /\\.style\\.css$/g,\n            cssProcessor: require(&#39;cssnano&#39;),\n            cssProcessorOptions: &#123; discardComments: &#123; removeAll: true &#125; &#125;,\n            canPrint: true\n        &#125;),\n    ],\n&#125;</code></pre>\n<h2 id=\"补齐css3前缀\"><a href=\"#补齐css3前缀\" class=\"headerlink\" title=\"补齐css3前缀\"></a>补齐css3前缀</h2><p>利用postcss-loader和autoperfixer这两个插件</p>\n<pre><code>&#123;\n  test: /\\.css$/,\n  use: [\n    &#39;style-loader&#39;,\n    &#39;css-loader&#39;,\n    &#123;\n      loader: &#39;postcss-loader&#39;,\n      options: &#123;\n        plugins: [\n          require(&#39;autoprefixer&#39;)\n        ]\n      &#125;\n    &#125;\n  ]\n&#125;</code></pre>\n<h2 id=\"移动端中rem转换\"><a href=\"#移动端中rem转换\" class=\"headerlink\" title=\"移动端中rem转换\"></a>移动端中rem转换</h2><p>使用px2rem-loader + lib-flexiable</p>\n<pre><code>&#123;\n  test: /\\.css$/,\n  use: [\n    &#39;style-loader&#39;,\n    &#39;css-loader&#39;,\n    &#39;less-loader&#39;,\n    &#123;\n      loader: &#39;px2rem-loader&#39;,\n      options: &#123;\n        remUnit: 75,//这是rem适配的配置  注意： remUnit在这里要根据lib-flexible的规则来配制，如果您的设计稿是750px的，用75就刚刚好。\n        remPrecision: 8\n      &#125;\n    &#125;\n  ]\n&#125;</code></pre>\n</style></p>","more":"<blockquote>\n<p>本文主要讲述样式文件，图片和字体资源的解析，html,css,js的压缩</p>\n</blockquote>\n<h2 id=\"解析css-sass-less\"><a href=\"#解析css-sass-less\" class=\"headerlink\" title=\"解析css,sass,less\"></a>解析css,sass,less</h2><p>css-loader: 用于加载.css文件，并且转换成commomjs对象<br>style-loader: 将样式通过<style>标签插入到head中<br>less-loader:将less转换成css</p>\n<pre><code>module: &#123;\n        rules: [\n            &#123; \n                test: /\\.css$/, \n                use: [\n                    &#39;style-loader&#39;,\n                    &#39;css-loader&#39;\n                ]\n            &#125;,\n            &#123; \n                test: /\\.less$/, \n                use: [\n                    &#39;style-loader&#39;,\n                    &#39;css-loader&#39;,\n                    &#39;less-loader&#39;\n                ]\n            &#125;\n        ]\n    &#125;</code></pre>\n<h2 id=\"图片和字体资源解析\"><a href=\"#图片和字体资源解析\" class=\"headerlink\" title=\"图片和字体资源解析\"></a>图片和字体资源解析</h2><p>file-loader: 用于处理图片和字体</p>\n<pre><code>module: &#123;\n        rules: [\n            &#123; \n                test: /\\.(png|svg|jpg|gif)$/, \n                use: [\n                    &#39;file-loader&#39;\n                ]\n            &#125;,\n            &#123; \n                test: /\\.(woff|woff2|eot|otf)$/, \n                use: [\n                    &#39;file-loader&#39;\n                ]\n            &#125;\n        ]\n    &#125;</code></pre>\n<p>url-loader： 也可以处理图片和字体，可以设置较小资源自动base64。</p>\n<pre><code>module: &#123;\n        rules: [\n            &#123; \n                test: /\\.(png|svg|jpg|gif)$/, \n                use: [&#123;\n                        loader: &#39;url-loader&#39;,\n                        options: &#123;\n                            limit: 10240\n                        &#125;\n                    &#125;]\n            &#125;\n        ]\n    &#125;</code></pre>\n<h2 id=\"html压缩\"><a href=\"#html压缩\" class=\"headerlink\" title=\"html压缩\"></a>html压缩</h2><p>html的压缩用’html-webpack-plugin’这个插件。</p>\n<pre><code>\nconst HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);\nmodule.exports = &#123;\n    ...\n\n    plugins: [\n        new HtmlWebpackPlugin(&#123;\n        title: &#39;Custom template&#39;,\n        template: &#39;./src/index.html&#39;, //指定要打包的html路径和文件名\n        filename:&#39;../index.html&#39; //指定输出路径和文件名\n      &#125;),\n    ]\n</code></pre>\n<h2 id=\"js文件压缩、\"><a href=\"#js文件压缩、\" class=\"headerlink\" title=\"js文件压缩、\"></a>js文件压缩、</h2><p>webpack 4之前的版本是通过webpack.optimize.CommonsChunkPlugin来压缩js，webpack 4版本之后被移除了，<br>webpack4内置了uglifyjs-webpack-plugin这个插件，所以默认打包后js已经压缩了。</p>\n<pre><code>\nvar UglifyJsPlugin = require(&#39;uglifyjs-webpack-plugin&#39;)\nvar OptimizeCssAssetsPlugin = require(&#39;optimize-css-assets-webpack-plugin&#39;)\n\nmodule.exports = &#123;\n  optimization: &#123;\n    minimizer: [\n      // 自定义js优化配置，将会覆盖默认配置\n      new UglifyJsPlugin(&#123;\n        exclude: /\\.min\\.js$/, // 过滤掉以&quot;.min.js&quot;结尾的文件，我们认为这个后缀本身就是已经压缩好的代码，没必要进行二次压缩\n        cache: true,\n        parallel: true, // 开启并行压缩，充分利用cpu\n        sourceMap: false,\n        extractComments: false, // 移除注释\n        uglifyOptions: &#123;\n          compress: &#123;\n            unused: true,\n            warnings: false,\n            drop_debugger: true\n          &#125;,\n          output: &#123;\n            comments: false\n          &#125;\n        &#125;\n      &#125;),\n      // 用于优化css文件\n      new OptimizeCssAssetsPlugin(&#123;\n        assetNameRegExp: /\\.css$/g,\n        cssProcessorOptions: &#123;\n          safe: true,\n          autoprefixer: &#123; disable: true &#125;, \n          discardComments: &#123;\n            removeAll: true // 移除注释\n          &#125;\n        &#125;,\n        canPrint: true\n      &#125;)\n    ]\n  &#125;\n&#125;\n</code></pre>\n<h2 id=\"css压缩\"><a href=\"#css压缩\" class=\"headerlink\" title=\"css压缩\"></a>css压缩</h2><p>css-loader在1.0以上版本没有了压缩配置，webpage4常用css压缩插件是’optimize-css-assets-webpack-plugin’，<br>需要配合安装css处理器’cssnano’。</p>\n<pre><code>const optimizeCss = require(&#39;optimize-css-assets-webpack-plugin&#39;);\n\nmodule.exports = &#123;\n\n    .....,\n    //\n    plugins: [\n        new optimizeCss(&#123;\n            assetNameRegExp: /\\.style\\.css$/g,\n            cssProcessor: require(&#39;cssnano&#39;),\n            cssProcessorOptions: &#123; discardComments: &#123; removeAll: true &#125; &#125;,\n            canPrint: true\n        &#125;),\n    ],\n&#125;</code></pre>\n<h2 id=\"补齐css3前缀\"><a href=\"#补齐css3前缀\" class=\"headerlink\" title=\"补齐css3前缀\"></a>补齐css3前缀</h2><p>利用postcss-loader和autoperfixer这两个插件</p>\n<pre><code>&#123;\n  test: /\\.css$/,\n  use: [\n    &#39;style-loader&#39;,\n    &#39;css-loader&#39;,\n    &#123;\n      loader: &#39;postcss-loader&#39;,\n      options: &#123;\n        plugins: [\n          require(&#39;autoprefixer&#39;)\n        ]\n      &#125;\n    &#125;\n  ]\n&#125;</code></pre>\n<h2 id=\"移动端中rem转换\"><a href=\"#移动端中rem转换\" class=\"headerlink\" title=\"移动端中rem转换\"></a>移动端中rem转换</h2><p>使用px2rem-loader + lib-flexiable</p>\n<pre><code>&#123;\n  test: /\\.css$/,\n  use: [\n    &#39;style-loader&#39;,\n    &#39;css-loader&#39;,\n    &#39;less-loader&#39;,\n    &#123;\n      loader: &#39;px2rem-loader&#39;,\n      options: &#123;\n        remUnit: 75,//这是rem适配的配置  注意： remUnit在这里要根据lib-flexible的规则来配制，如果您的设计稿是750px的，用75就刚刚好。\n        remPrecision: 8\n      &#125;\n    &#125;\n  ]\n&#125;</code></pre>\n","categories":[{"name":"webpack专区","path":"api/categories/webpack专区.json"}],"tags":[{"name":"webpack","path":"api/tags/webpack.json"}]}