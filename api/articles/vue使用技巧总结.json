{"title":"vue使用小技巧总结","slug":"vue使用技巧总结","date":"2023-07-11T09:09:12.000Z","updated":"2023-08-07T07:26:36.711Z","comments":true,"path":"api/articles/vue使用技巧总结.json","excerpt":null,"covers":null,"content":"<h1 id=\"Watch-immediate\"><a href=\"#Watch-immediate\" class=\"headerlink\" title=\"Watch immediate\"></a>Watch immediate</h1><p>当 watch 一个变量的时候，初始化时并不会执行，如下面的例子，你需要在created的时候手动调用一次。</p>\n<pre><code>// bad\ncreated() {\n  this.fetchUserList();\n},\nwatch: {\n  searchText: 'fetchUserList',\n}\n</code></pre>\n<p>你可以添加immediate属性，这样初始化的时候也会触发，然后上面的代码就能简化为：</p>\n<pre><code>// good\nwatch: {\n  searchText: {\n    handler: 'fetchUserList',\n    immediate: true,\n  }\n}\n\n</code></pre>\n<p>watch 还有一个容易被大家忽略的属性deep。当设置为true时，它会进行深度监听。简而言之就是你有一个 const obj={a:1,b:2}，里面任意一个 key 的 value 发生变化的时候都会触发watch。应用场景：比如我有一个列表，它有一堆query筛选项，这时候你就能deep watch它，只有任何一个筛序项改变的时候，就自动请求新的数据。或者你可以deep watch一个 form 表单，当任何一个字段内容发生变化的时候，你就帮它做自动保存等等。</p>\n<h1 id=\"Attrs-和-Listeners\"><a href=\"#Attrs-和-Listeners\" class=\"headerlink\" title=\"Attrs 和 Listeners\"></a>Attrs 和 Listeners</h1><p>这两个属性是 vue 2.4 版本之后提供的，它简直是二次封装组件或者说写高阶组件的神器。<br>可以通过v-bind=”$attrs”：传递所有属性、v-on=”$listeners”传递所有方法</p>\n<h2 id=\"attrs\"><a href=\"#attrs\" class=\"headerlink\" title=\"$attrs\"></a>$attrs</h2><p>从父组件传给自定义子组件的属性，如果没有 prop 接收会自动设置到子组件内部的最外层标签上，如果是 class 和 style 的话，会合并最外层标签的 class 和 style。</p>\n<p>如果子组件中不想继承父组件传入的非 prop 属性，可以使用 inheritAttrs 禁用继承，然后通过 v-bind=”$attrs” 把外部传入的 非 prop 属性设置给希望的标签上，但是这不会改变 class 和 style。</p>\n<h2 id=\"inheritAttrs-属性\"><a href=\"#inheritAttrs-属性\" class=\"headerlink\" title=\"inheritAttrs 属性\"></a>inheritAttrs 属性</h2><p>默认情况下父作用域的不被认作 props 的 attribute 绑定 (attribute bindings) 将会“回退”且作为普通的 HTML attribute 应用在子组件的根元素上。当撰写包裹一个目标元素或另一个组件的组件时，这可能不会总是符合预期行为。通过设置 inheritAttrs 到 false，这些默认行为将会被去掉。而通过 (同样是 2.4 新增的) 实例 property $attrs 可以让这些 attribute 生效，且可以通过 v-bind 显性的绑定到非根元素上。</p>\n<p>注意：这个选项不影响 class 和 style 绑定。</p>\n<p>父组件:</p>\n<pre><code>&lt;template&gt;\n  &lt;my-input\n      required\n      placeholder=\"请输入内容\"\n      type=\"text\"\n      class=\"theme-dark\"\n  /&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nimport MyInput from './child'\nexport default {\n  name: 'parent',\n  components: {\n    MyInput\n  }\n}\n&lt;/script&gt;</code></pre>\n<p>子组件：</p>\n<pre><code>&lt;template&gt;\n  &lt;div&gt;\n    &lt;input\n        v-bind=\"$attrs\"\n        class=\"form-control\"\n    /&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default {\n  name: 'MyInput',\n  inheritAttrs: false\n}\n&lt;/script&gt;</code></pre>\n<h2 id=\"listeners\"><a href=\"#listeners\" class=\"headerlink\" title=\"$listeners\"></a>$listeners</h2><p>包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=”$listeners” 传入内部组件——在创建更高层次的组件时非常有用。</p>\n<p>父组件：</p>\n<pre><code>&lt;template&gt;\n  &lt;my-input\n      required\n      placeholder\n      class=\"theme-dark\"\n      @focue=\"onFocus\"\n      @input=\"onInput\"\n  &gt;\n  &lt;/my-input&gt;\n&lt;/template&gt;\n&lt;script&gt;\nimport MyInput from './child'\nexport default {\n  components: {\n    MyInput\n  },\n  methods: {\n    onFocus (e) {\n      console.log(e.target.value)\n    },\n    onInput (e) {\n      console.log(e.target.value)\n    }\n  }\n}\n&lt;/script&gt;</code></pre>\n<p>子组件：</p>\n<pre><code>&lt;template&gt;\n  &lt;div&gt;\n    &lt;input\n        type=\"text\"\n        v-bind=\"$attrs\"\n        class=\"form-control\"\n        @focus=\"$emit('focus', $event)\"\n        @input=\"$emit('input', $event)\"\n    /&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default {\n  name: 'MyInput',\n  inheritAttrs: false\n}\n&lt;/script&gt;</code></pre>\n<p>这样绑定原生事件很麻烦，每一个原生事件都需要绑定，但用v-on=”$listeners”就会省事很多</p>\n<pre><code> &lt;input\n        type=\"text\"\n        v-bind=\"$attrs\"\n        class=\"form-control\"\n+       v-on=\"$listeners\"\n-       @focus=\"$emit('focus', $event)\"\n-       @input=\"$emit('input', $event)\"\n    /&gt;</code></pre>\n<p>这样一行代码就能解决绑定所有的原生事件的问题。</p>\n<h1 id=\"sync\"><a href=\"#sync\" class=\"headerlink\" title=\".sync\"></a>.sync</h1><p>这个也是 vue 2.3 之后新加的一个语法糖。这也是平时在分装组件的时候很好用的一个语法糖，它的实现机制和v-model是一样的。</p>\n<p>父组件：</p>\n<pre><code>&lt;template&gt;\n  &lt;div class=\"app\"&gt;\n    App.vue 我现在有 {{ total }}\n    &lt;hr /&gt;\n    &lt;Child :money.sync=\"total\" /&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nimport Child from \"./Child.vue\";\nexport default {\n  data() {\n    return { total: 10000 };\n  },\n  components: { Child: Child },\n};\n&lt;/script&gt;</code></pre>\n<p>子组件：</p>\n<pre><code>&lt;template&gt;\n  &lt;div class=\"child\"&gt;\n    {{ money }}\n    &lt;button @click=\"$emit('update:money', money - 100)\"&gt;\n      &lt;span&gt;花钱&lt;/span&gt;\n    &lt;/button&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default {\n  props: [\"money\"],\n};\n&lt;/script&gt;</code></pre>\n<p><a href=\"https://codesandbox.io/s/white-glade-xhj86?file=/src/App.vue\">实例</a></p>\n<h1 id=\"Object-freeze\"><a href=\"#Object-freeze\" class=\"headerlink\" title=\"Object.freeze\"></a>Object.freeze</h1><p>我们遇到一些 big data的业务场景，它就很有用了。尤其是做管理后台的时候，经常会有一些超大数据量的 table，或者一个含有 n 多数据的图表，这种数据量很大的东西使用起来最明显的感受就是卡。但其实很多时候其实这些数据其实并不需要响应式变化，这时候你就可以使用 Object.freeze 方法了，它可以冻结一个对象。</p>\n<p>使用方式：</p>\n<pre><code>this.item = Object.freeze(Object.assign({}, this.item))\n</code></pre>\n","more":"<h1 id=\"Watch-immediate\"><a href=\"#Watch-immediate\" class=\"headerlink\" title=\"Watch immediate\"></a>Watch immediate</h1><p>当 watch 一个变量的时候，初始化时并不会执行，如下面的例子，你需要在created的时候手动调用一次。</p>\n<pre><code>// bad\ncreated() &#123;\n  this.fetchUserList();\n&#125;,\nwatch: &#123;\n  searchText: &#39;fetchUserList&#39;,\n&#125;\n</code></pre>\n<p>你可以添加immediate属性，这样初始化的时候也会触发，然后上面的代码就能简化为：</p>\n<pre><code>// good\nwatch: &#123;\n  searchText: &#123;\n    handler: &#39;fetchUserList&#39;,\n    immediate: true,\n  &#125;\n&#125;\n\n</code></pre>\n<p>watch 还有一个容易被大家忽略的属性deep。当设置为true时，它会进行深度监听。简而言之就是你有一个 const obj={a:1,b:2}，里面任意一个 key 的 value 发生变化的时候都会触发watch。应用场景：比如我有一个列表，它有一堆query筛选项，这时候你就能deep watch它，只有任何一个筛序项改变的时候，就自动请求新的数据。或者你可以deep watch一个 form 表单，当任何一个字段内容发生变化的时候，你就帮它做自动保存等等。</p>\n<h1 id=\"Attrs-和-Listeners\"><a href=\"#Attrs-和-Listeners\" class=\"headerlink\" title=\"Attrs 和 Listeners\"></a>Attrs 和 Listeners</h1><p>这两个属性是 vue 2.4 版本之后提供的，它简直是二次封装组件或者说写高阶组件的神器。<br>可以通过v-bind=”$attrs”：传递所有属性、v-on=”$listeners”传递所有方法</p>\n<h2 id=\"attrs\"><a href=\"#attrs\" class=\"headerlink\" title=\"$attrs\"></a>$attrs</h2><p>从父组件传给自定义子组件的属性，如果没有 prop 接收会自动设置到子组件内部的最外层标签上，如果是 class 和 style 的话，会合并最外层标签的 class 和 style。</p>\n<p>如果子组件中不想继承父组件传入的非 prop 属性，可以使用 inheritAttrs 禁用继承，然后通过 v-bind=”$attrs” 把外部传入的 非 prop 属性设置给希望的标签上，但是这不会改变 class 和 style。</p>\n<h2 id=\"inheritAttrs-属性\"><a href=\"#inheritAttrs-属性\" class=\"headerlink\" title=\"inheritAttrs 属性\"></a>inheritAttrs 属性</h2><p>默认情况下父作用域的不被认作 props 的 attribute 绑定 (attribute bindings) 将会“回退”且作为普通的 HTML attribute 应用在子组件的根元素上。当撰写包裹一个目标元素或另一个组件的组件时，这可能不会总是符合预期行为。通过设置 inheritAttrs 到 false，这些默认行为将会被去掉。而通过 (同样是 2.4 新增的) 实例 property $attrs 可以让这些 attribute 生效，且可以通过 v-bind 显性的绑定到非根元素上。</p>\n<p>注意：这个选项不影响 class 和 style 绑定。</p>\n<p>父组件:</p>\n<pre><code>&lt;template&gt;\n  &lt;my-input\n      required\n      placeholder=&quot;请输入内容&quot;\n      type=&quot;text&quot;\n      class=&quot;theme-dark&quot;\n  /&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nimport MyInput from &#39;./child&#39;\nexport default &#123;\n  name: &#39;parent&#39;,\n  components: &#123;\n    MyInput\n  &#125;\n&#125;\n&lt;/script&gt;</code></pre>\n<p>子组件：</p>\n<pre><code>&lt;template&gt;\n  &lt;div&gt;\n    &lt;input\n        v-bind=&quot;$attrs&quot;\n        class=&quot;form-control&quot;\n    /&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  name: &#39;MyInput&#39;,\n  inheritAttrs: false\n&#125;\n&lt;/script&gt;</code></pre>\n<h2 id=\"listeners\"><a href=\"#listeners\" class=\"headerlink\" title=\"$listeners\"></a>$listeners</h2><p>包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=”$listeners” 传入内部组件——在创建更高层次的组件时非常有用。</p>\n<p>父组件：</p>\n<pre><code>&lt;template&gt;\n  &lt;my-input\n      required\n      placeholder\n      class=&quot;theme-dark&quot;\n      @focue=&quot;onFocus&quot;\n      @input=&quot;onInput&quot;\n  &gt;\n  &lt;/my-input&gt;\n&lt;/template&gt;\n&lt;script&gt;\nimport MyInput from &#39;./child&#39;\nexport default &#123;\n  components: &#123;\n    MyInput\n  &#125;,\n  methods: &#123;\n    onFocus (e) &#123;\n      console.log(e.target.value)\n    &#125;,\n    onInput (e) &#123;\n      console.log(e.target.value)\n    &#125;\n  &#125;\n&#125;\n&lt;/script&gt;</code></pre>\n<p>子组件：</p>\n<pre><code>&lt;template&gt;\n  &lt;div&gt;\n    &lt;input\n        type=&quot;text&quot;\n        v-bind=&quot;$attrs&quot;\n        class=&quot;form-control&quot;\n        @focus=&quot;$emit(&#39;focus&#39;, $event)&quot;\n        @input=&quot;$emit(&#39;input&#39;, $event)&quot;\n    /&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  name: &#39;MyInput&#39;,\n  inheritAttrs: false\n&#125;\n&lt;/script&gt;</code></pre>\n<p>这样绑定原生事件很麻烦，每一个原生事件都需要绑定，但用v-on=”$listeners”就会省事很多</p>\n<pre><code> &lt;input\n        type=&quot;text&quot;\n        v-bind=&quot;$attrs&quot;\n        class=&quot;form-control&quot;\n+       v-on=&quot;$listeners&quot;\n-       @focus=&quot;$emit(&#39;focus&#39;, $event)&quot;\n-       @input=&quot;$emit(&#39;input&#39;, $event)&quot;\n    /&gt;</code></pre>\n<p>这样一行代码就能解决绑定所有的原生事件的问题。</p>\n<h1 id=\"sync\"><a href=\"#sync\" class=\"headerlink\" title=\".sync\"></a>.sync</h1><p>这个也是 vue 2.3 之后新加的一个语法糖。这也是平时在分装组件的时候很好用的一个语法糖，它的实现机制和v-model是一样的。</p>\n<p>父组件：</p>\n<pre><code>&lt;template&gt;\n  &lt;div class=&quot;app&quot;&gt;\n    App.vue 我现在有 &#123;&#123; total &#125;&#125;\n    &lt;hr /&gt;\n    &lt;Child :money.sync=&quot;total&quot; /&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nimport Child from &quot;./Child.vue&quot;;\nexport default &#123;\n  data() &#123;\n    return &#123; total: 10000 &#125;;\n  &#125;,\n  components: &#123; Child: Child &#125;,\n&#125;;\n&lt;/script&gt;</code></pre>\n<p>子组件：</p>\n<pre><code>&lt;template&gt;\n  &lt;div class=&quot;child&quot;&gt;\n    &#123;&#123; money &#125;&#125;\n    &lt;button @click=&quot;$emit(&#39;update:money&#39;, money - 100)&quot;&gt;\n      &lt;span&gt;花钱&lt;/span&gt;\n    &lt;/button&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  props: [&quot;money&quot;],\n&#125;;\n&lt;/script&gt;</code></pre>\n<p><a href=\"https://codesandbox.io/s/white-glade-xhj86?file=/src/App.vue\">实例</a></p>\n<h1 id=\"Object-freeze\"><a href=\"#Object-freeze\" class=\"headerlink\" title=\"Object.freeze\"></a>Object.freeze</h1><p>我们遇到一些 big data的业务场景，它就很有用了。尤其是做管理后台的时候，经常会有一些超大数据量的 table，或者一个含有 n 多数据的图表，这种数据量很大的东西使用起来最明显的感受就是卡。但其实很多时候其实这些数据其实并不需要响应式变化，这时候你就可以使用 Object.freeze 方法了，它可以冻结一个对象。</p>\n<p>使用方式：</p>\n<pre><code>this.item = Object.freeze(Object.assign(&#123;&#125;, this.item))\n</code></pre>\n","categories":[{"name":"VUE专题","path":"api/categories/VUE专题.json"}],"tags":[{"name":"vue","path":"api/tags/vue.json"}]}