{"title":"nginx实现灰度发布","slug":"nginx实现灰度发布","date":"2021-08-09T08:33:19.000Z","updated":"2022-01-05T09:29:14.028Z","comments":true,"path":"api/articles/nginx实现灰度发布.json","excerpt":null,"covers":null,"content":"<blockquote>\n<p>灰度发布（又名金丝雀发布，英文一般称为GrayRelease或Dark launch）是为了能够让用户逐步过渡到新功能一种发布方式。 一般是产品上线一个功能，希望在线上可以进行A/B testing，即让一部分用户继续用产品特性A，一部分用户开始用产品特性B，如果用户对B没有什么反对意见，那么逐步扩大范围，把所有用户都迁移到B上面来。</p>\n</blockquote>\n<p>优点:</p>\n<ul>\n<li>灰度发布可以保证整体系统的稳定，在初始灰度的时候就可以发现、调整问题，以保证其影响度。</li>\n<li>灰度发布可以让部分用户尽快体验到最新的功能，提高用户的积极性，进而收集用户反馈改善产品。</li>\n</ul>\n<p>灰度发布在谷歌和Facebook等很多公司已经使用的相当成熟，具体的分流规则也有很多，下面简单介绍下几种常见的分流规则，并分别使用nginx来配置实现。</p>\n<h2 id=\"基于COOKIE分流\"><a href=\"#基于COOKIE分流\" class=\"headerlink\" title=\"基于COOKIE分流\"></a>基于COOKIE分流</h2><p>使用Cookie分流的原理为：在用户首次登录时查询该用户是否是灰度用户，并为其设置标识Cookie，后续采用Cookie标识来进行分流。<br>本文采用dark字段作为标识，如果cookie中dark的值true则分流到灰度环境，其他情况则分流到生产环境。<br>在nginx的原生变量中，$http_cookie的值为所有Cookie以key=value的形式拼接，而$cookie_dark则只获得Cookie中dark的值。所以可以采用两种方式来判断：</p>\n<ul>\n<li>使用$http_cookie，则里面需要包含dark=true；</li>\n<li>使用$cookie_dark，则其值需要为true。</li>\n</ul>\n<p>最终nginx.conf文件中的核心配置如下：</p>\n<pre class=\" language-js\"><code class=\"language-js\">upstream normal <span class=\"token punctuation\">{</span>\n    server <span class=\"token number\">127.0</span><span class=\"token punctuation\">.</span><span class=\"token number\">0.1</span><span class=\"token punctuation\">:</span><span class=\"token number\">8080</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\nupstream dark <span class=\"token punctuation\">{</span>\n    server <span class=\"token number\">127.0</span><span class=\"token punctuation\">.</span><span class=\"token number\">0.1</span><span class=\"token punctuation\">:</span><span class=\"token number\">8081</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\nserver <span class=\"token punctuation\">{</span>\n    listen       <span class=\"token number\">80</span><span class=\"token punctuation\">;</span>\n    server_name  localhost<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">set</span> $group normal<span class=\"token punctuation\">;</span>\n    #或者使用 <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>$cookie_dark <span class=\"token operator\">~</span><span class=\"token operator\">*</span> <span class=\"token string\">\"^true&amp;\"</span><span class=\"token punctuation\">)</span> 来判断\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>$http_cookie <span class=\"token operator\">~</span><span class=\"token operator\">*</span> <span class=\"token string\">\"dark=true\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span> \n        <span class=\"token keyword\">set</span> $group dark<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    location <span class=\"token operator\">/</span> <span class=\"token punctuation\">{</span>\n        proxy_pass http<span class=\"token punctuation\">:</span><span class=\"token operator\">/</span><span class=\"token operator\">/</span>$group<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"基于Header分流\"><a href=\"#基于Header分流\" class=\"headerlink\" title=\"基于Header分流\"></a>基于Header分流</h2><p>基于Header分流的原理和用法都和Cookie类似。只有两点不同：</p>\n<ul>\n<li>– 获取灰度标识，使用的是$http_dark（即$http_header名）的写法；<br>Header不能像Cookie一样在客户端保留，所以一般是在多层网络中使用，即入口层给Header赋值，分流层再去分流。</li>\n</ul>\n<p>这里为了演示ngx_http_map_module的用法，使用了map替代了上面的set if判断方法。</p>\n<pre class=\" language-js\"><code class=\"language-js\">map $http_dark $group <span class=\"token punctuation\">{</span>\n    <span class=\"token operator\">~</span><span class=\"token operator\">*</span><span class=\"token boolean\">true</span>$ dark<span class=\"token punctuation\">;</span> \n    <span class=\"token keyword\">default</span> normal<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\nserver <span class=\"token punctuation\">{</span>\n    listen       <span class=\"token number\">80</span><span class=\"token punctuation\">;</span>\n    server_name  localhost<span class=\"token punctuation\">;</span>\n    location <span class=\"token operator\">/</span> <span class=\"token punctuation\">{</span>\n        proxy_pass http<span class=\"token punctuation\">:</span><span class=\"token operator\">/</span><span class=\"token operator\">/</span>$group<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h2 id=\"基于IP分流\"><a href=\"#基于IP分流\" class=\"headerlink\" title=\"基于IP分流\"></a>基于IP分流</h2><p>于IP分流原理：校验客户端的IP是否在我们的灰度IP列表中。<br>所以关键有两点：</p>\n<ul>\n<li>如何获取客户端IP？</li>\n<li>灰度IP列表怎么保存？其实可以保存在配置文件或数据库等任意地方。</li>\n</ul>\n<p>假设我们有一张mysql的表存着配置的所有需要分发到灰度的IP地址，如果请求的IP在表中能够查到的话，则分流到灰度环境。我们这边最简单的创建了一个表，并插入一条IP地址。</p>\n<pre class=\" language-js\"><code class=\"language-js\">CREATE TABLE <span class=\"token template-string\"><span class=\"token string\">`test`</span></span><span class=\"token punctuation\">.</span><span class=\"token template-string\"><span class=\"token string\">`dark_launch_ips`</span></span><span class=\"token punctuation\">(</span> <span class=\"token template-string\"><span class=\"token string\">`ip`</span></span> <span class=\"token function\">VARCHAR</span><span class=\"token punctuation\">(</span><span class=\"token number\">16</span><span class=\"token punctuation\">)</span> NOT NULL<span class=\"token punctuation\">,</span> PRIMARY KEY <span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token string\">`ip`</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \nINSERT INTO <span class=\"token template-string\"><span class=\"token string\">`test`</span></span><span class=\"token punctuation\">.</span><span class=\"token template-string\"><span class=\"token string\">`dark_launch_ips`</span></span> <span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token string\">`ip`</span></span><span class=\"token punctuation\">)</span> VALUES <span class=\"token punctuation\">(</span><span class=\"token string\">'1.1.1.1'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>本节使用了lua脚本来判断分流，在Nginx里面使用lua需要Nginx额外增加lua-nginx-module模块，或者直接使用打包好的OpenResty。为了演示，我们依然使用了两个location，只是不再使用upstrem，而是使用content_by_lua简单返回一个字符串，目的是能够在区分分流的前提下尽量简化其他细节，以突出核心逻辑。在Nginx中连接mysql的方法参考lua-resty-mysql模块。最终Nginx的核心配置如下：</p>\n<pre class=\" language-js\"><code class=\"language-js\">location @normal <span class=\"token punctuation\">{</span>\n    content_by_lua <span class=\"token string\">'ngx.say(\"normal\")'</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\nlocation @dark <span class=\"token punctuation\">{</span>\n    content_by_lua <span class=\"token string\">'ngx.say(\"dark\")'</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\nlocation <span class=\"token operator\">/</span>test <span class=\"token punctuation\">{</span>\n    access_by_lua '\n        local mysql <span class=\"token operator\">=</span> require <span class=\"token string\">\"resty.mysql\"</span>\n        local db<span class=\"token punctuation\">,</span> err <span class=\"token operator\">=</span> mysql<span class=\"token punctuation\">:</span><span class=\"token keyword\">new</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">if</span> not db then\n            ngx<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>ngx<span class=\"token punctuation\">.</span>ERR<span class=\"token punctuation\">,</span> <span class=\"token string\">\"failed to instantiate mysql: \"</span><span class=\"token punctuation\">,</span> err<span class=\"token punctuation\">)</span>\n            ngx<span class=\"token punctuation\">.</span><span class=\"token function\">exec</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"@normal\"</span><span class=\"token punctuation\">)</span>\n        end\n        local ok<span class=\"token punctuation\">,</span> err<span class=\"token punctuation\">,</span> errcode<span class=\"token punctuation\">,</span> sqlstate <span class=\"token operator\">=</span> db<span class=\"token punctuation\">:</span>connect <span class=\"token punctuation\">{</span>\n            host <span class=\"token operator\">=</span> <span class=\"token string\">\"127.0.0.1\"</span><span class=\"token punctuation\">,</span>\n            port <span class=\"token operator\">=</span> <span class=\"token number\">3306</span><span class=\"token punctuation\">,</span>\n            database <span class=\"token operator\">=</span> <span class=\"token string\">\"test\"</span><span class=\"token punctuation\">,</span>\n            user <span class=\"token operator\">=</span> <span class=\"token string\">\"root\"</span><span class=\"token punctuation\">,</span>\n            password <span class=\"token operator\">=</span> <span class=\"token string\">\"root\"</span><span class=\"token punctuation\">,</span>\n            charset <span class=\"token operator\">=</span> <span class=\"token string\">\"utf8\"</span><span class=\"token punctuation\">,</span>\n            max_packet_size <span class=\"token operator\">=</span> <span class=\"token number\">1024</span> <span class=\"token operator\">*</span> <span class=\"token number\">1024</span><span class=\"token punctuation\">,</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">if</span> not ok then\n            ngx<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>ngx<span class=\"token punctuation\">.</span>ERR<span class=\"token punctuation\">,</span> <span class=\"token string\">\"failed to connect: \"</span><span class=\"token punctuation\">,</span> err<span class=\"token punctuation\">,</span> <span class=\"token string\">\": \"</span><span class=\"token punctuation\">,</span> errcode<span class=\"token punctuation\">,</span> <span class=\"token string\">\" \"</span><span class=\"token punctuation\">,</span> sqlstate<span class=\"token punctuation\">)</span>\n            ngx<span class=\"token punctuation\">.</span><span class=\"token function\">exec</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"@normal\"</span><span class=\"token punctuation\">)</span>\n        end\n        <span class=\"token operator\">--</span> 以上代码是连接数据库操作，下面代码是获取IP并去数据库查询验证\n        local req_ip <span class=\"token operator\">=</span> ngx<span class=\"token punctuation\">.</span><span class=\"token keyword\">var</span><span class=\"token punctuation\">.</span>http_x_real_ip or ngx<span class=\"token punctuation\">.</span><span class=\"token keyword\">var</span><span class=\"token punctuation\">.</span>http_x_forwarded_for or ngx<span class=\"token punctuation\">.</span><span class=\"token keyword\">var</span><span class=\"token punctuation\">.</span>remote_addr or <span class=\"token string\">\"0.0.0.0\"</span>\n        local name <span class=\"token operator\">=</span> ngx<span class=\"token punctuation\">.</span><span class=\"token function\">unescape_uri</span><span class=\"token punctuation\">(</span>req_ip<span class=\"token punctuation\">)</span>\n        local quoted_name <span class=\"token operator\">=</span> ngx<span class=\"token punctuation\">.</span><span class=\"token function\">quote_sql_str</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span> <span class=\"token operator\">--</span> 防SQL注入\n        local res<span class=\"token punctuation\">,</span> err<span class=\"token punctuation\">,</span> errcode<span class=\"token punctuation\">,</span> sqlstate <span class=\"token operator\">=</span> db<span class=\"token punctuation\">:</span><span class=\"token function\">query</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"SELECT COUNT(*) AS cnt FROM dark_launch_ips WHERE ip = \"</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> quoted_name<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">if</span> not res then\n            ngx<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>ngx<span class=\"token punctuation\">.</span>ERR<span class=\"token punctuation\">,</span> <span class=\"token string\">\"bad result: \"</span><span class=\"token punctuation\">,</span> err<span class=\"token punctuation\">,</span> <span class=\"token string\">\": \"</span><span class=\"token punctuation\">,</span> errcode<span class=\"token punctuation\">,</span> <span class=\"token string\">\": \"</span><span class=\"token punctuation\">,</span> sqlstate<span class=\"token punctuation\">,</span> <span class=\"token string\">\".\"</span><span class=\"token punctuation\">)</span>\n            ngx<span class=\"token punctuation\">.</span><span class=\"token function\">exec</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"@normal\"</span><span class=\"token punctuation\">)</span>\n        end\n        <span class=\"token keyword\">if</span> <span class=\"token function\">tonumber</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token string\">\"cnt\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token number\">0</span> then\n            ngx<span class=\"token punctuation\">.</span><span class=\"token function\">exec</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"@dark\"</span><span class=\"token punctuation\">)</span>\n        end\n        ngx<span class=\"token punctuation\">.</span><span class=\"token function\">exec</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"@normal\"</span><span class=\"token punctuation\">)</span>\n    '<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h2 id=\"基于URL分流\"><a href=\"#基于URL分流\" class=\"headerlink\" title=\"基于URL分流\"></a>基于URL分流</h2><p>下面再介绍下URL分流，例如以下场景：如果url以dark结尾，则分流到灰度。本文继续使用一个新的模块ngx.balancer来做负载均衡。</p>\n<pre class=\" language-js\"><code class=\"language-js\">upstream balancer <span class=\"token punctuation\">{</span>\n    server <span class=\"token number\">0.0</span><span class=\"token punctuation\">.</span><span class=\"token number\">0.1</span><span class=\"token punctuation\">;</span>   # 这里写一个不存在的IP，作为占位填充\n    balancer_by_lua_block <span class=\"token punctuation\">{</span>\n        local balancer <span class=\"token operator\">=</span> require <span class=\"token string\">\"ngx.balancer\"</span>\n        <span class=\"token operator\">--</span> 下面一般是根据某些参数来计算要分流到哪里\n        local host <span class=\"token operator\">=</span> <span class=\"token string\">\"127.0.0.1\"</span>\n        local port <span class=\"token operator\">=</span> <span class=\"token number\">8080</span>\n        local m<span class=\"token punctuation\">,</span> err <span class=\"token operator\">=</span> ngx<span class=\"token punctuation\">.</span>re<span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span>ngx<span class=\"token punctuation\">.</span><span class=\"token keyword\">var</span><span class=\"token punctuation\">.</span>uri<span class=\"token punctuation\">,</span> <span class=\"token string\">\"dark$\"</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">if</span> m then\n            port <span class=\"token operator\">=</span> <span class=\"token number\">8081</span>\n        end\n        local ok<span class=\"token punctuation\">,</span> err <span class=\"token operator\">=</span> balancer<span class=\"token punctuation\">.</span><span class=\"token function\">set_current_peer</span><span class=\"token punctuation\">(</span>host<span class=\"token punctuation\">,</span> port<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">if</span> not ok then\n            ngx<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>ngx<span class=\"token punctuation\">.</span>ERR<span class=\"token punctuation\">,</span> <span class=\"token string\">\"failed to set the current peer: \"</span><span class=\"token punctuation\">,</span> err<span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">return</span> ngx<span class=\"token punctuation\">.</span><span class=\"token function\">exit</span><span class=\"token punctuation\">(</span><span class=\"token number\">500</span><span class=\"token punctuation\">)</span>\n        end\n    <span class=\"token punctuation\">}</span>\n\n    keepalive <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>  # connection pool\n<span class=\"token punctuation\">}</span></code></pre>\n<p>访问<a href=\"http://localhost/someurl-dark\">http://localhost/someurl-dark</a> 访问的是灰度节点；访问<a href=\"http://localhost/someurl\">http://localhost/someurl</a> 访问的是生产节点。</p>\n<h2 id=\"基于cookie访问不同的目录\"><a href=\"#基于cookie访问不同的目录\" class=\"headerlink\" title=\"基于cookie访问不同的目录\"></a>基于cookie访问不同的目录</h2><pre class=\" language-JS\"><code class=\"language-JS\">location / {\n    set $rooturl /xxx/xxx/xxx/xxx;\n    if ($http_cookie ~* \"key=value\") {\n         set $rooturl /selfWorkspace/xxx/xxx/xxx;\n    }\n    root   $rooturl;\n}</code></pre>\n<p>就是加个if判断即可，重新设置root 的路径即可，注意如果404的情况下可能是目录属组或者权限问题。</p>\n","more":"<blockquote>\n<p>灰度发布（又名金丝雀发布，英文一般称为GrayRelease或Dark launch）是为了能够让用户逐步过渡到新功能一种发布方式。 一般是产品上线一个功能，希望在线上可以进行A/B testing，即让一部分用户继续用产品特性A，一部分用户开始用产品特性B，如果用户对B没有什么反对意见，那么逐步扩大范围，把所有用户都迁移到B上面来。</p>\n</blockquote>\n<p>优点:</p>\n<ul>\n<li>灰度发布可以保证整体系统的稳定，在初始灰度的时候就可以发现、调整问题，以保证其影响度。</li>\n<li>灰度发布可以让部分用户尽快体验到最新的功能，提高用户的积极性，进而收集用户反馈改善产品。</li>\n</ul>\n<p>灰度发布在谷歌和Facebook等很多公司已经使用的相当成熟，具体的分流规则也有很多，下面简单介绍下几种常见的分流规则，并分别使用nginx来配置实现。</p>\n<h2 id=\"基于COOKIE分流\"><a href=\"#基于COOKIE分流\" class=\"headerlink\" title=\"基于COOKIE分流\"></a>基于COOKIE分流</h2><p>使用Cookie分流的原理为：在用户首次登录时查询该用户是否是灰度用户，并为其设置标识Cookie，后续采用Cookie标识来进行分流。<br>本文采用dark字段作为标识，如果cookie中dark的值true则分流到灰度环境，其他情况则分流到生产环境。<br>在nginx的原生变量中，$http_cookie的值为所有Cookie以key=value的形式拼接，而$cookie_dark则只获得Cookie中dark的值。所以可以采用两种方式来判断：</p>\n<ul>\n<li>使用$http_cookie，则里面需要包含dark=true；</li>\n<li>使用$cookie_dark，则其值需要为true。</li>\n</ul>\n<p>最终nginx.conf文件中的核心配置如下：</p>\n<pre><code class=\"js\">upstream normal &#123;\n    server 127.0.0.1:8080;\n&#125;\nupstream dark &#123;\n    server 127.0.0.1:8081;\n&#125;\nserver &#123;\n    listen       80;\n    server_name  localhost;\n    set $group normal;\n    #或者使用 if ($cookie_dark ~* &quot;^true&amp;&quot;) 来判断\n    if ($http_cookie ~* &quot;dark=true&quot;)&#123; \n        set $group dark;\n    &#125;\n\n    location / &#123;\n        proxy_pass http://$group;\n    &#125;\n&#125;</code></pre>\n<h2 id=\"基于Header分流\"><a href=\"#基于Header分流\" class=\"headerlink\" title=\"基于Header分流\"></a>基于Header分流</h2><p>基于Header分流的原理和用法都和Cookie类似。只有两点不同：</p>\n<ul>\n<li>– 获取灰度标识，使用的是$http_dark（即$http_header名）的写法；<br>Header不能像Cookie一样在客户端保留，所以一般是在多层网络中使用，即入口层给Header赋值，分流层再去分流。</li>\n</ul>\n<p>这里为了演示ngx_http_map_module的用法，使用了map替代了上面的set if判断方法。</p>\n<pre><code class=\"js\">map $http_dark $group &#123;\n    ~*true$ dark; \n    default normal;\n&#125;\nserver &#123;\n    listen       80;\n    server_name  localhost;\n    location / &#123;\n        proxy_pass http://$group;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"基于IP分流\"><a href=\"#基于IP分流\" class=\"headerlink\" title=\"基于IP分流\"></a>基于IP分流</h2><p>于IP分流原理：校验客户端的IP是否在我们的灰度IP列表中。<br>所以关键有两点：</p>\n<ul>\n<li>如何获取客户端IP？</li>\n<li>灰度IP列表怎么保存？其实可以保存在配置文件或数据库等任意地方。</li>\n</ul>\n<p>假设我们有一张mysql的表存着配置的所有需要分发到灰度的IP地址，如果请求的IP在表中能够查到的话，则分流到灰度环境。我们这边最简单的创建了一个表，并插入一条IP地址。</p>\n<pre><code class=\"js\">CREATE TABLE `test`.`dark_launch_ips`( `ip` VARCHAR(16) NOT NULL, PRIMARY KEY (`ip`) ); \nINSERT INTO `test`.`dark_launch_ips` (`ip`) VALUES (&#39;1.1.1.1&#39;);\n</code></pre>\n<p>本节使用了lua脚本来判断分流，在Nginx里面使用lua需要Nginx额外增加lua-nginx-module模块，或者直接使用打包好的OpenResty。为了演示，我们依然使用了两个location，只是不再使用upstrem，而是使用content_by_lua简单返回一个字符串，目的是能够在区分分流的前提下尽量简化其他细节，以突出核心逻辑。在Nginx中连接mysql的方法参考lua-resty-mysql模块。最终Nginx的核心配置如下：</p>\n<pre><code class=\"js\">location @normal &#123;\n    content_by_lua &#39;ngx.say(&quot;normal&quot;)&#39;;\n&#125;\nlocation @dark &#123;\n    content_by_lua &#39;ngx.say(&quot;dark&quot;)&#39;;\n&#125;\nlocation /test &#123;\n    access_by_lua &#39;\n        local mysql = require &quot;resty.mysql&quot;\n        local db, err = mysql:new()\n        if not db then\n            ngx.log(ngx.ERR, &quot;failed to instantiate mysql: &quot;, err)\n            ngx.exec(&quot;@normal&quot;)\n        end\n        local ok, err, errcode, sqlstate = db:connect &#123;\n            host = &quot;127.0.0.1&quot;,\n            port = 3306,\n            database = &quot;test&quot;,\n            user = &quot;root&quot;,\n            password = &quot;root&quot;,\n            charset = &quot;utf8&quot;,\n            max_packet_size = 1024 * 1024,\n        &#125;\n        if not ok then\n            ngx.log(ngx.ERR, &quot;failed to connect: &quot;, err, &quot;: &quot;, errcode, &quot; &quot;, sqlstate)\n            ngx.exec(&quot;@normal&quot;)\n        end\n        -- 以上代码是连接数据库操作，下面代码是获取IP并去数据库查询验证\n        local req_ip = ngx.var.http_x_real_ip or ngx.var.http_x_forwarded_for or ngx.var.remote_addr or &quot;0.0.0.0&quot;\n        local name = ngx.unescape_uri(req_ip)\n        local quoted_name = ngx.quote_sql_str(name) -- 防SQL注入\n        local res, err, errcode, sqlstate = db:query(&quot;SELECT COUNT(*) AS cnt FROM dark_launch_ips WHERE ip = &quot; .. quoted_name)\n        if not res then\n            ngx.log(ngx.ERR, &quot;bad result: &quot;, err, &quot;: &quot;, errcode, &quot;: &quot;, sqlstate, &quot;.&quot;)\n            ngx.exec(&quot;@normal&quot;)\n        end\n        if tonumber(res[1][&quot;cnt&quot;]) &gt; 0 then\n            ngx.exec(&quot;@dark&quot;)\n        end\n        ngx.exec(&quot;@normal&quot;)\n    &#39;;\n&#125;\n</code></pre>\n<h2 id=\"基于URL分流\"><a href=\"#基于URL分流\" class=\"headerlink\" title=\"基于URL分流\"></a>基于URL分流</h2><p>下面再介绍下URL分流，例如以下场景：如果url以dark结尾，则分流到灰度。本文继续使用一个新的模块ngx.balancer来做负载均衡。</p>\n<pre><code class=\"js\">upstream balancer &#123;\n    server 0.0.0.1;   # 这里写一个不存在的IP，作为占位填充\n    balancer_by_lua_block &#123;\n        local balancer = require &quot;ngx.balancer&quot;\n        -- 下面一般是根据某些参数来计算要分流到哪里\n        local host = &quot;127.0.0.1&quot;\n        local port = 8080\n        local m, err = ngx.re.match(ngx.var.uri, &quot;dark$&quot;)\n        if m then\n            port = 8081\n        end\n        local ok, err = balancer.set_current_peer(host, port)\n        if not ok then\n            ngx.log(ngx.ERR, &quot;failed to set the current peer: &quot;, err)\n            return ngx.exit(500)\n        end\n    &#125;\n\n    keepalive 10;  # connection pool\n&#125;</code></pre>\n<p>访问<a href=\"http://localhost/someurl-dark\">http://localhost/someurl-dark</a> 访问的是灰度节点；访问<a href=\"http://localhost/someurl\">http://localhost/someurl</a> 访问的是生产节点。</p>\n<h2 id=\"基于cookie访问不同的目录\"><a href=\"#基于cookie访问不同的目录\" class=\"headerlink\" title=\"基于cookie访问不同的目录\"></a>基于cookie访问不同的目录</h2><pre><code class=\"JS\">location / &#123;\n    set $rooturl /xxx/xxx/xxx/xxx;\n    if ($http_cookie ~* &quot;key=value&quot;) &#123;\n         set $rooturl /selfWorkspace/xxx/xxx/xxx;\n    &#125;\n    root   $rooturl;\n&#125;</code></pre>\n<p>就是加个if判断即可，重新设置root 的路径即可，注意如果404的情况下可能是目录属组或者权限问题。</p>\n","categories":[{"name":"nginx专题","path":"api/categories/nginx专题.json"}],"tags":[{"name":"nginx","path":"api/tags/nginx.json"}]}