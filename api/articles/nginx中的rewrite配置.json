{"title":"nginx中的rewrite配置","slug":"nginx中的rewrite配置","date":"2021-04-19T13:00:38.000Z","updated":"2022-01-05T09:29:17.168Z","comments":true,"path":"api/articles/nginx中的rewrite配置.json","excerpt":null,"covers":null,"content":"<h2 id=\"Rewrite-规则\"><a href=\"#Rewrite-规则\" class=\"headerlink\" title=\"Rewrite 规则\"></a>Rewrite 规则</h2><p>nginx 通过 ngx_http_rewrite_module 模块支持 URI 重写、支持 if 条件判断，但不支持 else，使用 nginx 提供的全局变量或自己设置的变量，结合正则表达式和标志位实现 url 重写以及重定向。</p>\n<p>rewrite 只能放在 *server{},location{},if{}*中，并且只能对域名后边的除去传递的参数外的字符串起作用，例如 <a href=\"http://seanlook.com/a/we/index.php?id=1&amp;u=str\">http://seanlook.com/a/we/index.php?id=1&amp;u=str</a> 只对/a/we/index.php 重写。</p>\n<blockquote>\n<p>语法: rewrite regex replacement [flag];</p>\n</blockquote>\n<p>如果相对域名或参数字符串起作用，可以使用全局变量匹配，也可以使用 proxy_pass 反向代理。</p>\n<h2 id=\"指令执行顺序\"><a href=\"#指令执行顺序\" class=\"headerlink\" title=\"指令执行顺序\"></a>指令执行顺序</h2><p>表明看 rewrite 和 location 功能有点像，都能实现跳转，主要区别在于 rewrite 是在同一域名内更改获取资源的路径，而 location 是对一类路径做控制访问或反向代理，可以 proxy_pass 到其他机器。很多情况下 rewrite 也会写在 location 里，它们的执行顺序是：</p>\n<ol>\n<li>执行 server 块的 rewrite 指令</li>\n<li>执行 location 匹配</li>\n<li>执行选定的 location 中的 rewrite 指令</li>\n</ol>\n<p>如果其中某步 URI 被重写，则重新循环执行 1-3，直到找到真实存在的文件；循环超过 10 次，则返回 500 Internal Server Error 错误。</p>\n<h2 id=\"flag-标志位\"><a href=\"#flag-标志位\" class=\"headerlink\" title=\"flag 标志位\"></a>flag 标志位</h2><ul>\n<li>last : 相当于 Apache 的[L]标记，表示完成 rewrite</li>\n<li>break : 停止执行当前虚拟主机的后续 rewrite 指令集</li>\n<li>redirect : 返回 302 临时重定向，地址栏会显示跳转后的地址</li>\n<li>permanent : 返回 301 永久重定向，地址栏会显示跳转后的地址</li>\n</ul>\n<p>因为 301 和 302 不能简单的只返回状态码，还必须有重定向的 URL，这就是 return 指令无法返回 301,302 的原因了。这里 last 和 break 区别有点难以理解：</p>\n<ol>\n<li>last 一般写在 server 和 if 中，而 break 一般使用在 location 中</li>\n<li>last 不终止重写后的 url 匹配，即新的 url 会再从 server 走一遍匹配流程，而 break 终止重写后的匹配</li>\n<li>break 和 last 都能组织继续执行后面的 rewrite 指令</li>\n</ol>\n<p>例子：</p>\n<pre class=\" language-js\"><code class=\"language-js\">\nrewrite <span class=\"token operator\">^</span><span class=\"token operator\">/</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">.</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> http<span class=\"token punctuation\">:</span><span class=\"token operator\">/</span><span class=\"token operator\">/</span>www<span class=\"token punctuation\">.</span>baidu<span class=\"token punctuation\">.</span>com<span class=\"token operator\">/</span>$<span class=\"token number\">1</span> permanent<span class=\"token punctuation\">;</span></code></pre>\n<p>说明：</p>\n<ul>\n<li>rewrite 为固定关键字，表示开始进行 rewrite 匹配规则。</li>\n<li>regex 为 ^/(.*)。 这是一个正则表达式，匹配完整的域名和后面的路径地址。</li>\n<li>replacement 就是 <a href=\"http://www.baidu.com/1%E8%BF%99%E5%9D%97%E4%BA%86%EF%BC%8C%E5%85%B6%E4%B8%AD1%E6%98%AF%E5%8F%96regex%E9%83%A8%E5%88%86()%E9%87%8C%E9%9D%A2%E7%9A%84%E5%86%85%E5%AE%B9%E3%80%82%E5%A6%82%E6%9E%9C%E5%8C%B9%E9%85%8D%E6%88%90%E5%8A%9F%E5%90%8E%E8%B7%B3%E8%BD%AC%E5%88%B0%E7%9A%84URL\">http://www.baidu.com/1这块了，其中1是取regex部分()里面的内容。如果匹配成功后跳转到的URL</a>。</li>\n<li>flag 就是 permanent，代表永久重定向的含义，即跳转到 <a href=\"http://www.baidu.com/$1\">http://www.baidu.com/$1</a> 地址上。</li>\n</ul>\n<h2 id=\"理解-if-指令\"><a href=\"#理解-if-指令\" class=\"headerlink\" title=\"理解 if 指令\"></a>理解 if 指令</h2><p>该指令用来支持条件判断的，并且根据条件判断结果来选择不同的 nginx 的配置，我们可以在 server 块或 location 块中配置该指令，它的语法结构为：</p>\n<pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>condition<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\" spellcheck=\"true\">// ....</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>比如如果用户代理是手机访问的话，直接跳转到某个页面去，也可以使用 if 判断。比如如下：</p>\n<pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span> $http_user_agent <span class=\"token operator\">~</span><span class=\"token operator\">*</span> <span class=\"token string\">\"(Android)|(iPhone)|(Mobile)|(WAP)|(UCWEB)\"</span> <span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  rewrite <span class=\"token operator\">^</span><span class=\"token operator\">/</span>$  http<span class=\"token punctuation\">:</span><span class=\"token operator\">/</span><span class=\"token operator\">/</span>www<span class=\"token punctuation\">.</span>cnblogs<span class=\"token punctuation\">.</span>com  permanent；\n<span class=\"token punctuation\">}</span></code></pre>\n<p>Rewrite 指令可用的全局变量如下：</p>\n<ol>\n<li>$args: 该变量中存放了请求 URL 中的请求指令。比如 <a href=\"http://127.0.0.1:3001/?arg1=value1&amp;arg2=value2\">http://127.0.0.1:3001?arg1=value1&amp;arg2=value2</a> 中的<br>“arg1=value1&amp;arg2=value2”。</li>\n<li>$content_length: 该变量中存放了请求头中的 Content-length 字段。</li>\n<li>$content_type: 该变量中存放了请求头中的 Content-type 字段。</li>\n<li>$document_root: 该变量中存放了针对当前请求的根路径。</li>\n<li>$document_uri: 该变量中存放了请求的当前 URI, 但是不包括请求指令。比如 <a href=\"http://xxx.abc.com/home/1?arg1=value1\">http://xxx.abc.com/home/1?arg1=value1</a>&amp;<br>arg2=value2; 中的 “/home/1”</li>\n<li>$host: 变量中存放了请求的 URL 中的主机部分字段，比如<a href=\"http://xxx.abc.com:8080/home\">http://xxx.abc.com:8080/home</a>中的 xxx.abc.com.</li>\n<li>$http_host: 该变量与$host 唯一区别带有端口号：比如上面的是 xxx.abc.com:8080</li>\n<li>$http_user_agent: 变量中存放客户端的代理信息。</li>\n<li>$http_cookie, 该变量中存放客户端的 cookie 信息。</li>\n<li>$remote_addr 该变量中存放客户端的地址。</li>\n<li>$remote_port 该变量中存放了客户端与服务器建立连接的端口号。</li>\n<li>$remote_user 变量中存放客户端的用户名。</li>\n<li>$request_body_file 变量中存放了发给后端服务器的本地文件资源的名称</li>\n<li>$request_method 变量中存放了客户端的请求方式，比如 ‘GET’、’POST’等。</li>\n<li>$request_filename 变量中存放了当前请求的资源文件的路径名。</li>\n<li>$request_uri 变量中存放了当前请求的 URI，并且带请求指令。</li>\n<li>$query_string 和变量$args 含义一样。</li>\n<li>$scheme 变量中存放了客户端请求使用的协议，比如 ‘http’, ‘https’等。</li>\n<li>$server_protocol 变量中存放了客户端请求协议的版本, 比如 ‘HTTP/1.0’、’HTTP/1.1’ 等。</li>\n</ol>\n<pre class=\" language-js\"><code class=\"language-js\">例：http<span class=\"token punctuation\">:</span><span class=\"token operator\">/</span><span class=\"token operator\">/</span>localhost<span class=\"token punctuation\">:</span><span class=\"token number\">88</span><span class=\"token operator\">/</span>test1<span class=\"token operator\">/</span>test2<span class=\"token operator\">/</span>test<span class=\"token punctuation\">.</span>php\n$host：localhost\n$server_port：<span class=\"token number\">88</span>\n$request_uri：http<span class=\"token punctuation\">:</span><span class=\"token operator\">/</span><span class=\"token operator\">/</span>localhost<span class=\"token punctuation\">:</span><span class=\"token number\">88</span><span class=\"token operator\">/</span>test1<span class=\"token operator\">/</span>test2<span class=\"token operator\">/</span>test<span class=\"token punctuation\">.</span>php\n$document_uri：<span class=\"token operator\">/</span>test1<span class=\"token operator\">/</span>test2<span class=\"token operator\">/</span>test<span class=\"token punctuation\">.</span>php\n$document_root：<span class=\"token operator\">/</span><span class=\"token keyword\">var</span><span class=\"token operator\">/</span>www<span class=\"token operator\">/</span>html\n$request_filename：<span class=\"token operator\">/</span><span class=\"token keyword\">var</span><span class=\"token operator\">/</span>www<span class=\"token operator\">/</span>html<span class=\"token operator\">/</span>test1<span class=\"token operator\">/</span>test2<span class=\"token operator\">/</span>test<span class=\"token punctuation\">.</span>php</code></pre>\n<p>现在我们使用if指令来对nginx加一些判断；比如说我们访问<a href=\"http://xxx.abc.com:8080/home%E6%97%B6%E5%80%99%EF%BC%8C%E5%A6%82%E6%9E%9C$host\">http://xxx.abc.com:8080/home时候，如果$host</a> = ‘xxx.abc.com’ 的时候，就做重定向跳转，nginx配置代码如下：</p>\n<pre class=\" language-js\"><code class=\"language-js\">server <span class=\"token punctuation\">{</span>\n  listen <span class=\"token number\">8088</span><span class=\"token punctuation\">;</span>\n  server_name xxx<span class=\"token punctuation\">.</span>abc<span class=\"token punctuation\">.</span>com<span class=\"token punctuation\">;</span>\n  location <span class=\"token operator\">/</span> <span class=\"token punctuation\">{</span>\n    proxy_pass http<span class=\"token punctuation\">:</span><span class=\"token operator\">/</span><span class=\"token operator\">/</span><span class=\"token number\">127.0</span><span class=\"token punctuation\">.</span><span class=\"token number\">0.1</span><span class=\"token punctuation\">:</span><span class=\"token number\">3001</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>$host <span class=\"token operator\">=</span> <span class=\"token string\">'xxx.abc.com'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      rewrite <span class=\"token operator\">^</span><span class=\"token operator\">/</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">.</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> http<span class=\"token punctuation\">:</span><span class=\"token operator\">/</span><span class=\"token operator\">/</span>www<span class=\"token punctuation\">.</span>baidu<span class=\"token punctuation\">.</span>com redirect<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"常用正则\"><a href=\"#常用正则\" class=\"headerlink\" title=\"常用正则\"></a>常用正则</h2><ul>\n<li><p>. ： 匹配除换行符以外的任意字符</p>\n</li>\n<li><p>? ： 重复 0 次或 1 次</p>\n</li>\n<li><p>+ ： 重复 1 次或更多次</p>\n</li>\n<li><p>* ： 重复 0 次或更多次</p>\n</li>\n<li><p>\\d ：匹配数字</p>\n</li>\n<li><p>^ ： 匹配字符串的开始</p>\n</li>\n<li><p>$ ： 匹配字符串的介绍</p>\n</li>\n<li><p>{n} ： 重复 n 次</p>\n</li>\n<li><p>{n,} ： 重复 n 次或更多次</p>\n</li>\n<li><p>[c] ： 匹配单个字符 c</p>\n</li>\n<li><p>[a-z] ： 匹配 a-z 小写字母的任意一个</p>\n<p>小括号()之间匹配的内容，可以在后面通过$1 来引用，$2 表示的是前面第二个()里的内容。正则里面容易让人困惑的是\\转义特殊字符。</p>\n</li>\n</ul>\n<h3 id=\"对变量进行匹配\"><a href=\"#对变量进行匹配\" class=\"headerlink\" title=\"对变量进行匹配\"></a>对变量进行匹配</h3><p>‘<del>‘ 表示匹配过程中对大小写敏感。<br>‘</del><em>‘ 表示匹配过程中对大小写不敏感。<br>‘!<del>‘ 如果 ‘</del>‘ 匹配失败时，那么该条件就为true。<br>‘!~</em>‘ 如果 ‘~*’ 匹配失败时，那么该条件就为true。</p>\n<p>比如如果用户代理是手机访问的话，直接跳转到某个页面去，也可以使用 if 判断。比如如下：</p>\n<pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span> $http_user_agent <span class=\"token operator\">~</span><span class=\"token operator\">*</span> <span class=\"token string\">\"(Android)|(iPhone)|(Mobile)|(WAP)|(UCWEB)\"</span> <span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  rewrite <span class=\"token operator\">^</span><span class=\"token operator\">/</span>$  http<span class=\"token punctuation\">:</span><span class=\"token operator\">/</span><span class=\"token operator\">/</span>www<span class=\"token punctuation\">.</span>cnblogs<span class=\"token punctuation\">.</span>com  permanent；\n<span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"判断请求的文件是否存在\"><a href=\"#判断请求的文件是否存在\" class=\"headerlink\" title=\"判断请求的文件是否存在\"></a>判断请求的文件是否存在</h3><p>-f’ 如果请求的文件存在，那么该条件为true。<br>‘!-f’ 如果该文件的目录存在，该文件不存在，那么返回true。如果该文件和目录都不存在，则为false。<br>如果请求的目录不存在，请求的文件存在，也为false。</p>\n<pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">-</span>f $request_filename<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 判断请求的文件是否存在</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token operator\">-</span>f $request_filename<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 判断请求的文件是否不存在</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"判断请求的目录是否存\"><a href=\"#判断请求的目录是否存\" class=\"headerlink\" title=\"判断请求的目录是否存\"></a>判断请求的目录是否存</h3><p>使用 ‘-d’，如果请求的目录存在，则返回true。否则返回false。<br>使用 ‘!-d’, 如果请求的目录不存在，但是该请求的上级目录存在，则返回true。如果该上级目录不存在，则返回false…. 等等其他一些语法，不多介绍。</p>\n","more":"<h2 id=\"Rewrite-规则\"><a href=\"#Rewrite-规则\" class=\"headerlink\" title=\"Rewrite 规则\"></a>Rewrite 规则</h2><p>nginx 通过 ngx_http_rewrite_module 模块支持 URI 重写、支持 if 条件判断，但不支持 else，使用 nginx 提供的全局变量或自己设置的变量，结合正则表达式和标志位实现 url 重写以及重定向。</p>\n<p>rewrite 只能放在 *server{},location{},if{}*中，并且只能对域名后边的除去传递的参数外的字符串起作用，例如 <a href=\"http://seanlook.com/a/we/index.php?id=1&amp;u=str\">http://seanlook.com/a/we/index.php?id=1&amp;u=str</a> 只对/a/we/index.php 重写。</p>\n<blockquote>\n<p>语法: rewrite regex replacement [flag];</p>\n</blockquote>\n<p>如果相对域名或参数字符串起作用，可以使用全局变量匹配，也可以使用 proxy_pass 反向代理。</p>\n<h2 id=\"指令执行顺序\"><a href=\"#指令执行顺序\" class=\"headerlink\" title=\"指令执行顺序\"></a>指令执行顺序</h2><p>表明看 rewrite 和 location 功能有点像，都能实现跳转，主要区别在于 rewrite 是在同一域名内更改获取资源的路径，而 location 是对一类路径做控制访问或反向代理，可以 proxy_pass 到其他机器。很多情况下 rewrite 也会写在 location 里，它们的执行顺序是：</p>\n<ol>\n<li>执行 server 块的 rewrite 指令</li>\n<li>执行 location 匹配</li>\n<li>执行选定的 location 中的 rewrite 指令</li>\n</ol>\n<p>如果其中某步 URI 被重写，则重新循环执行 1-3，直到找到真实存在的文件；循环超过 10 次，则返回 500 Internal Server Error 错误。</p>\n<h2 id=\"flag-标志位\"><a href=\"#flag-标志位\" class=\"headerlink\" title=\"flag 标志位\"></a>flag 标志位</h2><ul>\n<li>last : 相当于 Apache 的[L]标记，表示完成 rewrite</li>\n<li>break : 停止执行当前虚拟主机的后续 rewrite 指令集</li>\n<li>redirect : 返回 302 临时重定向，地址栏会显示跳转后的地址</li>\n<li>permanent : 返回 301 永久重定向，地址栏会显示跳转后的地址</li>\n</ul>\n<p>因为 301 和 302 不能简单的只返回状态码，还必须有重定向的 URL，这就是 return 指令无法返回 301,302 的原因了。这里 last 和 break 区别有点难以理解：</p>\n<ol>\n<li>last 一般写在 server 和 if 中，而 break 一般使用在 location 中</li>\n<li>last 不终止重写后的 url 匹配，即新的 url 会再从 server 走一遍匹配流程，而 break 终止重写后的匹配</li>\n<li>break 和 last 都能组织继续执行后面的 rewrite 指令</li>\n</ol>\n<p>例子：</p>\n<pre><code class=\"js\">\nrewrite ^/(.*) http://www.baidu.com/$1 permanent;</code></pre>\n<p>说明：</p>\n<ul>\n<li>rewrite 为固定关键字，表示开始进行 rewrite 匹配规则。</li>\n<li>regex 为 ^/(.*)。 这是一个正则表达式，匹配完整的域名和后面的路径地址。</li>\n<li>replacement 就是 <a href=\"http://www.baidu.com/1%E8%BF%99%E5%9D%97%E4%BA%86%EF%BC%8C%E5%85%B6%E4%B8%AD1%E6%98%AF%E5%8F%96regex%E9%83%A8%E5%88%86()%E9%87%8C%E9%9D%A2%E7%9A%84%E5%86%85%E5%AE%B9%E3%80%82%E5%A6%82%E6%9E%9C%E5%8C%B9%E9%85%8D%E6%88%90%E5%8A%9F%E5%90%8E%E8%B7%B3%E8%BD%AC%E5%88%B0%E7%9A%84URL\">http://www.baidu.com/1这块了，其中1是取regex部分()里面的内容。如果匹配成功后跳转到的URL</a>。</li>\n<li>flag 就是 permanent，代表永久重定向的含义，即跳转到 <a href=\"http://www.baidu.com/$1\">http://www.baidu.com/$1</a> 地址上。</li>\n</ul>\n<h2 id=\"理解-if-指令\"><a href=\"#理解-if-指令\" class=\"headerlink\" title=\"理解 if 指令\"></a>理解 if 指令</h2><p>该指令用来支持条件判断的，并且根据条件判断结果来选择不同的 nginx 的配置，我们可以在 server 块或 location 块中配置该指令，它的语法结构为：</p>\n<pre><code class=\"js\">if (condition) &#123;\n  // ....\n&#125;</code></pre>\n<p>比如如果用户代理是手机访问的话，直接跳转到某个页面去，也可以使用 if 判断。比如如下：</p>\n<pre><code class=\"js\">if ( $http_user_agent ~* &quot;(Android)|(iPhone)|(Mobile)|(WAP)|(UCWEB)&quot; )&#123;\n  rewrite ^/$  http://www.cnblogs.com  permanent；\n&#125;</code></pre>\n<p>Rewrite 指令可用的全局变量如下：</p>\n<ol>\n<li>$args: 该变量中存放了请求 URL 中的请求指令。比如 <a href=\"http://127.0.0.1:3001/?arg1=value1&amp;arg2=value2\">http://127.0.0.1:3001?arg1=value1&amp;arg2=value2</a> 中的<br>“arg1=value1&amp;arg2=value2”。</li>\n<li>$content_length: 该变量中存放了请求头中的 Content-length 字段。</li>\n<li>$content_type: 该变量中存放了请求头中的 Content-type 字段。</li>\n<li>$document_root: 该变量中存放了针对当前请求的根路径。</li>\n<li>$document_uri: 该变量中存放了请求的当前 URI, 但是不包括请求指令。比如 <a href=\"http://xxx.abc.com/home/1?arg1=value1\">http://xxx.abc.com/home/1?arg1=value1</a>&amp;<br>arg2=value2; 中的 “/home/1”</li>\n<li>$host: 变量中存放了请求的 URL 中的主机部分字段，比如<a href=\"http://xxx.abc.com:8080/home\">http://xxx.abc.com:8080/home</a>中的 xxx.abc.com.</li>\n<li>$http_host: 该变量与$host 唯一区别带有端口号：比如上面的是 xxx.abc.com:8080</li>\n<li>$http_user_agent: 变量中存放客户端的代理信息。</li>\n<li>$http_cookie, 该变量中存放客户端的 cookie 信息。</li>\n<li>$remote_addr 该变量中存放客户端的地址。</li>\n<li>$remote_port 该变量中存放了客户端与服务器建立连接的端口号。</li>\n<li>$remote_user 变量中存放客户端的用户名。</li>\n<li>$request_body_file 变量中存放了发给后端服务器的本地文件资源的名称</li>\n<li>$request_method 变量中存放了客户端的请求方式，比如 ‘GET’、’POST’等。</li>\n<li>$request_filename 变量中存放了当前请求的资源文件的路径名。</li>\n<li>$request_uri 变量中存放了当前请求的 URI，并且带请求指令。</li>\n<li>$query_string 和变量$args 含义一样。</li>\n<li>$scheme 变量中存放了客户端请求使用的协议，比如 ‘http’, ‘https’等。</li>\n<li>$server_protocol 变量中存放了客户端请求协议的版本, 比如 ‘HTTP/1.0’、’HTTP/1.1’ 等。</li>\n</ol>\n<pre><code class=\"js\">例：http://localhost:88/test1/test2/test.php\n$host：localhost\n$server_port：88\n$request_uri：http://localhost:88/test1/test2/test.php\n$document_uri：/test1/test2/test.php\n$document_root：/var/www/html\n$request_filename：/var/www/html/test1/test2/test.php</code></pre>\n<p>现在我们使用if指令来对nginx加一些判断；比如说我们访问<a href=\"http://xxx.abc.com:8080/home%E6%97%B6%E5%80%99%EF%BC%8C%E5%A6%82%E6%9E%9C$host\">http://xxx.abc.com:8080/home时候，如果$host</a> = ‘xxx.abc.com’ 的时候，就做重定向跳转，nginx配置代码如下：</p>\n<pre><code class=\"js\">server &#123;\n  listen 8088;\n  server_name xxx.abc.com;\n  location / &#123;\n    proxy_pass http://127.0.0.1:3001;\n    if ($host = &#39;xxx.abc.com&#39;) &#123;\n      rewrite ^/(.*) http://www.baidu.com redirect;\n    &#125;\n  &#125;\n&#125;</code></pre>\n<h2 id=\"常用正则\"><a href=\"#常用正则\" class=\"headerlink\" title=\"常用正则\"></a>常用正则</h2><ul>\n<li><p>. ： 匹配除换行符以外的任意字符</p>\n</li>\n<li><p>? ： 重复 0 次或 1 次</p>\n</li>\n<li><p>+ ： 重复 1 次或更多次</p>\n</li>\n<li><p>* ： 重复 0 次或更多次</p>\n</li>\n<li><p>\\d ：匹配数字</p>\n</li>\n<li><p>^ ： 匹配字符串的开始</p>\n</li>\n<li><p>$ ： 匹配字符串的介绍</p>\n</li>\n<li><p>{n} ： 重复 n 次</p>\n</li>\n<li><p>{n,} ： 重复 n 次或更多次</p>\n</li>\n<li><p>[c] ： 匹配单个字符 c</p>\n</li>\n<li><p>[a-z] ： 匹配 a-z 小写字母的任意一个</p>\n<p>小括号()之间匹配的内容，可以在后面通过$1 来引用，$2 表示的是前面第二个()里的内容。正则里面容易让人困惑的是\\转义特殊字符。</p>\n</li>\n</ul>\n<h3 id=\"对变量进行匹配\"><a href=\"#对变量进行匹配\" class=\"headerlink\" title=\"对变量进行匹配\"></a>对变量进行匹配</h3><p>‘<del>‘ 表示匹配过程中对大小写敏感。<br>‘</del><em>‘ 表示匹配过程中对大小写不敏感。<br>‘!<del>‘ 如果 ‘</del>‘ 匹配失败时，那么该条件就为true。<br>‘!~</em>‘ 如果 ‘~*’ 匹配失败时，那么该条件就为true。</p>\n<p>比如如果用户代理是手机访问的话，直接跳转到某个页面去，也可以使用 if 判断。比如如下：</p>\n<pre><code class=\"js\">if ( $http_user_agent ~* &quot;(Android)|(iPhone)|(Mobile)|(WAP)|(UCWEB)&quot; )&#123;\n  rewrite ^/$  http://www.cnblogs.com  permanent；\n&#125;</code></pre>\n<h3 id=\"判断请求的文件是否存在\"><a href=\"#判断请求的文件是否存在\" class=\"headerlink\" title=\"判断请求的文件是否存在\"></a>判断请求的文件是否存在</h3><p>-f’ 如果请求的文件存在，那么该条件为true。<br>‘!-f’ 如果该文件的目录存在，该文件不存在，那么返回true。如果该文件和目录都不存在，则为false。<br>如果请求的目录不存在，请求的文件存在，也为false。</p>\n<pre><code class=\"js\">if (-f $request_filename) &#123;\n  // 判断请求的文件是否存在\n&#125;\n\nif (!-f $request_filename) &#123;\n  // 判断请求的文件是否不存在\n&#125;</code></pre>\n<h3 id=\"判断请求的目录是否存\"><a href=\"#判断请求的目录是否存\" class=\"headerlink\" title=\"判断请求的目录是否存\"></a>判断请求的目录是否存</h3><p>使用 ‘-d’，如果请求的目录存在，则返回true。否则返回false。<br>使用 ‘!-d’, 如果请求的目录不存在，但是该请求的上级目录存在，则返回true。如果该上级目录不存在，则返回false…. 等等其他一些语法，不多介绍。</p>\n","categories":[{"name":"nginx专题","path":"api/categories/nginx专题.json"}],"tags":[{"name":"nginx","path":"api/tags/nginx.json"}]}