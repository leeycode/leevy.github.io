{"title":"TypeScript在vue项目中的应用","slug":"ts在vue项目中的应用","date":"2020-10-30T09:09:12.000Z","updated":"2022-01-05T09:27:34.199Z","comments":true,"path":"api/articles/ts在vue项目中的应用.json","excerpt":null,"covers":["https://7.dusays.com/2020/11/02/056c4d4f841cf.png"],"content":"<h1 id=\"1-引言\"><a href=\"#1-引言\" class=\"headerlink\" title=\"1 引言\"></a>1 引言</h1><p>TypeScript 是一种由微软开发的自由和开源的编程语言。它是 JavaScript 的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程。</p>\n<p>TypeScript 优势：</p>\n<ul>\n<li>静态类型检查与代码提示</li>\n<li>适用大型项目开发，如代码重构等</li>\n<li>更好的协作</li>\n<li>更强的生产力</li>\n</ul>\n<h1 id=\"2-ts语法知识\"><a href=\"#2-ts语法知识\" class=\"headerlink\" title=\"2 ts语法知识\"></a>2 ts语法知识</h1><h2 id=\"2-1类型系统\"><a href=\"#2-1类型系统\" class=\"headerlink\" title=\"2.1类型系统\"></a>2.1类型系统</h2><p><img src=\"https://7.dusays.com/2020/11/02/056c4d4f841cf.png\" alt=\"类型注解\"></p>\n<h2 id=\"2-2类型保护\"><a href=\"#2-2类型保护\" class=\"headerlink\" title=\"2.2类型保护\"></a>2.2类型保护</h2><blockquote>\n<p>类型保护是可执行运行时检查的一种表达式，用于确保该类型在一定的范围内。</p>\n</blockquote>\n<ol>\n<li>as 操作符（类型断言）<br>当你比 ts 更确定其数据类型，你能使用 as 语法确定其类型，但需要遵守类型兼容转换。 另外一种写法：<typename>varName，但不建议使用</typename></li>\n</ol>\n<pre><code>function getDynamicValue(): number | string | undefined {\n  ...\n}\n\nconst v = getDynamicValue(); // v:number|string|undefined，联合类型变量只允许访问所有类型共有的属性\n\n// 确定返回 string\n(v as string).trim();</code></pre>\n<ol start=\"2\">\n<li>typeof 操作符</li>\n</ol>\n<pre><code>function isNumber(val: any): val is number {\n  return typeof val === 'number';\n}\n\nconst a: any = 1;\n\nif (isNumber(a)) {\n  // a:number\n}</code></pre>\n<ol start=\"3\">\n<li>instanceof 操作符</li>\n</ol>\n<pre><code>class Base {\n  ...\n}\n\nclass A extends Base {\n  ...\n}\n\nconst inst: Base = new A();\n\nif (inst instanceof A) {\n  // inst:A\n}</code></pre>\n<ol start=\"4\">\n<li>函数或变量后面添加 !</li>\n</ol>\n<p>当要去掉联合类型的可空类型（null | undefined）,可以使用 js if 语句或短路运算符实现类型保护，也可以使用 Typescript 2.0+ !语法</p>\n<pre><code>const x: string | null = getDynamicValue();\n\n// if判断\nif (x) {\n  // x:string\n}\n// 短路运算符\nfunction f(sn: string | null) {\n  return sn || '';\n}\n// !语法\nx!.trim();\n// or\nconst r = [1, 2, 3, 4].find(x =&gt; x === 3)!; // r:number\n</code></pre>\n<h1 id=\"3-开发环境准备\"><a href=\"#3-开发环境准备\" class=\"headerlink\" title=\"3 开发环境准备\"></a>3 开发环境准备</h1><h2 id=\"3-1-插件安装\"><a href=\"#3-1-插件安装\" class=\"headerlink\" title=\"3.1 插件安装\"></a>3.1 插件安装</h2><h3 id=\"3-1-1-Webpack-转译-Typescript-现有方案\"><a href=\"#3-1-1-Webpack-转译-Typescript-现有方案\" class=\"headerlink\" title=\"3.1.1 Webpack 转译 Typescript 现有方案\"></a>3.1.1 Webpack 转译 Typescript 现有方案</h3><h4 id=\"1-ts-loader-babel-loader-fork-ts-checker-webpack-plugin\"><a href=\"#1-ts-loader-babel-loader-fork-ts-checker-webpack-plugin\" class=\"headerlink\" title=\"1.ts-loader + babel-loader + fork-ts-checker-webpack-plugin\"></a>1.ts-loader + babel-loader + fork-ts-checker-webpack-plugin</h4><p>修改 webpack.config.js 的配置：</p>\n<pre><code>{ \n    test: /\\.ts?$/, \n    loader: \"ts-loader\",\n    options: {\n        // .vue文件必须加\n        appendTsSuffixTo: [/\\.vue$/]\n    },\n    exclude:/node_modules/\n}\n</code></pre>\n<p>每次重建时，类型脚本的语义检查器必须检查所有文件,随着项目变得越来越大，编译时间线性增加。这时我们使用 fork-ts-checker-webpack-plugin 另外开一个线程来进行类型检查，安装依赖：</p>\n<pre><code>npm install -D fork-ts-checker-webpack-plugin\n//使用：\nconst ForkTsCheckerWebpackPlugin = require('fork-ts-checker-webpack-plugin');\nplugins:[\n    new ForkTsCheckerWebpackPlugin()\n]\n</code></pre>\n<ul>\n<li>这种方案，当 webpack 编译的时候，ts-loader 会调用 typescript（所以本地项目需要安装 typescript），然后 typescript 运行的时候会去读取本地的 tsconfig.json 文件。</li>\n<li>默认情况下，ts-loader 会进行 转译 和 类型检查，每当文件改动时，都会重新去 转译 和 类型检查，当文件很多的时候，就会特别慢，影响开发速度。所以需要使用 fork-ts-checker-webpack-plugin ，开辟一个单独的线程去执行类型检查的任务，这样就不会影响 webpack 重新编译的速度。</li>\n<li>fork-ts-checker-webpack-plugin  这个插件要求最低 Node.js 6.11.5，webpack 4，TypeScript 2.1 和可选的 ESLint 6（其本身要求最低 Node.js 8.10.0）。</li>\n</ul>\n<h4 id=\"2-babel-loader-babel-preset-typescript\"><a href=\"#2-babel-loader-babel-preset-typescript\" class=\"headerlink\" title=\"2. babel-loader + @babel/preset-typescript\"></a>2. babel-loader + @babel/preset-typescript</h4><p>修改webpack.config.js</p>\n<pre><code>rules: [\n        {\n          test:/\\.(tsx?|jsx?)$/,\n          // 默认会调用 @babel/core \n          use:'babel-loader'\n        }\n]</code></pre>\n<p>.babelrc</p>\n<pre><code>{\n    \"presets\": [\n        \"@babel/env\"\n        \"@vue/babel-preset-jsx\",\n        \"@babel/preset-typescript\"\n    ]\n}</code></pre>\n<ul>\n<li>这种方案，当 webpack 编译的时候，babel-loader 会读取 .babelrc 里的配置，不会调用 typescript（所以本地项目无需安装 typescript），不会去检查类型</li>\n<li> 需要配置tsconfig.json的，因为需要在开发代码时，让 idea 提示错误信息</li>\n</ul>\n<h2 id=\"3-2-ts项目基本构成\"><a href=\"#3-2-ts项目基本构成\" class=\"headerlink\" title=\"3.2 ts项目基本构成\"></a>3.2 ts项目基本构成</h2><p>一个vue+ts项目的目录结构（<a href=\"https://github.com/leeycode/typeScript-vue-starter/\">typeScript-vue-starter</a>）：</p>\n<pre><code>├── /@types/                     # 全局类型声明\n├── /build/                      # webpack配置文件\n├── /src/                        # 源码目录\n│ ├── /assets/                   # 静态资源目录\n│ ├── /components/               # 公共组件目录\n│ ├── /constants/                # 项目constants目录\n│ │ ├── _const.less              # less常量\n│ ├── /pages/                    # UI组件目录\n│ ├── /services/                 # 请求服务目录\n│ ├── /router/                   # 路由目录\n│ ├── /store/                    # 存放store文件目录\n│ ├── /style/                    # 全局样式\n│ ├── /utils/                    # utils目录\n│ │ ├── request.ts               # 基于fetch封装的API请求工具\n│ │ ├── global.ts                # 公共方法库\n│ └── main.ts                    # 项目入口\n|——tsconfig.json                 # ts配置\n|——...</code></pre>\n<h2 id=\"3-3-tsconfig-json\"><a href=\"#3-3-tsconfig-json\" class=\"headerlink\" title=\"3.3 tsconfig.json\"></a>3.3 tsconfig.json</h2><p>在项目根目录下，这个json文件规定了ts的编译选项，相见的编译选项配置：</p>\n<pre><code>{\n  \"compilerOptions\": {\n    \"baseUrl\": \".\",                             // 用于解析非相对模块名称的基目录\n    \"outDir\": \"build/dist\",                     // 指定输出目录\n    \"module\": \"esnext\",                         // 指定使用模块: 'commonjs', 'amd', 'system', 'umd' or 'es2015'\n    \"target\": \"es5\",                            // 指定 ECMAScript 目标版本:\n    \"lib\": [\"dom\", \"esnext\"],                   // 指定要包含在编译中的库文件\n    \"sourceMap\": true,                          // 生成相应的 '.map' 文件\n    \"allowJs\": true,                            // 允许编译 javascript 文件\n    \"jsx\": \"preserve\",                          // 指定 jsx 代码的生成: 'preserve', 'react-native'等\n    \"moduleResolution\": \"node\",                 // 选择模块解析策略： 'node' (Node.js) or 'classic'\n    \"strict\": true                              // 启用所有严格类型检查选项\n    ...\n\n  },\n  \"include\": [\"src/**/*\", \"@types/**/*\"],       // 编译包含的文件   \n  \"exclude\": [                                  // 排除的文件                \n    \"node_modules\",\n    \"build\",\n    \"scripts\",\n    \"acceptance-tests\",\n    \"webpack\",\n    \"jest\",\n    \"src/setupTests.ts\",\n    \"config\"\n  ]\n}\n</code></pre>\n<h2 id=\"3-4-声明文件\"><a href=\"#3-4-声明文件\" class=\"headerlink\" title=\"3.4 声明文件\"></a>3.4 声明文件</h2><h3 id=\"types\"><a href=\"#types\" class=\"headerlink\" title=\"@types\"></a>@types</h3><p>安装第三方库之前，我们可以<a href=\"https://microsoft.github.io/TypeSearch//\">搜索DefinitelyTyped</a>，查看是否有第三方在维护类型声明。通过@types安装，就能在项目中使用它的类型声明。</p>\n<pre><code>- Partial :把 interface 所有属性变成可选\n// node_modules/typescript/lib/lib.es5.d.ts,安装ts的时候生成\ntype Partial&lt;T&gt; = {\n    [P in keyof T]?: T[P];\n};\n\nchangeFilter: (filter: Partial&lt;IRequsetParams&gt;) =&gt; void;\n\n- Event\n// node_modules/@types/react/index.d.ts,通过@types安装react的时候生成\n  handleClick = (e: React.MouseEvent&lt;HTMLDivElement, MouseEvent&gt;) =&gt; {\n    e.stopPropagation();\n  };\n\n- RouteComponentProps:提供了 location、history 的类型定义\n// node_modules/@types/react-router/index.d.ts\nexport interface ILoginProps extends RouteComponentProps {\n  login: (values: IUser, history: H.History) =&gt; void;\n}</code></pre>\n<h3 id=\"自定义声明文件\"><a href=\"#自定义声明文件\" class=\"headerlink\" title=\"自定义声明文件\"></a>自定义声明文件</h3><p>扩展名.d.ts 结尾就是项目中的声明文件。在上面的项目中，我们创建了一个名为@types的文件夹，用来维护项目中需要的变量声明。</p>\n<ol>\n<li>全局变量声明<pre><code>// config\ndeclare const config: {\nversion: string;\nsystemName: string;\ndebug: boolean;\n...\n}\n// 约束后台返回的数据 \ndeclare interface IResponseBody&lt;T&gt; {\ndata: T;\ncode: number;\ntotal: number;\n}\n...</code></pre>\n</li>\n<li>非js资源</li>\n</ol>\n<pre><code>declare module '*.svg';\ndeclare module '*.png';\ndeclare module '*.jpg';\n\ndeclare module '*.module.css';\ndeclare module '*.module.scss' </code></pre>\n<h1 id=\"4-组件编写的几种方法\"><a href=\"#4-组件编写的几种方法\" class=\"headerlink\" title=\"4 组件编写的几种方法\"></a>4 组件编写的几种方法</h1><h2 id=\"4-1-Vue-extend\"><a href=\"#4-1-Vue-extend\" class=\"headerlink\" title=\"4.1 Vue.extend()\"></a>4.1 Vue.extend()</h2><blockquote>\n<p>Vue.extend():使用基础 Vue 构造器，创建一个“子类”。 这种方式最接近 Vue 的单文件组件的写法，如果一个完善 Vue 项目从 JS 改成 TS，用这种方法很快，只要加上 lang=ts和一些必要的变量类型就好了，然后用Vue.extend()包裹就好。</p>\n</blockquote>\n<p>main.js 改为 main.ts 内容改成：</p>\n<pre><code>import Vue from \"vue\";\nimport App from \"./App.vue\";\n\nnew Vue({\n    el:\"#app\",\n    render:h=&gt;h(App)\n});\n</code></pre>\n<p>组件写法：</p>\n<pre><code>&lt;template&gt;\n    &lt;h1&gt;{{name}}&lt;/h1&gt;\n&lt;/template&gt;\n&lt;script lang=\"ts\"&gt;\n//也执行tsx,也就是jsx语法\nimport Vue from \"vue\";\n\nexport default Vue.extend({\n    data(){\n        return {\n            name:'liwu'\n        }\n    }\n})\n&lt;/script&gt;\n&lt;style scoped&gt;\nh1{\n    color: rgb(55, 142, 230);\n}\n&lt;/style&gt;\n</code></pre>\n<h2 id=\"4-2-vue-class-component\"><a href=\"#4-2-vue-class-component\" class=\"headerlink\" title=\"4.2 vue-class-component\"></a>4.2 vue-class-component</h2><blockquote>\n<p>通常和vue-property-decorator一起搭配使用，，vue-property-decorator是在vue-class-component上扩展来的，并且提供了很多修饰器比如 @Prop和@Watch等等，使用这个可以编写类式组件。</p>\n</blockquote>\n<p>1.组件写法：</p>\n<pre><code>&lt;template&gt;\n    &lt;h1&gt;{{name}}&lt;/h1&gt;\n&lt;/template&gt;\n&lt;script lang=\"ts\"&gt;\n\nimport Vue from \"vue\";\nimport Component from 'vue-class-component';\n\n// @Component 装饰器使你的类成为Vue组件\n@Component\n\nexport default class App extends Vue {\n    private name:string = 'liwu';\n}\n\n&lt;/script&gt;\n&lt;style scoped&gt;\nh1{\n    color: rgb(55, 142, 230);\n}\n&lt;/style&gt;</code></pre>\n<p>修改tsconfig.js，支持装饰器语法</p>\n<pre><code>\"experimentalDecorators\": true,</code></pre>\n<h2 id=\"4-3-jsx\"><a href=\"#4-3-jsx\" class=\"headerlink\" title=\"4.3 jsx\"></a>4.3 jsx</h2><blockquote>\n<p>JSX is an XML-like syntax extension to ECMAScript without any defined semantics. It’s NOT intended to be implemented by engines or browsers.</p>\n</blockquote>\n<p>1.jsx语法简介（写react的同学跳过）</p>\n<ul>\n<li>严格的标签闭合</li>\n<li>组件名要大写，否则解析成html标签</li>\n<li>变量用{}</li>\n</ul>\n<pre><code>let name = 'xxx';\n&lt;div&gt;{ name }&lt;/div&gt;</code></pre>\n<ul>\n<li>遍历用map</li>\n</ul>\n<pre><code>let list = ['李一','李二','李三'];\n\n&lt;div&gt;\n    {list.map((item, index) =&gt; {\n    return &lt;p key={index}&gt;this is {item}&lt;/p&gt; \n    })} \n&lt;/div&gt; </code></pre>\n<ul>\n<li>条件判断</li>\n</ul>\n<pre><code>&lt;div className={styles.wrapper}&gt;\n    {_.isEmpty(currRecord) ? null : (\n      &lt;Graph\n        graph={{ nodes, edges }}\n        options={this.options}\n        events={this.events}\n      /&gt;\n    )}\n&lt;/div&gt; </code></pre>\n<ul>\n<li>事件要用驼峰写法，传参要用bind</li>\n</ul>\n<pre><code>&lt;div\n    className={styles.content}\n    onMouseEnter={this.showSwitch}\n    onMouseLeave={this.hideSwitch}\n    onClick={this.handleClick.bind(this,params)}\n&gt;\n&lt;/div&gt;</code></pre>\n<ul>\n<li>使用domPropsInnerHTML来替代v-html</li>\n</ul>\n<pre><code>&lt;div\n    domPropsInnerHTML={this.htmlContent}\n&gt;\n&lt;/div&gt;</code></pre>\n<p>2.组件写法</p>\n<pre><code>import { Vue, Component } from 'vue-property-decorator';\nimport { CreateElement } from 'vue';\n@Component\nexport default class JSX extends Vue {\n  private count: number = 0;\n  private showInfo() {\n    this.count++;\n  }\n\n  protected render(h: CreateElement) {\n    return &lt;h2 onMouseenter={this.showInfo}&gt;JSX Test{this.count}&lt;/h2&gt;;\n  }\n}\n</code></pre>\n<h1 id=\"5-class组件详细用法\"><a href=\"#5-class组件详细用法\" class=\"headerlink\" title=\"5 class组件详细用法\"></a>5 class组件详细用法</h1><h2 id=\"使用Data\"><a href=\"#使用Data\" class=\"headerlink\" title=\"使用Data\"></a>使用Data</h2><pre><code>@Component\nexport default class HelloWorld extends Vue {\n  private msg: string = \"welcome to my app\"\n  private list: Array&lt;object&gt; = [\n    {\n        name: 'Melody',\n        age: '20'\n    },\n    {\n        name: 'James',\n        age: '20'\n    }\n  ]\n}\n</code></pre>\n<p>与ts等效的js代码</p>\n<pre><code>export default {\n  data() {\n    return {\n      msg: \"welcome to my app\",\n      list: [\n        {\n          name: 'Melody',\n          age: '20'\n        },\n        {\n          name: 'James',\n          age: '20'\n        }\n      ]\n    }\n}\n</code></pre>\n<h2 id=\"使用props\"><a href=\"#使用props\" class=\"headerlink\" title=\"使用props\"></a>使用props</h2><p>可以添加 required, default, type 为props指定验证要求，同样也可以使用 readonly 禁止操作props</p>\n<pre><code>import { Component, Prop, Vue } from 'vue-property-decorator'\n@Component\nexport default class HelloWorld extends Vue {\n  @Prop() readonly msg!: string\n  @Prop({default: 'Joy Melody'}) readonly name: string\n  @Prop({required: true}) readonly age: number\n  @Prop({required: false, type: String, default: 'Developer'}) readonly job: string\n}\n</code></pre>\n<p>与ts等效的js代码如下</p>\n<pre><code>export default {\n  props: {\n    msg,\n    name: {\n      default: 'Joy Melody'\n    },\n    age: {\n      required: true,\n    },\n    address: {\n      type: String\n    },\n    job: {\n      required: false,\n      type: string,\n      default: 'Developer'\n    }\n  }\n}\n\n</code></pre>\n<h2 id=\"Computed-属性\"><a href=\"#Computed-属性\" class=\"headerlink\" title=\"Computed 属性\"></a>Computed 属性</h2><pre><code>export default class HelloWorld extends Vue {\n  get fullName(): string {\n    return this.first+ ' '+ this.last\n  }\n}</code></pre>\n<p>与ts等效的js代码如下</p>\n<pre><code>export default {\n  fullName() {\n    return this.first + ' ' + this.last\n  }\n}\n</code></pre>\n<p>复杂点的涉及到setter和getter的 computed属性，在ts中写法如下：</p>\n<pre><code>export default class HelloWorld extends Vue {\n  get fullName(): string {\n    return this.first+ ' '+ this.last\n  }\n  set fullName(newValue: string) {\n    let names = newValue.split(' ')\n    this.first = names[0]\n    this.last = names[names.length - 1]\n  }\n}\n</code></pre>\n<p>与ts等效的js写法如下</p>\n<pre><code>fullName: {\n  get: function () {\n    return this.first + ' ' + this.last\n  },\n  set: function (newValue) {\n    let names = newValue.split(' ')\n    this.first = names[0]\n    this.last = names[names.length - 1]\n  }\n}\n</code></pre>\n<h2 id=\"使用Watch\"><a href=\"#使用Watch\" class=\"headerlink\" title=\"使用Watch\"></a>使用Watch</h2><p>@Watch(path: string, options: WatchOptions = {}) </p>\n<ul>\n<li><p>@Watch 装饰器接收两个参数：path: string 被侦听的属性名<br>options?: WatchOptions={} options可以包含两个属性</p>\n</li>\n<li><p>immediate?:boolean 侦听开始之后是否立即调用该回调函数<br>deep?:boolean 被侦听的对象的属性被改变时，是否调用该回调函数</p>\n</li>\n</ul>\n<pre><code>@Watch('child')\nonChildChanged (val: string, oldVal: string) {\n    if (val !== oldVal) {\n      window.console.log(val)\n    }\n}\n</code></pre>\n<p>与ts等效的js代码如下</p>\n<pre><code>watch: {\n    'child': {\n        handler: 'onChildChanged',\n        immediate: false,\n        deep: false \n    }\n},\nmethod: {\n    onChildChanged(val, oldVal) {\n        if (val !== oldVal) {\n          console.log(val)\n        }\n    }\n}\n\n</code></pre>\n<p>也可以写成: @Watch(‘child’, { immediate: true, deep: true }), 等价于:</p>\n<pre><code>watch: {\n    'child': {\n        handler: 'onChildChanged',\n        immediate: true,\n        deep: true \n    }\n},\nmethod: {\n    onChildChanged(val, oldVal) {\n        if (val !== oldVal) {\n          window.console.log(val)\n        }\n    }\n}\n\n</code></pre>\n<h2 id=\"Methods\"><a href=\"#Methods\" class=\"headerlink\" title=\"Methods\"></a>Methods</h2><pre><code>export default class HelloWorld extends Vue {\n  public clickMe(): void {\n    console.log('clicked')\n    console.log(this.addNum(4, 2))\n  }\n  public addNum(num1: number, num2: number): number {\n    return num1 + num2\n  }\n}\n</code></pre>\n<p>与ts等效的js代码如下</p>\n<pre><code>export default {\n  methods: {\n    clickMe() {\n      console.log('clicked')\n      console.log(this.addNum(4, 2))\n    }\n    addNum(num1, num2) {\n      return num1 + num2\n    }\n  }\n}\n</code></pre>\n<h2 id=\"Emit\"><a href=\"#Emit\" class=\"headerlink\" title=\"Emit\"></a>Emit</h2><p>子组件触发父组件的自定义事件并传递数据，在TypeScript中使用@Emit 装饰器</p>\n<pre><code>import { Vue, Component, Emit } from 'vue-property-decorator'\n\n@Component\nexport default class YourComponent extends Vue {\n  count = 0\n\n  @Emit()\n  addToCount(n: number) {\n    this.count += n\n  }\n}\n</code></pre>\n<p>与ts等效的js代码如下</p>\n<pre><code>export default {\n  data() {\n    return {\n      count: 0\n    }\n  },\n  methods: {\n    addToCount(n) {\n      this.count += n\n      this.$emit('add-to-count', n)\n    }\n  }\n}\n</code></pre>\n<h2 id=\"Mixins\"><a href=\"#Mixins\" class=\"headerlink\" title=\"Mixins\"></a>Mixins</h2><p>假设当前已经有一个mixins/ProjectMixin文件 如何在其他组件里面使用方式如下</p>\n<pre><code>&lt;template&gt;\n  &lt;div class=\"project-detail\"&gt;\n    {{ projectDetail }}\n  &lt;/div&gt;\n&lt;/template&gt;\n&lt;script lang=\"ts\"&gt;\nimport { Component, Vue, Mixins } from 'vue-property-decorator'\nimport ProjectMixin from '@/mixins/ProjectMixin'\n@Component\nexport default class Project extends Mixins(ProjectMixin) {\n  get projectDetail(): string {\n    return this.projName + ' ' + 'HS'\n  }\n}\n&lt;/script&gt;\n</code></pre>\n<p>与ts等效的js代码如下</p>\n<pre><code>&lt;template&gt;\n  &lt;div class=\"project-detail\"&gt;\n    {{ projectDetail }}\n  &lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\nimport ProjectMixin from '@/mixins/ProjectMixin'\nexport default {\n  mixins: [ ProjectMixin ],\n  computed: {\n    projectDetail() {\n      return this.projName + ' ' + 'HS'\n    }\n  }\n}\n&lt;/script&gt;</code></pre>\n<p>多个混入的情况</p>\n<pre><code>import { Component, Mixins } from 'vue-property-decorator'\n\nexport default class Test extends Mixins(Mixin1, Mixin2) {\n    test() {\n      this.methodFromMixin2()\n      console.log(this.valFromMixin1)\n    }\n}\n</code></pre>\n<h2 id=\"refs\"><a href=\"#refs\" class=\"headerlink\" title=\"refs\"></a>refs</h2><p>ts无法识别vue中的$refs,需要手动指定其类型：</p>\n<pre><code>&lt;template&gt;\n  &lt;loading ref=\"loading\"/&gt;\n  &lt;input type=\"text\" ref=\"inputRef\"&gt;\n&lt;/template&gt;\n\n&lt;script lang=\"ts\"&gt;\nimport { Component } from 'vue-property-decorator'\nimport Loading from \"@/components/Loading.vue\";\n\n@Component({\n  components: { Loading }\n})\n\nexport default class Project extends Vue {\n $refs!: {\n    loading: Loading;\n    inputRef: HTMLInputElement;\n  };\n\n public mounted() {\n    this.$refs.loading.showLoading();\n    // (this.$refs.loading as Loading).showLoading();\n    this.$refs.inputRef.focus();\n  }\n}\n&lt;/script&gt;</code></pre>\n<h1 id=\"6-路由\"><a href=\"#6-路由\" class=\"headerlink\" title=\"6 路由\"></a>6 路由</h1><h2 id=\"路由创建\"><a href=\"#路由创建\" class=\"headerlink\" title=\"路由创建\"></a>路由创建</h2><pre><code>import Vue from 'vue';\nimport VueRouter, { RouteConfig } from 'vue-router';\nimport Home from '@/pages/home/Home.vue';\n\nVue.use(VueRouter);\n\nconst routes: Array&lt;RouteConfig&gt; = [\n  {\n    path: '/',\n    name: 'home',\n    component: Home\n  },\n  {\n    path: '/about',\n    name: 'about',\n    component: () =&gt; import(/* webpackChunkName: \"about\" */ '@/pages/about/About.vue')\n  }\n];\n\nconst router = new VueRouter({\n  routes\n});\n\nexport default router;\n</code></pre>\n<h2 id=\"组件中监听路由\"><a href=\"#组件中监听路由\" class=\"headerlink\" title=\"组件中监听路由\"></a>组件中监听路由</h2><pre><code>&lt;script lang=\"ts\"&gt;\nimport { Component, Vue, Watch } from 'vue-property-decorator';\nimport { Route } from 'vue-router';\n\n@Component\nexport default class About extends Vue {\n  @Watch('$route', { immediate: true })\n  private changeRouter(route: Route) {\n    console.log('route', route);\n  }\n}\n</code></pre>\n<h2 id=\"组件中使用路由勾子函数\"><a href=\"#组件中使用路由勾子函数\" class=\"headerlink\" title=\"组件中使用路由勾子函数\"></a>组件中使用路由勾子函数</h2><p>main.ts中：</p>\n<pre><code>import { Component } from 'vue-property-decorator';\n\nComponent.registerHooks([\n  'beforeRouteEnter',\n  'beforeRouteLeave',\n  'beforeRouteUpdate'\n]);\n</code></pre>\n<p>组件中：</p>\n<pre><code>&lt;script lang=\"ts\"&gt;\nimport { Component, Vue, Watch } from 'vue-property-decorator';\nimport { Route } from 'vue-router';\n\n@Component\nexport default class About extends Vue {\n\n  private beforeRouteEnter(to: Route, from: Route, next: () =&gt; void): void {\n    console.log('beforeRouteEnter', to, from, next);\n    next(); \n  }\n\n  private beforeRouteUpdate(to: Route, from: Route, next: () =&gt; void): void {\n    console.log('beforeRouteUpdate'); // 暂时不生效，版本问题\n    next();\n  }\n\n  private beforeRouteLeave(to: Route, from: Route, next: () =&gt; void): void {\n    console.log('beforeRouteLeave');\n    next();\n  }\n}</code></pre>\n<h1 id=\"7-数据请求\"><a href=\"#7-数据请求\" class=\"headerlink\" title=\"7 数据请求\"></a>7 数据请求</h1><p>对返回值和入参做类型约束：</p>\n<pre><code>// global.d.ts \ndeclare interface ResponseBody&lt;T&gt; {\n  data: T;\n  code: number;\n  total: number;\n}\ndeclare interface ResponseStatus {\n  loading: boolean;\n  error: boolean;\n}\ndeclare interface Response&lt;T&gt; extends ResponseStatus {\n  res: IResponseBody&lt;T&gt;;\n}\ndeclare interface ResponseNotPage&lt;T&gt; extends ResponseStatus {\n  data: T;\n}\ndeclare interface PageParams {\n  page: number;\n  pageSize: number;\n}\ndeclare interface RequsetParams extends PageParams {\n  search: string;\n}\n\n\n// src/service/demo.ts\nexport const getInfo = (id: number) =&gt;\n  request&lt;ResponseBody&lt;{ id: number; address?: string; time?: string }&gt;&gt;(\n    Api.GET_LAST_TRACE_INFO,\n    {\n      router: { id }\n    }\n  );</code></pre>\n<h1 id=\"8-全局状态管理\"><a href=\"#8-全局状态管理\" class=\"headerlink\" title=\"8 全局状态管理\"></a>8 全局状态管理</h1><h2 id=\"8-1-开始使用\"><a href=\"#8-1-开始使用\" class=\"headerlink\" title=\"8.1 开始使用\"></a>8.1 开始使用</h2><p>安装依赖</p>\n<pre><code>npm install vuex-module-decorators --save-dev</code></pre>\n<p>如果想通过名字空间的形式来使用module, 需在@Module装饰器中添加额外的参数. 例如, 以下示例代码中添加一个namespaced为home的module</p>\n<pre><code>// src\\store\\module\\home.ts\nimport { VuexModule, Module, Mutation, Action, getModule } from 'vuex-module-decorators';\nimport store from '@/store';\n\n@Module({ namespaced: true, dynamic: true, name: 'home', store })\n\nexport default class Home extends VuexModule {\n  public name: string = '';\n  public message: string = '';\n\n  get getMessage() {\n    return `当前时间${new Date()}：${this.message}`;\n  }\n\n  @Mutation\n  private SET_NAME(newName: string): void {\n    this.name = newName;\n  }\n\n  @Mutation\n  private SET_MESSAGE(message: string) {\n    this.message = message;\n  }\n\n  @Action\n  public updateMessage(newName: string): void {\n    this.SET_NAME(newName);\n    this.SET_MESSAGE('欢迎您,');\n  }\n}\n\nexport const HomeModule = getModule(Home);\n\n</code></pre>\n<p>与ts等效的js代码如下</p>\n<pre><code>const UserModule = {\n    state: {\n        name: '',\n        message: ''\n    },\n    getters: { \n        getMessage: state =&gt; `当前时间${new Date()}：${state.user.message}`\n    },\n    mutations: { \n        SET_NAME: (state, name) =&gt; {\n            state.name = name\n        },\n        SET_MESSAGE: (state, message) =&gt; {\n            state.message = message\n        }\n    },\n    actions: { \n        updateMessage({commit}, newName){\n            commit(\"SET_NAME\", newName);\n            commit(\"SET_MESSAGE\", \"欢迎您,\");\n        }\n    },\n\n}\n</code></pre>\n<p>dynamic模式下的store</p>\n<pre><code>// \\src\\store\\index.ts\nimport Vue from 'vue';\nimport Vuex from 'vuex';\n\nVue.use(Vuex);\n\n// Declare empty store first, dynamically register all modules later.\nexport default new Vuex.Store({});\n</code></pre>\n<p>组件中使用：</p>\n<pre><code>// \\src\\pages\\home\\Home.vue\n\n&lt;template&gt;\n  &lt;div class=\"home\"&gt;\n    &lt;img alt=\"Vue logo\" src=\"../../assets/logo.png\" /&gt;\n    &lt;hello-world msg=\"vue.js\" /&gt;\n    {{ $store.state.home.name }}\n    &lt;br/&gt;\n    {{ info }}\n    &lt;button @click=\"handleClick\"&gt;点击&lt;/button&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script lang=\"ts\"&gt;\nimport { Component, Vue } from 'vue-property-decorator';\nimport HelloWorld from '@/components/HelloWorld.vue';\nimport { HomeModule } from '@/store/modules/home';\n\n@Component({\n  components: {\n    HelloWorld\n  }\n})\nexport default class Home extends Vue {\n  get info() {\n    return HomeModule.getMessage;\n  }\n\n  private handleClick() {\n    HomeModule.updateMessage('liwu');\n  }\n}\n\n&lt;/script&gt;\n</code></pre>\n","more":"<h1 id=\"1-引言\"><a href=\"#1-引言\" class=\"headerlink\" title=\"1 引言\"></a>1 引言</h1><p>TypeScript 是一种由微软开发的自由和开源的编程语言。它是 JavaScript 的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程。</p>\n<p>TypeScript 优势：</p>\n<ul>\n<li>静态类型检查与代码提示</li>\n<li>适用大型项目开发，如代码重构等</li>\n<li>更好的协作</li>\n<li>更强的生产力</li>\n</ul>\n<h1 id=\"2-ts语法知识\"><a href=\"#2-ts语法知识\" class=\"headerlink\" title=\"2 ts语法知识\"></a>2 ts语法知识</h1><h2 id=\"2-1类型系统\"><a href=\"#2-1类型系统\" class=\"headerlink\" title=\"2.1类型系统\"></a>2.1类型系统</h2><p><img src=\"https://7.dusays.com/2020/11/02/056c4d4f841cf.png\" alt=\"类型注解\"></p>\n<h2 id=\"2-2类型保护\"><a href=\"#2-2类型保护\" class=\"headerlink\" title=\"2.2类型保护\"></a>2.2类型保护</h2><blockquote>\n<p>类型保护是可执行运行时检查的一种表达式，用于确保该类型在一定的范围内。</p>\n</blockquote>\n<ol>\n<li>as 操作符（类型断言）<br>当你比 ts 更确定其数据类型，你能使用 as 语法确定其类型，但需要遵守类型兼容转换。 另外一种写法：<typeName>varName，但不建议使用</li>\n</ol>\n<pre><code>function getDynamicValue(): number | string | undefined &#123;\n  ...\n&#125;\n\nconst v = getDynamicValue(); // v:number|string|undefined，联合类型变量只允许访问所有类型共有的属性\n\n// 确定返回 string\n(v as string).trim();</code></pre>\n<ol start=\"2\">\n<li>typeof 操作符</li>\n</ol>\n<pre><code>function isNumber(val: any): val is number &#123;\n  return typeof val === &#39;number&#39;;\n&#125;\n\nconst a: any = 1;\n\nif (isNumber(a)) &#123;\n  // a:number\n&#125;</code></pre>\n<ol start=\"3\">\n<li>instanceof 操作符</li>\n</ol>\n<pre><code>class Base &#123;\n  ...\n&#125;\n\nclass A extends Base &#123;\n  ...\n&#125;\n\nconst inst: Base = new A();\n\nif (inst instanceof A) &#123;\n  // inst:A\n&#125;</code></pre>\n<ol start=\"4\">\n<li>函数或变量后面添加 !</li>\n</ol>\n<p>当要去掉联合类型的可空类型（null | undefined）,可以使用 js if 语句或短路运算符实现类型保护，也可以使用 Typescript 2.0+ !语法</p>\n<pre><code>const x: string | null = getDynamicValue();\n\n// if判断\nif (x) &#123;\n  // x:string\n&#125;\n// 短路运算符\nfunction f(sn: string | null) &#123;\n  return sn || &#39;&#39;;\n&#125;\n// !语法\nx!.trim();\n// or\nconst r = [1, 2, 3, 4].find(x =&gt; x === 3)!; // r:number\n</code></pre>\n<h1 id=\"3-开发环境准备\"><a href=\"#3-开发环境准备\" class=\"headerlink\" title=\"3 开发环境准备\"></a>3 开发环境准备</h1><h2 id=\"3-1-插件安装\"><a href=\"#3-1-插件安装\" class=\"headerlink\" title=\"3.1 插件安装\"></a>3.1 插件安装</h2><h3 id=\"3-1-1-Webpack-转译-Typescript-现有方案\"><a href=\"#3-1-1-Webpack-转译-Typescript-现有方案\" class=\"headerlink\" title=\"3.1.1 Webpack 转译 Typescript 现有方案\"></a>3.1.1 Webpack 转译 Typescript 现有方案</h3><h4 id=\"1-ts-loader-babel-loader-fork-ts-checker-webpack-plugin\"><a href=\"#1-ts-loader-babel-loader-fork-ts-checker-webpack-plugin\" class=\"headerlink\" title=\"1.ts-loader + babel-loader + fork-ts-checker-webpack-plugin\"></a>1.ts-loader + babel-loader + fork-ts-checker-webpack-plugin</h4><p>修改 webpack.config.js 的配置：</p>\n<pre><code>&#123; \n    test: /\\.ts?$/, \n    loader: &quot;ts-loader&quot;,\n    options: &#123;\n        // .vue文件必须加\n        appendTsSuffixTo: [/\\.vue$/]\n    &#125;,\n    exclude:/node_modules/\n&#125;\n</code></pre>\n<p>每次重建时，类型脚本的语义检查器必须检查所有文件,随着项目变得越来越大，编译时间线性增加。这时我们使用 fork-ts-checker-webpack-plugin 另外开一个线程来进行类型检查，安装依赖：</p>\n<pre><code>npm install -D fork-ts-checker-webpack-plugin\n//使用：\nconst ForkTsCheckerWebpackPlugin = require(&#39;fork-ts-checker-webpack-plugin&#39;);\nplugins:[\n    new ForkTsCheckerWebpackPlugin()\n]\n</code></pre>\n<ul>\n<li>这种方案，当 webpack 编译的时候，ts-loader 会调用 typescript（所以本地项目需要安装 typescript），然后 typescript 运行的时候会去读取本地的 tsconfig.json 文件。</li>\n<li>默认情况下，ts-loader 会进行 转译 和 类型检查，每当文件改动时，都会重新去 转译 和 类型检查，当文件很多的时候，就会特别慢，影响开发速度。所以需要使用 fork-ts-checker-webpack-plugin ，开辟一个单独的线程去执行类型检查的任务，这样就不会影响 webpack 重新编译的速度。</li>\n<li>fork-ts-checker-webpack-plugin  这个插件要求最低 Node.js 6.11.5，webpack 4，TypeScript 2.1 和可选的 ESLint 6（其本身要求最低 Node.js 8.10.0）。</li>\n</ul>\n<h4 id=\"2-babel-loader-babel-preset-typescript\"><a href=\"#2-babel-loader-babel-preset-typescript\" class=\"headerlink\" title=\"2. babel-loader + @babel/preset-typescript\"></a>2. babel-loader + @babel/preset-typescript</h4><p>修改webpack.config.js</p>\n<pre><code>rules: [\n        &#123;\n          test:/\\.(tsx?|jsx?)$/,\n          // 默认会调用 @babel/core \n          use:&#39;babel-loader&#39;\n        &#125;\n]</code></pre>\n<p>.babelrc</p>\n<pre><code>&#123;\n    &quot;presets&quot;: [\n        &quot;@babel/env&quot;\n        &quot;@vue/babel-preset-jsx&quot;,\n        &quot;@babel/preset-typescript&quot;\n    ]\n&#125;</code></pre>\n<ul>\n<li>这种方案，当 webpack 编译的时候，babel-loader 会读取 .babelrc 里的配置，不会调用 typescript（所以本地项目无需安装 typescript），不会去检查类型</li>\n<li> 需要配置tsconfig.json的，因为需要在开发代码时，让 idea 提示错误信息</li>\n</ul>\n<h2 id=\"3-2-ts项目基本构成\"><a href=\"#3-2-ts项目基本构成\" class=\"headerlink\" title=\"3.2 ts项目基本构成\"></a>3.2 ts项目基本构成</h2><p>一个vue+ts项目的目录结构（<a href=\"https://github.com/leeycode/typeScript-vue-starter/\">typeScript-vue-starter</a>）：</p>\n<pre><code>├── /@types/                     # 全局类型声明\n├── /build/                      # webpack配置文件\n├── /src/                        # 源码目录\n│ ├── /assets/                   # 静态资源目录\n│ ├── /components/               # 公共组件目录\n│ ├── /constants/                # 项目constants目录\n│ │ ├── _const.less              # less常量\n│ ├── /pages/                    # UI组件目录\n│ ├── /services/                 # 请求服务目录\n│ ├── /router/                   # 路由目录\n│ ├── /store/                    # 存放store文件目录\n│ ├── /style/                    # 全局样式\n│ ├── /utils/                    # utils目录\n│ │ ├── request.ts               # 基于fetch封装的API请求工具\n│ │ ├── global.ts                # 公共方法库\n│ └── main.ts                    # 项目入口\n|——tsconfig.json                 # ts配置\n|——...</code></pre>\n<h2 id=\"3-3-tsconfig-json\"><a href=\"#3-3-tsconfig-json\" class=\"headerlink\" title=\"3.3 tsconfig.json\"></a>3.3 tsconfig.json</h2><p>在项目根目录下，这个json文件规定了ts的编译选项，相见的编译选项配置：</p>\n<pre><code>&#123;\n  &quot;compilerOptions&quot;: &#123;\n    &quot;baseUrl&quot;: &quot;.&quot;,                             // 用于解析非相对模块名称的基目录\n    &quot;outDir&quot;: &quot;build/dist&quot;,                     // 指定输出目录\n    &quot;module&quot;: &quot;esnext&quot;,                         // 指定使用模块: &#39;commonjs&#39;, &#39;amd&#39;, &#39;system&#39;, &#39;umd&#39; or &#39;es2015&#39;\n    &quot;target&quot;: &quot;es5&quot;,                            // 指定 ECMAScript 目标版本:\n    &quot;lib&quot;: [&quot;dom&quot;, &quot;esnext&quot;],                   // 指定要包含在编译中的库文件\n    &quot;sourceMap&quot;: true,                          // 生成相应的 &#39;.map&#39; 文件\n    &quot;allowJs&quot;: true,                            // 允许编译 javascript 文件\n    &quot;jsx&quot;: &quot;preserve&quot;,                          // 指定 jsx 代码的生成: &#39;preserve&#39;, &#39;react-native&#39;等\n    &quot;moduleResolution&quot;: &quot;node&quot;,                 // 选择模块解析策略： &#39;node&#39; (Node.js) or &#39;classic&#39;\n    &quot;strict&quot;: true                              // 启用所有严格类型检查选项\n    ...\n\n  &#125;,\n  &quot;include&quot;: [&quot;src/**/*&quot;, &quot;@types/**/*&quot;],       // 编译包含的文件   \n  &quot;exclude&quot;: [                                  // 排除的文件                \n    &quot;node_modules&quot;,\n    &quot;build&quot;,\n    &quot;scripts&quot;,\n    &quot;acceptance-tests&quot;,\n    &quot;webpack&quot;,\n    &quot;jest&quot;,\n    &quot;src/setupTests.ts&quot;,\n    &quot;config&quot;\n  ]\n&#125;\n</code></pre>\n<h2 id=\"3-4-声明文件\"><a href=\"#3-4-声明文件\" class=\"headerlink\" title=\"3.4 声明文件\"></a>3.4 声明文件</h2><h3 id=\"types\"><a href=\"#types\" class=\"headerlink\" title=\"@types\"></a>@types</h3><p>安装第三方库之前，我们可以<a href=\"https://microsoft.github.io/TypeSearch//\">搜索DefinitelyTyped</a>，查看是否有第三方在维护类型声明。通过@types安装，就能在项目中使用它的类型声明。</p>\n<pre><code>- Partial :把 interface 所有属性变成可选\n// node_modules/typescript/lib/lib.es5.d.ts,安装ts的时候生成\ntype Partial&lt;T&gt; = &#123;\n    [P in keyof T]?: T[P];\n&#125;;\n\nchangeFilter: (filter: Partial&lt;IRequsetParams&gt;) =&gt; void;\n\n- Event\n// node_modules/@types/react/index.d.ts,通过@types安装react的时候生成\n  handleClick = (e: React.MouseEvent&lt;HTMLDivElement, MouseEvent&gt;) =&gt; &#123;\n    e.stopPropagation();\n  &#125;;\n\n- RouteComponentProps:提供了 location、history 的类型定义\n// node_modules/@types/react-router/index.d.ts\nexport interface ILoginProps extends RouteComponentProps &#123;\n  login: (values: IUser, history: H.History) =&gt; void;\n&#125;</code></pre>\n<h3 id=\"自定义声明文件\"><a href=\"#自定义声明文件\" class=\"headerlink\" title=\"自定义声明文件\"></a>自定义声明文件</h3><p>扩展名.d.ts 结尾就是项目中的声明文件。在上面的项目中，我们创建了一个名为@types的文件夹，用来维护项目中需要的变量声明。</p>\n<ol>\n<li>全局变量声明<pre><code>// config\ndeclare const config: &#123;\nversion: string;\nsystemName: string;\ndebug: boolean;\n...\n&#125;\n// 约束后台返回的数据 \ndeclare interface IResponseBody&lt;T&gt; &#123;\ndata: T;\ncode: number;\ntotal: number;\n&#125;\n...</code></pre>\n</li>\n<li>非js资源</li>\n</ol>\n<pre><code>declare module &#39;*.svg&#39;;\ndeclare module &#39;*.png&#39;;\ndeclare module &#39;*.jpg&#39;;\n\ndeclare module &#39;*.module.css&#39;;\ndeclare module &#39;*.module.scss&#39; </code></pre>\n<h1 id=\"4-组件编写的几种方法\"><a href=\"#4-组件编写的几种方法\" class=\"headerlink\" title=\"4 组件编写的几种方法\"></a>4 组件编写的几种方法</h1><h2 id=\"4-1-Vue-extend\"><a href=\"#4-1-Vue-extend\" class=\"headerlink\" title=\"4.1 Vue.extend()\"></a>4.1 Vue.extend()</h2><blockquote>\n<p>Vue.extend():使用基础 Vue 构造器，创建一个“子类”。 这种方式最接近 Vue 的单文件组件的写法，如果一个完善 Vue 项目从 JS 改成 TS，用这种方法很快，只要加上 lang=ts和一些必要的变量类型就好了，然后用Vue.extend()包裹就好。</p>\n</blockquote>\n<p>main.js 改为 main.ts 内容改成：</p>\n<pre><code>import Vue from &quot;vue&quot;;\nimport App from &quot;./App.vue&quot;;\n\nnew Vue(&#123;\n    el:&quot;#app&quot;,\n    render:h=&gt;h(App)\n&#125;);\n</code></pre>\n<p>组件写法：</p>\n<pre><code>&lt;template&gt;\n    &lt;h1&gt;&#123;&#123;name&#125;&#125;&lt;/h1&gt;\n&lt;/template&gt;\n&lt;script lang=&quot;ts&quot;&gt;\n//也执行tsx,也就是jsx语法\nimport Vue from &quot;vue&quot;;\n\nexport default Vue.extend(&#123;\n    data()&#123;\n        return &#123;\n            name:&#39;liwu&#39;\n        &#125;\n    &#125;\n&#125;)\n&lt;/script&gt;\n&lt;style scoped&gt;\nh1&#123;\n    color: rgb(55, 142, 230);\n&#125;\n&lt;/style&gt;\n</code></pre>\n<h2 id=\"4-2-vue-class-component\"><a href=\"#4-2-vue-class-component\" class=\"headerlink\" title=\"4.2 vue-class-component\"></a>4.2 vue-class-component</h2><blockquote>\n<p>通常和vue-property-decorator一起搭配使用，，vue-property-decorator是在vue-class-component上扩展来的，并且提供了很多修饰器比如 @Prop和@Watch等等，使用这个可以编写类式组件。</p>\n</blockquote>\n<p>1.组件写法：</p>\n<pre><code>&lt;template&gt;\n    &lt;h1&gt;&#123;&#123;name&#125;&#125;&lt;/h1&gt;\n&lt;/template&gt;\n&lt;script lang=&quot;ts&quot;&gt;\n\nimport Vue from &quot;vue&quot;;\nimport Component from &#39;vue-class-component&#39;;\n\n// @Component 装饰器使你的类成为Vue组件\n@Component\n\nexport default class App extends Vue &#123;\n    private name:string = &#39;liwu&#39;;\n&#125;\n\n&lt;/script&gt;\n&lt;style scoped&gt;\nh1&#123;\n    color: rgb(55, 142, 230);\n&#125;\n&lt;/style&gt;</code></pre>\n<p>修改tsconfig.js，支持装饰器语法</p>\n<pre><code>&quot;experimentalDecorators&quot;: true,</code></pre>\n<h2 id=\"4-3-jsx\"><a href=\"#4-3-jsx\" class=\"headerlink\" title=\"4.3 jsx\"></a>4.3 jsx</h2><blockquote>\n<p>JSX is an XML-like syntax extension to ECMAScript without any defined semantics. It’s NOT intended to be implemented by engines or browsers.</p>\n</blockquote>\n<p>1.jsx语法简介（写react的同学跳过）</p>\n<ul>\n<li>严格的标签闭合</li>\n<li>组件名要大写，否则解析成html标签</li>\n<li>变量用{}</li>\n</ul>\n<pre><code>let name = &#39;xxx&#39;;\n&lt;div&gt;&#123; name &#125;&lt;/div&gt;</code></pre>\n<ul>\n<li>遍历用map</li>\n</ul>\n<pre><code>let list = [&#39;李一&#39;,&#39;李二&#39;,&#39;李三&#39;];\n\n&lt;div&gt;\n    &#123;list.map((item, index) =&gt; &#123;\n    return &lt;p key=&#123;index&#125;&gt;this is &#123;item&#125;&lt;/p&gt; \n    &#125;)&#125; \n&lt;/div&gt; </code></pre>\n<ul>\n<li>条件判断</li>\n</ul>\n<pre><code>&lt;div className=&#123;styles.wrapper&#125;&gt;\n    &#123;_.isEmpty(currRecord) ? null : (\n      &lt;Graph\n        graph=&#123;&#123; nodes, edges &#125;&#125;\n        options=&#123;this.options&#125;\n        events=&#123;this.events&#125;\n      /&gt;\n    )&#125;\n&lt;/div&gt; </code></pre>\n<ul>\n<li>事件要用驼峰写法，传参要用bind</li>\n</ul>\n<pre><code>&lt;div\n    className=&#123;styles.content&#125;\n    onMouseEnter=&#123;this.showSwitch&#125;\n    onMouseLeave=&#123;this.hideSwitch&#125;\n    onClick=&#123;this.handleClick.bind(this,params)&#125;\n&gt;\n&lt;/div&gt;</code></pre>\n<ul>\n<li>使用domPropsInnerHTML来替代v-html</li>\n</ul>\n<pre><code>&lt;div\n    domPropsInnerHTML=&#123;this.htmlContent&#125;\n&gt;\n&lt;/div&gt;</code></pre>\n<p>2.组件写法</p>\n<pre><code>import &#123; Vue, Component &#125; from &#39;vue-property-decorator&#39;;\nimport &#123; CreateElement &#125; from &#39;vue&#39;;\n@Component\nexport default class JSX extends Vue &#123;\n  private count: number = 0;\n  private showInfo() &#123;\n    this.count++;\n  &#125;\n\n  protected render(h: CreateElement) &#123;\n    return &lt;h2 onMouseenter=&#123;this.showInfo&#125;&gt;JSX Test&#123;this.count&#125;&lt;/h2&gt;;\n  &#125;\n&#125;\n</code></pre>\n<h1 id=\"5-class组件详细用法\"><a href=\"#5-class组件详细用法\" class=\"headerlink\" title=\"5 class组件详细用法\"></a>5 class组件详细用法</h1><h2 id=\"使用Data\"><a href=\"#使用Data\" class=\"headerlink\" title=\"使用Data\"></a>使用Data</h2><pre><code>@Component\nexport default class HelloWorld extends Vue &#123;\n  private msg: string = &quot;welcome to my app&quot;\n  private list: Array&lt;object&gt; = [\n    &#123;\n        name: &#39;Melody&#39;,\n        age: &#39;20&#39;\n    &#125;,\n    &#123;\n        name: &#39;James&#39;,\n        age: &#39;20&#39;\n    &#125;\n  ]\n&#125;\n</code></pre>\n<p>与ts等效的js代码</p>\n<pre><code>export default &#123;\n  data() &#123;\n    return &#123;\n      msg: &quot;welcome to my app&quot;,\n      list: [\n        &#123;\n          name: &#39;Melody&#39;,\n          age: &#39;20&#39;\n        &#125;,\n        &#123;\n          name: &#39;James&#39;,\n          age: &#39;20&#39;\n        &#125;\n      ]\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"使用props\"><a href=\"#使用props\" class=\"headerlink\" title=\"使用props\"></a>使用props</h2><p>可以添加 required, default, type 为props指定验证要求，同样也可以使用 readonly 禁止操作props</p>\n<pre><code>import &#123; Component, Prop, Vue &#125; from &#39;vue-property-decorator&#39;\n@Component\nexport default class HelloWorld extends Vue &#123;\n  @Prop() readonly msg!: string\n  @Prop(&#123;default: &#39;Joy Melody&#39;&#125;) readonly name: string\n  @Prop(&#123;required: true&#125;) readonly age: number\n  @Prop(&#123;required: false, type: String, default: &#39;Developer&#39;&#125;) readonly job: string\n&#125;\n</code></pre>\n<p>与ts等效的js代码如下</p>\n<pre><code>export default &#123;\n  props: &#123;\n    msg,\n    name: &#123;\n      default: &#39;Joy Melody&#39;\n    &#125;,\n    age: &#123;\n      required: true,\n    &#125;,\n    address: &#123;\n      type: String\n    &#125;,\n    job: &#123;\n      required: false,\n      type: string,\n      default: &#39;Developer&#39;\n    &#125;\n  &#125;\n&#125;\n\n</code></pre>\n<h2 id=\"Computed-属性\"><a href=\"#Computed-属性\" class=\"headerlink\" title=\"Computed 属性\"></a>Computed 属性</h2><pre><code>export default class HelloWorld extends Vue &#123;\n  get fullName(): string &#123;\n    return this.first+ &#39; &#39;+ this.last\n  &#125;\n&#125;</code></pre>\n<p>与ts等效的js代码如下</p>\n<pre><code>export default &#123;\n  fullName() &#123;\n    return this.first + &#39; &#39; + this.last\n  &#125;\n&#125;\n</code></pre>\n<p>复杂点的涉及到setter和getter的 computed属性，在ts中写法如下：</p>\n<pre><code>export default class HelloWorld extends Vue &#123;\n  get fullName(): string &#123;\n    return this.first+ &#39; &#39;+ this.last\n  &#125;\n  set fullName(newValue: string) &#123;\n    let names = newValue.split(&#39; &#39;)\n    this.first = names[0]\n    this.last = names[names.length - 1]\n  &#125;\n&#125;\n</code></pre>\n<p>与ts等效的js写法如下</p>\n<pre><code>fullName: &#123;\n  get: function () &#123;\n    return this.first + &#39; &#39; + this.last\n  &#125;,\n  set: function (newValue) &#123;\n    let names = newValue.split(&#39; &#39;)\n    this.first = names[0]\n    this.last = names[names.length - 1]\n  &#125;\n&#125;\n</code></pre>\n<h2 id=\"使用Watch\"><a href=\"#使用Watch\" class=\"headerlink\" title=\"使用Watch\"></a>使用Watch</h2><p>@Watch(path: string, options: WatchOptions = {}) </p>\n<ul>\n<li><p>@Watch 装饰器接收两个参数：path: string 被侦听的属性名<br>options?: WatchOptions={} options可以包含两个属性</p>\n</li>\n<li><p>immediate?:boolean 侦听开始之后是否立即调用该回调函数<br>deep?:boolean 被侦听的对象的属性被改变时，是否调用该回调函数</p>\n</li>\n</ul>\n<pre><code>@Watch(&#39;child&#39;)\nonChildChanged (val: string, oldVal: string) &#123;\n    if (val !== oldVal) &#123;\n      window.console.log(val)\n    &#125;\n&#125;\n</code></pre>\n<p>与ts等效的js代码如下</p>\n<pre><code>watch: &#123;\n    &#39;child&#39;: &#123;\n        handler: &#39;onChildChanged&#39;,\n        immediate: false,\n        deep: false \n    &#125;\n&#125;,\nmethod: &#123;\n    onChildChanged(val, oldVal) &#123;\n        if (val !== oldVal) &#123;\n          console.log(val)\n        &#125;\n    &#125;\n&#125;\n\n</code></pre>\n<p>也可以写成: @Watch(‘child’, { immediate: true, deep: true }), 等价于:</p>\n<pre><code>watch: &#123;\n    &#39;child&#39;: &#123;\n        handler: &#39;onChildChanged&#39;,\n        immediate: true,\n        deep: true \n    &#125;\n&#125;,\nmethod: &#123;\n    onChildChanged(val, oldVal) &#123;\n        if (val !== oldVal) &#123;\n          window.console.log(val)\n        &#125;\n    &#125;\n&#125;\n\n</code></pre>\n<h2 id=\"Methods\"><a href=\"#Methods\" class=\"headerlink\" title=\"Methods\"></a>Methods</h2><pre><code>export default class HelloWorld extends Vue &#123;\n  public clickMe(): void &#123;\n    console.log(&#39;clicked&#39;)\n    console.log(this.addNum(4, 2))\n  &#125;\n  public addNum(num1: number, num2: number): number &#123;\n    return num1 + num2\n  &#125;\n&#125;\n</code></pre>\n<p>与ts等效的js代码如下</p>\n<pre><code>export default &#123;\n  methods: &#123;\n    clickMe() &#123;\n      console.log(&#39;clicked&#39;)\n      console.log(this.addNum(4, 2))\n    &#125;\n    addNum(num1, num2) &#123;\n      return num1 + num2\n    &#125;\n  &#125;\n&#125;\n</code></pre>\n<h2 id=\"Emit\"><a href=\"#Emit\" class=\"headerlink\" title=\"Emit\"></a>Emit</h2><p>子组件触发父组件的自定义事件并传递数据，在TypeScript中使用@Emit 装饰器</p>\n<pre><code>import &#123; Vue, Component, Emit &#125; from &#39;vue-property-decorator&#39;\n\n@Component\nexport default class YourComponent extends Vue &#123;\n  count = 0\n\n  @Emit()\n  addToCount(n: number) &#123;\n    this.count += n\n  &#125;\n&#125;\n</code></pre>\n<p>与ts等效的js代码如下</p>\n<pre><code>export default &#123;\n  data() &#123;\n    return &#123;\n      count: 0\n    &#125;\n  &#125;,\n  methods: &#123;\n    addToCount(n) &#123;\n      this.count += n\n      this.$emit(&#39;add-to-count&#39;, n)\n    &#125;\n  &#125;\n&#125;\n</code></pre>\n<h2 id=\"Mixins\"><a href=\"#Mixins\" class=\"headerlink\" title=\"Mixins\"></a>Mixins</h2><p>假设当前已经有一个mixins/ProjectMixin文件 如何在其他组件里面使用方式如下</p>\n<pre><code>&lt;template&gt;\n  &lt;div class=&quot;project-detail&quot;&gt;\n    &#123;&#123; projectDetail &#125;&#125;\n  &lt;/div&gt;\n&lt;/template&gt;\n&lt;script lang=&quot;ts&quot;&gt;\nimport &#123; Component, Vue, Mixins &#125; from &#39;vue-property-decorator&#39;\nimport ProjectMixin from &#39;@/mixins/ProjectMixin&#39;\n@Component\nexport default class Project extends Mixins(ProjectMixin) &#123;\n  get projectDetail(): string &#123;\n    return this.projName + &#39; &#39; + &#39;HS&#39;\n  &#125;\n&#125;\n&lt;/script&gt;\n</code></pre>\n<p>与ts等效的js代码如下</p>\n<pre><code>&lt;template&gt;\n  &lt;div class=&quot;project-detail&quot;&gt;\n    &#123;&#123; projectDetail &#125;&#125;\n  &lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\nimport ProjectMixin from &#39;@/mixins/ProjectMixin&#39;\nexport default &#123;\n  mixins: [ ProjectMixin ],\n  computed: &#123;\n    projectDetail() &#123;\n      return this.projName + &#39; &#39; + &#39;HS&#39;\n    &#125;\n  &#125;\n&#125;\n&lt;/script&gt;</code></pre>\n<p>多个混入的情况</p>\n<pre><code>import &#123; Component, Mixins &#125; from &#39;vue-property-decorator&#39;\n\nexport default class Test extends Mixins(Mixin1, Mixin2) &#123;\n    test() &#123;\n      this.methodFromMixin2()\n      console.log(this.valFromMixin1)\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"refs\"><a href=\"#refs\" class=\"headerlink\" title=\"refs\"></a>refs</h2><p>ts无法识别vue中的$refs,需要手动指定其类型：</p>\n<pre><code>&lt;template&gt;\n  &lt;loading ref=&quot;loading&quot;/&gt;\n  &lt;input type=&quot;text&quot; ref=&quot;inputRef&quot;&gt;\n&lt;/template&gt;\n\n&lt;script lang=&quot;ts&quot;&gt;\nimport &#123; Component &#125; from &#39;vue-property-decorator&#39;\nimport Loading from &quot;@/components/Loading.vue&quot;;\n\n@Component(&#123;\n  components: &#123; Loading &#125;\n&#125;)\n\nexport default class Project extends Vue &#123;\n $refs!: &#123;\n    loading: Loading;\n    inputRef: HTMLInputElement;\n  &#125;;\n\n public mounted() &#123;\n    this.$refs.loading.showLoading();\n    // (this.$refs.loading as Loading).showLoading();\n    this.$refs.inputRef.focus();\n  &#125;\n&#125;\n&lt;/script&gt;</code></pre>\n<h1 id=\"6-路由\"><a href=\"#6-路由\" class=\"headerlink\" title=\"6 路由\"></a>6 路由</h1><h2 id=\"路由创建\"><a href=\"#路由创建\" class=\"headerlink\" title=\"路由创建\"></a>路由创建</h2><pre><code>import Vue from &#39;vue&#39;;\nimport VueRouter, &#123; RouteConfig &#125; from &#39;vue-router&#39;;\nimport Home from &#39;@/pages/home/Home.vue&#39;;\n\nVue.use(VueRouter);\n\nconst routes: Array&lt;RouteConfig&gt; = [\n  &#123;\n    path: &#39;/&#39;,\n    name: &#39;home&#39;,\n    component: Home\n  &#125;,\n  &#123;\n    path: &#39;/about&#39;,\n    name: &#39;about&#39;,\n    component: () =&gt; import(/* webpackChunkName: &quot;about&quot; */ &#39;@/pages/about/About.vue&#39;)\n  &#125;\n];\n\nconst router = new VueRouter(&#123;\n  routes\n&#125;);\n\nexport default router;\n</code></pre>\n<h2 id=\"组件中监听路由\"><a href=\"#组件中监听路由\" class=\"headerlink\" title=\"组件中监听路由\"></a>组件中监听路由</h2><pre><code>&lt;script lang=&quot;ts&quot;&gt;\nimport &#123; Component, Vue, Watch &#125; from &#39;vue-property-decorator&#39;;\nimport &#123; Route &#125; from &#39;vue-router&#39;;\n\n@Component\nexport default class About extends Vue &#123;\n  @Watch(&#39;$route&#39;, &#123; immediate: true &#125;)\n  private changeRouter(route: Route) &#123;\n    console.log(&#39;route&#39;, route);\n  &#125;\n&#125;\n</code></pre>\n<h2 id=\"组件中使用路由勾子函数\"><a href=\"#组件中使用路由勾子函数\" class=\"headerlink\" title=\"组件中使用路由勾子函数\"></a>组件中使用路由勾子函数</h2><p>main.ts中：</p>\n<pre><code>import &#123; Component &#125; from &#39;vue-property-decorator&#39;;\n\nComponent.registerHooks([\n  &#39;beforeRouteEnter&#39;,\n  &#39;beforeRouteLeave&#39;,\n  &#39;beforeRouteUpdate&#39;\n]);\n</code></pre>\n<p>组件中：</p>\n<pre><code>&lt;script lang=&quot;ts&quot;&gt;\nimport &#123; Component, Vue, Watch &#125; from &#39;vue-property-decorator&#39;;\nimport &#123; Route &#125; from &#39;vue-router&#39;;\n\n@Component\nexport default class About extends Vue &#123;\n\n  private beforeRouteEnter(to: Route, from: Route, next: () =&gt; void): void &#123;\n    console.log(&#39;beforeRouteEnter&#39;, to, from, next);\n    next(); \n  &#125;\n\n  private beforeRouteUpdate(to: Route, from: Route, next: () =&gt; void): void &#123;\n    console.log(&#39;beforeRouteUpdate&#39;); // 暂时不生效，版本问题\n    next();\n  &#125;\n\n  private beforeRouteLeave(to: Route, from: Route, next: () =&gt; void): void &#123;\n    console.log(&#39;beforeRouteLeave&#39;);\n    next();\n  &#125;\n&#125;</code></pre>\n<h1 id=\"7-数据请求\"><a href=\"#7-数据请求\" class=\"headerlink\" title=\"7 数据请求\"></a>7 数据请求</h1><p>对返回值和入参做类型约束：</p>\n<pre><code>// global.d.ts \ndeclare interface ResponseBody&lt;T&gt; &#123;\n  data: T;\n  code: number;\n  total: number;\n&#125;\ndeclare interface ResponseStatus &#123;\n  loading: boolean;\n  error: boolean;\n&#125;\ndeclare interface Response&lt;T&gt; extends ResponseStatus &#123;\n  res: IResponseBody&lt;T&gt;;\n&#125;\ndeclare interface ResponseNotPage&lt;T&gt; extends ResponseStatus &#123;\n  data: T;\n&#125;\ndeclare interface PageParams &#123;\n  page: number;\n  pageSize: number;\n&#125;\ndeclare interface RequsetParams extends PageParams &#123;\n  search: string;\n&#125;\n\n\n// src/service/demo.ts\nexport const getInfo = (id: number) =&gt;\n  request&lt;ResponseBody&lt;&#123; id: number; address?: string; time?: string &#125;&gt;&gt;(\n    Api.GET_LAST_TRACE_INFO,\n    &#123;\n      router: &#123; id &#125;\n    &#125;\n  );</code></pre>\n<h1 id=\"8-全局状态管理\"><a href=\"#8-全局状态管理\" class=\"headerlink\" title=\"8 全局状态管理\"></a>8 全局状态管理</h1><h2 id=\"8-1-开始使用\"><a href=\"#8-1-开始使用\" class=\"headerlink\" title=\"8.1 开始使用\"></a>8.1 开始使用</h2><p>安装依赖</p>\n<pre><code>npm install vuex-module-decorators --save-dev</code></pre>\n<p>如果想通过名字空间的形式来使用module, 需在@Module装饰器中添加额外的参数. 例如, 以下示例代码中添加一个namespaced为home的module</p>\n<pre><code>// src\\store\\module\\home.ts\nimport &#123; VuexModule, Module, Mutation, Action, getModule &#125; from &#39;vuex-module-decorators&#39;;\nimport store from &#39;@/store&#39;;\n\n@Module(&#123; namespaced: true, dynamic: true, name: &#39;home&#39;, store &#125;)\n\nexport default class Home extends VuexModule &#123;\n  public name: string = &#39;&#39;;\n  public message: string = &#39;&#39;;\n\n  get getMessage() &#123;\n    return `当前时间$&#123;new Date()&#125;：$&#123;this.message&#125;`;\n  &#125;\n\n  @Mutation\n  private SET_NAME(newName: string): void &#123;\n    this.name = newName;\n  &#125;\n\n  @Mutation\n  private SET_MESSAGE(message: string) &#123;\n    this.message = message;\n  &#125;\n\n  @Action\n  public updateMessage(newName: string): void &#123;\n    this.SET_NAME(newName);\n    this.SET_MESSAGE(&#39;欢迎您,&#39;);\n  &#125;\n&#125;\n\nexport const HomeModule = getModule(Home);\n\n</code></pre>\n<p>与ts等效的js代码如下</p>\n<pre><code>const UserModule = &#123;\n    state: &#123;\n        name: &#39;&#39;,\n        message: &#39;&#39;\n    &#125;,\n    getters: &#123; \n        getMessage: state =&gt; `当前时间$&#123;new Date()&#125;：$&#123;state.user.message&#125;`\n    &#125;,\n    mutations: &#123; \n        SET_NAME: (state, name) =&gt; &#123;\n            state.name = name\n        &#125;,\n        SET_MESSAGE: (state, message) =&gt; &#123;\n            state.message = message\n        &#125;\n    &#125;,\n    actions: &#123; \n        updateMessage(&#123;commit&#125;, newName)&#123;\n            commit(&quot;SET_NAME&quot;, newName);\n            commit(&quot;SET_MESSAGE&quot;, &quot;欢迎您,&quot;);\n        &#125;\n    &#125;,\n\n&#125;\n</code></pre>\n<p>dynamic模式下的store</p>\n<pre><code>// \\src\\store\\index.ts\nimport Vue from &#39;vue&#39;;\nimport Vuex from &#39;vuex&#39;;\n\nVue.use(Vuex);\n\n// Declare empty store first, dynamically register all modules later.\nexport default new Vuex.Store(&#123;&#125;);\n</code></pre>\n<p>组件中使用：</p>\n<pre><code>// \\src\\pages\\home\\Home.vue\n\n&lt;template&gt;\n  &lt;div class=&quot;home&quot;&gt;\n    &lt;img alt=&quot;Vue logo&quot; src=&quot;../../assets/logo.png&quot; /&gt;\n    &lt;hello-world msg=&quot;vue.js&quot; /&gt;\n    &#123;&#123; $store.state.home.name &#125;&#125;\n    &lt;br/&gt;\n    &#123;&#123; info &#125;&#125;\n    &lt;button @click=&quot;handleClick&quot;&gt;点击&lt;/button&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script lang=&quot;ts&quot;&gt;\nimport &#123; Component, Vue &#125; from &#39;vue-property-decorator&#39;;\nimport HelloWorld from &#39;@/components/HelloWorld.vue&#39;;\nimport &#123; HomeModule &#125; from &#39;@/store/modules/home&#39;;\n\n@Component(&#123;\n  components: &#123;\n    HelloWorld\n  &#125;\n&#125;)\nexport default class Home extends Vue &#123;\n  get info() &#123;\n    return HomeModule.getMessage;\n  &#125;\n\n  private handleClick() &#123;\n    HomeModule.updateMessage(&#39;liwu&#39;);\n  &#125;\n&#125;\n\n&lt;/script&gt;\n</code></pre>\n","categories":[{"name":"VUE专题","path":"api/categories/VUE专题.json"}],"tags":[{"name":"vue","path":"api/tags/vue.json"},{"name":"TypeScript","path":"api/tags/TypeScript.json"}]}