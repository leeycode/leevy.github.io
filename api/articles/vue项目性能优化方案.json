{"title":"vue项目性能优化方案","slug":"vue项目性能优化方案","date":"2020-10-30T09:09:12.000Z","updated":"2022-01-05T09:27:27.617Z","comments":true,"path":"api/articles/vue项目性能优化方案.json","excerpt":null,"covers":["https://7.dusays.com/2020/11/02/3ce96e73d8ee0.jpg"],"content":"<p><img src=\"https://7.dusays.com/2020/11/02/3ce96e73d8ee0.jpg\" alt=\"vue.jpg\"></p>\n<h1 id=\"按需使用第三方库\"><a href=\"#按需使用第三方库\" class=\"headerlink\" title=\"按需使用第三方库\"></a>按需使用第三方库</h1><p>项目引入过多的第三方库会增大项目体积，带来性能问题<br>。以 Bootstrap 为例，如果你只是用一下它的响应式机制，还不如自己手写相关的 CSS，也不会太复杂，完全没有必要引入整个库。moment.js，Lodash.js这些库为了普适性，提供了尽可能多的功能，但你的项目可能只用了极少部分。我们不鼓励重复造轮子，但是要按需引入。现在很多库都提供了 ES 模块化的方式，也可以做到这一点。</p>\n<p>采用按需引入的方式引入第三方组件，减少在入口文件全局引入。</p>\n<h1 id=\"路由懒加载\"><a href=\"#路由懒加载\" class=\"headerlink\" title=\"路由懒加载\"></a>路由懒加载</h1><p>路由懒加载也可以提高入口页面的加载速度，因为很多路由页面在多数情况下并没有被访问，在打包的时候放到单独的文件里可以减少入口页的体积。路由懒加载是通过 webpack 的动态 import来实现的。</p>\n<pre><code>// in router.js\nimport Home from '@/views/Home.vue'; // 静态 import\nconst About = () =&gt; import('@/views/About.vue'); // 动态 import\nconst router = new VueRouter({\n  routes: [\n    { path: '/', component: Home },\n    { path: '/about', component: About }\n  ]\n})\n</code></pre>\n<p>另外，这些懒加载的路由还可以分组，让相关性模块的多个路由页面打包到同一个 chunk，算是一种折中方案：既实现了按需加载，又不会过于碎片化。适用于子路由页面。</p>\n<pre><code>// in router.js\nimport Home from '@/views/Home.vue'; // traditonal imports\nimport User from '@/views/User.vue';\nconst About = () =&gt;  import('@/views/About.vue'); // dynamic import\nconst router = new VueRouter({\n  routes: [\n    { path: '/', component: Home },\n    { path: '/about', component: About },\n    { path: '/user/:id', component: User, \n      children: [\n        {\n          path: '/settings',\n          component: () =&gt; import(/* webpackChunkName: \"user\" */ '@/views/UserSettings')\n        },\n        {\n          path: '/articles',\n          component: () =&gt; import(/* webpackChunkName: \"user\" */ '@/views/UserArticles')\n        }\n      ]\n    } \n  ]\n})\n</code></pre>\n<p>这是通过 webpack 的注释语法/* webpackChunkName: “user” */实现的，webpackChunkName相同的路由会打进同一个 chunk文件。</p>\n<h1 id=\"只做展示用数据禁用响应式\"><a href=\"#只做展示用数据禁用响应式\" class=\"headerlink\" title=\"只做展示用数据禁用响应式\"></a>只做展示用数据禁用响应式</h1><p>默认情况下，定义在 Vue 组件data 里的数据都是响应式的，这种机制方便了数据绑定，当数据变化时界面得到自动更新。但有时候我们只是将数据显示到界面上，之后也不会改变它。这种情况下我们根本用不上响应式机制，而实现响应式是有性能代价的，特别是对于大对象和大列表。</p>\n<p>建议将data还有Vuex 里面只用于展示的数据通过Object.freeze()禁用对象的响应式特性。</p>\n<h1 id=\"资源释放\"><a href=\"#资源释放\" class=\"headerlink\" title=\"资源释放\"></a>资源释放</h1><ol>\n<li> 如果在mounted/created 钩子中使用了$on，需要在beforeDestroy 中做对应解绑($off)处理</li>\n<li> 如果在mounted/created 钩子中绑定了DOM/BOM 对象中的事件，需要在beforeDestroy 中做对应解绑处理</li>\n<li> 如果在mounted/created 钩子中使用了第三方库初始化，需要在beforeDestroy 中做对应销毁处理</li>\n<li> 如果使用setTimeout setInterval需要在beforeDestroy中做对应销毁处理，（最好不用）可以使用nextTick代替</li>\n<li> 模块形成的闭包内部变量使用完后没有置成null</li>\n<li> 全局变量没有回收</li>\n<li> 绑在EventBus的事件没有解绑，注册的总线事件（Bus）要在组件销毁时(beforeDestroy/destroyed)卸载</li>\n</ol>\n<h1 id=\"v-if-和-v-show-区分使用场景\"><a href=\"#v-if-和-v-show-区分使用场景\" class=\"headerlink\" title=\"v-if 和 v-show 区分使用场景\"></a>v-if 和 v-show 区分使用场景</h1><p>v-if&nbsp;是&nbsp;真正&nbsp;的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</p>\n<p>v-show&nbsp;就简单得多， 不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 的 display 属性进行切换。</p>\n<p>所以，v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景；v-show 则适用于需要非常频繁切换条件的场景。</p>\n<h1 id=\"computed-和-watch-区分使用场景\"><a href=\"#computed-和-watch-区分使用场景\" class=\"headerlink\" title=\"computed 和 watch &nbsp;区分使用场景\"></a>computed 和 watch &nbsp;区分使用场景</h1><p>（1）computed：&nbsp;是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed &nbsp;的值；</p>\n<p>（2） watch：&nbsp;更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；</p>\n<p>运用场景：</p>\n<p>当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；</p>\n<p>当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</p>\n<h1 id=\"v-for-遍历必须为-item-添加-key，且避免同时使用-v-if\"><a href=\"#v-for-遍历必须为-item-添加-key，且避免同时使用-v-if\" class=\"headerlink\" title=\"v-for 遍历必须为 item 添加 key，且避免同时使用 v-if\"></a>v-for 遍历必须为 item 添加 key，且避免同时使用 v-if</h1><p>（1）v-for 遍历必须为 item 添加 key</p>\n<p>在列表数据进行遍历渲染时，需要为每一项 item 设置唯一 key 值，方便 Vue.js 内部机制精准找到该条列表数据。当 state 更新时，新的状态值和旧的状态值对比，较快地定位到 diff 。</p>\n<p>（2）v-for 遍历避免同时使用 v-if</p>\n<p>v-for 比 v-if 优先级高，如果每一次都需要遍历整个数组，将会影响速度，尤其是当之需要渲染很小一部分的时候，必要情况下应该替换成 computed 属性。</p>\n<pre><code>&lt;ul&gt;\n  &lt;li\n    v-for=\"user in activeUsers\"\n    :key=\"user.id\"&gt;\n    {{ user.name }}\n  &lt;/li&gt;\n&lt;/ul&gt;\ncomputed: {\n  activeUsers: function () {\n    return this.users.filter(function (user) {\n   return user.isActive\n    })\n  }\n}</code></pre>\n<h1 id=\"减少-ES6-转为-ES5-的冗余代码\"><a href=\"#减少-ES6-转为-ES5-的冗余代码\" class=\"headerlink\" title=\"减少 ES6 转为 ES5 的冗余代码\"></a>减少 ES6 转为 ES5 的冗余代码</h1><p>Babel 插件会在将 ES6 代码转换成 ES5 代码时会注入一些辅助函数，例如下面的 ES6 代码：</p>\n<pre><code>class HelloWebpack extends Component{...}</code></pre>\n<p>这段代码再被转换成能正常运行的 ES5 代码时需要以下两个辅助函数：</p>\n<pre><code>babel-runtime/helpers/createClass  // 用于实现 class 语法\nbabel-runtime/helpers/inherits  // 用于实现 extends 语法</code></pre>\n<p>在默认情况下， Babel 会在每个输出文件中内嵌这些依赖的辅助函数代码，如果多个源代码文件都依赖这些辅助函数，那么这些辅助函数的代码将会出现很多次，造成代码冗余。为了不让这些辅助函数的代码重复出现，可以在依赖它们时通过&nbsp;require(‘babel-runtime/helpers/createClass’)&nbsp;的方式导入，这样就能做到只让它们出现一次。babel-plugin-transform-runtime&nbsp;插件就是用来实现这个作用的，将相关辅助函数进行替换成导入语句，从而减小 babel 编译出来的代码的文件大小。</p>\n<p>首先，安装 babel-plugin-transform-runtime ：</p>\n<pre><code>npm install babel-plugin-transform-runtime --save-dev</code></pre>\n<p>然后，修改 .babelrc  配置文件为：</p>\n<pre><code>\"plugins\": [\n    \"transform-runtime\"\n]</code></pre>\n<h1 id=\"开启gzip压缩\"><a href=\"#开启gzip压缩\" class=\"headerlink\" title=\"开启gzip压缩\"></a>开启gzip压缩</h1><p>首先，修改productionGzip 为true,<br>安装 compression-webpack-plugin ：</p>\n<pre><code> // \n\n npm install --save-dev compression-webpack-plugin \n //(此处有坑) 如果打包报错，应该是版本问题 ，先卸载之前安装的此插件 ，然后安装低版本 \n  npm install --save-dev compression-webpack-plugin@1.1.11</code></pre>\n<p>修改nginx的配置</p>\n<pre><code>http {  //在 http中配置如下代码，\n   gzip on;\n   gzip_disable \"msie6\"; \n   gzip_vary on; \n   gzip_proxied any;\n   gzip_comp_level 8; #压缩级别\n   gzip_buffers 16 8k;\n   #gzip_http_version 1.1;\n   gzip_min_length 100; #不压缩临界值\n   gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png;\n }</code></pre>\n<h1 id=\"图片懒加载\"><a href=\"#图片懒加载\" class=\"headerlink\" title=\"图片懒加载\"></a>图片懒加载</h1><p>如果应用里需要展示大量图片，通常的做法是懒加载图片。懒加载的基本原理是提前准备好图片 URL，当图片真正进入可视范围时才去加载。可以手动实现懒加载机制，不过更方便的是直接用现成的插件，比如 [vue-lazyload]<br>安装：</p>\n<pre><code>npm i vue-lazyload -S</code></pre>\n<p>引入：</p>\n<pre><code>import VueLazyload from 'vue-lazyload'\nVue.use(VueLazyload)\n</code></pre>\n<p>使用：</p>\n<pre><code> &lt;ul&gt;\n    &lt;li v-for=\"img in list\"&gt;\n      &lt;img v-lazy=\"img.src\"&gt;\n    &lt;/li&gt;\n  &lt;/ul&gt;\n</code></pre>\n<h1 id=\"cdn加速\"><a href=\"#cdn加速\" class=\"headerlink\" title=\"cdn加速\"></a>cdn加速</h1><p>采用cdn加速去从别的服务器上加载第三方库而非自己的服务器，这样就会快很多.并且能节省自己服务器的带宽。</p>\n<p>首先，在index.html中 将你所需的第三方库的链接加载进来：</p>\n<pre><code>&lt;script src=\"https://cdn.bootcdn.net/ajax/libs/vue/3.0.0-beta.18/vue.cjs.js\"&gt;&lt;/script&gt;</code></pre>\n<p>在webpack.base.conf 中添加 externals 来告诉webpack我们这些第三方库不需要打包</p>\n<pre><code>externals:{\n    // key表示第三方插件名称，value是暴露出的全局变量\n    'vue':'Vue'\n}</code></pre>\n<p>在 主文件main.js 或者其他 js 修改引用这些配置的第三方插件</p>\n<pre><code>// import Vue from 'vue';\n\nconst Vue = require('vue');</code></pre>\n<h1 id=\"Webpack-对图片进行压缩\"><a href=\"#Webpack-对图片进行压缩\" class=\"headerlink\" title=\"Webpack 对图片进行压缩\"></a>Webpack 对图片进行压缩</h1><p>安装 image-webpack-loader ：</p>\n<pre><code>npm install image-webpack-loader --save-dev</code></pre>\n<p>然后，在 webpack.base.conf.js  中进行配置：</p>\n<pre><code>{\n  test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/,\n  use:[\n     {\n      loader: 'url-loader',\n      options: {\n        limit: 10000 ,\n        name: '[path][name].[ext]?[hash:6]!./dir/file.png'\n      }\n    },\n    /*对图片进行压缩*/\n    {\n      loader: 'image-webpack-loader',\n      query: {\n        progressive: true,\n        optimizationLevel: 7,\n        interlaced: false,\n        pngquant: {\n          quality: '65-90',\n          speed: 4\n        }\n      }\n    }\n  ]\n}\n</code></pre>\n<h1 id=\"pax-ui框架相关\"><a href=\"#pax-ui框架相关\" class=\"headerlink\" title=\"pax-ui框架相关\"></a>pax-ui框架相关</h1><p>（1） 表单组件<br>pax组件的Form表单组件会对绑定数据监听，表单组件很多的情况下页面会卡顿，在pax-form上设置局部更新，会提升一部分性能。</p>\n<pre><code>&lt;pax-form :form=\"form\" :selfUpdate=\"true\"&gt;&lt;/pax-form&gt;</code></pre>\n<p>(2) select组件<br>select大数据量情况下，会造成页面元素较多，在ie上消耗更多的内存。建议采用虚拟滚动的方式：</p>\n<pre><code>import { RecycleScroller} from 'vue-virtual-scroller';\n\n// 在Select预留卡槽中使用\n详情见文档：IE浏览器select大数据问题造成输入不流畅分析处理</code></pre>\n<p>（3）tree组件<br>pax-tree在ie上问题严重,如果兼容ie，建议用@pa/vue-org-tree,使用方法参考ztree.js</p>\n<pre><code>npm install @pa/vue-org-tree --save-dev</code></pre>\n","more":"<p><img src=\"https://7.dusays.com/2020/11/02/3ce96e73d8ee0.jpg\" alt=\"vue.jpg\"></p>\n<h1 id=\"按需使用第三方库\"><a href=\"#按需使用第三方库\" class=\"headerlink\" title=\"按需使用第三方库\"></a>按需使用第三方库</h1><p>项目引入过多的第三方库会增大项目体积，带来性能问题<br>。以 Bootstrap 为例，如果你只是用一下它的响应式机制，还不如自己手写相关的 CSS，也不会太复杂，完全没有必要引入整个库。moment.js，Lodash.js这些库为了普适性，提供了尽可能多的功能，但你的项目可能只用了极少部分。我们不鼓励重复造轮子，但是要按需引入。现在很多库都提供了 ES 模块化的方式，也可以做到这一点。</p>\n<p>采用按需引入的方式引入第三方组件，减少在入口文件全局引入。</p>\n<h1 id=\"路由懒加载\"><a href=\"#路由懒加载\" class=\"headerlink\" title=\"路由懒加载\"></a>路由懒加载</h1><p>路由懒加载也可以提高入口页面的加载速度，因为很多路由页面在多数情况下并没有被访问，在打包的时候放到单独的文件里可以减少入口页的体积。路由懒加载是通过 webpack 的动态 import来实现的。</p>\n<pre><code>// in router.js\nimport Home from &#39;@/views/Home.vue&#39;; // 静态 import\nconst About = () =&gt; import(&#39;@/views/About.vue&#39;); // 动态 import\nconst router = new VueRouter(&#123;\n  routes: [\n    &#123; path: &#39;/&#39;, component: Home &#125;,\n    &#123; path: &#39;/about&#39;, component: About &#125;\n  ]\n&#125;)\n</code></pre>\n<p>另外，这些懒加载的路由还可以分组，让相关性模块的多个路由页面打包到同一个 chunk，算是一种折中方案：既实现了按需加载，又不会过于碎片化。适用于子路由页面。</p>\n<pre><code>// in router.js\nimport Home from &#39;@/views/Home.vue&#39;; // traditonal imports\nimport User from &#39;@/views/User.vue&#39;;\nconst About = () =&gt;  import(&#39;@/views/About.vue&#39;); // dynamic import\nconst router = new VueRouter(&#123;\n  routes: [\n    &#123; path: &#39;/&#39;, component: Home &#125;,\n    &#123; path: &#39;/about&#39;, component: About &#125;,\n    &#123; path: &#39;/user/:id&#39;, component: User, \n      children: [\n        &#123;\n          path: &#39;/settings&#39;,\n          component: () =&gt; import(/* webpackChunkName: &quot;user&quot; */ &#39;@/views/UserSettings&#39;)\n        &#125;,\n        &#123;\n          path: &#39;/articles&#39;,\n          component: () =&gt; import(/* webpackChunkName: &quot;user&quot; */ &#39;@/views/UserArticles&#39;)\n        &#125;\n      ]\n    &#125; \n  ]\n&#125;)\n</code></pre>\n<p>这是通过 webpack 的注释语法/* webpackChunkName: “user” */实现的，webpackChunkName相同的路由会打进同一个 chunk文件。</p>\n<h1 id=\"只做展示用数据禁用响应式\"><a href=\"#只做展示用数据禁用响应式\" class=\"headerlink\" title=\"只做展示用数据禁用响应式\"></a>只做展示用数据禁用响应式</h1><p>默认情况下，定义在 Vue 组件data 里的数据都是响应式的，这种机制方便了数据绑定，当数据变化时界面得到自动更新。但有时候我们只是将数据显示到界面上，之后也不会改变它。这种情况下我们根本用不上响应式机制，而实现响应式是有性能代价的，特别是对于大对象和大列表。</p>\n<p>建议将data还有Vuex 里面只用于展示的数据通过Object.freeze()禁用对象的响应式特性。</p>\n<h1 id=\"资源释放\"><a href=\"#资源释放\" class=\"headerlink\" title=\"资源释放\"></a>资源释放</h1><ol>\n<li> 如果在mounted/created 钩子中使用了$on，需要在beforeDestroy 中做对应解绑($off)处理</li>\n<li> 如果在mounted/created 钩子中绑定了DOM/BOM 对象中的事件，需要在beforeDestroy 中做对应解绑处理</li>\n<li> 如果在mounted/created 钩子中使用了第三方库初始化，需要在beforeDestroy 中做对应销毁处理</li>\n<li> 如果使用setTimeout setInterval需要在beforeDestroy中做对应销毁处理，（最好不用）可以使用nextTick代替</li>\n<li> 模块形成的闭包内部变量使用完后没有置成null</li>\n<li> 全局变量没有回收</li>\n<li> 绑在EventBus的事件没有解绑，注册的总线事件（Bus）要在组件销毁时(beforeDestroy/destroyed)卸载</li>\n</ol>\n<h1 id=\"v-if-和-v-show-区分使用场景\"><a href=\"#v-if-和-v-show-区分使用场景\" class=\"headerlink\" title=\"v-if 和 v-show 区分使用场景\"></a>v-if 和 v-show 区分使用场景</h1><p>v-if 是 真正 的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</p>\n<p>v-show 就简单得多， 不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 的 display 属性进行切换。</p>\n<p>所以，v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景；v-show 则适用于需要非常频繁切换条件的场景。</p>\n<h1 id=\"computed-和-watch-区分使用场景\"><a href=\"#computed-和-watch-区分使用场景\" class=\"headerlink\" title=\"computed 和 watch  区分使用场景\"></a>computed 和 watch  区分使用场景</h1><p>（1）computed： 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed  的值；</p>\n<p>（2） watch： 更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；</p>\n<p>运用场景：</p>\n<p>当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；</p>\n<p>当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</p>\n<h1 id=\"v-for-遍历必须为-item-添加-key，且避免同时使用-v-if\"><a href=\"#v-for-遍历必须为-item-添加-key，且避免同时使用-v-if\" class=\"headerlink\" title=\"v-for 遍历必须为 item 添加 key，且避免同时使用 v-if\"></a>v-for 遍历必须为 item 添加 key，且避免同时使用 v-if</h1><p>（1）v-for 遍历必须为 item 添加 key</p>\n<p>在列表数据进行遍历渲染时，需要为每一项 item 设置唯一 key 值，方便 Vue.js 内部机制精准找到该条列表数据。当 state 更新时，新的状态值和旧的状态值对比，较快地定位到 diff 。</p>\n<p>（2）v-for 遍历避免同时使用 v-if</p>\n<p>v-for 比 v-if 优先级高，如果每一次都需要遍历整个数组，将会影响速度，尤其是当之需要渲染很小一部分的时候，必要情况下应该替换成 computed 属性。</p>\n<pre><code>&lt;ul&gt;\n  &lt;li\n    v-for=&quot;user in activeUsers&quot;\n    :key=&quot;user.id&quot;&gt;\n    &#123;&#123; user.name &#125;&#125;\n  &lt;/li&gt;\n&lt;/ul&gt;\ncomputed: &#123;\n  activeUsers: function () &#123;\n    return this.users.filter(function (user) &#123;\n   return user.isActive\n    &#125;)\n  &#125;\n&#125;</code></pre>\n<h1 id=\"减少-ES6-转为-ES5-的冗余代码\"><a href=\"#减少-ES6-转为-ES5-的冗余代码\" class=\"headerlink\" title=\"减少 ES6 转为 ES5 的冗余代码\"></a>减少 ES6 转为 ES5 的冗余代码</h1><p>Babel 插件会在将 ES6 代码转换成 ES5 代码时会注入一些辅助函数，例如下面的 ES6 代码：</p>\n<pre><code>class HelloWebpack extends Component&#123;...&#125;</code></pre>\n<p>这段代码再被转换成能正常运行的 ES5 代码时需要以下两个辅助函数：</p>\n<pre><code>babel-runtime/helpers/createClass  // 用于实现 class 语法\nbabel-runtime/helpers/inherits  // 用于实现 extends 语法</code></pre>\n<p>在默认情况下， Babel 会在每个输出文件中内嵌这些依赖的辅助函数代码，如果多个源代码文件都依赖这些辅助函数，那么这些辅助函数的代码将会出现很多次，造成代码冗余。为了不让这些辅助函数的代码重复出现，可以在依赖它们时通过 require(‘babel-runtime/helpers/createClass’) 的方式导入，这样就能做到只让它们出现一次。babel-plugin-transform-runtime 插件就是用来实现这个作用的，将相关辅助函数进行替换成导入语句，从而减小 babel 编译出来的代码的文件大小。</p>\n<p>首先，安装 babel-plugin-transform-runtime ：</p>\n<pre><code>npm install babel-plugin-transform-runtime --save-dev</code></pre>\n<p>然后，修改 .babelrc  配置文件为：</p>\n<pre><code>&quot;plugins&quot;: [\n    &quot;transform-runtime&quot;\n]</code></pre>\n<h1 id=\"开启gzip压缩\"><a href=\"#开启gzip压缩\" class=\"headerlink\" title=\"开启gzip压缩\"></a>开启gzip压缩</h1><p>首先，修改productionGzip 为true,<br>安装 compression-webpack-plugin ：</p>\n<pre><code> // \n\n npm install --save-dev compression-webpack-plugin \n //(此处有坑) 如果打包报错，应该是版本问题 ，先卸载之前安装的此插件 ，然后安装低版本 \n  npm install --save-dev compression-webpack-plugin@1.1.11</code></pre>\n<p>修改nginx的配置</p>\n<pre><code>http &#123;  //在 http中配置如下代码，\n   gzip on;\n   gzip_disable &quot;msie6&quot;; \n   gzip_vary on; \n   gzip_proxied any;\n   gzip_comp_level 8; #压缩级别\n   gzip_buffers 16 8k;\n   #gzip_http_version 1.1;\n   gzip_min_length 100; #不压缩临界值\n   gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png;\n &#125;</code></pre>\n<h1 id=\"图片懒加载\"><a href=\"#图片懒加载\" class=\"headerlink\" title=\"图片懒加载\"></a>图片懒加载</h1><p>如果应用里需要展示大量图片，通常的做法是懒加载图片。懒加载的基本原理是提前准备好图片 URL，当图片真正进入可视范围时才去加载。可以手动实现懒加载机制，不过更方便的是直接用现成的插件，比如 [vue-lazyload]<br>安装：</p>\n<pre><code>npm i vue-lazyload -S</code></pre>\n<p>引入：</p>\n<pre><code>import VueLazyload from &#39;vue-lazyload&#39;\nVue.use(VueLazyload)\n</code></pre>\n<p>使用：</p>\n<pre><code> &lt;ul&gt;\n    &lt;li v-for=&quot;img in list&quot;&gt;\n      &lt;img v-lazy=&quot;img.src&quot;&gt;\n    &lt;/li&gt;\n  &lt;/ul&gt;\n</code></pre>\n<h1 id=\"cdn加速\"><a href=\"#cdn加速\" class=\"headerlink\" title=\"cdn加速\"></a>cdn加速</h1><p>采用cdn加速去从别的服务器上加载第三方库而非自己的服务器，这样就会快很多.并且能节省自己服务器的带宽。</p>\n<p>首先，在index.html中 将你所需的第三方库的链接加载进来：</p>\n<pre><code>&lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/vue/3.0.0-beta.18/vue.cjs.js&quot;&gt;&lt;/script&gt;</code></pre>\n<p>在webpack.base.conf 中添加 externals 来告诉webpack我们这些第三方库不需要打包</p>\n<pre><code>externals:&#123;\n    // key表示第三方插件名称，value是暴露出的全局变量\n    &#39;vue&#39;:&#39;Vue&#39;\n&#125;</code></pre>\n<p>在 主文件main.js 或者其他 js 修改引用这些配置的第三方插件</p>\n<pre><code>// import Vue from &#39;vue&#39;;\n\nconst Vue = require(&#39;vue&#39;);</code></pre>\n<h1 id=\"Webpack-对图片进行压缩\"><a href=\"#Webpack-对图片进行压缩\" class=\"headerlink\" title=\"Webpack 对图片进行压缩\"></a>Webpack 对图片进行压缩</h1><p>安装 image-webpack-loader ：</p>\n<pre><code>npm install image-webpack-loader --save-dev</code></pre>\n<p>然后，在 webpack.base.conf.js  中进行配置：</p>\n<pre><code>&#123;\n  test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/,\n  use:[\n     &#123;\n      loader: &#39;url-loader&#39;,\n      options: &#123;\n        limit: 10000 ,\n        name: &#39;[path][name].[ext]?[hash:6]!./dir/file.png&#39;\n      &#125;\n    &#125;,\n    /*对图片进行压缩*/\n    &#123;\n      loader: &#39;image-webpack-loader&#39;,\n      query: &#123;\n        progressive: true,\n        optimizationLevel: 7,\n        interlaced: false,\n        pngquant: &#123;\n          quality: &#39;65-90&#39;,\n          speed: 4\n        &#125;\n      &#125;\n    &#125;\n  ]\n&#125;\n</code></pre>\n<h1 id=\"pax-ui框架相关\"><a href=\"#pax-ui框架相关\" class=\"headerlink\" title=\"pax-ui框架相关\"></a>pax-ui框架相关</h1><p>（1） 表单组件<br>pax组件的Form表单组件会对绑定数据监听，表单组件很多的情况下页面会卡顿，在pax-form上设置局部更新，会提升一部分性能。</p>\n<pre><code>&lt;pax-form :form=&quot;form&quot; :selfUpdate=&quot;true&quot;&gt;&lt;/pax-form&gt;</code></pre>\n<p>(2) select组件<br>select大数据量情况下，会造成页面元素较多，在ie上消耗更多的内存。建议采用虚拟滚动的方式：</p>\n<pre><code>import &#123; RecycleScroller&#125; from &#39;vue-virtual-scroller&#39;;\n\n// 在Select预留卡槽中使用\n详情见文档：IE浏览器select大数据问题造成输入不流畅分析处理</code></pre>\n<p>（3）tree组件<br>pax-tree在ie上问题严重,如果兼容ie，建议用@pa/vue-org-tree,使用方法参考ztree.js</p>\n<pre><code>npm install @pa/vue-org-tree --save-dev</code></pre>\n","categories":[{"name":"VUE专题","path":"api/categories/VUE专题.json"}],"tags":[{"name":"vue","path":"api/tags/vue.json"}]}