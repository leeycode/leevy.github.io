{"title":"前端缓存问题","slug":"前端缓存问题","date":"2021-02-20T07:23:14.000Z","updated":"2021-02-20T08:13:42.211Z","comments":true,"path":"api/articles/前端缓存问题.json","excerpt":null,"covers":["https://7.dusays.com/2021/02/20/689c4e15f25a7.png","https://7.dusays.com/2021/02/20/0bbd461ec7cf5.png","https://7.dusays.com/2021/02/20/016d4a97ceaa7.png","https://7.dusays.com/2021/02/20/7380544e1f4c1.png","https://7.dusays.com/2021/02/20/371f279c2667a.png"],"content":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>彻底禁止缓存，这个需求是错误的。缓存是浏览器的功能特性，又不是 Bug。但是前端知道如何处理浏览器缓存，用户并不一定了解，特别是一些静态资源的缓存，让用户一脸懵逼，因此特意总结了下。</p>\n<h2 id=\"浏览器缓存的原理\"><a href=\"#浏览器缓存的原理\" class=\"headerlink\" title=\"浏览器缓存的原理\"></a>浏览器缓存的原理</h2><p>浏览器的缓存分为强制缓存和协商缓存。当二次打开网页时，浏览器会先对缓存发起http请求，只要请求的资源存在缓存并且该资源的请求头expires和cache-control中存在缓存的标志，那就默认读取缓存，如果缓存失效但缓存依然存在，这时有会对服务器发出http请求，通过last-modified和etag两个请求头验证是否存在协商缓存，存在协商缓存就让浏览器照样读取缓存。</p>\n<p>当然，如果你资源已经不存在了或者明确禁止缓存，那浏览器也不可能使用缓存，这也是解决缓存问题的办法</p>\n<p><img src=\"https://7.dusays.com/2021/02/20/689c4e15f25a7.png\" alt=\"第一次发起http请求\"></p>\n<h3 id=\"强制缓存\"><a href=\"#强制缓存\" class=\"headerlink\" title=\"强制缓存\"></a>强制缓存</h3><p>设置强制缓存有两个属性expires和cache-control，cache-control优先级高于 expires,常用有5个值：</p>\n<ol>\n<li>public:所有内容都将被缓存（客户端和代理服务器都可缓存）</li>\n<li>private:所有内容只有客户端可以缓存</li>\n<li>no-cache: 客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定</li>\n<li>no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存 </li>\n<li>max-age=xxx (xxx is numeric)：缓存内容将在xxx秒后失效</li>\n</ol>\n<p><img src=\"https://7.dusays.com/2021/02/20/0bbd461ec7cf5.png\" alt=\"2.png\"></p>\n<p>强制缓存是否生效，可以查看控制台的network选项，下面的size属性，一般就是from memory cache或者from disk cache，一个是从内存中加载缓存，一个是硬盘中加载缓存，区别就是内存要快些，一般先是读取硬盘中的缓存，要是你刷新一下，就从内存中读取，不然刷新的时候怎么那么快</p>\n<p><img src=\"https://7.dusays.com/2021/02/20/016d4a97ceaa7.png\" alt=\"3.png\"></p>\n<h3 id=\"协商缓存\"><a href=\"#协商缓存\" class=\"headerlink\" title=\"协商缓存\"></a>协商缓存</h3><p>当强制缓存失败，浏览器就请求服务器，如果服务器觉得用缓存没问题，资源又没有更新，那么，即使缓存设了到期时间，浏览器依然会读取，此时服务器返回304，如果资源更新了，就从服务器请求更新，返回200。如何判断资源是否更新，就是靠last-modified和etag两个请求头，这里我就不多讲了</p>\n<p>但是要注意，强制缓存要优先于协商缓存，所以嘛，就算你更新了，浏览器依旧会读取缓存，</p>\n<h2 id=\"前端解决缓存的办法\"><a href=\"#前端解决缓存的办法\" class=\"headerlink\" title=\"前端解决缓存的办法\"></a>前端解决缓存的办法</h2><h3 id=\"meta缓存头设置为禁止缓存\"><a href=\"#meta缓存头设置为禁止缓存\" class=\"headerlink\" title=\"meta缓存头设置为禁止缓存\"></a>meta缓存头设置为禁止缓存</h3><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token operator\">&lt;</span><span class=\"token operator\">!</span><span class=\"token operator\">--</span> 在入口文件index<span class=\"token punctuation\">.</span>html中，头部添加meta标签 <span class=\"token operator\">--</span><span class=\"token operator\">></span>\n<span class=\"token operator\">&lt;</span>meta http<span class=\"token operator\">-</span>equiv<span class=\"token operator\">=</span><span class=\"token string\">\"Expires\"</span> content<span class=\"token operator\">=</span><span class=\"token string\">\"0\"</span><span class=\"token operator\">></span>\n<span class=\"token operator\">&lt;</span>meta http<span class=\"token operator\">-</span>equiv<span class=\"token operator\">=</span><span class=\"token string\">\"Pragma\"</span> content<span class=\"token operator\">=</span><span class=\"token string\">\"no-cache\"</span><span class=\"token operator\">></span>\n<span class=\"token operator\">&lt;</span>meta http<span class=\"token operator\">-</span>equiv<span class=\"token operator\">=</span><span class=\"token string\">\"Cache-control\"</span> content<span class=\"token operator\">=</span><span class=\"token string\">\"no-cache\"</span><span class=\"token operator\">></span>\n<span class=\"token operator\">&lt;</span>meta http<span class=\"token operator\">-</span>equiv<span class=\"token operator\">=</span><span class=\"token string\">\"Cache\"</span> content<span class=\"token operator\">=</span><span class=\"token string\">\"no-cache\"</span><span class=\"token operator\">></span></code></pre>\n<h3 id=\"静态资源加上版本号\"><a href=\"#静态资源加上版本号\" class=\"headerlink\" title=\"静态资源加上版本号\"></a>静态资源加上版本号</h3><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// webpack.prod.conf.js</span>\n<span class=\"token keyword\">const</span> Version <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Date</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getTime</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\noutput<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    path<span class=\"token punctuation\">:</span> config<span class=\"token punctuation\">.</span>build<span class=\"token punctuation\">.</span>assetsRoot<span class=\"token punctuation\">,</span>\n    filename<span class=\"token punctuation\">:</span> utils<span class=\"token punctuation\">.</span><span class=\"token function\">assetsPath</span><span class=\"token punctuation\">(</span><span class=\"token string\">'js/[name].[chunkhash].'</span><span class=\"token operator\">+</span>_Version<span class=\"token operator\">+</span><span class=\"token string\">'js'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    chunkFilename<span class=\"token punctuation\">:</span> utils<span class=\"token punctuation\">.</span><span class=\"token function\">assetsPath</span><span class=\"token punctuation\">(</span><span class=\"token string\">'js/[id].[chunkhash].'</span><span class=\"token operator\">+</span>_Version<span class=\"token operator\">+</span><span class=\"token string\">'js'</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"服务端配置\"><a href=\"#服务端配置\" class=\"headerlink\" title=\"服务端配置\"></a>服务端配置</h3><pre class=\" language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// nginx端配置</span>\nlocation <span class=\"token operator\">=</span> <span class=\"token operator\">/</span>index<span class=\"token punctuation\">.</span>html <span class=\"token punctuation\">{</span>\n    add_header Cache<span class=\"token operator\">-</span>Control <span class=\"token string\">\"no-cache, no-store\"</span><span class=\"token punctuation\">;</span>\n    # add_header Cache<span class=\"token operator\">-</span>Control no<span class=\"token operator\">-</span>store<span class=\"token punctuation\">;</span>\n    # add_header Pragma no<span class=\"token operator\">-</span>cache<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"快速清理浏览器缓存\"><a href=\"#快速清理浏览器缓存\" class=\"headerlink\" title=\"快速清理浏览器缓存\"></a>快速清理浏览器缓存</h2><ul>\n<li>Ctrl+shift+Del 清空浏览数据设置的快捷键，可以清除浏览数据呀，cookie呀，缓存呀，这是清除浏览器所有的缓存</li>\n</ul>\n<p><img src=\"https://7.dusays.com/2021/02/20/7380544e1f4c1.png\"></p>\n<ul>\n<li>控制台禁止缓存 这个隐藏在控制台network选项里的，对于开发人员很好用，默认禁止缓存</li>\n</ul>\n<p><img src=\"https://7.dusays.com/2021/02/20/371f279c2667a.png\"></p>\n","more":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>彻底禁止缓存，这个需求是错误的。缓存是浏览器的功能特性，又不是 Bug。但是前端知道如何处理浏览器缓存，用户并不一定了解，特别是一些静态资源的缓存，让用户一脸懵逼，因此特意总结了下。</p>\n<h2 id=\"浏览器缓存的原理\"><a href=\"#浏览器缓存的原理\" class=\"headerlink\" title=\"浏览器缓存的原理\"></a>浏览器缓存的原理</h2><p>浏览器的缓存分为强制缓存和协商缓存。当二次打开网页时，浏览器会先对缓存发起http请求，只要请求的资源存在缓存并且该资源的请求头expires和cache-control中存在缓存的标志，那就默认读取缓存，如果缓存失效但缓存依然存在，这时有会对服务器发出http请求，通过last-modified和etag两个请求头验证是否存在协商缓存，存在协商缓存就让浏览器照样读取缓存。</p>\n<p>当然，如果你资源已经不存在了或者明确禁止缓存，那浏览器也不可能使用缓存，这也是解决缓存问题的办法</p>\n<p><img src=\"https://7.dusays.com/2021/02/20/689c4e15f25a7.png\" alt=\"第一次发起http请求\"></p>\n<h3 id=\"强制缓存\"><a href=\"#强制缓存\" class=\"headerlink\" title=\"强制缓存\"></a>强制缓存</h3><p>设置强制缓存有两个属性expires和cache-control，cache-control优先级高于 expires,常用有5个值：</p>\n<ol>\n<li>public:所有内容都将被缓存（客户端和代理服务器都可缓存）</li>\n<li>private:所有内容只有客户端可以缓存</li>\n<li>no-cache: 客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定</li>\n<li>no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存 </li>\n<li>max-age=xxx (xxx is numeric)：缓存内容将在xxx秒后失效</li>\n</ol>\n<p><img src=\"https://7.dusays.com/2021/02/20/0bbd461ec7cf5.png\" alt=\"2.png\"></p>\n<p>强制缓存是否生效，可以查看控制台的network选项，下面的size属性，一般就是from memory cache或者from disk cache，一个是从内存中加载缓存，一个是硬盘中加载缓存，区别就是内存要快些，一般先是读取硬盘中的缓存，要是你刷新一下，就从内存中读取，不然刷新的时候怎么那么快</p>\n<p><img src=\"https://7.dusays.com/2021/02/20/016d4a97ceaa7.png\" alt=\"3.png\"></p>\n<h3 id=\"协商缓存\"><a href=\"#协商缓存\" class=\"headerlink\" title=\"协商缓存\"></a>协商缓存</h3><p>当强制缓存失败，浏览器就请求服务器，如果服务器觉得用缓存没问题，资源又没有更新，那么，即使缓存设了到期时间，浏览器依然会读取，此时服务器返回304，如果资源更新了，就从服务器请求更新，返回200。如何判断资源是否更新，就是靠last-modified和etag两个请求头，这里我就不多讲了</p>\n<p>但是要注意，强制缓存要优先于协商缓存，所以嘛，就算你更新了，浏览器依旧会读取缓存，</p>\n<h2 id=\"前端解决缓存的办法\"><a href=\"#前端解决缓存的办法\" class=\"headerlink\" title=\"前端解决缓存的办法\"></a>前端解决缓存的办法</h2><h3 id=\"meta缓存头设置为禁止缓存\"><a href=\"#meta缓存头设置为禁止缓存\" class=\"headerlink\" title=\"meta缓存头设置为禁止缓存\"></a>meta缓存头设置为禁止缓存</h3><pre><code class=\"js\">&lt;!-- 在入口文件index.html中，头部添加meta标签 --&gt;\n&lt;meta http-equiv=&quot;Expires&quot; content=&quot;0&quot;&gt;\n&lt;meta http-equiv=&quot;Pragma&quot; content=&quot;no-cache&quot;&gt;\n&lt;meta http-equiv=&quot;Cache-control&quot; content=&quot;no-cache&quot;&gt;\n&lt;meta http-equiv=&quot;Cache&quot; content=&quot;no-cache&quot;&gt;</code></pre>\n<h3 id=\"静态资源加上版本号\"><a href=\"#静态资源加上版本号\" class=\"headerlink\" title=\"静态资源加上版本号\"></a>静态资源加上版本号</h3><pre><code class=\"js\">// webpack.prod.conf.js\nconst Version = new Date().getTime();\n\noutput: &#123;\n    path: config.build.assetsRoot,\n    filename: utils.assetsPath(&#39;js/[name].[chunkhash].&#39;+_Version+&#39;js&#39;),\n    chunkFilename: utils.assetsPath(&#39;js/[id].[chunkhash].&#39;+_Version+&#39;js&#39;)\n&#125;</code></pre>\n<h3 id=\"服务端配置\"><a href=\"#服务端配置\" class=\"headerlink\" title=\"服务端配置\"></a>服务端配置</h3><pre><code class=\"js\">// nginx端配置\nlocation = /index.html &#123;\n    add_header Cache-Control &quot;no-cache, no-store&quot;;\n    # add_header Cache-Control no-store;\n    # add_header Pragma no-cache;\n&#125;</code></pre>\n<h2 id=\"快速清理浏览器缓存\"><a href=\"#快速清理浏览器缓存\" class=\"headerlink\" title=\"快速清理浏览器缓存\"></a>快速清理浏览器缓存</h2><ul>\n<li>Ctrl+shift+Del 清空浏览数据设置的快捷键，可以清除浏览数据呀，cookie呀，缓存呀，这是清除浏览器所有的缓存</li>\n</ul>\n<p><img src=\"https://7.dusays.com/2021/02/20/7380544e1f4c1.png\"></p>\n<ul>\n<li>控制台禁止缓存 这个隐藏在控制台network选项里的，对于开发人员很好用，默认禁止缓存</li>\n</ul>\n<p><img src=\"https://7.dusays.com/2021/02/20/371f279c2667a.png\"></p>\n","categories":[{"name":"项目总结","path":"api/categories/项目总结.json"}],"tags":[{"name":"踩的坑","path":"api/tags/踩的坑.json"}]}