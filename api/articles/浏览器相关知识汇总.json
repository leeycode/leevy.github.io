{"title":"浏览器相关知识汇总","slug":"浏览器相关知识汇总","date":"2022-01-08T02:20:16.000Z","updated":"2022-02-08T02:53:34.650Z","comments":true,"path":"api/articles/浏览器相关知识汇总.json","excerpt":null,"covers":["https://bu.dusays.com/2022/02/08/3d60d09942ab5.png","https://bu.dusays.com/2022/02/08/fb4af500748f0.png","https://bu.dusays.com/2022/02/08/541d4de2022f2.png","https://bu.dusays.com/2022/02/08/0efbbd6b78be8.png"],"content":"<h1 id=\"浏览器如何渲染UI\"><a href=\"#浏览器如何渲染UI\" class=\"headerlink\" title=\"浏览器如何渲染UI\"></a>浏览器如何渲染UI</h1><ol>\n<li>浏览器获取HTML文件，然后对文件进行解析，形成DOM Tree</li>\n<li>与此同时，进行CSS解析，生成Style Rules</li>\n<li>接着将DOM Tree与Style Rules合成为 Render Tree</li>\n<li>接着进入布局（Layout）阶段，也就是为每个节点分配一个应出现在屏幕上的确切坐标</li>\n<li>随后调用GPU进行绘制（Paint），遍历Render Tree的节点，并将元素呈现出来</li>\n</ol>\n<p><img src=\"https://bu.dusays.com/2022/02/08/3d60d09942ab5.png\" alt=\"image.png\"></p>\n<h1 id=\"浏览器如何解析CSS\"><a href=\"#浏览器如何解析CSS\" class=\"headerlink\" title=\"浏览器如何解析CSS\"></a>浏览器如何解析CSS</h1><p>浏览器会『从右往左』解析CSS选择器。<br>DOM Tree与Style Rules合成为 Render Tree，实际上是需要将Style Rules附着到DOM Tree上，因此需要根据选择器提供的信息对DOM Tree进行遍历，才能将样式附着到对应的DOM元素上。</p>\n<pre class=\" language-js\"><code class=\"language-js\"><span class=\"token punctuation\">.</span>mod<span class=\"token operator\">-</span>nav h3 span <span class=\"token punctuation\">{</span>font<span class=\"token operator\">-</span>size<span class=\"token punctuation\">:</span> 16px<span class=\"token punctuation\">;</span><span class=\"token punctuation\">}</span>\n</code></pre>\n<p><img src=\"https://bu.dusays.com/2022/02/08/fb4af500748f0.png\" alt=\"image _1_.png\"></p>\n<p>从右至左的匹配过程是：</p>\n<ol>\n<li>先找到所有的最右节点 span，对于每一个 span，向上寻找节点 h3</li>\n<li>由 h3再向上寻找 class=mod-nav 的节点</li>\n<li>最后找到根元素 html 则结束这个分支的遍历。</li>\n</ol>\n<h1 id=\"DOM-Tree是如何构建的\"><a href=\"#DOM-Tree是如何构建的\" class=\"headerlink\" title=\"DOM Tree是如何构建的\"></a>DOM Tree是如何构建的</h1><ol>\n<li>转码: 浏览器将接收到的二进制数据按照指定编码格式转化为HTML字符串</li>\n<li>生成Tokens: 之后开始parser，浏览器会将HTML字符串解析成Tokens</li>\n<li>构建Nodes: 对Node添加特定的属性，通过指针确定 Node 的父、子、兄弟关系和所属 treeScope</li>\n<li>生成DOM Tree: 通过node包含的指针确定的关系构建出DOM Tree</li>\n</ol>\n<p><img src=\"https://bu.dusays.com/2022/02/08/541d4de2022f2.png\" alt=\"image _2_.png\"></p>\n<h1 id=\"浏览器重绘与重排的区别\"><a href=\"#浏览器重绘与重排的区别\" class=\"headerlink\" title=\"浏览器重绘与重排的区别\"></a>浏览器重绘与重排的区别</h1><ul>\n<li>重排: 部分渲染树（或者整个渲染树）需要重新分析并且节点尺寸需要重新计算，表现为重新生成布局，重新排列元素。如改变元素尺寸<strong>边距、填充、边框、宽度和高度</strong>等，<strong>添加或者删除</strong>可见的DOM元素</li>\n<li>重绘: 由于节点的几何属性发生改变或者由于样式发生改变，例如改变元素背景色时，屏幕上的部分内容需要更新，表现为某些元素的外观被改变。如<br>改变元素的<strong>color、background、box-shadow</strong>等属性</li>\n</ul>\n<p>单单改变元素的外观，肯定不会引起网页重新生成布局，但当浏览器完成重排之后，将会重新绘制受到此次重排影响的部分</p>\n<p>重排和重绘代价是高昂的，它们会破坏用户体验，并且让UI展示非常迟缓，而相比之下重排的性能影响更大，在两者无法避免的情况下，一般我们宁可选择代价更小的重绘。</p>\n<h1 id=\"如何触发重排和重绘\"><a href=\"#如何触发重排和重绘\" class=\"headerlink\" title=\"如何触发重排和重绘\"></a>如何触发重排和重绘</h1><p>任何改变用来构建渲染树的信息都会导致一次重排或重绘：</p>\n<ul>\n<li>添加、删除、更新DOM节点</li>\n<li>通过display: none隐藏一个DOM节点-触发重排和重绘</li>\n<li>通过visibility: hidden隐藏一个DOM节点-只触发重绘，因为没有几何变化</li>\n<li>移动或者给页面中的DOM节点添加动画</li>\n<li>添加一个样式表，调整样式属性</li>\n<li>用户行为，例如调整窗口大小，改变字号，或者滚动。</li>\n<li>查询某些属性或调用某些方法。比如说：<br>offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight</li>\n</ul>\n<h1 id=\"如何避免重绘或者重排\"><a href=\"#如何避免重绘或者重排\" class=\"headerlink\" title=\"如何避免重绘或者重排\"></a>如何避免重绘或者重排</h1><ul>\n<li>集中改变样式</li>\n<li>使用DocumentFragment</li>\n<li>提升为合成层</li>\n<li>缓存需要修改的DOM元素</li>\n<li>尽量只修改position：absolute或fixed元素，对其他元素影响不大<br>动画开始GPU加速，translate使用3D变化</li>\n</ul>\n<p><img src=\"https://bu.dusays.com/2022/02/08/0efbbd6b78be8.png\" alt=\"image _3_.png\"></p>\n<p>transform 不重绘，不回流是因为transform属于合成属性，对合成属性进行transition/animate动画时，将会创建一个合成层。这使得动画元素在一个独立的层中进行渲染。当元素的内容没有发生改变，就没有必要进行重绘。浏览器会通过重新复合来创建动画帧。</p>\n","more":"<h1 id=\"浏览器如何渲染UI\"><a href=\"#浏览器如何渲染UI\" class=\"headerlink\" title=\"浏览器如何渲染UI\"></a>浏览器如何渲染UI</h1><ol>\n<li>浏览器获取HTML文件，然后对文件进行解析，形成DOM Tree</li>\n<li>与此同时，进行CSS解析，生成Style Rules</li>\n<li>接着将DOM Tree与Style Rules合成为 Render Tree</li>\n<li>接着进入布局（Layout）阶段，也就是为每个节点分配一个应出现在屏幕上的确切坐标</li>\n<li>随后调用GPU进行绘制（Paint），遍历Render Tree的节点，并将元素呈现出来</li>\n</ol>\n<p><img src=\"https://bu.dusays.com/2022/02/08/3d60d09942ab5.png\" alt=\"image.png\"></p>\n<h1 id=\"浏览器如何解析CSS\"><a href=\"#浏览器如何解析CSS\" class=\"headerlink\" title=\"浏览器如何解析CSS\"></a>浏览器如何解析CSS</h1><p>浏览器会『从右往左』解析CSS选择器。<br>DOM Tree与Style Rules合成为 Render Tree，实际上是需要将Style Rules附着到DOM Tree上，因此需要根据选择器提供的信息对DOM Tree进行遍历，才能将样式附着到对应的DOM元素上。</p>\n<pre><code class=\"js\">.mod-nav h3 span &#123;font-size: 16px;&#125;\n</code></pre>\n<p><img src=\"https://bu.dusays.com/2022/02/08/fb4af500748f0.png\" alt=\"image _1_.png\"></p>\n<p>从右至左的匹配过程是：</p>\n<ol>\n<li>先找到所有的最右节点 span，对于每一个 span，向上寻找节点 h3</li>\n<li>由 h3再向上寻找 class=mod-nav 的节点</li>\n<li>最后找到根元素 html 则结束这个分支的遍历。</li>\n</ol>\n<h1 id=\"DOM-Tree是如何构建的\"><a href=\"#DOM-Tree是如何构建的\" class=\"headerlink\" title=\"DOM Tree是如何构建的\"></a>DOM Tree是如何构建的</h1><ol>\n<li>转码: 浏览器将接收到的二进制数据按照指定编码格式转化为HTML字符串</li>\n<li>生成Tokens: 之后开始parser，浏览器会将HTML字符串解析成Tokens</li>\n<li>构建Nodes: 对Node添加特定的属性，通过指针确定 Node 的父、子、兄弟关系和所属 treeScope</li>\n<li>生成DOM Tree: 通过node包含的指针确定的关系构建出DOM Tree</li>\n</ol>\n<p><img src=\"https://bu.dusays.com/2022/02/08/541d4de2022f2.png\" alt=\"image _2_.png\"></p>\n<h1 id=\"浏览器重绘与重排的区别\"><a href=\"#浏览器重绘与重排的区别\" class=\"headerlink\" title=\"浏览器重绘与重排的区别\"></a>浏览器重绘与重排的区别</h1><ul>\n<li>重排: 部分渲染树（或者整个渲染树）需要重新分析并且节点尺寸需要重新计算，表现为重新生成布局，重新排列元素。如改变元素尺寸<strong>边距、填充、边框、宽度和高度</strong>等，<strong>添加或者删除</strong>可见的DOM元素</li>\n<li>重绘: 由于节点的几何属性发生改变或者由于样式发生改变，例如改变元素背景色时，屏幕上的部分内容需要更新，表现为某些元素的外观被改变。如<br>改变元素的<strong>color、background、box-shadow</strong>等属性</li>\n</ul>\n<p>单单改变元素的外观，肯定不会引起网页重新生成布局，但当浏览器完成重排之后，将会重新绘制受到此次重排影响的部分</p>\n<p>重排和重绘代价是高昂的，它们会破坏用户体验，并且让UI展示非常迟缓，而相比之下重排的性能影响更大，在两者无法避免的情况下，一般我们宁可选择代价更小的重绘。</p>\n<h1 id=\"如何触发重排和重绘\"><a href=\"#如何触发重排和重绘\" class=\"headerlink\" title=\"如何触发重排和重绘\"></a>如何触发重排和重绘</h1><p>任何改变用来构建渲染树的信息都会导致一次重排或重绘：</p>\n<ul>\n<li>添加、删除、更新DOM节点</li>\n<li>通过display: none隐藏一个DOM节点-触发重排和重绘</li>\n<li>通过visibility: hidden隐藏一个DOM节点-只触发重绘，因为没有几何变化</li>\n<li>移动或者给页面中的DOM节点添加动画</li>\n<li>添加一个样式表，调整样式属性</li>\n<li>用户行为，例如调整窗口大小，改变字号，或者滚动。</li>\n<li>查询某些属性或调用某些方法。比如说：<br>offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight</li>\n</ul>\n<h1 id=\"如何避免重绘或者重排\"><a href=\"#如何避免重绘或者重排\" class=\"headerlink\" title=\"如何避免重绘或者重排\"></a>如何避免重绘或者重排</h1><ul>\n<li>集中改变样式</li>\n<li>使用DocumentFragment</li>\n<li>提升为合成层</li>\n<li>缓存需要修改的DOM元素</li>\n<li>尽量只修改position：absolute或fixed元素，对其他元素影响不大<br>动画开始GPU加速，translate使用3D变化</li>\n</ul>\n<p><img src=\"https://bu.dusays.com/2022/02/08/0efbbd6b78be8.png\" alt=\"image _3_.png\"></p>\n<p>transform 不重绘，不回流是因为transform属于合成属性，对合成属性进行transition/animate动画时，将会创建一个合成层。这使得动画元素在一个独立的层中进行渲染。当元素的内容没有发生改变，就没有必要进行重绘。浏览器会通过重新复合来创建动画帧。</p>\n","categories":[{"name":"前端基础","path":"api/categories/前端基础.json"}],"tags":[{"name":"浏览器","path":"api/tags/浏览器.json"}]}